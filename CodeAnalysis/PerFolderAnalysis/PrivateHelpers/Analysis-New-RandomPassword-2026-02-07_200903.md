# Code Analysis Report
Generated: 2/7/2026 8:09:03 PM

## Summary
 This script generates passwords using three different methods: Random, Readable, and Passphrase. Here's a brief explanation of each method:

1. **Random**: The password is generated by randomly selecting characters from a predefined set that includes uppercase letters, lowercase letters, digits, and symbols (if the `NonAlpha` parameter is greater than 0). The length of the generated password ensures it contains at least one character from each category.

2. **Readable**: The password is created by randomly selecting words from a wordlist, ensuring at least two capitalized words to meet the uppercase and lowercase categories. Digits are also added, and an optional symbol can be inserted at a random position among the parts. The password's length is ensured by padding it with lowercase letters if necessary.

3. **Passphrase**: This method generates a multi-word password with a specified number of words (default 3) separated by a user-defined separator, contains digits, and an optional symbol at the end. The password's length is ensured by padding it with lowercase letters if necessary.

Additionally, the script supports filtering out specific sequences from the generated passwords using the `DisallowTokens` parameter. This can help prevent generating passwords that contain sensitive information or common patterns.

The script also uses a random number generator and ensures that the generated password meets certain conditions, such as containing at least one uppercase letter, one lowercase letter, and a digit, to increase its security.

## Source Code
```powershell

function New-RandomPassword {
    <#
    .SYNOPSIS
        Generates passwords that meet AD "complexity" (3/4 categories) using Random, Readable, or Passphrase styles.

    .DESCRIPTION
        - Random: cryptographically-random with optional symbols; exact length.
        - Readable: Two (or more) capitalized words + digits (+ optional symbol); length is a minimum.
        - Passphrase: 3â€“4 lower/Title words with separators + digits; length is a minimum.
        All styles avoid ambiguous characters when -NoAmbiguous is set. You can provide -DisallowTokens
        to prevent generating passwords that include user-related tokens (e.g., given/surname fragments).

    .PARAMETER Length
        For Random: exact length. For Readable/Passphrase: *minimum* length; will be padded if shorter.

    .PARAMETER NonAlpha
        Number of required symbols (Random style only). Set to 0 to omit symbols entirely.

    .PARAMETER NoAmbiguous
        Excludes look-alike chars and, for Readable/Passphrase, filters out words containing ambiguous letters.

    .PARAMETER Style
        Random | Readable | Passphrase

    .PARAMETER Words
        Number of words for Readable/Passphrase (Readable defaults 2; Passphrase defaults 3).

    .PARAMETER Digits
        Number of digits to include (ensures numeric category).

    .PARAMETER Separator
        Character(s) used between words for Readable/Passphrase (e.g., '-', '.', '').

    .PARAMETER IncludeSymbol
        Adds exactly one symbol in Readable/Passphrase styles (not required for AD).

    .PARAMETER WordListPath
        Optional path to a newline-delimited word list. If not supplied or not found, a built-in list is used.

    .PARAMETER DisallowTokens
        Array of strings to avoid (case-insensitive). If any token of length >= 3 appears, regenerates.

    .EXAMPLE
        New-RandomPassword -Style Readable -Length 12 -Digits 2
        # Example: RiverStone88

    .EXAMPLE
        New-RandomPassword -Style Passphrase -Length 16 -Separator '-' -Digits 3
        # Example: tiger-forest-echo721

    .EXAMPLE
        New-RandomPassword -Style Random -Length 16 -NonAlpha 0 -NoAmbiguous
        # Example: Hw7t9GZxFv3K2QmN
    #>
    [CmdletBinding(DefaultParameterSetName = 'Random')]
    param(
        [ValidateRange(8, 256)]
        [int]$Length = 16,

        # Random style only: number of required non-alphanumeric (symbols)
        [Parameter(ParameterSetName = 'Random')]
        [ValidateRange(0, 64)]
        [int]$NonAlpha = 0,

        [switch]$NoAmbiguous,

        [ValidateSet('Random', 'Readable', 'Passphrase')]
        [string]$Style = 'Random',

        # Word-based styles
        [ValidateRange(2, 6)]
        [int]$Words = 2,

        [ValidateRange(1, 6)]
        [int]$Digits = 2,

        [string]$Separator = '',

        [switch]$IncludeSymbol,

        [string]$WordListPath,

        [string[]]$DisallowTokens = @(),

        [ValidateRange(1, 200)]
        [int]$MaxRegenerate = 50
    )

    # Character sets
    $UpperSet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
    $LowerSet = 'abcdefghijklmnopqrstuvwxyz'
    $DigitSet = '0123456789'
    $SymbolSet = '!@#$%^&*_-+=?'

    if ($NoAmbiguous) {
        $UpperSet = 'ABCDEFGHJKLMNPQRSTUVWXYZ'      # no I, O
        $LowerSet = 'abcdefghijkmnpqrstuvwxyz'      # no l, o
        $DigitSet = '23456789'                      # no 0, 1
        # symbols ok as-is
    }

    # Crypto RNG helpers
    $rng = [System.Security.Cryptography.RandomNumberGenerator]::Create()
    $hasGetInt32 = ([System.Security.Cryptography.RandomNumberGenerator].GetMethod('GetInt32', [type[]]@([int], [int])) -ne $null)

    function Get-RandomIndex {
        param([int]$MaxExclusive)
        if ($MaxExclusive -le 0) { return 0 }
        if ($hasGetInt32) {
            return [System.Security.Cryptography.RandomNumberGenerator]::GetInt32(0, $MaxExclusive)
        }
        else {
            $b = New-Object byte[] 4
            $rng.GetBytes($b)
            return [Math]::Abs([BitConverter]::ToInt32($b, 0) % $MaxExclusive)
        }
    }

    function Get-RandomChar {
        param([string]$DigitSet)
        $DigitSet[(Get-RandomIndex $DigitSet.Length)]
    }

    function Get-RandomFromList {
        param([string[]]$List)
        $List[(Get-RandomIndex $List.Count)]
    }

    function Shuffle([char[]]$arr) {
        for ($i = $arr.Length - 1; $i -gt 0; $i--) {
            $j = Get-RandomIndex ($i + 1)
            if ($j -ne $i) {
                $tmp = $arr[$i]; $arr[$i] = $arr[$j]; $arr[$j] = $tmp
            }
        }
        -join $arr
    }

    function Load-WordList {
        param([string]$Path, [switch]$NoAmbiguous)
        $list = @()
        if ($Path -and (Test-Path -LiteralPath $Path)) {
            $list = Get-Content -LiteralPath $Path -ErrorAction Stop | Where-Object { $_ -match '^[A-Za-z]{3,10}$' }
        }
        if (-not $list -or $list.Count -lt 100) {
            # Fallback mini list if wordlist.txt fails to load
            $list = @(
                'river', 'stone', 'blue', 'green', 'tiger', 'forest', 'echo', 'delta', 'nova', 'ember', 'maple', 'cedar', 'birch', 'pine',
                'silver', 'shadow', 'crimson', 'cobalt', 'onyx', 'raven', 'falcon', 'otter', 'fox', 'wolf', 'lynx', 'badger', 'eagle',
                'harbor', 'summit', 'meadow', 'prairie', 'canyon', 'valley', 'spring', 'autumn', 'winter', 'summer', 'breeze', 'cloud',
                'storm', 'thunder', 'rain', 'snow', 'frost', 'glacier', 'aurora', 'comet', 'meteor', 'orbit', 'quartz', 'granite', 'basalt',
                'pebble', 'coral', 'reef', 'tide', 'delta', 'lagoon', 'moss', 'fern', 'willow', 'aspen', 'spruce', 'hemlock', 'elm',
                'copper', 'iron', 'nickel', 'zinc', 'amber', 'topaz', 'agate', 'jade', 'opal', 'pearl', 'sapphire', 'ruby', 'garnet',
                'swift', 'brisk', 'rapid', 'steady', 'bold', 'bright', 'quiet', 'gentle', 'keen', 'vivid', 'lively', 'nimble', 'solid',
                'lofty', 'noble', 'true', 'prime', 'vantage', 'zenith', 'apex', 'vertex', 'vector', 'gamma', 'omega', 'alpha', 'sigma',
                'orbit', 'photon', 'quark', 'ion', 'pixel', 'matrix', 'cipher', 'beacon', 'signal', 'kernel', 'crypto', 'evergreen', 'lake'
            )
        }
        $list = $list | ForEach-Object { $_.ToLowerInvariant().Trim() } | Where-Object { $_ -ne '' } | Select-Object -Unique
        if ($NoAmbiguous) {
            $list = $list | Where-Object { $_ -notmatch '[ilo10]' } # filter words with ambiguous chars
        }
        return $list
    }

    function Violates-Tokens {
        param([string]$Text, [string[]]$Tokens)
        foreach ($t in $Tokens) {
            if ([string]::IsNullOrWhiteSpace($t)) { continue }
            $tok = $t.Trim()
            if ($tok.Length -lt 3) { continue } # AD typically flags 3+ char sequences
            if ($Text -imatch [regex]::Escape($tok)) { return $true }
        }
        return $false
    }

    try {
        switch ($Style) {
            'Random' {
                # Ensure at least: 1 upper, 1 lower, 1 digit, + NonAlpha symbols
                $minRequired = 3 + $NonAlpha
                if ($Length -lt $minRequired) {
                    throw "Requested Length $Length is less than required minimum $minRequired (1 upper + 1 lower + 1 digit + $NonAlpha symbol(s))."
                }

                # Collect mandatory characters
                $chars = New-Object System.Collections.Generic.List[char]
                $chars.Add((Get-RandomChar $UpperSet))
                $chars.Add((Get-RandomChar $LowerSet))
                $chars.Add((Get-RandomChar $DigitSet))
                for ($i = 0; $i -lt $NonAlpha; $i++) { $chars.Add((Get-RandomChar $SymbolSet)) }

                # Fill remaining with union of sets (respecting NonAlpha=0 if you want no symbols)
                $all = ($UpperSet + $LowerSet + $DigitSet + ($NonAlpha -gt 0 ? $SymbolSet : '')).ToCharArray()
                while ($chars.Count -lt $Length) {
                    $chars.Add($all[(Get-RandomIndex $all.Length)])
                }

                # Shuffle & return
                $pwd = Shuffle ($chars.ToArray())
                return $pwd
            }

            'Readable' {
                # Make at least 2 words capitalized to ensure Upper+Lower, plus digits -> meets 3/4
                $wl = Load-WordList -Path $WordListPath -NoAmbiguous:$NoAmbiguous
                if ($Words -lt 2) { $Words = 2 } # enforce sane min for readability

                for ($attempt = 0; $attempt -lt $MaxRegenerate; $attempt++) {
                    $picked = for ($i = 1; $i -le $Words; $i++) { Get-RandomFromList $wl }
                    $capIdx = Get-RandomIndex $picked.Count
                    $wordsOut = for ($i = 0; $i -lt $picked.Count; $i++) {
                        if ($i -eq $capIdx) {
                            # TitleCase one word for uppercase category
                            ($picked[$i].Substring(0, 1).ToUpperInvariant() + $picked[$i].Substring(1).ToLowerInvariant())
                        }
                        else {
                            $picked[$i].ToLowerInvariant()
                        }
                    }

                    $digitsStr = -join (1..$Digits | ForEach-Object { Get-RandomChar $DigitSet })
                    $parts = @($wordsOut -join $Separator, $digitsStr)

                    if ($IncludeSymbol) {
                        # Insert symbol at a random position among parts
                        $sym = Get-RandomChar $SymbolSet
                        $insertPos = Get-RandomIndex ($parts.Count + 1)
                        $parts = ($parts[0..($insertPos - 1)] + $sym + $parts[$insertPos..($parts.Count - 1)]) -join ''
                    }
                    else {
                        $parts = -join $parts
                    }

                    $candidate = $parts

                    # Ensure minimum length (pad with lowercase if short)
                    if ($candidate.Length -lt $Length) {
                        $padCount = $Length - $candidate.Length
                        $pad = -join (1..$padCount | ForEach-Object { Get-RandomChar $LowerSet })
                        $candidate += $pad
                    }

                    if ($DisallowTokens.Count -gt 0 -and (Violates-Tokens -Text $candidate -Tokens $DisallowTokens)) {
                        continue
                    }

                    # Sanity: ensure categories: upper, lower, digit
                    if (($candidate -cmatch '[A-Z]') -and ($candidate -cmatch '[a-z]') -and ($candidate -match '\d')) {
                        return $candidate
                    }
                }
                throw "Failed to generate a Readable password after $MaxRegenerate attempts. Consider relaxing DisallowTokens/length."
            }

            'Passphrase' {
                # Typically 3+ words, lower/title with separator, + digits; length is a minimum
                if ($Words -lt 3) { $Words = 3 }
                $wl = Load-WordList -Path $WordListPath -NoAmbiguous:$NoAmbiguous

                for ($attempt = 0; $attempt -lt $MaxRegenerate; $attempt++) {
                    $picked = for ($i = 1; $i -le $Words; $i++) { Get-RandomFromList $wl }
                    # Capitalize one random word to ensure uppercase category
                    $capIdx = Get-RandomIndex $picked.Count
                    for ($i = 0; $i -lt $picked.Count; $i++) {
                        if ($i -eq $capIdx) {
                            $picked[$i] = $picked[$i].Substring(0, 1).ToUpperInvariant() + $picked[$i].Substring(1).ToLowerInvariant()
                        }
                        else {
                            $picked[$i] = $picked[$i].ToLowerInvariant()
                        }
                    }

                    $core = ($picked -join $Separator)
                    $digitsStr = -join (1..$Digits | ForEach-Object { Get-RandomChar $DigitsSet })
                    $candidate = $core + $digitsStr

                    if ($IncludeSymbol) {
                        $candidate += (Get-RandomChar $SymbolSet)
                    }

                    if ($candidate.Length -lt $Length) {
                        $padCount = $Length - $candidate.Length
                        $pad = -join (1..$padCount | ForEach-Object { Get-RandomChar $LowerSet })
                        $candidate += $pad
                    }

                    if ($DisallowTokens.Count -gt 0 -and (Violates-Tokens -Text $candidate -Tokens $DisallowTokens)) {
                        continue
                    }

                    # Ensure categories: upper, lower, digit
                    if (($candidate -cmatch '[A-Z]') -and ($candidate -cmatch '[a-z]') -and ($candidate -match '\d')) {
                        return $candidate
                    }
                }
                throw "Failed to generate a Passphrase after $MaxRegenerate attempts. Consider relaxing DisallowTokens/length."
            }
        }
    }
    finally {
        $rng.Dispose()
    }
}

[SIGNATURE BLOCK REMOVED]

```
