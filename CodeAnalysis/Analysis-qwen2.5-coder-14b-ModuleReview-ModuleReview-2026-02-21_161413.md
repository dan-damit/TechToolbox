# Code Analysis Report
Generated: 2/21/2026 4:14:13 PM

## Mode
ModuleReview

## Summary
The provided text is the full content of a PowerShell module named TechToolbox, which includes various scripts and functions for system administration tasks. The module appears to provide a suite of tools for managing systems, performing diagnostics, and automating administrative tasks. Here are some key components and functionalities:

1. **Initialization and Setup**:
   - The module starts by displaying a logo and initializes several script-scoped variables.
   - It checks if the module has already been initialized to prevent re-imports.
   - It includes an optional self-install helper (`Initialize-TechToolboxHome.ps1`) that can initialize the module's home directory on the system.

2. **Loading Functions**:
   - The module loads private functions from a `Private` folder and public functions from a `Public` folder.
   - Public functions are exported at the end of the module file.

3. **Runtime Initialization**:
   - A function `Initialize-TechToolboxRuntime` sets up the runtime environment, including initializing paths, configuration, logging, interop settings, and environment variables.
   - This initialization is done lazily, meaning it only runs when needed.

4. **Module Functions**:
   - The module includes a variety of functions for different purposes, such as:
     - Network diagnostics (`Invoke-SubnetScan`)
     - System information gathering (`Get-SystemSnapshot`)
     - Windows update management (`Reset-WindowsUpdateComponents`)
     - Software installation and removal (`Enable-NetFx3`, `Remove-EpicorEdgeAgent`)
     - File system operations (`Clear-TempFiles`, `Copy-PathResilient`)
     - Security tools (`Test-PathAs`, `Set-PageFileSize`)
     - And many more.

5. **Configuration and Logging**:
   - The module uses a configuration file located at `Config\config.json` to store settings.
   - It supports logging through the `Write-Log` function, which can output messages to different levels (e.g., Info, Warn, Error).

6. **Building and Packaging**:
   - A build script (`Build.ps1`) is provided for building the module, including updating the manifest, running PSSA (PowerShell Script Analyzer) for code analysis, signing module files, and packaging artifacts into a ZIP file.

7. **Security and Authentication**:
   - The module includes functions for code signing using certificates (`Set-AuthenticodeSignature`).
   - It supports impersonation (`Invoke-Impersonation`) to run commands under different credentials.

8. **Remote Execution**:
   - Several workers scripts (e.g., `Get-SystemSnapshot.Worker.ps1`, `Remove-EpicorEdgeAgent.Worker.ps1`) are designed to be executed on remote systems, likely through a framework like PDQ Inventory or similar.

This module seems to be a comprehensive toolset for system administrators, offering both local and remote management capabilities. It is well-structured with modular design principles, making it easy to extend and maintain.

## Source Code
```powershell
### FILE: C:\TechToolbox\Dependencies\ExchangeOnlineManagement\3.9.2\netCore\ExchangeOnlineManagement.psm1
# Import the REST module so that the EXO* cmdlets are present before Connect-ExchangeOnline in the powershell instance.
$RestModule = "Microsoft.Exchange.Management.RestApiClient.dll"
$RestModulePath = [System.IO.Path]::Combine($PSScriptRoot, $RestModule)
Import-Module $RestModulePath 

$ExoPowershellModule = "Microsoft.Exchange.Management.ExoPowershellGalleryModule.dll"
$ExoPowershellModulePath = [System.IO.Path]::Combine($PSScriptRoot, $ExoPowershellModule)
Import-Module $ExoPowershellModulePath

#Keep track of Execution status of last cmdlet
$global:EXO_LastExecutionStatus = $true;

############# Helper Functions Begin #############

    <#
    Get the ExchangeOnlineManagement module version.
    Same function is present in the autogen module. Both the codes should be kept in sync.
    #>
    function Get-ModuleVersion
    {
        try
        {
            # Return the already computed version info if available.
            if ($script:ModuleVersion -ne $null -and $script:ModuleVersion -ne '')
            {
                Write-Verbose "Returning precomputed version info: $script:ModuleVersion"
                return $script:ModuleVersion;
            }

            $exoModule = Get-Module ExchangeOnlineManagement
            
            # Check for ExchangeOnlineManagementBeta in case the psm1 is loaded directly
            if ($exoModule -eq $null)
            {
               $exoModule = (Get-Command -Name Connect-ExchangeOnline).Module
            }

            # Get the module version from the loaded module info.
            $script:ModuleVersion = $exoModule.Version.ToString()

            # Look for prerelease information from the corresponding module manifest.
            $exoModuleRoot = (Get-Item $exoModule.Path).Directory.Parent.FullName

            $exoModuleManifestPath = Join-Path -Path $exoModuleRoot -ChildPath ExchangeOnlineManagement.psd1
            $isExoModuleManifestPathValid = Test-Path -Path $exoModuleManifestPath
            if ($isExoModuleManifestPathValid -ne $true)
            {
                # Could be a local debug build import for testing. Skip extracting prerelease info for those.
                Write-Verbose "Module manifest path invalid, path: $exoModuleManifestPath, skipping extracting prerelease info"
                return $script:ModuleVersion
            }

            $exoModuleManifestContent = Get-Content -Path $exoModuleManifestPath
            $preReleaseInfo = $exoModuleManifestContent -match "Prerelease = '(.*)'"
            if ($preReleaseInfo -ne $null)
            {
                $script:ModuleVersion = "{0}-{1}" -f $exoModule.Version.ToString(),$preReleaseInfo[0].Split('=')[1].Trim().Trim("'")
            }

            Write-Verbose "Computed version info: $script:ModuleVersion"
            return $script:ModuleVersion
        }
        catch
        {
            return [string]::Empty
        }
    }

    <#
    .Synopsis Validates a given Uri
    #>
    function Test-Uri
    {
        [CmdletBinding()]
        [OutputType([bool])]
        Param
        (
            # Uri to be validated
            [Parameter(Mandatory=$true, ValueFromPipelineByPropertyName=$true, Position=0)]
            [string]
            $UriString
        )

        [Uri]$uri = $UriString -as [Uri]

        $uri.AbsoluteUri -ne $null -and $uri.Scheme -eq 'https'
    }

    <#
    .Synopsis Is Cloud Shell Environment
    #>
    function global:IsCloudShellEnvironment()
    {
        return [Microsoft.Exchange.Management.AdminApiProvider.Utility]::IsCloudShellEnvironment();
    }

    <#
    .SYNOPSIS Extract organization name from UserPrincipalName
    #>
    function Get-OrgNameFromUPN
    {
        param([string] $UPN)
        $fields = $UPN -split '@'
        return $fields[-1]
    }

    <#
    .SYNOPSIS Get the command from the given module
    #>
    function global:Get-WrappedCommand
    {
        param(
        [string] $CommandName,
        [string] $ModuleName,
        [string] $CommandType)

        $cmd = (Get-Module $moduleName).ExportedFunctions[$CommandName]
        return $cmd
    }

    <#
    .Synopsis Writes a message to the console in Yellow.
    Call this method with caution since it uses Write-Host internally which cannot be suppressed by the user.
    #>
    function Write-Message
    {
        param([string] $message)
        Write-Host $message -ForegroundColor Yellow
    }

############# Helper Functions End #############

###### Begin Main ######

$EOPConnectionInProgress = $false
function Connect-ExchangeOnline 
{
    [CmdletBinding()]
    param(

        # Connection Uri for the Remote PowerShell endpoint
        [string] $ConnectionUri = '',

        # Azure AD Authorization endpoint Uri that can issue the OAuth2 access tokens
        [string] $AzureADAuthorizationEndpointUri = '',

        # Exchange Environment name
        [Microsoft.Exchange.Management.RestApiClient.ExchangeEnvironment] $ExchangeEnvironmentName = 'O365Default',

        # PowerShell session options to be used when opening the Remote PowerShell session
        [System.Management.Automation.Remoting.PSSessionOption] $PSSessionOption = $null,

        # Switch to bypass use of mailbox anchoring hint.
        [switch] $BypassMailboxAnchoring = $false,

        # Delegated Organization Name
        [string] $DelegatedOrganization = '',

        # Prefix 
        [string] $Prefix = '',

        # Show Banner of Exchange cmdlets Mapping and recent updates
        [switch] $ShowBanner = $true,

        #Cmdlets to Import for rps cmdlets , by default it would bring all
        [string[]] $CommandName = @("*"),

        #The way the output objects would be printed on the console
        [string[]] $FormatTypeName = @("*"),

        # Use to Skip Exchange Format file loading into current shell.
        [switch] $SkipLoadingFormatData = $false,

        # Use to skip downloading and loading the help files into the current connection.
        [switch] $SkipLoadingCmdletHelp = $true,

        # Use to enable downloading and loading the help files into the current connection.
        [switch] $LoadCmdletHelp = $false,

        # Externally provided access token
        [string] $AccessToken = '',

        # Client certificate to sign the temp module
        [System.Security.Cryptography.X509Certificates.X509Certificate2] $SigningCertificate = $null,

        # switch to disable WAM
        [switch] $DisableWAM = $false,

        # Temp Base Path
        [string] $EXOModuleBasePath  = [System.IO.Path]::GetTempPath()
    )
    DynamicParam
    {
        if (($isCloudShell = IsCloudShellEnvironment) -eq $false)
        {
            $attributes = New-Object System.Management.Automation.ParameterAttribute
            $attributes.Mandatory = $false

            $attributeCollection = New-Object System.Collections.ObjectModel.Collection[System.Attribute]
            $attributeCollection.Add($attributes)

            # User Principal Name or email address of the user
            $UserPrincipalName = New-Object System.Management.Automation.RuntimeDefinedParameter('UserPrincipalName', [string], $attributeCollection)
            $UserPrincipalName.Value = ''

            # User Credential to Logon
            $Credential = New-Object System.Management.Automation.RuntimeDefinedParameter('Credential', [System.Management.Automation.PSCredential], $attributeCollection)
            $Credential.Value = $null

            # Certificate
            $Certificate = New-Object System.Management.Automation.RuntimeDefinedParameter('Certificate', [System.Security.Cryptography.X509Certificates.X509Certificate2], $attributeCollection)
            $Certificate.Value = $null

            # Certificate Path 
            $CertificateFilePath = New-Object System.Management.Automation.RuntimeDefinedParameter('CertificateFilePath', [string], $attributeCollection)
            $CertificateFilePath.Value = ''

            # Certificate Password
            $CertificatePassword = New-Object System.Management.Automation.RuntimeDefinedParameter('CertificatePassword', [System.Security.SecureString], $attributeCollection)
            $CertificatePassword.Value = $null

            # Certificate Thumbprint
            $CertificateThumbprint = New-Object System.Management.Automation.RuntimeDefinedParameter('CertificateThumbprint', [string], $attributeCollection)
            $CertificateThumbprint.Value = ''

            # Application Id
            $AppId = New-Object System.Management.Automation.RuntimeDefinedParameter('AppId', [string], $attributeCollection)
            $AppId.Value = ''

            # Organization
            $Organization = New-Object System.Management.Automation.RuntimeDefinedParameter('Organization', [string], $attributeCollection)
            $Organization.Value = ''

            # Switch to collect telemetry on command execution. 
            $EnableErrorReporting = New-Object System.Management.Automation.RuntimeDefinedParameter('EnableErrorReporting', [switch], $attributeCollection)
            $EnableErrorReporting.Value = $false
            
            # Where to store EXO command telemetry data. By default telemetry is stored in the directory "%TEMP%/EXOTelemetry" in the file : EXOCmdletTelemetry-yyyymmdd-hhmmss.csv.
            $LogDirectoryPath = New-Object System.Management.Automation.RuntimeDefinedParameter('LogDirectoryPath', [string], $attributeCollection)
            $LogDirectoryPath.Value = [System.IO.Path]::Combine([System.IO.Path]::GetTempPath(), "EXOCmdletTelemetry")

            # Create a new attribute and valiate set against the LogLevel
            $LogLevelAttribute = New-Object System.Management.Automation.ParameterAttribute
            $LogLevelAttribute.Mandatory = $false
            $LogLevelAttributeCollection = New-Object System.Collections.ObjectModel.Collection[System.Attribute]
            $LogLevelAttributeCollection.Add($LogLevelAttribute)
            $LogLevelList = @([Microsoft.Online.CSE.RestApiPowerShellModule.Instrumentation.LogLevel]::Default, [Microsoft.Online.CSE.RestApiPowerShellModule.Instrumentation.LogLevel]::All)
            $ValidateSet = New-Object System.Management.Automation.ValidateSetAttribute($LogLevelList)
            $LogLevel = New-Object System.Management.Automation.RuntimeDefinedParameter('LogLevel', [Microsoft.Online.CSE.RestApiPowerShellModule.Instrumentation.LogLevel], $LogLevelAttributeCollection)
            $LogLevel.Attributes.Add($ValidateSet)

            # Switch to use Managed Identity flow. 
            $ManagedIdentity = New-Object System.Management.Automation.RuntimeDefinedParameter('ManagedIdentity', [switch], $attributeCollection)
            $ManagedIdentity.Value = $false

            # ManagedIdentityAccountId to be used in case of User Assigned Managed Identity flow
            $ManagedIdentityAccountId = New-Object System.Management.Automation.RuntimeDefinedParameter('ManagedIdentityAccountId', [string], $attributeCollection)
            $ManagedIdentityAccountId.Value = ''

# EXO params start

            # Switch to track perfomance 
            $TrackPerformance = New-Object System.Management.Automation.RuntimeDefinedParameter('TrackPerformance', [bool], $attributeCollection)
            $TrackPerformance.Value = $false

            # Flag to enable or disable showing the number of objects written
            $ShowProgress = New-Object System.Management.Automation.RuntimeDefinedParameter('ShowProgress', [bool], $attributeCollection)
            $ShowProgress.Value = $false

            # Switch to enable/disable Multi-threading in the EXO cmdlets
            $UseMultithreading = New-Object System.Management.Automation.RuntimeDefinedParameter('UseMultithreading', [bool], $attributeCollection)
            $UseMultithreading.Value = $true

            # Pagesize Param
            $PageSize = New-Object System.Management.Automation.RuntimeDefinedParameter('PageSize', [uint32], $attributeCollection)
            $PageSize.Value = 1000

            # Switch to MSI auth 
            $Device = New-Object System.Management.Automation.RuntimeDefinedParameter('Device', [switch], $attributeCollection)
            $Device.Value = $false

            # Switch to CmdInline parameters
            $InlineCredential = New-Object System.Management.Automation.RuntimeDefinedParameter('InlineCredential', [switch], $attributeCollection)
            $InlineCredential.Value = $false

# EXO params end
            $paramDictionary = New-object System.Management.Automation.RuntimeDefinedParameterDictionary
            $paramDictionary.Add('UserPrincipalName', $UserPrincipalName)
            $paramDictionary.Add('Credential', $Credential)
            $paramDictionary.Add('Certificate', $Certificate)
            $paramDictionary.Add('CertificateFilePath', $CertificateFilePath)
            $paramDictionary.Add('CertificatePassword', $CertificatePassword)
            $paramDictionary.Add('AppId', $AppId)
            $paramDictionary.Add('Organization', $Organization)
            $paramDictionary.Add('EnableErrorReporting', $EnableErrorReporting)
            $paramDictionary.Add('LogDirectoryPath', $LogDirectoryPath)
            $paramDictionary.Add('LogLevel', $LogLevel)
            $paramDictionary.Add('TrackPerformance', $TrackPerformance)
            $paramDictionary.Add('ShowProgress', $ShowProgress)
            $paramDictionary.Add('UseMultithreading', $UseMultithreading)
            $paramDictionary.Add('PageSize', $PageSize)
            $paramDictionary.Add('ManagedIdentity', $ManagedIdentity)
            $paramDictionary.Add('ManagedIdentityAccountId', $ManagedIdentityAccountId)
            if($PSEdition -eq 'Core')
            {
                $paramDictionary.Add('Device', $Device)
                $paramDictionary.Add('InlineCredential', $InlineCredential);
                # We do not want to expose certificate thumprint in Linux as it is not feasible there.
                if($IsWindows)
                {
                    $paramDictionary.Add('CertificateThumbprint', $CertificateThumbprint);
                }
            }
            else 
            {
                $paramDictionary.Add('CertificateThumbprint', $CertificateThumbprint);
            }

            return $paramDictionary
        }
        else
        {
            $attributes = New-Object System.Management.Automation.ParameterAttribute
            $attributes.Mandatory = $false

            $attributeCollection = New-Object System.Collections.ObjectModel.Collection[System.Attribute]
            $attributeCollection.Add($attributes)

            # Switch to MSI auth 
            $Device = New-Object System.Management.Automation.RuntimeDefinedParameter('Device', [switch], $attributeCollection)
            $Device.Value = $false

            # Switch to collect telemetry on command execution. 
            $EnableErrorReporting = New-Object System.Management.Automation.RuntimeDefinedParameter('EnableErrorReporting', [switch], $attributeCollection)
            $EnableErrorReporting.Value = $false
            
            # Where to store EXO command telemetry data. By default telemetry is stored in the directory "%TEMP%/EXOTelemetry" in the file : EXOCmdletTelemetry-yyyymmdd-hhmmss.csv.
            $LogDirectoryPath = New-Object System.Management.Automation.RuntimeDefinedParameter('LogDirectoryPath', [string], $attributeCollection)
            $LogDirectoryPath.Value = [System.IO.Path]::Combine([System.IO.Path]::GetTempPath(), "EXOCmdletTelemetry")

            # Create a new attribute and validate set against the LogLevel
            $LogLevelAttribute = New-Object System.Management.Automation.ParameterAttribute
            $LogLevelAttribute.Mandatory = $false
            $LogLevelAttributeCollection = New-Object System.Collections.ObjectModel.Collection[System.Attribute]
            $LogLevelAttributeCollection.Add($LogLevelAttribute)
            $LogLevelList = @([Microsoft.Online.CSE.RestApiPowerShellModule.Instrumentation.LogLevel]::Default, [Microsoft.Online.CSE.RestApiPowerShellModule.Instrumentation.LogLevel]::All)
            $ValidateSet = New-Object System.Management.Automation.ValidateSetAttribute($LogLevelList)
            $LogLevel = New-Object System.Management.Automation.RuntimeDefinedParameter('LogLevel', [Microsoft.Online.CSE.RestApiPowerShellModule.Instrumentation.LogLevel], $LogLevelAttributeCollection)
            $LogLevel.Attributes.Add($ValidateSet)

            # Switch to CmdInline parameters
            $InlineCredential = New-Object System.Management.Automation.RuntimeDefinedParameter('InlineCredential', [switch], $attributeCollection)
            $InlineCredential.Value = $false

            # User Credential to Logon
            $Credential = New-Object System.Management.Automation.RuntimeDefinedParameter('Credential', [System.Management.Automation.PSCredential], $attributeCollection)
            $Credential.Value = $null

            $paramDictionary = New-object System.Management.Automation.RuntimeDefinedParameterDictionary
            $paramDictionary.Add('Device', $Device)
            $paramDictionary.Add('EnableErrorReporting', $EnableErrorReporting)
            $paramDictionary.Add('LogDirectoryPath', $LogDirectoryPath)
            $paramDictionary.Add('LogLevel', $LogLevel)
            $paramDictionary.Add('Credential', $Credential)
            $paramDictionary.Add('InlineCredential', $InlineCredential)
            return $paramDictionary
        }
    }
    process {
        $global:EXO_LastExecutionStatus = $true;
        $EnableSearchOnlySession = $false
        if (Test-Path Variable:Script:EnableSearchOnlySession)
        {
            $var = Get-Variable -Name "EnableSearchOnlySession" -Scope Script -ErrorAction SilentlyContinue
            if ($null -ne $var) {
                $EnableSearchOnlySession = $var.Value
            }
        }
        $startTime = Get-Date

        # Validate parameters
        if (($ConnectionUri -ne '') -and (-not (Test-Uri $ConnectionUri)))
        {
            $global:EXO_LastExecutionStatus = $false;
            throw "Invalid ConnectionUri parameter '$ConnectionUri'"
        }
        if (($AzureADAuthorizationEndpointUri -ne '') -and (-not (Test-Uri $AzureADAuthorizationEndpointUri)))
        {
            $global:EXO_LastExecutionStatus = $false;
            throw "Invalid AzureADAuthorizationEndpointUri parameter '$AzureADAuthorizationEndpointUri'"
        }
        if (($Prefix -ne ''))
        {
            if ($Prefix -notmatch '^[a-z0-9]+$') 
            {
                $global:EXO_LastExecutionStatus = $false;
                throw "Use of any special characters in the Prefix string is not supported."
            }
            if ($Prefix -eq 'EXO') 
            {
                $global:EXO_LastExecutionStatus = $false;
                throw "Prefix 'EXO' is a reserved Prefix, please use a different prefix."
            }
        }

        # Keep track of error count at beginning.
        $errorCountAtStart = $global:Error.Count;
        try
        {
            $moduleVersion = Get-ModuleVersion
            Write-Verbose "ModuleVersion: $moduleVersion"

            # Generate a ConnectionId to use in all logs and to send in all server calls.
            $connectionContextID = [System.Guid]::NewGuid()

            $cmdletLogger = New-CmdletLogger -ExoModuleVersion $moduleVersion -LogDirectoryPath $LogDirectoryPath.Value -EnableErrorReporting:$EnableErrorReporting.Value -ConnectionId $connectionContextID
            $logFilePath = $cmdletLogger.GetCurrentLogFilePath()
            
            if ($EnableErrorReporting.Value -eq $true)
            {
                Write-Message ("Writing cmdlet logs to " + $logFilePath)
            }

            $cmdletLogger.InitLog($connectionContextID)
            $cmdletLogger.LogStartTime($connectionContextID, $startTime)
            if ($EOPConnectionInProgress -eq $true)
            {
                $cmdletLogger.LogCmdletName($connectionContextID, "Connect-IPPSSession");
            }
            else
            {
                $cmdletLogger.LogCmdletName($connectionContextID, "Connect-ExchangeOnline");
            }
            $cmdletLogger.LogCmdletParameters($connectionContextID, $PSBoundParameters);

            if ($isCloudShell -eq $false)
            {
                $ConnectionContext = Get-ConnectionContext -ExchangeEnvironmentName $ExchangeEnvironmentName -ConnectionUri $ConnectionUri `
                -AzureADAuthorizationEndpointUri $AzureADAuthorizationEndpointUri -UserPrincipalName $UserPrincipalName.Value `
                -PSSessionOption $PSSessionOption -Credential $Credential.Value -BypassMailboxAnchoring:$BypassMailboxAnchoring `
                -DelegatedOrg $DelegatedOrganization -Certificate $Certificate.Value -CertificateFilePath $CertificateFilePath.Value `
                -CertificatePassword $CertificatePassword.Value -CertificateThumbprint $CertificateThumbprint.Value -AppId $AppId.Value `
                -Organization $Organization.Value -Device:$Device.Value -InlineCredential:$InlineCredential.Value -CommandName $CommandName `
                -FormatTypeName $FormatTypeName -Prefix $Prefix -PageSize $PageSize.Value -ExoModuleVersion:$moduleVersion -Logger $cmdletLogger `
                -ConnectionId $connectionContextID -EnableErrorReporting:$EnableErrorReporting.Value `
                -ManagedIdentity:$ManagedIdentity.Value -ManagedIdentityAccountId $ManagedIdentityAccountId.Value -AccessToken $AccessToken -DisableWAM:$DisableWAM -LogDirectoryPath $LogDirectoryPath.Value -EnableSearchOnlySession $EnableSearchOnlySession -EXOModuleBasePath $EXOModuleBasePath
            }
            else
            {
                $ConnectionContext = Get-ConnectionContext -ExchangeEnvironmentName $ExchangeEnvironmentName -ConnectionUri $ConnectionUri `
                -AzureADAuthorizationEndpointUri $AzureADAuthorizationEndpointUri -Credential $Credential.Value -PSSessionOption $PSSessionOption `
                -BypassMailboxAnchoring:$BypassMailboxAnchoring -Device:$Device.Value -InlineCredential:$InlineCredential.Value `
                -DelegatedOrg $DelegatedOrganization -CommandName $CommandName -FormatTypeName $FormatTypeName -Prefix $Prefix -ExoModuleVersion:$moduleVersion `
                -Logger $cmdletLogger -ConnectionId $connectionContextID -EnableErrorReporting:$EnableErrorReporting.Value -AccessToken $AccessToken -DisableWAM:$DisableWAM -LogDirectoryPath $LogDirectoryPath.Value -EnableSearchOnlySession $EnableSearchOnlySession -EXOModuleBasePath $EXOModuleBasePath

            }

            if ($isCloudShell -eq $false)
            {
                $global:_EXO_EnableErrorReporting = $EnableErrorReporting.Value;
            }

            if ($ShowBanner -eq $true)
            {
                try
                {
                    $BannerContent = Get-EXOBanner -ConnectionContext:$ConnectionContext
                    Write-Host -ForegroundColor Yellow $BannerContent
                }
                catch
                {
                    Write-Verbose "Failed to fetch banner content from server. Reason: $_"
                    $cmdletLogger.LogGenericError($connectionContextID, $_);
                }
            }

            if (($ConnectionUri -ne '') -and ($AzureADAuthorizationEndpointUri -eq ''))
            {
                Write-Information "Using ConnectionUri:'$ConnectionUri', in the environment:'$ExchangeEnvironmentName'."
            }
            if (($AzureADAuthorizationEndpointUri -ne '') -and ($ConnectionUri -eq ''))
            {
                Write-Information "Using AzureADAuthorizationEndpointUri:'$AzureADAuthorizationEndpointUri', in the environment:'$ExchangeEnvironmentName'."
            }

            $ImportedModuleName = '';
            $LogModuleDirectoryPath = [System.IO.Path]::GetTempPath();

            

            # Download the new web based EXOModule
            if ($SigningCertificate -ne $null)
            {
                $ImportedModule = New-EXOModule -ConnectionContext $ConnectionContext -SkipLoadingFormatData:$SkipLoadingFormatData -SigningCertificate $SigningCertificate;
            }
            else
            {
                $ImportedModule = New-EXOModule -ConnectionContext $ConnectionContext -SkipLoadingFormatData:$SkipLoadingFormatData;
            }
            if ($null -ne $ImportedModule)
            {
                $ImportedModuleName = $ImportedModule.Name;
                $LogModuleDirectoryPath = $ImportedModule.ModuleBase

                Write-Verbose "AutoGen EXOModule created at  $($ImportedModule.ModuleBase)"

                if ($LoadCmdletHelp -eq $true -and $HelpFileNames -ne $null -and $HelpFileNames -is [array] -and $HelpFileNames.Count -gt 0)
                {
                    Get-HelpFiles -HelpFileNames $HelpFileNames -ConnectionContext $ConnectionContext -ImportedModule $ImportedModule -EnableErrorReporting:$EnableErrorReporting.Value
                }
                else
                {
                    $cmdletLogger.LogGenericInfo($connectionContextID, "Skipping cmdlet help data");
                }
            }
            else
            {
                $global:EXO_LastExecutionStatus = $false;
                throw "Module could not be correctly formed. Please run Connect-ExchangeOnline again."
            }
            

            # If we are configured to collect telemetry, add telemetry wrappers in case of an RPS connection
            if ($EnableErrorReporting.Value -eq $true)
            {

                $endTime = Get-Date
                $cmdletLogger.LogEndTime($connectionContextID, $endTime);
                $cmdletLogger.CommitLog($connectionContextID);

                if ($EOPConnectionInProgress -eq $false)
                {
                    # Set the AppSettings
                    Set-ExoAppSettings -ShowProgress $ShowProgress.Value -PageSize $PageSize.Value -UseMultithreading $UseMultithreading.Value -TrackPerformance $TrackPerformance.Value -EnableErrorReporting $true -LogDirectoryPath $LogDirectoryPath.Value -LogLevel $LogLevel.Value
                }
            }
            else 
            {
                if ($EOPConnectionInProgress -eq $false)
                {
                    # Set the AppSettings disabling the logging
                    Set-ExoAppSettings -ShowProgress $ShowProgress.Value -PageSize $PageSize.Value -UseMultithreading $UseMultithreading.Value -TrackPerformance $TrackPerformance.Value -EnableErrorReporting $false
                }
            }
        }
        catch
        {
            # If telemetry is enabled, log errors generated from this cmdlet also.
            # If telemetry is not enabled, calls to cmdletLogger will be a no-op.
            $errorCountAtProcessEnd = $global:Error.Count 
            $numErrorRecordsToConsider = $errorCountAtProcessEnd - $errorCountAtStart
            for ($i = 0 ; $i -lt $numErrorRecordsToConsider ; $i++)
            {
                $cmdletLogger.LogGenericError($connectionContextID, $global:Error[$i]);
            }

            $cmdletLogger.CommitLog($connectionContextID);

            if ($EnableErrorReporting.Value -eq $true)
            {
                if ($global:_EXO_TelemetryFilePath -eq $null)
                {
                    $global:_EXO_TelemetryFilePath = New-EXOClientTelemetryFilePath -LogDirectoryPath $LogDirectoryPath.Value

                    # Import the REST module
                    $RestPowershellModule = "Microsoft.Exchange.Management.RestApiClient.dll";
                    $RestModulePath = [System.IO.Path]::Combine($PSScriptRoot, $RestPowershellModule);
                    Import-Module $RestModulePath -Cmdlet Set-ExoAppSettings;

                    # Set the AppSettings
                    Set-ExoAppSettings -ShowProgress $ShowProgress.Value -PageSize $PageSize.Value -UseMultithreading $UseMultithreading.Value -TrackPerformance $TrackPerformance.Value -ConnectionUri $ConnectionUri -EnableErrorReporting $true -LogDirectoryPath $LogDirectoryPath.Value -LogLevel $LogLevel.Value
                }

                # Log errors which are encountered during Connect-ExchangeOnline execution. 
                Write-Message ("Writing Connect-ExchangeOnline error log to " + $global:_EXO_TelemetryFilePath)
                Push-EXOTelemetryRecord -TelemetryFilePath $global:_EXO_TelemetryFilePath -CommandName Connect-ExchangeOnline -CommandParams $PSCmdlet.MyInvocation.BoundParameters -OrganizationName  $global:_EXO_ExPSTelemetryOrganization -ScriptName $global:_EXO_ExPSTelemetryScriptName  -ScriptExecutionGuid $global:_EXO_ExPSTelemetryScriptExecutionGuid -ErrorObject $global:Error -ErrorRecordsToConsider ($errorCountAtProcessEnd - $errorCountAtStart) 
            }

            $global:EXO_LastExecutionStatus = $false;

            if ($_.Exception -ne $null)
            {
                # Connect-ExchangeOnline Failed, Remove ConnectionContext from Map.
                if ([Microsoft.Exchange.Management.ExoPowershellSnapin.ConnectionContextFactory]::RemoveConnectionContextUsingConnectionId($connectionContextID))
                {
                    Write-Verbose "ConnectionContext Removed"
                }

                if ($_.Exception.InnerException -ne $null)
                {
                    throw $_.Exception.InnerException;
                }
                else
                {
                    throw $_.Exception;
                }
            }
            else
            {
                throw $_;
            }
        }
    }
}

function Connect-IPPSSession
{
    [CmdletBinding()]
    param(
        # Connection Uri for the Remote PowerShell endpoint
        [string] $ConnectionUri = 'https://ps.compliance.protection.outlook.com/PowerShell-LiveId',

        # Azure AD Authorization endpoint Uri that can issue the OAuth2 access tokens
        [string] $AzureADAuthorizationEndpointUri = 'https://login.microsoftonline.com/organizations',

        # Delegated Organization Name
        [string] $DelegatedOrganization = '',

        # PowerShell session options to be used when opening the Remote PowerShell session
        [System.Management.Automation.Remoting.PSSessionOption] $PSSessionOption = $null,

        # Switch to bypass use of mailbox anchoring hint.
        [switch] $BypassMailboxAnchoring = $false,

        # Prefix 
        [string] $Prefix = '',

        #Cmdlets to Import, by default it would bring all
        [string[]] $CommandName = @("*"),

        #The way the output objects would be printed on the console
        [string[]] $FormatTypeName = @("*"),

        # Show Banner of scc cmdlets Mapping and recent updates
        [switch] $ShowBanner = $true,

        # switch to disable WAM
        [switch] $DisableWAM = $false,

        # Externally provided access token
        [string] $AccessToken = '',
        
        # Switch to using OBO Token
        [switch] $EnableSearchOnlySession = $false,

        # TempBasePath
        [string] $EXOModuleBasePath = [System.IO.Path]::GetTempPath()
    )
    DynamicParam
    {
        if (($isCloudShell = IsCloudShellEnvironment) -eq $false)
        {
            $attributes = New-Object System.Management.Automation.ParameterAttribute
            $attributes.Mandatory = $false

            $attributeCollection = New-Object System.Collections.ObjectModel.Collection[System.Attribute]
            $attributeCollection.Add($attributes)

            # User Principal Name or email address of the user
            $UserPrincipalName = New-Object System.Management.Automation.RuntimeDefinedParameter('UserPrincipalName', [string], $attributeCollection)
            $UserPrincipalName.Value = ''

            # User Credential to Logon
            $Credential = New-Object System.Management.Automation.RuntimeDefinedParameter('Credential', [System.Management.Automation.PSCredential], $attributeCollection)
            $Credential.Value = $null

            # Certificate
            $Certificate = New-Object System.Management.Automation.RuntimeDefinedParameter('Certificate', [System.Security.Cryptography.X509Certificates.X509Certificate2], $attributeCollection)
            $Certificate.Value = $null

            # Certificate Path 
            $CertificateFilePath = New-Object System.Management.Automation.RuntimeDefinedParameter('CertificateFilePath', [string], $attributeCollection)
            $CertificateFilePath.Value = ''

            # Certificate Password
            $CertificatePassword = New-Object System.Management.Automation.RuntimeDefinedParameter('CertificatePassword', [System.Security.SecureString], $attributeCollection)
            $CertificatePassword.Value = $null

            # Certificate Thumbprint
            $CertificateThumbprint = New-Object System.Management.Automation.RuntimeDefinedParameter('CertificateThumbprint', [string], $attributeCollection)
            $CertificateThumbprint.Value = ''

            # Application Id
            $AppId = New-Object System.Management.Automation.RuntimeDefinedParameter('AppId', [string], $attributeCollection)
            $AppId.Value = ''

            # Organization
            $Organization = New-Object System.Management.Automation.RuntimeDefinedParameter('Organization', [string], $attributeCollection)
            $Organization.Value = ''

            # Switch to collect telemetry on command execution. 
            $EnableErrorReporting = New-Object System.Management.Automation.RuntimeDefinedParameter('EnableErrorReporting', [switch], $attributeCollection)
            $EnableErrorReporting.Value = $false
            
            # Where to store command telemetry data. By default telemetry is stored in the directory "%TEMP%/EXOTelemetry" in the file : EXOCmdletTelemetry-yyyymmdd-hhmmss.csv.
            $LogDirectoryPath = New-Object System.Management.Automation.RuntimeDefinedParameter('LogDirectoryPath', [string], $attributeCollection)
            $LogDirectoryPath.Value = [System.IO.Path]::Combine([System.IO.Path]::GetTempPath(), "EXOCmdletTelemetry")
            # Create a new attribute and validate set against the LogLevel
            $LogLevelAttribute = New-Object System.Management.Automation.ParameterAttribute
            $LogLevelAttribute.Mandatory = $false
            $LogLevelAttributeCollection = New-Object System.Collections.ObjectModel.Collection[System.Attribute]
            $LogLevelAttributeCollection.Add($LogLevelAttribute)
            $LogLevelList = @([Microsoft.Online.CSE.RestApiPowerShellModule.Instrumentation.LogLevel]::Default, [Microsoft.Online.CSE.RestApiPowerShellModule.Instrumentation.LogLevel]::All)
            $ValidateSet = New-Object System.Management.Automation.ValidateSetAttribute($LogLevelList)
            $LogLevel = New-Object System.Management.Automation.RuntimeDefinedParameter('LogLevel', [Microsoft.Online.CSE.RestApiPowerShellModule.Instrumentation.LogLevel], $LogLevelAttributeCollection)
            $LogLevel.Attributes.Add($ValidateSet)

            $paramDictionary = New-object System.Management.Automation.RuntimeDefinedParameterDictionary
            $paramDictionary.Add('UserPrincipalName', $UserPrincipalName)
            $paramDictionary.Add('Credential', $Credential)
            $paramDictionary.Add('Certificate', $Certificate)
            $paramDictionary.Add('CertificateFilePath', $CertificateFilePath)
            $paramDictionary.Add('CertificatePassword', $CertificatePassword)
            $paramDictionary.Add('AppId', $AppId)
            $paramDictionary.Add('Organization', $Organization)
            $paramDictionary.Add('EnableErrorReporting', $EnableErrorReporting)
            $paramDictionary.Add('LogDirectoryPath', $LogDirectoryPath)
            $paramDictionary.Add('LogLevel', $LogLevel)
            if($PSEdition -eq 'Core')
            {
                # We do not want to expose certificate thumprint in Linux as it is not feasible there.
                if($IsWindows)
                {
                    $paramDictionary.Add('CertificateThumbprint', $CertificateThumbprint);
                }
            }
            else 
            {
                $paramDictionary.Add('CertificateThumbprint', $CertificateThumbprint);
            }

            return $paramDictionary
        }
        else
        {
            $attributes = New-Object System.Management.Automation.ParameterAttribute
            $attributes.Mandatory = $false

            $attributeCollection = New-Object System.Collections.ObjectModel.Collection[System.Attribute]
            $attributeCollection.Add($attributes)

            # Switch to MSI auth 
            $Device = New-Object System.Management.Automation.RuntimeDefinedParameter('Device', [switch], $attributeCollection)
            $Device.Value = $false

            # Switch to collect telemetry on command execution. 
            $EnableErrorReporting = New-Object System.Management.Automation.RuntimeDefinedParameter('EnableErrorReporting', [switch], $attributeCollection)
            $EnableErrorReporting.Value = $false
            
            # Where to store EXO command telemetry data. By default telemetry is stored in the directory "%TEMP%/EXOTelemetry" in the file : EXOCmdletTelemetry-yyyymmdd-hhmmss.csv.
            $LogDirectoryPath = New-Object System.Management.Automation.RuntimeDefinedParameter('LogDirectoryPath', [string], $attributeCollection)
            $LogDirectoryPath.Value = [System.IO.Path]::Combine([System.IO.Path]::GetTempPath(), "EXOCmdletTelemetry")
            # Create a new attribute and validate set against the LogLevel
            $LogLevelAttribute = New-Object System.Management.Automation.ParameterAttribute
            $LogLevelAttribute.Mandatory = $false
            $LogLevelAttributeCollection = New-Object System.Collections.ObjectModel.Collection[System.Attribute]
            $LogLevelAttributeCollection.Add($LogLevelAttribute)
            $LogLevelList = @([Microsoft.Online.CSE.RestApiPowerShellModule.Instrumentation.LogLevel]::Default, [Microsoft.Online.CSE.RestApiPowerShellModule.Instrumentation.LogLevel]::All)
            $ValidateSet = New-Object System.Management.Automation.ValidateSetAttribute($LogLevelList)
            $LogLevel = New-Object System.Management.Automation.RuntimeDefinedParameter('LogLevel', [Microsoft.Online.CSE.RestApiPowerShellModule.Instrumentation.LogLevel], $LogLevelAttributeCollection)
            $LogLevel.Attributes.Add($ValidateSet)
            $paramDictionary = New-object System.Management.Automation.RuntimeDefinedParameterDictionary
            $paramDictionary.Add('Device', $Device)
            $paramDictionary.Add('EnableErrorReporting', $EnableErrorReporting)
            $paramDictionary.Add('LogDirectoryPath', $LogDirectoryPath)
            $paramDictionary.Add('LogLevel', $LogLevel)
            return $paramDictionary
        }
    }
    process 
    {
        try
        {
            $EOPConnectionInProgress = $true
            Set-Variable -Name "EnableSearchOnlySession" -Value $EnableSearchOnlySession.IsPresent -Scope Script
            if ($isCloudShell -eq $false)
            {
                $LogLevelValue = [Microsoft.Online.CSE.RestApiPowerShellModule.Instrumentation.LogLevel]::All
                if($LogLevel.Value)
                {
                    $LogLevelValue = $LogLevel.Value
                }
                $certThumbprint = $CertificateThumbprint.Value
                # Will pass CertificateThumbprint if it is not null or not empty
                if($certThumbprint)
                {
                    Connect-ExchangeOnline -ConnectionUri $ConnectionUri -AzureADAuthorizationEndpointUri $AzureADAuthorizationEndpointUri -UserPrincipalName $UserPrincipalName.Value -PSSessionOption $PSSessionOption -Credential $Credential.Value -BypassMailboxAnchoring:$BypassMailboxAnchoring -ShowBanner:$ShowBanner -DelegatedOrganization $DelegatedOrganization -Certificate $Certificate.Value -CertificateFilePath $CertificateFilePath.Value -CertificatePassword $CertificatePassword.Value -CertificateThumbprint $certThumbprint -AppId $AppId.Value -Organization $Organization.Value -Prefix $Prefix -CommandName $CommandName -FormatTypeName $FormatTypeName -DisableWAM:$DisableWAM -EnableErrorReporting:$EnableErrorReporting.Value -LogLevel $LogLevelValue -LogDirectoryPath $LogDirectoryPath.Value -EXOModuleBasePath $EXOModuleBasePath
                }
                else
                {
                    Connect-ExchangeOnline -ConnectionUri $ConnectionUri -AzureADAuthorizationEndpointUri $AzureADAuthorizationEndpointUri -UserPrincipalName $UserPrincipalName.Value -PSSessionOption $PSSessionOption -Credential $Credential.Value -BypassMailboxAnchoring:$BypassMailboxAnchoring -ShowBanner:$ShowBanner -DelegatedOrganization $DelegatedOrganization -Certificate $Certificate.Value -CertificateFilePath $CertificateFilePath.Value -CertificatePassword $CertificatePassword.Value -AppId $AppId.Value -Organization $Organization.Value -Prefix $Prefix -CommandName $CommandName -FormatTypeName $FormatTypeName -DisableWAM:$DisableWAM -AccessToken $AccessToken -EnableErrorReporting:$EnableErrorReporting.Value -LogLevel $LogLevelValue -LogDirectoryPath $LogDirectoryPath.Value -EXOModuleBasePath $EXOModuleBasePath
                }
            }
            else
            {
                Connect-ExchangeOnline -ConnectionUri $ConnectionUri -AzureADAuthorizationEndpointUri $AzureADAuthorizationEndpointUri -PSSessionOption $PSSessionOption -BypassMailboxAnchoring:$BypassMailboxAnchoring -Device:$Device.Value -ShowBanner:$ShowBanner -DelegatedOrganization $DelegatedOrganization -Prefix $Prefix -CommandName $CommandName -FormatTypeName $FormatTypeName -DisableWAM:$DisableWAM -AccessToken $AccessToken -EnableErrorReporting:$EnableErrorReporting.Value -LogLevel $LogLevelValue -LogDirectoryPath $LogDirectoryPath.Value -EXOModuleBasePath $EXOModuleBasePath
            }
        }
        finally
        {
            $EOPConnectionInProgress = $false
        }
    }
}

function Disconnect-ExchangeOnline
{
    [CmdletBinding(SupportsShouldProcess, ConfirmImpact='High', DefaultParameterSetName='DefaultParameterSet')]
    param(
        [Parameter(Mandatory=$true, ParameterSetName='ConnectionId', ValueFromPipelineByPropertyName=$true)]
        [string[]] $ConnectionId,
        [Parameter(Mandatory=$true, ParameterSetName='ModulePrefix')]
        [string[]] $ModulePrefix
    )

    process
    {
        $global:EXO_LastExecutionStatus = $true;
        $disconnectConfirmationMessage = ""
        Switch ($PSCmdlet.ParameterSetName)
        {
            'ConnectionId'
            {
                $disconnectConfirmationMessage = [Microsoft.Exchange.Management.ExoPowershellSnapin.ConnectionContextFactory]::GetDisconnectConfirmationMessageByConnectionId($ConnectionId)
                break
            }
            'ModulePrefix'
            {
                $disconnectConfirmationMessage = [Microsoft.Exchange.Management.ExoPowershellSnapin.ConnectionContextFactory]::GetDisconnectConfirmationMessageByModulePrefix($ModulePrefix)
                break
            }
            Default
            {
                $disconnectConfirmationMessage = [Microsoft.Exchange.Management.ExoPowershellSnapin.ConnectionContextFactory]::GetDisconnectConfirmationMessageWithInbuilt()
            }
        }
	
        if ($PSCmdlet.ShouldProcess(
            $disconnectConfirmationMessage,
            "Press(Y/y/A/a) if you want to continue.",
            $disconnectConfirmationMessage))
        {

            # Keep track of error count at beginning.
            $errorCountAtStart = $global:Error.Count;
            $startTime = Get-Date

            try
            {
                # Get all the connection contexts so that the logger can be initialized.
                $connectionContexts = [Microsoft.Exchange.Management.ExoPowershellSnapin.ConnectionContextFactory]::GetAllConnectionContexts()
                $disconnectCmdletId = [System.Guid]::NewGuid().ToString()

                # denotes if any of the connections is an RPS session.
                # This is used to Push-EXOTelemetryRecord in case any RPS connections are present.
                $rpsConnectionWithErrorReportingExists = $false
                
                foreach ($context in $connectionContexts)
                {
                    $context.Logger.InitLog($disconnectCmdletId);
                    $context.Logger.LogStartTime($disconnectCmdletId, $startTime);
                    $context.Logger.LogCmdletName($disconnectCmdletId, "Disconnect-ExchangeOnline");
                    if ($context.IsRpsSession -and $context.ErrorReportingEnabled)
                    {
                        $rpsConnectionWithErrorReportingExists = $true
                    }
                }

                # Import the module once more to ensure that Test-ActiveToken is present
                $ExoPowershellModule = "Microsoft.Exchange.Management.ExoPowershellGalleryModule.dll";
                $ModulePath = [System.IO.Path]::Combine($PSScriptRoot, $ExoPowershellModule);
                Import-Module $ModulePath -Cmdlet Clear-ActiveToken;

                $existingPSSession = Get-PSSession | Where-Object {$_.ConfigurationName -like "Microsoft.Exchange" -and $_.Name -like "ExchangeOnlineInternalSession*"}

                if ($existingPSSession.count -gt 0) 
                {
                    for ($index = 0; $index -lt $existingPSSession.count; $index++)
                    {
                        $session = $existingPSSession[$index]
                        Remove-PSSession -session $session

                        Write-Information "Removed the PSSession $($session.Name) connected to $($session.ComputerName)"

                        # Remove any active access token from the cache
                        # If the connectionId of the session being cleared is equal to AppSettings.ConnectionId, this means connection to EXO cmdlets will break.
                        if ($session.ConnectionContext.ConnectionId -ieq [Microsoft.Exchange.Management.AdminApiProvider.AppSettings]::ConnectionId)
                        {
                            Clear-ActiveToken -TokenProvider $session.TokenProvider -IsSessionUsedByInbuiltCmdlets:$true
                        }
                        else
                        {
                            Clear-ActiveToken -TokenProvider $session.TokenProvider -IsSessionUsedByInbuiltCmdlets:$false
                        }

                        # Remove any previous modules loaded because of the current PSSession
                        if ($session.PreviousModuleName -ne $null)
                        {
                            if ((Get-Module $session.PreviousModuleName).Count -ne 0)
                            {
                                $null = Remove-Module -Name $session.PreviousModuleName -ErrorAction SilentlyContinue
                            }

                            $session.PreviousModuleName = $null
                        }

                        # Remove any leaked module in case of removal of broken session object
                        if ($session.CurrentModuleName -ne $null)
                        {
                            if ((Get-Module $session.CurrentModuleName).Count -ne 0)
                            {
                                $null = Remove-Module -Name $session.CurrentModuleName -ErrorAction SilentlyContinue
                            }
                        }
                    }
                }

                $modulesToRemove = $null
                Switch ($PSCmdlet.ParameterSetName)
                {
                    'ConnectionId'
                    {
                        # Call GetModulesToRemoveByConnectionId in this scenario
                        $modulesToRemove = [Microsoft.Exchange.Management.ExoPowershellSnapin.ConnectionContextFactory]::GetModulesToRemoveByConnectionId($ConnectionId)
                        break
                    }
                    'ModulePrefix'
                    {
                        # Call GetModulesToRemoveByModulePrefix in this scenario
                        $modulesToRemove = [Microsoft.Exchange.Management.ExoPowershellSnapin.ConnectionContextFactory]::GetModulesToRemoveByModulePrefix($ModulePrefix)
                        break
                    }
                    Default
                    {
                        # Remove all the AutoREST modules from this instance of powershell if created
                        $existingAutoRESTModules = Get-Module "tmpEXO_*"
                        foreach ($module in $existingAutoRESTModules)
                        {  
                            $null = Remove-Module -Name $module -ErrorAction SilentlyContinue
                        }

                        # The below call to remove all connection contexts could be removed as we already have an OnRemove event hooked to the module. Work Item 3461604 to investigate this
                        # Remove all ConnectionContexts
                        # this internally clears all the active tokens in ConnectionContexts
                        [Microsoft.Exchange.Management.ExoPowershellSnapin.ConnectionContextFactory]::RemoveAllConnectionContexts()
                    }
                }

                if ($modulesToRemove -ne $null -and $modulesToRemove.Count -gt 0)
                {
                    $null = Remove-Module $modulesToRemove -ErrorAction SilentlyContinue
                }

                Write-Information "Disconnected successfully !"

                # Remove all the Wrapped modules from this instance of powershell if created
                $existingWrappedModules = Get-Module "EXOCmdletWrapper-*"
                foreach ($module in $existingWrappedModules)
                {
                    $null = Remove-Module -Name $module -ErrorAction SilentlyContinue
                }

                if ($rpsConnectionWithErrorReportingExists)
                {
                    if ($global:_EXO_TelemetryFilePath -eq $null)
                    {
                        $global:_EXO_TelemetryFilePath = New-EXOClientTelemetryFilePath
                    }

                    Push-EXOTelemetryRecord -TelemetryFilePath $global:_EXO_TelemetryFilePath -CommandName Disconnect-ExchangeOnline -CommandParams $PSCmdlet.MyInvocation.BoundParameters -OrganizationName  $global:_EXO_ExPSTelemetryOrganization -ScriptName $global:_EXO_ExPSTelemetryScriptName  -ScriptExecutionGuid $global:_EXO_ExPSTelemetryScriptExecutionGuid
                }
            }
            catch
            {
                # If telemetry is enabled for any of the connections, log errors generated from this cmdlet also. 
                $errorCountAtProcessEnd = $global:Error.Count
                $global:EXO_LastExecutionStatus = $false;
                
                $endTime = Get-Date
                foreach ($context in $connectionContexts)
                {
                    $numErrorRecordsToConsider = $errorCountAtProcessEnd - $errorCountAtStart
                    for ($i = 0 ; $i -lt $numErrorRecordsToConsider ; $i++)
                    {
                        $context.Logger.LogGenericError($disconnectCmdletId, $global:Error[$i]);
                    }

                    $context.Logger.LogEndTime($disconnectCmdletId, $endTime);
                    $context.Logger.CommitLog($disconnectCmdletId);
                    $logFilePath = $context.Logger.GetCurrentLogFilePath();
                }

                if ($rpsConnectionWithErrorReportingExists)
                {
                    if ($global:_EXO_TelemetryFilePath -eq $null)
                    {
                        $global:_EXO_TelemetryFilePath = New-EXOClientTelemetryFilePath
                    }

                    # Log errors which are encountered during Disconnect-ExchangeOnline execution. 
                    Write-Message ("Writing Disconnect-ExchangeOnline errors to " + $global:_EXO_TelemetryFilePath)

                    Push-EXOTelemetryRecord -TelemetryFilePath $global:_EXO_TelemetryFilePath -CommandName Disconnect-ExchangeOnline -CommandParams $PSCmdlet.MyInvocation.BoundParameters -OrganizationName  $global:_EXO_ExPSTelemetryOrganization -ScriptName $global:_EXO_ExPSTelemetryScriptName  -ScriptExecutionGuid $global:_EXO_ExPSTelemetryScriptExecutionGuid -ErrorObject $global:Error -ErrorRecordsToConsider ($errorCountAtProcessEnd - $errorCountAtStart) 
                }

                throw $_
            }

            $endTime = Get-Date
            foreach ($context in $connectionContexts)
            {
                if ($context.Logger -ne $null)
                {
                    $context.Logger.LogEndTime($disconnectCmdletId, $endTime);
                    $context.Logger.CommitLog($disconnectCmdletId);
                }
            }
        }
    }
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Dependencies\ExchangeOnlineManagement\3.9.2\netFramework\Create-SelfSignedCertificate.ps1
<#
.SYNOPSIS
Utility script to creates a Self Signed Certificate(s), which can be used as Client Certificate for Azure Apps.
.DESCRIPTION
This utility generates a new certificate with the given name in the certificate store and export the new certificate to the current directory.
If there is a certificate with the same name already present in the store then this script would fail. Use -Force option to force remove the existing certificate with the same name from the store and create a new certificate.
.EXAMPLE
PS C:\> .\Create-SelfSignedCertificate.ps1 -CommonName "MyCert" -StartDate 2015-11-21 -EndDate 2017-11-21
This will create a new self signed certificate with the common name "CN=MyCert". During creation you will be asked to provide a password to protect the private key.
.EXAMPLE
PS C:\> .\Create-SelfSignedCertificate.ps1 -CommonName "MyCert" -StartDate 2015-11-21 -EndDate 2017-11-21 -Password (ConvertTo-SecureString -String <Password> -AsPlainText -Force)
<Password> should be replaced with the password string for the certificate.
This will create a new self signed certificate with the common name "CN=MyCert". The password as specified in the Password parameter will be used to protect the private key
.EXAMPLE
PS C:\> .\Create-SelfSignedCertificate.ps1 -CommonName "MyCert" -StartDate 2015-11-21 -EndDate 2017-11-21 -Force
Using -Force option would remove the exising "MyCert" certificate in the store. In all other cases if there is already a certificate in the store with the name "MyCert" the script would fail to execute.
This will create a new self signed certificate with the common name "CN=MyCert". During creation you will be asked to provide a password to protect the private key. If there is already a certificate with the common name you specified, it will be removed first.
#>
Param(

   [Parameter(Mandatory=$true)]
   [string]$CommonName,

   [Parameter(Mandatory=$true)]
   [DateTime]$StartDate,
   
   [Parameter(Mandatory=$true)]
   [DateTime]$EndDate,

   [Parameter(Mandatory=$false, HelpMessage="Will overwrite existing certificates")]
   [Switch]$Force,

   [Parameter(Mandatory=$false)]
   [SecureString]$Password
)

# DO NOT MODIFY BELOW

function CreateSelfSignedCertificate(){
    
    # Remove an existing certificates with the same common name from personal and root stores, if -Force option is set.
    # Need to be very wary of this as could break something
    if($CommonName.ToLower().StartsWith("cn="))
    {
        # Remove CN from common name
        $CommonName = $CommonName.Substring(3)
    }
    $certs = Get-ChildItem -Path Cert:\LocalMachine\my | Where-Object{$_.Subject -eq "CN=$CommonName"}
    if($certs -ne $null -and $certs.Length -gt 0)
    {
        if($Force)
        {
        
            foreach($c in $certs)
            {
                remove-item $c.PSPath
            }
        } else {
            Write-Host -ForegroundColor Red "One or more certificates with the same common name (CN=$CommonName) are already located in the local certificate store. Use -Force to remove existing certificate with the same name and create new one.";
            return $false
        }
    }

    $name = new-object -com "X509Enrollment.CX500DistinguishedName.1"
    $name.Encode("CN=$CommonName", 0)

    $key = new-object -com "X509Enrollment.CX509PrivateKey.1"
    $key.ProviderName = "Microsoft RSA SChannel Cryptographic Provider"
    $key.KeySpec = 1
    $key.Length = 2048 
    $key.SecurityDescriptor = "D:PAI(A;;0xd01f01ff;;;SY)(A;;0xd01f01ff;;;BA)(A;;0x80120089;;;NS)"
    $key.MachineContext = 1
    $key.ExportPolicy = 1 # This is required to allow the private key to be exported
    $key.Create()

    $serverauthoid = new-object -com "X509Enrollment.CObjectId.1"
    $serverauthoid.InitializeFromValue("1.3.6.1.5.5.7.3.1") # Server Authentication
    $ekuoids = new-object -com "X509Enrollment.CObjectIds.1"
    $ekuoids.add($serverauthoid)
    $ekuext = new-object -com "X509Enrollment.CX509ExtensionEnhancedKeyUsage.1"
    $ekuext.InitializeEncode($ekuoids)

    $cert = new-object -com "X509Enrollment.CX509CertificateRequestCertificate.1"
    $cert.InitializeFromPrivateKey(2, $key, "")
    $cert.Subject = $name
    $cert.Issuer = $cert.Subject
    $cert.NotBefore = $StartDate
    $cert.NotAfter = $EndDate
    $cert.X509Extensions.Add($ekuext)
    $cert.Encode()

    $enrollment = new-object -com "X509Enrollment.CX509Enrollment.1"
    $enrollment.InitializeFromRequest($cert)
    $certdata = $enrollment.CreateRequest(0)
    $enrollment.InstallResponse(2, $certdata, 0, "")
    return $true
}

function ExportPFXFile()
{
    if($CommonName.ToLower().StartsWith("cn="))
    {
        # Remove CN from common name
        $CommonName = $CommonName.Substring(3)
    }
    if($Password -eq $null)
    {
        $Password = Read-Host -Prompt "Enter Password to protect private key" -AsSecureString
    }
    $cert = Get-ChildItem -Path Cert:\LocalMachine\my | where-object{$_.Subject -eq "CN=$CommonName"}
    
    Export-PfxCertificate -Cert $cert -Password $Password -FilePath "$($CommonName).pfx"
    Export-Certificate -Cert $cert -Type CERT -FilePath "$CommonName.cer"
}

function RemoveCertsFromStore()
{
    # Once the certificates have been been exported we can safely remove them from the store
    if($CommonName.ToLower().StartsWith("cn="))
    {
        # Remove CN from common name
        $CommonName = $CommonName.Substring(3)
    }
    $certs = Get-ChildItem -Path Cert:\LocalMachine\my | Where-Object{$_.Subject -eq "CN=$CommonName"}
    foreach($c in $certs)
    {
        remove-item $c.PSPath
    }
}

if(CreateSelfSignedCertificate)
{
    ExportPFXFile
    RemoveCertsFromStore
}
[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Dependencies\ExchangeOnlineManagement\3.9.2\netFramework\ExchangeOnlineManagement.psm1
# Import the REST module so that the EXO* cmdlets are present before Connect-ExchangeOnline in the powershell instance.
$RestModule = "Microsoft.Exchange.Management.RestApiClient.dll"
$RestModulePath = [System.IO.Path]::Combine($PSScriptRoot, $RestModule)
Import-Module $RestModulePath 

$ExoPowershellModule = "Microsoft.Exchange.Management.ExoPowershellGalleryModule.dll"
$ExoPowershellModulePath = [System.IO.Path]::Combine($PSScriptRoot, $ExoPowershellModule)
Import-Module $ExoPowershellModulePath

#Keep track of Execution status of last cmdlet
$global:EXO_LastExecutionStatus = $true;

############# Helper Functions Begin #############

    <#
    Get the ExchangeOnlineManagement module version.
    Same function is present in the autogen module. Both the codes should be kept in sync.
    #>
    function Get-ModuleVersion
    {
        try
        {
            # Return the already computed version info if available.
            if ($script:ModuleVersion -ne $null -and $script:ModuleVersion -ne '')
            {
                Write-Verbose "Returning precomputed version info: $script:ModuleVersion"
                return $script:ModuleVersion;
            }

            $exoModule = Get-Module ExchangeOnlineManagement
            
            # Check for ExchangeOnlineManagementBeta in case the psm1 is loaded directly
            if ($exoModule -eq $null)
            {
               $exoModule = (Get-Command -Name Connect-ExchangeOnline).Module
            }

            # Get the module version from the loaded module info.
            $script:ModuleVersion = $exoModule.Version.ToString()

            # Look for prerelease information from the corresponding module manifest.
            $exoModuleRoot = (Get-Item $exoModule.Path).Directory.Parent.FullName

            $exoModuleManifestPath = Join-Path -Path $exoModuleRoot -ChildPath ExchangeOnlineManagement.psd1
            $isExoModuleManifestPathValid = Test-Path -Path $exoModuleManifestPath
            if ($isExoModuleManifestPathValid -ne $true)
            {
                # Could be a local debug build import for testing. Skip extracting prerelease info for those.
                Write-Verbose "Module manifest path invalid, path: $exoModuleManifestPath, skipping extracting prerelease info"
                return $script:ModuleVersion
            }

            $exoModuleManifestContent = Get-Content -Path $exoModuleManifestPath
            $preReleaseInfo = $exoModuleManifestContent -match "Prerelease = '(.*)'"
            if ($preReleaseInfo -ne $null)
            {
                $script:ModuleVersion = "{0}-{1}" -f $exoModule.Version.ToString(),$preReleaseInfo[0].Split('=')[1].Trim().Trim("'")
            }

            Write-Verbose "Computed version info: $script:ModuleVersion"
            return $script:ModuleVersion
        }
        catch
        {
            return [string]::Empty
        }
    }

    <#
    .Synopsis Validates a given Uri
    #>
    function Test-Uri
    {
        [CmdletBinding()]
        [OutputType([bool])]
        Param
        (
            # Uri to be validated
            [Parameter(Mandatory=$true, ValueFromPipelineByPropertyName=$true, Position=0)]
            [string]
            $UriString
        )

        [Uri]$uri = $UriString -as [Uri]

        $uri.AbsoluteUri -ne $null -and $uri.Scheme -eq 'https'
    }

    <#
    .Synopsis Is Cloud Shell Environment
    #>
    function global:IsCloudShellEnvironment()
    {
        return [Microsoft.Exchange.Management.AdminApiProvider.Utility]::IsCloudShellEnvironment();
    }

    <#
    .SYNOPSIS Extract organization name from UserPrincipalName
    #>
    function Get-OrgNameFromUPN
    {
        param([string] $UPN)
        $fields = $UPN -split '@'
        return $fields[-1]
    }

    <#
    .SYNOPSIS Get the command from the given module
    #>
    function global:Get-WrappedCommand
    {
        param(
        [string] $CommandName,
        [string] $ModuleName,
        [string] $CommandType)

        $cmd = (Get-Module $moduleName).ExportedFunctions[$CommandName]
        return $cmd
    }

    <#
    .Synopsis Writes a message to the console in Yellow.
    Call this method with caution since it uses Write-Host internally which cannot be suppressed by the user.
    #>
    function Write-Message
    {
        param([string] $message)
        Write-Host $message -ForegroundColor Yellow
    }

############# Helper Functions End #############

###### Begin Main ######

$EOPConnectionInProgress = $false
function Connect-ExchangeOnline 
{
    [CmdletBinding()]
    param(

        # Connection Uri for the Remote PowerShell endpoint
        [string] $ConnectionUri = '',

        # Azure AD Authorization endpoint Uri that can issue the OAuth2 access tokens
        [string] $AzureADAuthorizationEndpointUri = '',

        # Exchange Environment name
        [Microsoft.Exchange.Management.RestApiClient.ExchangeEnvironment] $ExchangeEnvironmentName = 'O365Default',

        # PowerShell session options to be used when opening the Remote PowerShell session
        [System.Management.Automation.Remoting.PSSessionOption] $PSSessionOption = $null,

        # Switch to bypass use of mailbox anchoring hint.
        [switch] $BypassMailboxAnchoring = $false,

        # Delegated Organization Name
        [string] $DelegatedOrganization = '',

        # Prefix 
        [string] $Prefix = '',

        # Show Banner of Exchange cmdlets Mapping and recent updates
        [switch] $ShowBanner = $true,

        #Cmdlets to Import for rps cmdlets , by default it would bring all
        [string[]] $CommandName = @("*"),

        #The way the output objects would be printed on the console
        [string[]] $FormatTypeName = @("*"),

        # Use to Skip Exchange Format file loading into current shell.
        [switch] $SkipLoadingFormatData = $false,

        # Use to skip downloading and loading the help files into the current connection.
        [switch] $SkipLoadingCmdletHelp = $true,

        # Use to enable downloading and loading the help files into the current connection.
        [switch] $LoadCmdletHelp = $false,

        # Externally provided access token
        [string] $AccessToken = '',

        # Client certificate to sign the temp module
        [System.Security.Cryptography.X509Certificates.X509Certificate2] $SigningCertificate = $null,

        # switch to disable WAM
        [switch] $DisableWAM = $false,

        # Temp Base Path
        [string] $EXOModuleBasePath  = [System.IO.Path]::GetTempPath()
    )
    DynamicParam
    {
        if (($isCloudShell = IsCloudShellEnvironment) -eq $false)
        {
            $attributes = New-Object System.Management.Automation.ParameterAttribute
            $attributes.Mandatory = $false

            $attributeCollection = New-Object System.Collections.ObjectModel.Collection[System.Attribute]
            $attributeCollection.Add($attributes)

            # User Principal Name or email address of the user
            $UserPrincipalName = New-Object System.Management.Automation.RuntimeDefinedParameter('UserPrincipalName', [string], $attributeCollection)
            $UserPrincipalName.Value = ''

            # User Credential to Logon
            $Credential = New-Object System.Management.Automation.RuntimeDefinedParameter('Credential', [System.Management.Automation.PSCredential], $attributeCollection)
            $Credential.Value = $null

            # Certificate
            $Certificate = New-Object System.Management.Automation.RuntimeDefinedParameter('Certificate', [System.Security.Cryptography.X509Certificates.X509Certificate2], $attributeCollection)
            $Certificate.Value = $null

            # Certificate Path 
            $CertificateFilePath = New-Object System.Management.Automation.RuntimeDefinedParameter('CertificateFilePath', [string], $attributeCollection)
            $CertificateFilePath.Value = ''

            # Certificate Password
            $CertificatePassword = New-Object System.Management.Automation.RuntimeDefinedParameter('CertificatePassword', [System.Security.SecureString], $attributeCollection)
            $CertificatePassword.Value = $null

            # Certificate Thumbprint
            $CertificateThumbprint = New-Object System.Management.Automation.RuntimeDefinedParameter('CertificateThumbprint', [string], $attributeCollection)
            $CertificateThumbprint.Value = ''

            # Application Id
            $AppId = New-Object System.Management.Automation.RuntimeDefinedParameter('AppId', [string], $attributeCollection)
            $AppId.Value = ''

            # Organization
            $Organization = New-Object System.Management.Automation.RuntimeDefinedParameter('Organization', [string], $attributeCollection)
            $Organization.Value = ''

            # Switch to collect telemetry on command execution. 
            $EnableErrorReporting = New-Object System.Management.Automation.RuntimeDefinedParameter('EnableErrorReporting', [switch], $attributeCollection)
            $EnableErrorReporting.Value = $false
            
            # Where to store EXO command telemetry data. By default telemetry is stored in the directory "%TEMP%/EXOTelemetry" in the file : EXOCmdletTelemetry-yyyymmdd-hhmmss.csv.
            $LogDirectoryPath = New-Object System.Management.Automation.RuntimeDefinedParameter('LogDirectoryPath', [string], $attributeCollection)
            $LogDirectoryPath.Value = [System.IO.Path]::Combine([System.IO.Path]::GetTempPath(), "EXOCmdletTelemetry")

            # Create a new attribute and valiate set against the LogLevel
            $LogLevelAttribute = New-Object System.Management.Automation.ParameterAttribute
            $LogLevelAttribute.Mandatory = $false
            $LogLevelAttributeCollection = New-Object System.Collections.ObjectModel.Collection[System.Attribute]
            $LogLevelAttributeCollection.Add($LogLevelAttribute)
            $LogLevelList = @([Microsoft.Online.CSE.RestApiPowerShellModule.Instrumentation.LogLevel]::Default, [Microsoft.Online.CSE.RestApiPowerShellModule.Instrumentation.LogLevel]::All)
            $ValidateSet = New-Object System.Management.Automation.ValidateSetAttribute($LogLevelList)
            $LogLevel = New-Object System.Management.Automation.RuntimeDefinedParameter('LogLevel', [Microsoft.Online.CSE.RestApiPowerShellModule.Instrumentation.LogLevel], $LogLevelAttributeCollection)
            $LogLevel.Attributes.Add($ValidateSet)

            # Switch to use Managed Identity flow. 
            $ManagedIdentity = New-Object System.Management.Automation.RuntimeDefinedParameter('ManagedIdentity', [switch], $attributeCollection)
            $ManagedIdentity.Value = $false

            # ManagedIdentityAccountId to be used in case of User Assigned Managed Identity flow
            $ManagedIdentityAccountId = New-Object System.Management.Automation.RuntimeDefinedParameter('ManagedIdentityAccountId', [string], $attributeCollection)
            $ManagedIdentityAccountId.Value = ''

# EXO params start

            # Switch to track perfomance 
            $TrackPerformance = New-Object System.Management.Automation.RuntimeDefinedParameter('TrackPerformance', [bool], $attributeCollection)
            $TrackPerformance.Value = $false

            # Flag to enable or disable showing the number of objects written
            $ShowProgress = New-Object System.Management.Automation.RuntimeDefinedParameter('ShowProgress', [bool], $attributeCollection)
            $ShowProgress.Value = $false

            # Switch to enable/disable Multi-threading in the EXO cmdlets
            $UseMultithreading = New-Object System.Management.Automation.RuntimeDefinedParameter('UseMultithreading', [bool], $attributeCollection)
            $UseMultithreading.Value = $true

            # Pagesize Param
            $PageSize = New-Object System.Management.Automation.RuntimeDefinedParameter('PageSize', [uint32], $attributeCollection)
            $PageSize.Value = 1000

            # Switch to MSI auth 
            $Device = New-Object System.Management.Automation.RuntimeDefinedParameter('Device', [switch], $attributeCollection)
            $Device.Value = $false

            # Switch to CmdInline parameters
            $InlineCredential = New-Object System.Management.Automation.RuntimeDefinedParameter('InlineCredential', [switch], $attributeCollection)
            $InlineCredential.Value = $false

# EXO params end
            $paramDictionary = New-object System.Management.Automation.RuntimeDefinedParameterDictionary
            $paramDictionary.Add('UserPrincipalName', $UserPrincipalName)
            $paramDictionary.Add('Credential', $Credential)
            $paramDictionary.Add('Certificate', $Certificate)
            $paramDictionary.Add('CertificateFilePath', $CertificateFilePath)
            $paramDictionary.Add('CertificatePassword', $CertificatePassword)
            $paramDictionary.Add('AppId', $AppId)
            $paramDictionary.Add('Organization', $Organization)
            $paramDictionary.Add('EnableErrorReporting', $EnableErrorReporting)
            $paramDictionary.Add('LogDirectoryPath', $LogDirectoryPath)
            $paramDictionary.Add('LogLevel', $LogLevel)
            $paramDictionary.Add('TrackPerformance', $TrackPerformance)
            $paramDictionary.Add('ShowProgress', $ShowProgress)
            $paramDictionary.Add('UseMultithreading', $UseMultithreading)
            $paramDictionary.Add('PageSize', $PageSize)
            $paramDictionary.Add('ManagedIdentity', $ManagedIdentity)
            $paramDictionary.Add('ManagedIdentityAccountId', $ManagedIdentityAccountId)
            if($PSEdition -eq 'Core')
            {
                $paramDictionary.Add('Device', $Device)
                $paramDictionary.Add('InlineCredential', $InlineCredential);
                # We do not want to expose certificate thumprint in Linux as it is not feasible there.
                if($IsWindows)
                {
                    $paramDictionary.Add('CertificateThumbprint', $CertificateThumbprint);
                }
            }
            else 
            {
                $paramDictionary.Add('CertificateThumbprint', $CertificateThumbprint);
            }

            return $paramDictionary
        }
        else
        {
            $attributes = New-Object System.Management.Automation.ParameterAttribute
            $attributes.Mandatory = $false

            $attributeCollection = New-Object System.Collections.ObjectModel.Collection[System.Attribute]
            $attributeCollection.Add($attributes)

            # Switch to MSI auth 
            $Device = New-Object System.Management.Automation.RuntimeDefinedParameter('Device', [switch], $attributeCollection)
            $Device.Value = $false

            # Switch to collect telemetry on command execution. 
            $EnableErrorReporting = New-Object System.Management.Automation.RuntimeDefinedParameter('EnableErrorReporting', [switch], $attributeCollection)
            $EnableErrorReporting.Value = $false
            
            # Where to store EXO command telemetry data. By default telemetry is stored in the directory "%TEMP%/EXOTelemetry" in the file : EXOCmdletTelemetry-yyyymmdd-hhmmss.csv.
            $LogDirectoryPath = New-Object System.Management.Automation.RuntimeDefinedParameter('LogDirectoryPath', [string], $attributeCollection)
            $LogDirectoryPath.Value = [System.IO.Path]::Combine([System.IO.Path]::GetTempPath(), "EXOCmdletTelemetry")

            # Create a new attribute and validate set against the LogLevel
            $LogLevelAttribute = New-Object System.Management.Automation.ParameterAttribute
            $LogLevelAttribute.Mandatory = $false
            $LogLevelAttributeCollection = New-Object System.Collections.ObjectModel.Collection[System.Attribute]
            $LogLevelAttributeCollection.Add($LogLevelAttribute)
            $LogLevelList = @([Microsoft.Online.CSE.RestApiPowerShellModule.Instrumentation.LogLevel]::Default, [Microsoft.Online.CSE.RestApiPowerShellModule.Instrumentation.LogLevel]::All)
            $ValidateSet = New-Object System.Management.Automation.ValidateSetAttribute($LogLevelList)
            $LogLevel = New-Object System.Management.Automation.RuntimeDefinedParameter('LogLevel', [Microsoft.Online.CSE.RestApiPowerShellModule.Instrumentation.LogLevel], $LogLevelAttributeCollection)
            $LogLevel.Attributes.Add($ValidateSet)

            # Switch to CmdInline parameters
            $InlineCredential = New-Object System.Management.Automation.RuntimeDefinedParameter('InlineCredential', [switch], $attributeCollection)
            $InlineCredential.Value = $false

            # User Credential to Logon
            $Credential = New-Object System.Management.Automation.RuntimeDefinedParameter('Credential', [System.Management.Automation.PSCredential], $attributeCollection)
            $Credential.Value = $null

            $paramDictionary = New-object System.Management.Automation.RuntimeDefinedParameterDictionary
            $paramDictionary.Add('Device', $Device)
            $paramDictionary.Add('EnableErrorReporting', $EnableErrorReporting)
            $paramDictionary.Add('LogDirectoryPath', $LogDirectoryPath)
            $paramDictionary.Add('LogLevel', $LogLevel)
            $paramDictionary.Add('Credential', $Credential)
            $paramDictionary.Add('InlineCredential', $InlineCredential)
            return $paramDictionary
        }
    }
    process {
        $global:EXO_LastExecutionStatus = $true;
        $EnableSearchOnlySession = $false
        if (Test-Path Variable:Script:EnableSearchOnlySession)
        {
            $var = Get-Variable -Name "EnableSearchOnlySession" -Scope Script -ErrorAction SilentlyContinue
            if ($null -ne $var) {
                $EnableSearchOnlySession = $var.Value
            }
        }
        $startTime = Get-Date

        # Validate parameters
        if (($ConnectionUri -ne '') -and (-not (Test-Uri $ConnectionUri)))
        {
            $global:EXO_LastExecutionStatus = $false;
            throw "Invalid ConnectionUri parameter '$ConnectionUri'"
        }
        if (($AzureADAuthorizationEndpointUri -ne '') -and (-not (Test-Uri $AzureADAuthorizationEndpointUri)))
        {
            $global:EXO_LastExecutionStatus = $false;
            throw "Invalid AzureADAuthorizationEndpointUri parameter '$AzureADAuthorizationEndpointUri'"
        }
        if (($Prefix -ne ''))
        {
            if ($Prefix -notmatch '^[a-z0-9]+$') 
            {
                $global:EXO_LastExecutionStatus = $false;
                throw "Use of any special characters in the Prefix string is not supported."
            }
            if ($Prefix -eq 'EXO') 
            {
                $global:EXO_LastExecutionStatus = $false;
                throw "Prefix 'EXO' is a reserved Prefix, please use a different prefix."
            }
        }

        # Keep track of error count at beginning.
        $errorCountAtStart = $global:Error.Count;
        try
        {
            $moduleVersion = Get-ModuleVersion
            Write-Verbose "ModuleVersion: $moduleVersion"

            # Generate a ConnectionId to use in all logs and to send in all server calls.
            $connectionContextID = [System.Guid]::NewGuid()

            $cmdletLogger = New-CmdletLogger -ExoModuleVersion $moduleVersion -LogDirectoryPath $LogDirectoryPath.Value -EnableErrorReporting:$EnableErrorReporting.Value -ConnectionId $connectionContextID
            $logFilePath = $cmdletLogger.GetCurrentLogFilePath()
            
            if ($EnableErrorReporting.Value -eq $true)
            {
                Write-Message ("Writing cmdlet logs to " + $logFilePath)
            }

            $cmdletLogger.InitLog($connectionContextID)
            $cmdletLogger.LogStartTime($connectionContextID, $startTime)
            if ($EOPConnectionInProgress -eq $true)
            {
                $cmdletLogger.LogCmdletName($connectionContextID, "Connect-IPPSSession");
            }
            else
            {
                $cmdletLogger.LogCmdletName($connectionContextID, "Connect-ExchangeOnline");
            }
            $cmdletLogger.LogCmdletParameters($connectionContextID, $PSBoundParameters);

            if ($isCloudShell -eq $false)
            {
                $ConnectionContext = Get-ConnectionContext -ExchangeEnvironmentName $ExchangeEnvironmentName -ConnectionUri $ConnectionUri `
                -AzureADAuthorizationEndpointUri $AzureADAuthorizationEndpointUri -UserPrincipalName $UserPrincipalName.Value `
                -PSSessionOption $PSSessionOption -Credential $Credential.Value -BypassMailboxAnchoring:$BypassMailboxAnchoring `
                -DelegatedOrg $DelegatedOrganization -Certificate $Certificate.Value -CertificateFilePath $CertificateFilePath.Value `
                -CertificatePassword $CertificatePassword.Value -CertificateThumbprint $CertificateThumbprint.Value -AppId $AppId.Value `
                -Organization $Organization.Value -Device:$Device.Value -InlineCredential:$InlineCredential.Value -CommandName $CommandName `
                -FormatTypeName $FormatTypeName -Prefix $Prefix -PageSize $PageSize.Value -ExoModuleVersion:$moduleVersion -Logger $cmdletLogger `
                -ConnectionId $connectionContextID -EnableErrorReporting:$EnableErrorReporting.Value `
                -ManagedIdentity:$ManagedIdentity.Value -ManagedIdentityAccountId $ManagedIdentityAccountId.Value -AccessToken $AccessToken -DisableWAM:$DisableWAM -LogDirectoryPath $LogDirectoryPath.Value -EnableSearchOnlySession $EnableSearchOnlySession -EXOModuleBasePath $EXOModuleBasePath
            }
            else
            {
                $ConnectionContext = Get-ConnectionContext -ExchangeEnvironmentName $ExchangeEnvironmentName -ConnectionUri $ConnectionUri `
                -AzureADAuthorizationEndpointUri $AzureADAuthorizationEndpointUri -Credential $Credential.Value -PSSessionOption $PSSessionOption `
                -BypassMailboxAnchoring:$BypassMailboxAnchoring -Device:$Device.Value -InlineCredential:$InlineCredential.Value `
                -DelegatedOrg $DelegatedOrganization -CommandName $CommandName -FormatTypeName $FormatTypeName -Prefix $Prefix -ExoModuleVersion:$moduleVersion `
                -Logger $cmdletLogger -ConnectionId $connectionContextID -EnableErrorReporting:$EnableErrorReporting.Value -AccessToken $AccessToken -DisableWAM:$DisableWAM -LogDirectoryPath $LogDirectoryPath.Value -EnableSearchOnlySession $EnableSearchOnlySession -EXOModuleBasePath $EXOModuleBasePath

            }

            if ($isCloudShell -eq $false)
            {
                $global:_EXO_EnableErrorReporting = $EnableErrorReporting.Value;
            }

            if ($ShowBanner -eq $true)
            {
                try
                {
                    $BannerContent = Get-EXOBanner -ConnectionContext:$ConnectionContext
                    Write-Host -ForegroundColor Yellow $BannerContent
                }
                catch
                {
                    Write-Verbose "Failed to fetch banner content from server. Reason: $_"
                    $cmdletLogger.LogGenericError($connectionContextID, $_);
                }
            }

            if (($ConnectionUri -ne '') -and ($AzureADAuthorizationEndpointUri -eq ''))
            {
                Write-Information "Using ConnectionUri:'$ConnectionUri', in the environment:'$ExchangeEnvironmentName'."
            }
            if (($AzureADAuthorizationEndpointUri -ne '') -and ($ConnectionUri -eq ''))
            {
                Write-Information "Using AzureADAuthorizationEndpointUri:'$AzureADAuthorizationEndpointUri', in the environment:'$ExchangeEnvironmentName'."
            }

            $ImportedModuleName = '';
            $LogModuleDirectoryPath = [System.IO.Path]::GetTempPath();

            

            # Download the new web based EXOModule
            if ($SigningCertificate -ne $null)
            {
                $ImportedModule = New-EXOModule -ConnectionContext $ConnectionContext -SkipLoadingFormatData:$SkipLoadingFormatData -SigningCertificate $SigningCertificate;
            }
            else
            {
                $ImportedModule = New-EXOModule -ConnectionContext $ConnectionContext -SkipLoadingFormatData:$SkipLoadingFormatData;
            }
            if ($null -ne $ImportedModule)
            {
                $ImportedModuleName = $ImportedModule.Name;
                $LogModuleDirectoryPath = $ImportedModule.ModuleBase

                Write-Verbose "AutoGen EXOModule created at  $($ImportedModule.ModuleBase)"

                if ($LoadCmdletHelp -eq $true -and $HelpFileNames -ne $null -and $HelpFileNames -is [array] -and $HelpFileNames.Count -gt 0)
                {
                    Get-HelpFiles -HelpFileNames $HelpFileNames -ConnectionContext $ConnectionContext -ImportedModule $ImportedModule -EnableErrorReporting:$EnableErrorReporting.Value
                }
                else
                {
                    $cmdletLogger.LogGenericInfo($connectionContextID, "Skipping cmdlet help data");
                }
            }
            else
            {
                $global:EXO_LastExecutionStatus = $false;
                throw "Module could not be correctly formed. Please run Connect-ExchangeOnline again."
            }
            

            # If we are configured to collect telemetry, add telemetry wrappers in case of an RPS connection
            if ($EnableErrorReporting.Value -eq $true)
            {

                $endTime = Get-Date
                $cmdletLogger.LogEndTime($connectionContextID, $endTime);
                $cmdletLogger.CommitLog($connectionContextID);

                if ($EOPConnectionInProgress -eq $false)
                {
                    # Set the AppSettings
                    Set-ExoAppSettings -ShowProgress $ShowProgress.Value -PageSize $PageSize.Value -UseMultithreading $UseMultithreading.Value -TrackPerformance $TrackPerformance.Value -EnableErrorReporting $true -LogDirectoryPath $LogDirectoryPath.Value -LogLevel $LogLevel.Value
                }
            }
            else 
            {
                if ($EOPConnectionInProgress -eq $false)
                {
                    # Set the AppSettings disabling the logging
                    Set-ExoAppSettings -ShowProgress $ShowProgress.Value -PageSize $PageSize.Value -UseMultithreading $UseMultithreading.Value -TrackPerformance $TrackPerformance.Value -EnableErrorReporting $false
                }
            }
        }
        catch
        {
            # If telemetry is enabled, log errors generated from this cmdlet also.
            # If telemetry is not enabled, calls to cmdletLogger will be a no-op.
            $errorCountAtProcessEnd = $global:Error.Count 
            $numErrorRecordsToConsider = $errorCountAtProcessEnd - $errorCountAtStart
            for ($i = 0 ; $i -lt $numErrorRecordsToConsider ; $i++)
            {
                $cmdletLogger.LogGenericError($connectionContextID, $global:Error[$i]);
            }

            $cmdletLogger.CommitLog($connectionContextID);

            if ($EnableErrorReporting.Value -eq $true)
            {
                if ($global:_EXO_TelemetryFilePath -eq $null)
                {
                    $global:_EXO_TelemetryFilePath = New-EXOClientTelemetryFilePath -LogDirectoryPath $LogDirectoryPath.Value

                    # Import the REST module
                    $RestPowershellModule = "Microsoft.Exchange.Management.RestApiClient.dll";
                    $RestModulePath = [System.IO.Path]::Combine($PSScriptRoot, $RestPowershellModule);
                    Import-Module $RestModulePath -Cmdlet Set-ExoAppSettings;

                    # Set the AppSettings
                    Set-ExoAppSettings -ShowProgress $ShowProgress.Value -PageSize $PageSize.Value -UseMultithreading $UseMultithreading.Value -TrackPerformance $TrackPerformance.Value -ConnectionUri $ConnectionUri -EnableErrorReporting $true -LogDirectoryPath $LogDirectoryPath.Value -LogLevel $LogLevel.Value
                }

                # Log errors which are encountered during Connect-ExchangeOnline execution. 
                Write-Message ("Writing Connect-ExchangeOnline error log to " + $global:_EXO_TelemetryFilePath)
                Push-EXOTelemetryRecord -TelemetryFilePath $global:_EXO_TelemetryFilePath -CommandName Connect-ExchangeOnline -CommandParams $PSCmdlet.MyInvocation.BoundParameters -OrganizationName  $global:_EXO_ExPSTelemetryOrganization -ScriptName $global:_EXO_ExPSTelemetryScriptName  -ScriptExecutionGuid $global:_EXO_ExPSTelemetryScriptExecutionGuid -ErrorObject $global:Error -ErrorRecordsToConsider ($errorCountAtProcessEnd - $errorCountAtStart) 
            }

            $global:EXO_LastExecutionStatus = $false;

            if ($_.Exception -ne $null)
            {
                # Connect-ExchangeOnline Failed, Remove ConnectionContext from Map.
                if ([Microsoft.Exchange.Management.ExoPowershellSnapin.ConnectionContextFactory]::RemoveConnectionContextUsingConnectionId($connectionContextID))
                {
                    Write-Verbose "ConnectionContext Removed"
                }

                if ($_.Exception.InnerException -ne $null)
                {
                    throw $_.Exception.InnerException;
                }
                else
                {
                    throw $_.Exception;
                }
            }
            else
            {
                throw $_;
            }
        }
    }
}

function Connect-IPPSSession
{
    [CmdletBinding()]
    param(
        # Connection Uri for the Remote PowerShell endpoint
        [string] $ConnectionUri = 'https://ps.compliance.protection.outlook.com/PowerShell-LiveId',

        # Azure AD Authorization endpoint Uri that can issue the OAuth2 access tokens
        [string] $AzureADAuthorizationEndpointUri = 'https://login.microsoftonline.com/organizations',

        # Delegated Organization Name
        [string] $DelegatedOrganization = '',

        # PowerShell session options to be used when opening the Remote PowerShell session
        [System.Management.Automation.Remoting.PSSessionOption] $PSSessionOption = $null,

        # Switch to bypass use of mailbox anchoring hint.
        [switch] $BypassMailboxAnchoring = $false,

        # Prefix 
        [string] $Prefix = '',

        #Cmdlets to Import, by default it would bring all
        [string[]] $CommandName = @("*"),

        #The way the output objects would be printed on the console
        [string[]] $FormatTypeName = @("*"),

        # Show Banner of scc cmdlets Mapping and recent updates
        [switch] $ShowBanner = $true,

        # switch to disable WAM
        [switch] $DisableWAM = $false,

        # Externally provided access token
        [string] $AccessToken = '',
        
        # Switch to using OBO Token
        [switch] $EnableSearchOnlySession = $false,

        # TempBasePath
        [string] $EXOModuleBasePath = [System.IO.Path]::GetTempPath()
    )
    DynamicParam
    {
        if (($isCloudShell = IsCloudShellEnvironment) -eq $false)
        {
            $attributes = New-Object System.Management.Automation.ParameterAttribute
            $attributes.Mandatory = $false

            $attributeCollection = New-Object System.Collections.ObjectModel.Collection[System.Attribute]
            $attributeCollection.Add($attributes)

            # User Principal Name or email address of the user
            $UserPrincipalName = New-Object System.Management.Automation.RuntimeDefinedParameter('UserPrincipalName', [string], $attributeCollection)
            $UserPrincipalName.Value = ''

            # User Credential to Logon
            $Credential = New-Object System.Management.Automation.RuntimeDefinedParameter('Credential', [System.Management.Automation.PSCredential], $attributeCollection)
            $Credential.Value = $null

            # Certificate
            $Certificate = New-Object System.Management.Automation.RuntimeDefinedParameter('Certificate', [System.Security.Cryptography.X509Certificates.X509Certificate2], $attributeCollection)
            $Certificate.Value = $null

            # Certificate Path 
            $CertificateFilePath = New-Object System.Management.Automation.RuntimeDefinedParameter('CertificateFilePath', [string], $attributeCollection)
            $CertificateFilePath.Value = ''

            # Certificate Password
            $CertificatePassword = New-Object System.Management.Automation.RuntimeDefinedParameter('CertificatePassword', [System.Security.SecureString], $attributeCollection)
            $CertificatePassword.Value = $null

            # Certificate Thumbprint
            $CertificateThumbprint = New-Object System.Management.Automation.RuntimeDefinedParameter('CertificateThumbprint', [string], $attributeCollection)
            $CertificateThumbprint.Value = ''

            # Application Id
            $AppId = New-Object System.Management.Automation.RuntimeDefinedParameter('AppId', [string], $attributeCollection)
            $AppId.Value = ''

            # Organization
            $Organization = New-Object System.Management.Automation.RuntimeDefinedParameter('Organization', [string], $attributeCollection)
            $Organization.Value = ''

            # Switch to collect telemetry on command execution. 
            $EnableErrorReporting = New-Object System.Management.Automation.RuntimeDefinedParameter('EnableErrorReporting', [switch], $attributeCollection)
            $EnableErrorReporting.Value = $false
            
            # Where to store command telemetry data. By default telemetry is stored in the directory "%TEMP%/EXOTelemetry" in the file : EXOCmdletTelemetry-yyyymmdd-hhmmss.csv.
            $LogDirectoryPath = New-Object System.Management.Automation.RuntimeDefinedParameter('LogDirectoryPath', [string], $attributeCollection)
            $LogDirectoryPath.Value = [System.IO.Path]::Combine([System.IO.Path]::GetTempPath(), "EXOCmdletTelemetry")
            # Create a new attribute and validate set against the LogLevel
            $LogLevelAttribute = New-Object System.Management.Automation.ParameterAttribute
            $LogLevelAttribute.Mandatory = $false
            $LogLevelAttributeCollection = New-Object System.Collections.ObjectModel.Collection[System.Attribute]
            $LogLevelAttributeCollection.Add($LogLevelAttribute)
            $LogLevelList = @([Microsoft.Online.CSE.RestApiPowerShellModule.Instrumentation.LogLevel]::Default, [Microsoft.Online.CSE.RestApiPowerShellModule.Instrumentation.LogLevel]::All)
            $ValidateSet = New-Object System.Management.Automation.ValidateSetAttribute($LogLevelList)
            $LogLevel = New-Object System.Management.Automation.RuntimeDefinedParameter('LogLevel', [Microsoft.Online.CSE.RestApiPowerShellModule.Instrumentation.LogLevel], $LogLevelAttributeCollection)
            $LogLevel.Attributes.Add($ValidateSet)

            $paramDictionary = New-object System.Management.Automation.RuntimeDefinedParameterDictionary
            $paramDictionary.Add('UserPrincipalName', $UserPrincipalName)
            $paramDictionary.Add('Credential', $Credential)
            $paramDictionary.Add('Certificate', $Certificate)
            $paramDictionary.Add('CertificateFilePath', $CertificateFilePath)
            $paramDictionary.Add('CertificatePassword', $CertificatePassword)
            $paramDictionary.Add('AppId', $AppId)
            $paramDictionary.Add('Organization', $Organization)
            $paramDictionary.Add('EnableErrorReporting', $EnableErrorReporting)
            $paramDictionary.Add('LogDirectoryPath', $LogDirectoryPath)
            $paramDictionary.Add('LogLevel', $LogLevel)
            if($PSEdition -eq 'Core')
            {
                # We do not want to expose certificate thumprint in Linux as it is not feasible there.
                if($IsWindows)
                {
                    $paramDictionary.Add('CertificateThumbprint', $CertificateThumbprint);
                }
            }
            else 
            {
                $paramDictionary.Add('CertificateThumbprint', $CertificateThumbprint);
            }

            return $paramDictionary
        }
        else
        {
            $attributes = New-Object System.Management.Automation.ParameterAttribute
            $attributes.Mandatory = $false

            $attributeCollection = New-Object System.Collections.ObjectModel.Collection[System.Attribute]
            $attributeCollection.Add($attributes)

            # Switch to MSI auth 
            $Device = New-Object System.Management.Automation.RuntimeDefinedParameter('Device', [switch], $attributeCollection)
            $Device.Value = $false

            # Switch to collect telemetry on command execution. 
            $EnableErrorReporting = New-Object System.Management.Automation.RuntimeDefinedParameter('EnableErrorReporting', [switch], $attributeCollection)
            $EnableErrorReporting.Value = $false
            
            # Where to store EXO command telemetry data. By default telemetry is stored in the directory "%TEMP%/EXOTelemetry" in the file : EXOCmdletTelemetry-yyyymmdd-hhmmss.csv.
            $LogDirectoryPath = New-Object System.Management.Automation.RuntimeDefinedParameter('LogDirectoryPath', [string], $attributeCollection)
            $LogDirectoryPath.Value = [System.IO.Path]::Combine([System.IO.Path]::GetTempPath(), "EXOCmdletTelemetry")
            # Create a new attribute and validate set against the LogLevel
            $LogLevelAttribute = New-Object System.Management.Automation.ParameterAttribute
            $LogLevelAttribute.Mandatory = $false
            $LogLevelAttributeCollection = New-Object System.Collections.ObjectModel.Collection[System.Attribute]
            $LogLevelAttributeCollection.Add($LogLevelAttribute)
            $LogLevelList = @([Microsoft.Online.CSE.RestApiPowerShellModule.Instrumentation.LogLevel]::Default, [Microsoft.Online.CSE.RestApiPowerShellModule.Instrumentation.LogLevel]::All)
            $ValidateSet = New-Object System.Management.Automation.ValidateSetAttribute($LogLevelList)
            $LogLevel = New-Object System.Management.Automation.RuntimeDefinedParameter('LogLevel', [Microsoft.Online.CSE.RestApiPowerShellModule.Instrumentation.LogLevel], $LogLevelAttributeCollection)
            $LogLevel.Attributes.Add($ValidateSet)
            $paramDictionary = New-object System.Management.Automation.RuntimeDefinedParameterDictionary
            $paramDictionary.Add('Device', $Device)
            $paramDictionary.Add('EnableErrorReporting', $EnableErrorReporting)
            $paramDictionary.Add('LogDirectoryPath', $LogDirectoryPath)
            $paramDictionary.Add('LogLevel', $LogLevel)
            return $paramDictionary
        }
    }
    process 
    {
        try
        {
            $EOPConnectionInProgress = $true
            Set-Variable -Name "EnableSearchOnlySession" -Value $EnableSearchOnlySession.IsPresent -Scope Script
            if ($isCloudShell -eq $false)
            {
                $LogLevelValue = [Microsoft.Online.CSE.RestApiPowerShellModule.Instrumentation.LogLevel]::All
                if($LogLevel.Value)
                {
                    $LogLevelValue = $LogLevel.Value
                }
                $certThumbprint = $CertificateThumbprint.Value
                # Will pass CertificateThumbprint if it is not null or not empty
                if($certThumbprint)
                {
                    Connect-ExchangeOnline -ConnectionUri $ConnectionUri -AzureADAuthorizationEndpointUri $AzureADAuthorizationEndpointUri -UserPrincipalName $UserPrincipalName.Value -PSSessionOption $PSSessionOption -Credential $Credential.Value -BypassMailboxAnchoring:$BypassMailboxAnchoring -ShowBanner:$ShowBanner -DelegatedOrganization $DelegatedOrganization -Certificate $Certificate.Value -CertificateFilePath $CertificateFilePath.Value -CertificatePassword $CertificatePassword.Value -CertificateThumbprint $certThumbprint -AppId $AppId.Value -Organization $Organization.Value -Prefix $Prefix -CommandName $CommandName -FormatTypeName $FormatTypeName -DisableWAM:$DisableWAM -EnableErrorReporting:$EnableErrorReporting.Value -LogLevel $LogLevelValue -LogDirectoryPath $LogDirectoryPath.Value -EXOModuleBasePath $EXOModuleBasePath
                }
                else
                {
                    Connect-ExchangeOnline -ConnectionUri $ConnectionUri -AzureADAuthorizationEndpointUri $AzureADAuthorizationEndpointUri -UserPrincipalName $UserPrincipalName.Value -PSSessionOption $PSSessionOption -Credential $Credential.Value -BypassMailboxAnchoring:$BypassMailboxAnchoring -ShowBanner:$ShowBanner -DelegatedOrganization $DelegatedOrganization -Certificate $Certificate.Value -CertificateFilePath $CertificateFilePath.Value -CertificatePassword $CertificatePassword.Value -AppId $AppId.Value -Organization $Organization.Value -Prefix $Prefix -CommandName $CommandName -FormatTypeName $FormatTypeName -DisableWAM:$DisableWAM -AccessToken $AccessToken -EnableErrorReporting:$EnableErrorReporting.Value -LogLevel $LogLevelValue -LogDirectoryPath $LogDirectoryPath.Value -EXOModuleBasePath $EXOModuleBasePath
                }
            }
            else
            {
                Connect-ExchangeOnline -ConnectionUri $ConnectionUri -AzureADAuthorizationEndpointUri $AzureADAuthorizationEndpointUri -PSSessionOption $PSSessionOption -BypassMailboxAnchoring:$BypassMailboxAnchoring -Device:$Device.Value -ShowBanner:$ShowBanner -DelegatedOrganization $DelegatedOrganization -Prefix $Prefix -CommandName $CommandName -FormatTypeName $FormatTypeName -DisableWAM:$DisableWAM -AccessToken $AccessToken -EnableErrorReporting:$EnableErrorReporting.Value -LogLevel $LogLevelValue -LogDirectoryPath $LogDirectoryPath.Value -EXOModuleBasePath $EXOModuleBasePath
            }
        }
        finally
        {
            $EOPConnectionInProgress = $false
        }
    }
}

function Disconnect-ExchangeOnline
{
    [CmdletBinding(SupportsShouldProcess, ConfirmImpact='High', DefaultParameterSetName='DefaultParameterSet')]
    param(
        [Parameter(Mandatory=$true, ParameterSetName='ConnectionId', ValueFromPipelineByPropertyName=$true)]
        [string[]] $ConnectionId,
        [Parameter(Mandatory=$true, ParameterSetName='ModulePrefix')]
        [string[]] $ModulePrefix
    )

    process
    {
        $global:EXO_LastExecutionStatus = $true;
        $disconnectConfirmationMessage = ""
        Switch ($PSCmdlet.ParameterSetName)
        {
            'ConnectionId'
            {
                $disconnectConfirmationMessage = [Microsoft.Exchange.Management.ExoPowershellSnapin.ConnectionContextFactory]::GetDisconnectConfirmationMessageByConnectionId($ConnectionId)
                break
            }
            'ModulePrefix'
            {
                $disconnectConfirmationMessage = [Microsoft.Exchange.Management.ExoPowershellSnapin.ConnectionContextFactory]::GetDisconnectConfirmationMessageByModulePrefix($ModulePrefix)
                break
            }
            Default
            {
                $disconnectConfirmationMessage = [Microsoft.Exchange.Management.ExoPowershellSnapin.ConnectionContextFactory]::GetDisconnectConfirmationMessageWithInbuilt()
            }
        }
	
        if ($PSCmdlet.ShouldProcess(
            $disconnectConfirmationMessage,
            "Press(Y/y/A/a) if you want to continue.",
            $disconnectConfirmationMessage))
        {

            # Keep track of error count at beginning.
            $errorCountAtStart = $global:Error.Count;
            $startTime = Get-Date

            try
            {
                # Get all the connection contexts so that the logger can be initialized.
                $connectionContexts = [Microsoft.Exchange.Management.ExoPowershellSnapin.ConnectionContextFactory]::GetAllConnectionContexts()
                $disconnectCmdletId = [System.Guid]::NewGuid().ToString()

                # denotes if any of the connections is an RPS session.
                # This is used to Push-EXOTelemetryRecord in case any RPS connections are present.
                $rpsConnectionWithErrorReportingExists = $false
                
                foreach ($context in $connectionContexts)
                {
                    $context.Logger.InitLog($disconnectCmdletId);
                    $context.Logger.LogStartTime($disconnectCmdletId, $startTime);
                    $context.Logger.LogCmdletName($disconnectCmdletId, "Disconnect-ExchangeOnline");
                    if ($context.IsRpsSession -and $context.ErrorReportingEnabled)
                    {
                        $rpsConnectionWithErrorReportingExists = $true
                    }
                }

                # Import the module once more to ensure that Test-ActiveToken is present
                $ExoPowershellModule = "Microsoft.Exchange.Management.ExoPowershellGalleryModule.dll";
                $ModulePath = [System.IO.Path]::Combine($PSScriptRoot, $ExoPowershellModule);
                Import-Module $ModulePath -Cmdlet Clear-ActiveToken;

                $existingPSSession = Get-PSSession | Where-Object {$_.ConfigurationName -like "Microsoft.Exchange" -and $_.Name -like "ExchangeOnlineInternalSession*"}

                if ($existingPSSession.count -gt 0) 
                {
                    for ($index = 0; $index -lt $existingPSSession.count; $index++)
                    {
                        $session = $existingPSSession[$index]
                        Remove-PSSession -session $session

                        Write-Information "Removed the PSSession $($session.Name) connected to $($session.ComputerName)"

                        # Remove any active access token from the cache
                        # If the connectionId of the session being cleared is equal to AppSettings.ConnectionId, this means connection to EXO cmdlets will break.
                        if ($session.ConnectionContext.ConnectionId -ieq [Microsoft.Exchange.Management.AdminApiProvider.AppSettings]::ConnectionId)
                        {
                            Clear-ActiveToken -TokenProvider $session.TokenProvider -IsSessionUsedByInbuiltCmdlets:$true
                        }
                        else
                        {
                            Clear-ActiveToken -TokenProvider $session.TokenProvider -IsSessionUsedByInbuiltCmdlets:$false
                        }

                        # Remove any previous modules loaded because of the current PSSession
                        if ($session.PreviousModuleName -ne $null)
                        {
                            if ((Get-Module $session.PreviousModuleName).Count -ne 0)
                            {
                                $null = Remove-Module -Name $session.PreviousModuleName -ErrorAction SilentlyContinue
                            }

                            $session.PreviousModuleName = $null
                        }

                        # Remove any leaked module in case of removal of broken session object
                        if ($session.CurrentModuleName -ne $null)
                        {
                            if ((Get-Module $session.CurrentModuleName).Count -ne 0)
                            {
                                $null = Remove-Module -Name $session.CurrentModuleName -ErrorAction SilentlyContinue
                            }
                        }
                    }
                }

                $modulesToRemove = $null
                Switch ($PSCmdlet.ParameterSetName)
                {
                    'ConnectionId'
                    {
                        # Call GetModulesToRemoveByConnectionId in this scenario
                        $modulesToRemove = [Microsoft.Exchange.Management.ExoPowershellSnapin.ConnectionContextFactory]::GetModulesToRemoveByConnectionId($ConnectionId)
                        break
                    }
                    'ModulePrefix'
                    {
                        # Call GetModulesToRemoveByModulePrefix in this scenario
                        $modulesToRemove = [Microsoft.Exchange.Management.ExoPowershellSnapin.ConnectionContextFactory]::GetModulesToRemoveByModulePrefix($ModulePrefix)
                        break
                    }
                    Default
                    {
                        # Remove all the AutoREST modules from this instance of powershell if created
                        $existingAutoRESTModules = Get-Module "tmpEXO_*"
                        foreach ($module in $existingAutoRESTModules)
                        {  
                            $null = Remove-Module -Name $module -ErrorAction SilentlyContinue
                        }

                        # The below call to remove all connection contexts could be removed as we already have an OnRemove event hooked to the module. Work Item 3461604 to investigate this
                        # Remove all ConnectionContexts
                        # this internally clears all the active tokens in ConnectionContexts
                        [Microsoft.Exchange.Management.ExoPowershellSnapin.ConnectionContextFactory]::RemoveAllConnectionContexts()
                    }
                }

                if ($modulesToRemove -ne $null -and $modulesToRemove.Count -gt 0)
                {
                    $null = Remove-Module $modulesToRemove -ErrorAction SilentlyContinue
                }

                Write-Information "Disconnected successfully !"

                # Remove all the Wrapped modules from this instance of powershell if created
                $existingWrappedModules = Get-Module "EXOCmdletWrapper-*"
                foreach ($module in $existingWrappedModules)
                {
                    $null = Remove-Module -Name $module -ErrorAction SilentlyContinue
                }

                if ($rpsConnectionWithErrorReportingExists)
                {
                    if ($global:_EXO_TelemetryFilePath -eq $null)
                    {
                        $global:_EXO_TelemetryFilePath = New-EXOClientTelemetryFilePath
                    }

                    Push-EXOTelemetryRecord -TelemetryFilePath $global:_EXO_TelemetryFilePath -CommandName Disconnect-ExchangeOnline -CommandParams $PSCmdlet.MyInvocation.BoundParameters -OrganizationName  $global:_EXO_ExPSTelemetryOrganization -ScriptName $global:_EXO_ExPSTelemetryScriptName  -ScriptExecutionGuid $global:_EXO_ExPSTelemetryScriptExecutionGuid
                }
            }
            catch
            {
                # If telemetry is enabled for any of the connections, log errors generated from this cmdlet also. 
                $errorCountAtProcessEnd = $global:Error.Count
                $global:EXO_LastExecutionStatus = $false;
                
                $endTime = Get-Date
                foreach ($context in $connectionContexts)
                {
                    $numErrorRecordsToConsider = $errorCountAtProcessEnd - $errorCountAtStart
                    for ($i = 0 ; $i -lt $numErrorRecordsToConsider ; $i++)
                    {
                        $context.Logger.LogGenericError($disconnectCmdletId, $global:Error[$i]);
                    }

                    $context.Logger.LogEndTime($disconnectCmdletId, $endTime);
                    $context.Logger.CommitLog($disconnectCmdletId);
                    $logFilePath = $context.Logger.GetCurrentLogFilePath();
                }

                if ($rpsConnectionWithErrorReportingExists)
                {
                    if ($global:_EXO_TelemetryFilePath -eq $null)
                    {
                        $global:_EXO_TelemetryFilePath = New-EXOClientTelemetryFilePath
                    }

                    # Log errors which are encountered during Disconnect-ExchangeOnline execution. 
                    Write-Message ("Writing Disconnect-ExchangeOnline errors to " + $global:_EXO_TelemetryFilePath)

                    Push-EXOTelemetryRecord -TelemetryFilePath $global:_EXO_TelemetryFilePath -CommandName Disconnect-ExchangeOnline -CommandParams $PSCmdlet.MyInvocation.BoundParameters -OrganizationName  $global:_EXO_ExPSTelemetryOrganization -ScriptName $global:_EXO_ExPSTelemetryScriptName  -ScriptExecutionGuid $global:_EXO_ExPSTelemetryScriptExecutionGuid -ErrorObject $global:Error -ErrorRecordsToConsider ($errorCountAtProcessEnd - $errorCountAtStart) 
                }

                throw $_
            }

            $endTime = Get-Date
            foreach ($context in $connectionContexts)
            {
                if ($context.Logger -ne $null)
                {
                    $context.Logger.LogEndTime($disconnectCmdletId, $endTime);
                    $context.Logger.CommitLog($disconnectCmdletId);
                }
            }
        }
    }
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Dependencies\PackageManagement\1.4.8.1\DSCResources\MSFT_PackageManagement\MSFT_PackageManagement.psm1
#
# Copyright (c) Microsoft Corporation.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# This PS DSC resource enables installing a package. The resource uses Install-Package cmdlet
# to install the package from various providers/sources.

Import-LocalizedData -BindingVariable LocalizedData -filename MSFT_PackageManagement.strings.psd1

Import-Module -Name "$PSScriptRoot\..\PackageManagementDscUtilities.psm1"

function Get-TargetResource
{
    <#
    .SYNOPSIS

    This DSC resource provides a mechanism to download and install packages on a computer. 

    Get-TargetResource returns the current state of the resource.

    .PARAMETER Name
    Specifies the name of the Package to be installed or uninstalled.

    .PARAMETER Source
    Specifies the name of the package source where the package can be found.
    This can either be a URI or a source registered with Register-PackageSource cmdlet.
    The DSC resource MSFT_PackageManagementSource can also register a package source.
    
    .PARAMETER RequiredVersion
    Specifies the exact version of the package that you want to install. If you do not specify this parameter, 
    this DSC resource installs the newest available version of the package that also satisfies any
    maximum version specified by the MaximumVersion parameter.

    .PARAMETER MaximumVersion
    Specifies the maximum allowed version of the package that you want to install. If you do not specify this parameter, 
    this DSC resource installs the highest-numbered available version of the package.

    .PARAMETER MinimumVersion
    Specifies the minimum allowed version of the package that you want to install. If you do not add this parameter, 
    this DSC resource intalls the highest available version of the package that also satisfies any maximum 
    specified version specified by the MaximumVersion parameter.

    .PARAMETER SourceCredential
    Specifies a user account that has rights to install a package for a specified package provider or source.

    .PARAMETER ProviderName
    Specifies a package provider name to which to scope your package search. You can get package provider names 
    by running the Get-PackageProvider cmdlet.

    .PARAMETER AdditionalParameters
    Provider specific parameters that are passed as an Hashtable. For example, for NuGet provider you can
    pass additional parameters like DestinationPath.
    #>

    [CmdletBinding()]
    [OutputType([System.Collections.Hashtable])]
    param
    (
        [Parameter(Mandatory = $true)]
        [System.String]
        $Name,

        [Parameter()]
        [System.String]
        $RequiredVersion,
        
        [Parameter()]
        [System.String]
        $MinimumVersion,

        [Parameter()]
        [System.String]
        $MaximumVersion,

        [Parameter()]
        [System.String]
        $Source,

        [Parameter()]
        [PSCredential] $SourceCredential,

        [Parameter()]
        [System.String]
        $ProviderName,
        
        [Parameter()]
        [Microsoft.Management.Infrastructure.CimInstance[]]$AdditionalParameters        
    )
    
    $ensure = "Absent"
    $null = $PSBoundParameters.Remove("Source")
    $null = $PSBoundParameters.Remove("SourceCredential")

    if ($AdditionalParameters)
    {
         foreach($instance in $AdditionalParameters)
         {
             Write-Verbose ('AdditionalParameter: {0}, AdditionalParameterValue: {1}' -f $instance.Key, $instance.Value)
             $null = $PSBoundParameters.Add($instance.Key, $instance.Value)
         }
    }
    $null = $PSBoundParameters.Remove("AdditionalParameters")
    
    $verboseMessage =$localizedData.StartGetPackage -f (GetMessageFromParameterDictionary $PSBoundParameters),$env:PSModulePath
    Write-Verbose -Message $verboseMessage
    $result = PackageManagement\Get-Package @PSBoundParameters -ErrorAction SilentlyContinue -WarningAction SilentlyContinue
        

    if ($result.count -eq 1)
    {
        Write-Verbose -Message ($localizedData.PackageFound -f $Name)
        $ensure = "Present"
    }
    elseif ($result.count -gt 1)
    {
        Write-Verbose -Message ($localizedData.MultiplePackagesFound -f $Name)
        $ensure = "Present"
    }
    else
    {
        Write-Verbose -Message ($localizedData.PackageNotFound -f $($Name))
    }

    Write-Debug -Message "Source $($Name) is $($ensure)"
                         
    
    if ($ensure -eq 'Absent')
    {
        return @{
            Ensure       = $ensure
            Name         = $Name
            ProviderName = $ProviderName
            RequiredVersion = $RequiredVersion
            MinimumVersion = $MinimumVersion
            MaximumVersion = $MaximumVersion
        }
    }
    else
    {
        if ($result.Count -gt 1)
        {
          $result = $result[0]
        }

        return  @{
                Ensure             = $ensure
                Name               = $result.Name
                ProviderName       = $result.ProviderName
                Source             = $result.source
                RequiredVersion    = $result.Version
            } 
    } 
}

function Test-TargetResource
{
    <#
    .SYNOPSIS

    This DSC resource provides a mechanism to download and install packages on a computer. 

    Test-TargetResource returns a boolean which determines whether the resource is in
    desired state or not.

    .PARAMETER Name
    Specifies the name of the Package to be installed or uninstalled.

    .PARAMETER Source
    Specifies the name of the package source where the package can be found.
    This can either be a URI or a source registered with Register-PackageSource cmdlet.
    The DSC resource MSFT_PackageManagementSource can also register a package source.
    
    .PARAMETER RequiredVersion
    Specifies the exact version of the package that you want to install. If you do not specify this parameter, 
    this DSC resource installs the newest available version of the package that also satisfies any
    maximum version specified by the MaximumVersion parameter.

    .PARAMETER MaximumVersion
    Specifies the maximum allowed version of the package that you want to install. If you do not specify this parameter, 
    this DSC resource installs the highest-numbered available version of the package.

    .PARAMETER MinimumVersion
    Specifies the minimum allowed version of the package that you want to install. If you do not add this parameter, 
    this DSC resource intalls the highest available version of the package that also satisfies any maximum 
    specified version specified by the MaximumVersion parameter.

    .PARAMETER SourceCredential
    Specifies a user account that has rights to install a package for a specified package provider or source.

    .PARAMETER ProviderName
    Specifies a package provider name to which to scope your package search. You can get package provider names 
    by running the Get-PackageProvider cmdlet.

    .PARAMETER AdditionalParameters
    Provider specific parameters that are passed as an Hashtable. For example, for NuGet provider you can
    pass additional parameters like DestinationPath.
    #>

    [CmdletBinding()]
    [OutputType([bool])]
    param
    (
        [Parameter(Mandatory = $true)]
        [System.String]
        $Name,

        [Parameter()]
        [System.String]
        $RequiredVersion,
        
        [Parameter()]
        [System.String]
        $MinimumVersion,

        [Parameter()]
        [System.String]
        $MaximumVersion,

        [Parameter()]
        [System.String]
        $Source,

        [Parameter()]
        [PSCredential] $SourceCredential,
                
        [ValidateSet("Present","Absent")]
        [System.String]
        $Ensure="Present",

        [Parameter()]
        [System.String]
        $ProviderName,
        
        [Parameter()]
        [Microsoft.Management.Infrastructure.CimInstance[]]$AdditionalParameters         
    )

    
    Write-Verbose -Message ($localizedData.StartTestPackage -f (GetMessageFromParameterDictionary $PSBoundParameters))
    $null = $PSBoundParameters.Remove("Ensure")
    
    $temp = Get-TargetResource @PSBoundParameters

    if ($temp.Ensure -eq $ensure)
    {
        Write-Verbose -Message ($localizedData.InDesiredState -f $Name, $Ensure, $temp.Ensure)            
        return $True 
    }
    else
    {
        Write-Verbose -Message ($localizedData.NotInDesiredState -f $Name,$ensure,$temp.ensure)            
        return [bool] $False
    }    
}

function Set-TargetResource
{
    <#
    .SYNOPSIS

    This DSC resource provides a mechanism to download and install packages on a computer. 

    Set-TargetResource either intalls or uninstall a package as defined by the vaule of Ensure parameter.

    .PARAMETER Name
    Specifies the name of the Package to be installed or uninstalled.

    .PARAMETER Source
    Specifies the name of the package source where the package can be found.
    This can either be a URI or a source registered with Register-PackageSource cmdlet.
    The DSC resource MSFT_PackageManagementSource can also register a package source.
    
    .PARAMETER RequiredVersion
    Specifies the exact version of the package that you want to install. If you do not specify this parameter, 
    this DSC resource installs the newest available version of the package that also satisfies any
    maximum version specified by the MaximumVersion parameter.

    .PARAMETER MaximumVersion
    Specifies the maximum allowed version of the package that you want to install. If you do not specify this parameter, 
    this DSC resource installs the highest-numbered available version of the package.

    .PARAMETER MinimumVersion
    Specifies the minimum allowed version of the package that you want to install. If you do not add this parameter, 
    this DSC resource intalls the highest available version of the package that also satisfies any maximum 
    specified version specified by the MaximumVersion parameter.

    .PARAMETER SourceCredential
    Specifies a user account that has rights to install a package for a specified package provider or source.

    .PARAMETER ProviderName
    Specifies a package provider name to which to scope your package search. You can get package provider names 
    by running the Get-PackageProvider cmdlet.

    .PARAMETER AdditionalParameters
    Provider specific parameters that are passed as an Hashtable. For example, for NuGet provider you can
    pass additional parameters like DestinationPath.
    #>

    [CmdletBinding()]
    param
    (
        [Parameter(Mandatory = $true)]
        [System.String]
        $Name,

        [Parameter()]
        [System.String]
        $RequiredVersion,
        
        [Parameter()]
        [System.String]
        $MinimumVersion,

        [Parameter()]
        [System.String]
        $MaximumVersion,

        [Parameter()]
        [System.String]
        $Source,

        [Parameter()]
        [PSCredential] $SourceCredential,

        [ValidateSet("Present","Absent")]
        [System.String]
        $Ensure="Present",

        [Parameter()]
        [System.String]
        $ProviderName,
        
        [Parameter()]
        [Microsoft.Management.Infrastructure.CimInstance[]]$AdditionalParameters        
    )

    Write-Verbose -Message ($localizedData.StartSetPackage -f (GetMessageFromParameterDictionary $PSBoundParameters))
    
    $null = $PSBoundParameters.Remove("Ensure")

    if ($PSBoundParameters.ContainsKey("SourceCredential"))
    {
        $PSBoundParameters.Add("Credential", $SourceCredential)
        $null = $PSBoundParameters.Remove("SourceCredential")
    }
    
    if ($AdditionalParameters)
    {
         foreach($instance in $AdditionalParameters)
         {
             Write-Verbose ('AdditionalParameter: {0}, AdditionalParameterValue: {1}' -f $instance.Key, $instance.Value)
             $null = $PSBoundParameters.Add($instance.Key, $instance.Value)
         }
    }

    $PSBoundParameters.Remove("AdditionalParameters")

       
        # We do not want others to control the behavior of ErrorAction
        # while calling Install-Package/Uninstall-Package.
        $PSBoundParameters.Remove("ErrorAction")
        if ($Ensure -eq "Present")
        {
            PackageManagement\Install-Package @PSBoundParameters -ErrorAction Stop
        }   
        else
        {
            # we dont source location for uninstalling an already
            # installed package
            $PSBoundParameters.Remove("Source")
            # Ensure is Absent
            PackageManagement\Uninstall-Package @PSBoundParameters -ErrorAction Stop
        }
 }
 
 function GetMessageFromParameterDictionary
 {
    <#
        Returns a strng of form "ParameterName:ParameterValue"
        Used with Write-Verbose message. The input is mostly $PSBoundParameters
    #>
    param([System.Collections.IDictionary] $paramDictionary)

    $returnValue = ""
    $paramDictionary.Keys | ForEach-Object { $returnValue += "-{0} {1} " -f $_,$paramDictionary[$_] }
    return $returnValue
 }

Export-ModuleMember -function Get-TargetResource, Set-TargetResource, Test-TargetResource


[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Dependencies\PackageManagement\1.4.8.1\DSCResources\MSFT_PackageManagementSource\MSFT_PackageManagementSource.psm1
#
# Copyright (c) Microsoft Corporation.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# This PS DSC resource enables register or unregister a package source through DSC Get, Set and Test operations on DSC managed nodes.

Import-LocalizedData -BindingVariable LocalizedData -filename MSFT_PackageManagementSource.strings.psd1

Import-Module -Name "$PSScriptRoot\..\PackageManagementDscUtilities.psm1"

function Get-TargetResource
{
    <#
    .SYNOPSIS

    This DSC resource provides a mechanism to register/unregister a package source on your computer. 

    Get-TargetResource returns the current state of the resource.

    .PARAMETER Name
    Specifies the name of the package source to be registered or unregistered on your system.

    .PARAMETER ProviderName
    Specifies the name of the PackageManagement provider through which you can interop with the package source.

    .PARAMETER SourceLocation
    Specifies the Uri of the package source.
    #>

    [CmdletBinding()]
    [OutputType([System.Collections.Hashtable])]
    param
    (
        [parameter(Mandatory = $true)]
        [System.String]
        $Name,

        [parameter(Mandatory = $true)]
        [System.String]
        $ProviderName,

        [parameter(Mandatory = $true)]
        [System.String]
        $SourceLocation
    )

    #initialize a local var
    $ensure = "Absent"

    #Set the installation policy by default, untrusted. 
    $installationPolicy ="Untrusted"

    $PSBoundParameters.Add("Location", $SourceLocation)
    $PSBoundParameters.Remove("SourceLocation")

    #Validate Uri and add Location because PackageManagement uses Location not SourceLocation. 
    #ValidateArgument  -Argument $PSBoundParameters['Location'] -Type 'PackageSource' -ProviderName $ProviderName

    Write-Verbose -Message ($localizedData.StartGetPackageSource -f $($Name))

    #check if the package source already registered on the computer
    # Note: Assume Get-PackageSource returns the first source if multiple are found
    $source = PackageManagement\Get-PackageSource @PSBoundParameters -ForceBootstrap -ErrorAction SilentlyContinue -WarningAction SilentlyContinue  
        

    if (($source.count -gt 0) -and ($source.IsRegistered))
    {
        Write-Verbose -Message ($localizedData.PackageSourceFound -f $($Name))
        $ensure = "Present"
    }
    else
    {
        Write-Verbose -Message ($localizedData.PackageSourceNotFound -f $($Name))
    }

    Write-Debug -Message "Source $($Name) is $($ensure)"
                         
    
    if ($ensure -eq 'Absent')
    {
        return @{
            Ensure       = $ensure
            Name         = $Name
            ProviderName = $ProviderName
        }
    }
    else
    {
        if ($source.IsTrusted)
        {
            $installationPolicy = "Trusted"
        }

        return @{
            Ensure             = $ensure
            Name               = $Name
            ProviderName       = $ProviderName
            SourceLocation          = $source.Location
            InstallationPolicy = $installationPolicy
        }
    } 
}

function Test-TargetResource
{
    <#
    .SYNOPSIS

    This DSC resource provides a mechanism to register/unregister a package source on your computer. 

    Test-TargetResource validates whether the resource is currently in the desired state.

    .PARAMETER Name
    Specifies the name of the package source to be registered or unregistered on your system.

    .PARAMETER ProviderName
    Specifies the name of the PackageManagement provider through which you can interop with the package source.

    .PARAMETER SourceLocation
    Specifies the Uri of the package source.

    .PARAMETER Ensure
    Determines whether the package source to be registered or unregistered.

    .PARAMETER SourceCredential
    Provides access to the package on a remote source. 

    .PARAMETER InstallationPolicy
    Determines whether you trust the packages source.
    #>

    [CmdletBinding()]
    [OutputType([System.Boolean])]
    param
    (
        [parameter(Mandatory = $true)]
        [System.String]
        $Name,

        [parameter(Mandatory = $true)]
        [System.String]
        $ProviderName,

        [parameter(Mandatory = $true)]
        [System.String]
        $SourceLocation,

        [ValidateSet("Present","Absent")]
        [System.String]
        $Ensure="Present",

        [System.Management.Automation.PSCredential]
        $SourceCredential,

        [ValidateSet("Trusted","Untrusted")]
        [System.String]
        $InstallationPolicy="Untrusted"
    )

    #Get the current status of the package source 
    Write-Debug -Message  "Calling Get-TargetResource"

    $status = Get-TargetResource -Name $Name -ProviderName $ProviderName -SourceLocation $SourceLocation
 
    if($status.Ensure -eq $Ensure)
    {
        
        if ($status.Ensure -eq "Present") 
        {
            #Check if the source location matches. As get-package takes location (SourceLocation) parameter, the result from Get-package should 
            #belong to the particular source location. But currently it does not. Below is the workaround.
            #
            if ($status.SourceLocation -ine $SourceLocation) 
            {
                Write-Verbose -Message ($localizedData.NotInDesiredStateDuetoLocationMismatch -f $($Name), $($SourceLocation), $($status.SourceLocation))
                return $false 
            }  

            #Check if the installationPolicy matches. Sometimes the registered source and desired source can be the same except for InstallationPolicy
            #
            if ($status.InstallationPolicy -ine $InstallationPolicy)
            {
                Write-Verbose -Message ($localizedData.NotInDesiredStateDuetoPolicyMismatch -f $($Name), $($InstallationPolicy), $($status.InstallationPolicy))
                return $false 
            }           
        }

        Write-Verbose -Message ($localizedData.InDesiredState -f $($Name), $($Ensure), $($status.Ensure))                   
        return $true
    }
    else
    {
        Write-Verbose -Message ($localizedData.NotInDesiredState -f $($Name), $($Ensure), $($status.Ensure))
        return $false
    }
}

function Set-TargetResource
{
    <#
    .SYNOPSIS

    This DSC resource provides a mechanism to register/unregister a package source on your computer. 

    Set-TargetResource sets the resource to the desired state. "Make it so".

    .PARAMETER Name
    Specifies the name of the package source to be registered or unregistered on your system.

    .PARAMETER ProviderName
    Specifies the name of the PackageManagement provider through which you can interop with the package source.

    .PARAMETER SourceLocation
    Specifies the Uri of the package source.

    .PARAMETER Ensure
    Determines whether the package source to be registered or unregistered.

    .PARAMETER SourceCredential
    Provides access to the package on a remote source. 

    .PARAMETER InstallationPolicy
    Determines whether you trust the packages source.
    #>

    [CmdletBinding()]
    param
    (
        [parameter(Mandatory = $true)]
        [System.String]
        $Name,

        [parameter(Mandatory = $true)]
        [System.String]
        $ProviderName,

        [parameter(Mandatory = $true)]
        [System.String]
        $SourceLocation,

        [ValidateSet("Present","Absent")]
        [System.String]
        $Ensure="Present",

        [System.Management.Automation.PSCredential]
        $SourceCredential,

        [ValidateSet("Trusted","Untrusted")]
        [System.String]
        $InstallationPolicy="Untrusted"
    )

    #Add Location because PackageManagement uses Location not SourceLocation. 
    $PSBoundParameters.Add("Location", $SourceLocation)

    if ($PSBoundParameters.ContainsKey("SourceCredential"))
    {
        $PSBoundParameters.Add("Credential", $SourceCredential)
    }

    if ($InstallationPolicy -ieq "Trusted")
    {
        $PSBoundParameters.Add("Trusted", $True)
    }
    else
    {
        $PSBoundParameters.Add("Trusted", $False)
    }
    

    if($Ensure -ieq "Present")
    {   
        #
        #Warn a user about the installation policy
        #
        Write-Warning -Message ($localizedData.InstallationPolicyWarning -f $($Name), $($SourceLocation), $($InstallationPolicy))

        $extractedArguments = ExtractArguments -FunctionBoundParameters $PSBoundParameters `
                                               -ArgumentNames ("Name","ProviderName", "Location", "Credential", "Trusted")   
        
        Write-Verbose -Message ($localizedData.StartRegisterPackageSource -f $($Name)) 

        if ($name -eq "psgallery")
        {         
            # In WMF 5.0 RTM, we are not able to register 'psgallery' package source. Thus let's try Set-PSRepository to see if we can
            # update the registration. 
            
            # Before calling the Set-PSRepository cmdlet, we need to make sure the PSGallery already registered.

            $psgallery = PackageManagement\Get-PackageSource -name $name -Location $SourceLocation -ProviderName $ProviderName -ErrorAction SilentlyContinue -WarningAction SilentlyContinue

            if( $psgallery)
            {
                Set-PSRepository -Name $name -SourceLocation $SourceLocation -InstallationPolicy $InstallationPolicy -ErrorVariable ev 
            }
            else
            {
                # The following works if you are running TP5 or later
                $extractedArguments.Remove("Location")
                PackageManagement\Register-PackageSource @extractedArguments -Force -ErrorVariable ev  

            }
        }
        else
        {                                       
            PackageManagement\Register-PackageSource @extractedArguments -Force -ErrorVariable ev  
        }
            
        if($null -ne $ev -and $ev.Count -gt 0)
        {
            ThrowError  -ExceptionName "System.InvalidOperationException" `
                        -ExceptionMessage ($localizedData.RegisterFailed -f $Name, $ev.Exception)`
                        -ErrorId "RegisterFailed" `
                        -ErrorCategory InvalidOperation                  
        }
        else
        {
            Write-Verbose -Message ($localizedData.RegisteredSuccess -f $($Name))           
        }                      
    }
    #Ensure=Absent
    else 
    {
        $extractedArguments = ExtractArguments -FunctionBoundParameters $PSBoundParameters `
                                               -ArgumentNames $("Name","ProviderName", "Location", "Credential")  
                                                       
        Write-Verbose -Message ($localizedData.StartUnRegisterPackageSource -f $($Name))  
                         
        PackageManagement\Unregister-PackageSource @extractedArguments -Force -ErrorVariable ev 
        
        if($null -ne $ev -and $ev.Count -gt 0)
        {
            ThrowError  -ExceptionName "System.InvalidOperationException" `
                        -ExceptionMessage ($localizedData.UnRegisterFailed -f $Name, $ev.Exception)`
                        -ErrorId "UnRegisterFailed" `
                        -ErrorCategory InvalidOperation       
        }
        else
        {
            Write-Verbose -Message ($localizedData.UnRegisteredSuccess -f $($Name))            
        }                    
    }  
 }

Export-ModuleMember -function Get-TargetResource, Set-TargetResource, Test-TargetResource


[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Dependencies\PackageManagement\1.4.8.1\DSCResources\PackageManagementDscUtilities.psm1
#
# Copyright (c) Microsoft Corporation.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
#Helper functions for PackageManagement DSC Resouces

Import-LocalizedData -BindingVariable LocalizedData -filename PackageManagementDscUtilities.strings.psd1


 Function ExtractArguments
{
    <#
    .SYNOPSIS

    This is a helper function that extract the parameters from a given table. 

    .PARAMETER FunctionBoundParameters
    Specifies the hashtable containing a set of parameters to be extracted

    .PARAMETER ArgumentNames
    Specifies A list of arguments you want to extract
    #>

    Param
    (
        [parameter(Mandatory = $true)]
        [System.Collections.Hashtable]
        $FunctionBoundParameters,

        #A list of arguments you want to extract
        [parameter(Mandatory = $true)]
        [System.String[]]$ArgumentNames
    )

    Write-Verbose -Message ($LocalizedData.CallingFunction -f $($MyInvocation.mycommand))

    $returnValue=@{}

    foreach ($arg in $ArgumentNames)
    {
        if($FunctionBoundParameters.ContainsKey($arg))
        {
            #Found an argument we are looking for, so we add it to return collection
            $returnValue.Add($arg,$FunctionBoundParameters[$arg])
        }
    }

    return $returnValue
 }

function ThrowError
{
    <#
    .SYNOPSIS

    This is a helper function that throws an error. 

    .PARAMETER ExceptionName
    Specifies the type of errors, e.g. System.ArgumentException

    .PARAMETER ExceptionMessage
    Specifies the exception message

    .PARAMETER ErrorId
    Specifies an identifier of the error

    .PARAMETER ErrorCategory
    Specifies the error category, e.g., InvalidArgument defined in System.Management.Automation. 

    #>

    param
    (        
        [parameter(Mandatory = $true)]
        [ValidateNotNullOrEmpty()]
        [System.String]        
        $ExceptionName,

        [parameter(Mandatory = $true)]
        [ValidateNotNullOrEmpty()]
        [System.String]
        $ExceptionMessage,      
        
        [parameter(Mandatory = $true)]
        [ValidateNotNullOrEmpty()]
        [System.String]
        $ErrorId,

        [parameter(Mandatory = $true)]
        [ValidateNotNull()]
        [System.Management.Automation.ErrorCategory]
        $ErrorCategory
    )
    
    Write-Verbose -Message ($LocalizedData.CallingFunction -f $($MyInvocation.mycommand))
        
    $exception   = New-Object -TypeName $ExceptionName -ArgumentList $ExceptionMessage;
    $errorRecord = New-Object -TypeName System.Management.Automation.ErrorRecord -ArgumentList ($exception, $ErrorId, $ErrorCategory, $null)    
    throw $errorRecord
}

Function ValidateArgument
{
    <#
    .SYNOPSIS

    This is a helper function that validates the arguments. 

    .PARAMETER Argument
    Specifies the argument to be validated.

    .PARAMETER Type
    Specifies the type of argument.
    #>

    [CmdletBinding()]
    param
    (
        [parameter(Mandatory = $true)]
        [ValidateNotNullOrEmpty()]
        [string]$Argument,

        [parameter(Mandatory = $true)]
        [ValidateNotNullOrEmpty()]
        [String]$Type,

        [parameter(Mandatory = $true)]
        [ValidateNotNullOrEmpty()]
        [String]$ProviderName
    )

    Write-Verbose -Message ($LocalizedData.CallingFunction -f $($MyInvocation.mycommand))

    switch ($Type)
    {

        "SourceUri"
        {
            # Checks whether given URI represents specific scheme
            # Most common schemes: file, http, https, ftp        
            $scheme =@('http', 'https', 'file', 'ftp')
 
            $newUri = $Argument -as [System.URI]  
            $returnValue = ($newUri -and $newUri.AbsoluteURI -and ($scheme -icontains $newuri.Scheme)) 

            if ($returnValue -eq $false)
            {                
                ThrowError  -ExceptionName "System.ArgumentException" `
                            -ExceptionMessage ($LocalizedData.InValidUri -f $Argument)`
                            -ErrorId "InValidUri" `
                            -ErrorCategory InvalidArgument
            }
            
            #Check whether it's a valid uri. Wait for the response within 2mins.
            <#$result = Invoke-WebRequest $newUri -TimeoutSec 120 -UseBasicParsing -ErrorAction SilentlyContinue

            if ($null -eq (([xml]$result.Content).service ))
            {
                ThrowError  -ExceptionName "System.ArgumentException" `
                            -ExceptionMessage ($LocalizedData.InValidUri -f $Argument)`
                            -ErrorId "InValidUri" `
                            -ErrorCategory InvalidArgument
            }#>
                                         
        }
        "DestinationPath"
        {
            $returnValue = Test-Path -Path $Argument
            if ($returnValue -eq $false)
            {
                ThrowError  -ExceptionName "System.ArgumentException" `
                            -ExceptionMessage ($LocalizedData.PathDoesNotExist -f $Argument)`
                            -ErrorId "PathDoesNotExist" `
                            -ErrorCategory InvalidArgument
            }
        }
        "PackageSource"
        {      
            #Argument can be either the package source Name or source Uri.  
            
            #Check if the source is a uri 
            $uri = $Argument -as [System.URI]  

            if($uri -and $uri.AbsoluteURI) 
            {
                # Check if it's a valid Uri
                ValidateArgument -Argument $Argument -Type "SourceUri" -ProviderName $ProviderName
            }
            else
            {
                #Check if it's a registered package source name                                                             
                $source = PackageManagement\Get-PackageSource -Name $Argument -ProviderName $ProviderName -verbose -ErrorVariable ev
                if ((-not $source) -or $ev) 
                {
                    #We do not need to throw error here as Get-PackageSource does already
                    Write-Verbose -Message ($LocalizedData.SourceNotFound -f $source)                
                }
            }
        }
        default
        {
            ThrowError  -ExceptionName "System.ArgumentException" `
                        -ExceptionMessage ($LocalizedData.UnexpectedArgument -f $Type)`
                        -ErrorId "UnexpectedArgument" `
                        -ErrorCategory InvalidArgument
        }
     }           
}

Function ValidateVersionArgument
{
    <#
    .SYNOPSIS

    This is a helper function that does the version validation. 

    .PARAMETER RequiredVersion
    Provides the required version.

    .PARAMETER MaximumVersion
    Provides the maximum version.

    .PARAMETER MinimumVersion
    Provides the minimum version.
    #>

    [CmdletBinding()]
    param
    (
        [string]$RequiredVersion,
        [string]$MinimumVersion,
        [string]$MaximumVersion

    )
         
    Write-Verbose -Message ($LocalizedData.CallingFunction -f $($MyInvocation.mycommand))

    $isValid = $false
         
    #Case 1: No further check required if a user provides either none or one of these: minimumVersion, maximumVersion, and requiredVersion
    if ($PSBoundParameters.Count -le 1)
    {
        return $true
    }

    #Case 2: #If no RequiredVersion is provided 
    if (-not $PSBoundParameters.ContainsKey('RequiredVersion'))
    {
        #If no RequiredVersion, both MinimumVersion and MaximumVersion are provided. Otherwise fall into the Case #1
        $isValid = $PSBoundParameters['MinimumVersion'] -le $PSBoundParameters['MaximumVersion']
    }
    
    #Case 3: RequiredVersion is provided. 
    #        In this case  MinimumVersion and/or MaximumVersion also are provided. Otherwise fall in to Case #1.
    #        This is an invalid case. When RequiredVersion is provided, others are not allowed. so $isValid is false, which is already set in the init

    if ($isValid -eq $false)
    {        
        ThrowError  -ExceptionName "System.ArgumentException" `
                    -ExceptionMessage ($LocalizedData.VersionError)`
                    -ErrorId "VersionError" `
                    -ErrorCategory InvalidArgument
    }
}

Function Get-InstallationPolicy
{
    <#
    .SYNOPSIS

    This is a helper function that retrives the InstallationPolicy from the given repository. 

    .PARAMETER RepositoryName
    Provides the repository Name.

    #>

    Param
    (
        [parameter(Mandatory = $true)]
        [ValidateNotNullOrEmpty()]
        [System.String]$RepositoryName
    )

    Write-Verbose -Message ($LocalizedData.CallingFunction -f $($MyInvocation.mycommand))

    $repositoryobj = PackageManagement\Get-PackageSource -Name $RepositoryName -ErrorAction SilentlyContinue -WarningAction SilentlyContinue

    if ($repositoryobj)
    {      
        return $repositoryobj.IsTrusted
    }                  
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Dependencies\PackageManagement\1.4.8.1\PackageManagement.psm1
#
# Script module for module 'PackageManagement'
#
Set-StrictMode -Version Latest
Microsoft.PowerShell.Utility\Import-LocalizedData  LocalizedData -filename PackageManagement.Resources.psd1

# Summary: PackageManagement is supported on Windows PowerShell 3.0 or later, Nano Server and PowerShellCore
$isCore = ($PSVersionTable.Keys -contains "PSEdition") -and ($PSVersionTable.PSEdition -ne 'Desktop')
$binarySubPath = ''
if ($isCore)
{
    $binarySubPath = Join-Path -Path 'coreclr' -ChildPath 'netstandard2.0'
} else {
    $binarySubPath = 'fullclr'
}

# Set up some helper variables to make it easier to work with the module
$script:PSModule = $ExecutionContext.SessionState.Module
$script:PSModuleRoot = $script:PSModule.ModuleBase

$script:PkgMgmt = 'Microsoft.PackageManagement.dll'
$script:PSPkgMgmt = 'Microsoft.PowerShell.PackageManagement.dll'


# Try to import the OneGet assemblies at the same directory regardless fullclr or coreclr
$OneGetModulePath = Join-Path -Path $script:PSModuleRoot -ChildPath $script:PkgMgmt
$binaryModuleRoot = $script:PSModuleRoot


if(-not (Test-Path -Path $OneGetModulePath))
{
    # Import the appropriate nested binary module based on the current PowerShell version
    $binaryModuleRoot = Join-Path -Path $script:PSModuleRoot -ChildPath $binarySubPath
    $OneGetModulePath = Join-Path -Path $binaryModuleRoot -ChildPath $script:PkgMgmt
}

$PSOneGetModulePath = Join-Path -Path $binaryModuleRoot -ChildPath $script:PSPkgMgmt
$OneGetModule = Import-Module -Name $OneGetModulePath -PassThru
$PSOneGetModule = Import-Module -Name $PSOneGetModulePath -PassThru


# When the module is unloaded, remove the nested binary module that was loaded with it
if($OneGetModule)
{
    $script:PSModule.OnRemove = {
        Remove-Module -ModuleInfo $OneGetModule
    }
}

if($PSOneGetModule)
{
    $script:PSModule.OnRemove = {
        Remove-Module -ModuleInfo $PSOneGetModule
    }
}
[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Dependencies\PackageManagement\1.4.8.1\PackageProviderFunctions.psm1
###
# ==++==
#
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
###

<#
	Overrides the default Write-Debug so that the output gets routed back thru the
	$request.Debug() function
#>
function Write-Debug {
	param(
	[Parameter(Mandatory=$true)][string] $message,
	[parameter(ValueFromRemainingArguments=$true)]
	[object[]]
	 $args= @()
	)

	if( -not $request  ) {
		if( -not $args  ) {
			Microsoft.PowerShell.Utility\write-verbose $message
			return
		}

		$msg = [system.string]::format($message, $args)
		Microsoft.PowerShell.Utility\write-verbose $msg
		return
	}

	if( -not $args  ) {
		$null = $request.Debug($message);
		return
	}
	$null = $request.Debug($message,$args);
}

function Write-Error {
	param( 
		[Parameter(Mandatory=$true)][string] $Message,
		[Parameter()][string] $Category,
		[Parameter()][string] $ErrorId,
		[Parameter()][string] $TargetObject
	)

	$null = $request.Warning($Message);
}

<#
	Overrides the default Write-Verbose so that the output gets routed back thru the
	$request.Verbose() function
#>

function Write-Progress {
    param(
        [CmdletBinding()]

        [Parameter(Position=0)]
        [string]
        $Activity,

        # This parameter is not supported by request object
        [Parameter(Position=1)]
        [ValidateNotNullOrEmpty()]
        [string]
        $Status,

        [Parameter(Position=2)]
        [ValidateRange(0,[int]::MaxValue)]
        [int]
        $Id,

        [Parameter()]
        [int]
        $PercentComplete=-1,

        # This parameter is not supported by request object
        [Parameter()]
        [int]
        $SecondsRemaining=-1,

        # This parameter is not supported by request object
        [Parameter()]
        [string]
        $CurrentOperation,        

        [Parameter()]
        [ValidateRange(-1,[int]::MaxValue)]
        [int]
        $ParentID=-1,

        [Parameter()]
        [switch]
        $Completed,

        # This parameter is not supported by request object
        [Parameter()]
        [int]
        $SourceID,

	    [object[]]
        $args= @()
    )

    $params = @{}

    if ($PSBoundParameters.ContainsKey("Activity")) {
        $params.Add("Activity", $PSBoundParameters["Activity"])
    }

    if ($PSBoundParameters.ContainsKey("Status")) {
        $params.Add("Status", $PSBoundParameters["Status"])
    }

    if ($PSBoundParameters.ContainsKey("PercentComplete")) {
        $params.Add("PercentComplete", $PSBoundParameters["PercentComplete"])
    }

    if ($PSBoundParameters.ContainsKey("Id")) {
        $params.Add("Id", $PSBoundParameters["Id"])
    }

    if ($PSBoundParameters.ContainsKey("ParentID")) {
        $params.Add("ParentID", $PSBoundParameters["ParentID"])
    }

    if ($PSBoundParameters.ContainsKey("Completed")) {
        $params.Add("Completed", $PSBoundParameters["Completed"])
    }

	if( -not $request  ) {    
		if( -not $args  ) {
			Microsoft.PowerShell.Utility\Write-Progress @params
			return
		}

		$params["Activity"] = [system.string]::format($Activity, $args)
		Microsoft.PowerShell.Utility\Write-Progress @params
		return
	}

	if( -not $args  ) {
        $request.Progress($Activity, $Status, $Id, $PercentComplete, $SecondsRemaining, $CurrentOperation, $ParentID, $Completed)
	}

}

function Write-Verbose{
	param(
	[Parameter(Mandatory=$true)][string] $message,
	[parameter(ValueFromRemainingArguments=$true)]
	[object[]]
	 $args= @()
	)

	if( -not $request ) {
		if( -not $args ) {
			Microsoft.PowerShell.Utility\write-verbose $message
			return
		}

		$msg = [system.string]::format($message, $args)
		Microsoft.PowerShell.Utility\write-verbose $msg
		return
	}

	if( -not $args ) {
		$null = $request.Verbose($message);
		return
	}
	$null = $request.Verbose($message,$args);
}

<#
	Overrides the default Write-Warning so that the output gets routed back thru the
	$request.Warning() function
#>

function Write-Warning{
	param(
	[Parameter(Mandatory=$true)][string] $message,
	[parameter(ValueFromRemainingArguments=$true)]
	[object[]]
	 $args= @()
	)

	if( -not $request ) {
		if( -not $args ) {
			Microsoft.PowerShell.Utility\write-warning $message
			return
		}

		$msg = [system.string]::format($message, $args)
		Microsoft.PowerShell.Utility\write-warning $msg
		return
	}

	if( -not $args ) {
		$null = $request.Warning($message);
		return
	}
	$null = $request.Warning($message,$args);
}

<#
	Creates a new instance of a PackageSource object
#>
function New-PackageSource {
	param(
		[Parameter(Mandatory=$true)][string] $name,
		[Parameter(Mandatory=$true)][string] $location,
		[Parameter(Mandatory=$true)][bool] $trusted,
		[Parameter(Mandatory=$true)][bool] $registered,
		[bool] $valid = $false,
		[System.Collections.Hashtable] $details = $null
	)

	return New-Object -TypeName Microsoft.PackageManagement.MetaProvider.PowerShell.PackageSource -ArgumentList $name,$location,$trusted,$registered,$valid,$details
}

<#
	Creates a new instance of a SoftwareIdentity object
#>
function New-SoftwareIdentity {
	param(
		[Parameter(Mandatory=$true)][string] $fastPackageReference,
		[Parameter(Mandatory=$true)][string] $name,
		[Parameter(Mandatory=$true)][string] $version,
		[Parameter(Mandatory=$true)][string] $versionScheme,
		[Parameter(Mandatory=$true)][string] $source,
		[string] $summary,
		[string] $searchKey = $null,
		[string] $fullPath = $null,
		[string] $filename = $null,
		[System.Collections.Hashtable] $details = $null,
		[System.Collections.ArrayList] $entities = $null,
		[System.Collections.ArrayList] $links = $null,
		[bool] $fromTrustedSource = $false,
		[System.Collections.ArrayList] $dependencies = $null,
		[string] $tagId = $null,
		[string] $culture = $null,
        [string] $destination = $null
	)
	return New-Object -TypeName Microsoft.PackageManagement.MetaProvider.PowerShell.SoftwareIdentity -ArgumentList $fastPackageReference, $name, $version,  $versionScheme,  $source,  $summary,  $searchKey, $fullPath, $filename , $details , $entities, $links, $fromTrustedSource, $dependencies, $tagId, $culture, $destination
}

<#
	Creates a new instance of a SoftwareIdentity object based on an xml string
#>
function New-SoftwareIdentityFromXml {
    param(
        [Parameter(Mandatory=$true)][string] $xmlSwidtag,
        [bool] $commitImmediately = $false
    )

    return New-Object -TypeName Microsoft.PackageManagement.MetaProvider.PowerShell.SoftwareIdentity -ArgumentList $xmlSwidtag, $commitImmediately
}

<#
	Creates a new instance of a DyamicOption object
#>
function New-DynamicOption {
	param(
		[Parameter(Mandatory=$true)][Microsoft.PackageManagement.MetaProvider.PowerShell.OptionCategory] $category,
		[Parameter(Mandatory=$true)][string] $name,
		[Parameter(Mandatory=$true)][Microsoft.PackageManagement.MetaProvider.PowerShell.OptionType] $expectedType,
		[Parameter(Mandatory=$true)][bool] $isRequired,
		[System.Collections.ArrayList] $permittedValues = $null
	)

	if( -not $permittedValues ) {
		return New-Object -TypeName Microsoft.PackageManagement.MetaProvider.PowerShell.DynamicOption -ArgumentList $category,$name,  $expectedType, $isRequired
	}
	return New-Object -TypeName Microsoft.PackageManagement.MetaProvider.PowerShell.DynamicOption -ArgumentList $category,$name,  $expectedType, $isRequired, $permittedValues.ToArray()
}

<#
	Creates a new instance of a Feature object
#>
function New-Feature {
	param(
		[Parameter(Mandatory=$true)][string] $name,
		[System.Collections.ArrayList] $values = $null
	)

	if( -not $values ) {
		return New-Object -TypeName Microsoft.PackageManagement.MetaProvider.PowerShell.Feature -ArgumentList $name
	}
	return New-Object -TypeName Microsoft.PackageManagement.MetaProvider.PowerShell.Feature -ArgumentList $name, $values.ToArray()
}

<#
	Duplicates the $request object and overrides the client-supplied data with the specified values.
#>
function New-Request {
	param(
		[System.Collections.Hashtable] $options = $null,
		[System.Collections.ArrayList] $sources = $null,
		[PSCredential] $credential = $null
	)

	return $request.CloneRequest( $options, $sources, $credential )
}

function New-Entity {
	param(
		[Parameter(Mandatory=$true)][string] $name,
		[Parameter(Mandatory=$true,ParameterSetName="role")][string] $role,
		[Parameter(Mandatory=$true,ParameterSetName="roles")][System.Collections.ArrayList]$roles,
        [string] $regId = $null,
        [string] $thumbprint= $null
	)

	$o = New-Object -TypeName Microsoft.PackageManagement.MetaProvider.PowerShell.Entity
	$o.Name = $name

	# support role as a NMTOKENS string or an array of strings
	if( $role ) {
		$o.Role = $role
	} 
	if( $roles )  {
		$o.Roles = $roles
	}

	$o.regId = $regId
	$o.thumbprint = $thumbprint
	return $o
}

function New-Link {
	param(
		[Parameter(Mandatory=$true)][string] $HRef,
		[Parameter(Mandatory=$true)][string] $relationship,
		[string] $mediaType = $null,
		[string] $ownership = $null,
		[string] $use= $null,
		[string] $appliesToMedia= $null,
		[string] $artifact = $null
	)

	$o = New-Object -TypeName Microsoft.PackageManagement.MetaProvider.PowerShell.Link

	$o.HRef = $HRef
	$o.Relationship =$relationship
	$o.MediaType =$mediaType
	$o.Ownership =$ownership
	$o.Use = $use
	$o.AppliesToMedia = $appliesToMedia
	$o.Artifact = $artifact

	return $o
}

function New-Dependency {
	param(
		[Parameter(Mandatory=$true)][string] $providerName,
		[Parameter(Mandatory=$true)][string] $packageName,
		[string] $version= $null,
		[string] $source = $null,
		[string] $appliesTo = $null
	)

	$o = New-Object -TypeName Microsoft.PackageManagement.MetaProvider.PowerShell.Dependency

	$o.ProviderName = $providerName
	$o.PackageName =$packageName
	$o.Version =$version
	$o.Source =$source
	$o.AppliesTo = $appliesTo

	return $o
}
[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Dependencies\PowerShellGet\2.2.5\DscResources\MSFT_PSModule\MSFT_PSModule.psm1
#
# Copyright (c) Microsoft Corporation.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

$resourceModuleRoot = Split-Path -Path (Split-Path -Path $PSScriptRoot -Parent) -Parent

# Import localization helper functions.
$helperName = 'PowerShellGet.LocalizationHelper'
$dscResourcesFolderFilePath = Join-Path -Path $resourceModuleRoot -ChildPath "Modules\$helperName\$helperName.psm1"
Import-Module -Name $dscResourcesFolderFilePath

$script:localizedData = Get-LocalizedData -ResourceName 'MSFT_PSModule' -ScriptRoot $PSScriptRoot

# Import resource helper functions.
$helperName = 'PowerShellGet.ResourceHelper'
$dscResourcesFolderFilePath = Join-Path -Path $resourceModuleRoot -ChildPath "Modules\$helperName\$helperName.psm1"
Import-Module -Name $dscResourcesFolderFilePath

<#
    .SYNOPSIS
        This DSC resource provides a mechanism to download PowerShell modules from the PowerShell
        Gallery and install it on your computer.

        Get-TargetResource returns the current state of the resource.

    .PARAMETER Name
        Specifies the name of the PowerShell module to be installed or uninstalled.

    .PARAMETER Repository
        Specifies the name of the module source repository where the module can be found.

    .PARAMETER RequiredVersion
        Provides the version of the module you want to install or uninstall.

    .PARAMETER MaximumVersion
        Provides the maximum version of the module you want to install or uninstall.

    .PARAMETER MinimumVersion
        Provides the minimum version of the module you want to install or uninstall.

    .PARAMETER Force
        Forces the installation of modules. If a module of the same name and version already exists on the computer,
        this parameter overwrites the existing module with one of the same name that was found by the command.

    .PARAMETER AllowClobber
        Allows the installation of modules regardless of if other existing module on the computer have cmdlets
        of the same name.

    .PARAMETER SkipPublisherCheck
        Allows the installation of modules that have not been catalog signed.
#>
function Get-TargetResource {
    <#
        These suppressions are added because this repository have other Visual Studio Code workspace
        settings than those in DscResource.Tests DSC test framework.
        Only those suppression that contradict this repository guideline is added here.
    #>
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('DscResource.AnalyzerRules\Measure-ForEachStatement', '')]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('DscResource.AnalyzerRules\Measure-FunctionBlockBraces', '')]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('DscResource.AnalyzerRules\Measure-IfStatement', '')]
    [CmdletBinding()]
    [OutputType([System.Collections.Hashtable])]
    param
    (
        [Parameter(Mandatory = $true)]
        [System.String]
        $Name,

        [Parameter()]
        [System.String]
        $Repository = 'PSGallery',

        [Parameter()]
        [System.String]
        $RequiredVersion,

        [Parameter()]
        [System.String]
        $MaximumVersion,

        [Parameter()]
        [System.String]
        $MinimumVersion,

        [Parameter()]
        [System.Boolean]
        $Force,

        [Parameter()]
        [System.Boolean]
        $AllowClobber,

        [Parameter()]
        [System.Boolean]
        $SkipPublisherCheck
    )

    $returnValue = @{
        Ensure             = 'Absent'
        Name               = $Name
        Repository         = $Repository
        Description        = $null
        Guid               = $null
        ModuleBase         = $null
        ModuleType         = $null
        Author             = $null
        InstalledVersion   = $null
        RequiredVersion    = $RequiredVersion
        MinimumVersion     = $MinimumVersion
        MaximumVersion     = $MaximumVersion
        Force              = $Force
        AllowClobber       = $AllowClobber
        SkipPublisherCheck = $SkipPublisherCheck
        InstallationPolicy = $null
    }

    Write-Verbose -Message ($localizedData.GetTargetResourceMessage -f $Name)

    $extractedArguments = New-SplatParameterHashTable -FunctionBoundParameters $PSBoundParameters `
        -ArgumentNames ('Name', 'Repository', 'MinimumVersion', 'MaximumVersion', 'RequiredVersion')

    # Get the module with the right version and repository properties.
    $modules = Get-RightModule @extractedArguments -ErrorAction SilentlyContinue -WarningAction SilentlyContinue

    # If the module is found, the count > 0
    if ($modules.Count -gt 0) {
        Write-Verbose -Message ($localizedData.ModuleFound -f $Name)

        # Find a module with the latest version and return its properties.
        $latestModule = $modules[0]

        foreach ($module in $modules) {
            if ($module.Version -gt $latestModule.Version) {
                $latestModule = $module
            }
        }

        # Check if the repository matches.
        $repositoryName = Get-ModuleRepositoryName -Module $latestModule -ErrorAction SilentlyContinue -WarningAction SilentlyContinue

        if ($repositoryName) {
            $installationPolicy = Get-InstallationPolicy -RepositoryName $repositoryName -ErrorAction SilentlyContinue -WarningAction SilentlyContinue
        }

        if ($installationPolicy) {
            $installationPolicyReturnValue = 'Trusted'
        }
        else {
            $installationPolicyReturnValue = 'Untrusted'
        }

        $returnValue.Ensure = 'Present'
        $returnValue.Repository = $repositoryName
        $returnValue.Description = $latestModule.Description
        $returnValue.Guid = $latestModule.Guid
        $returnValue.ModuleBase = $latestModule.ModuleBase
        $returnValue.ModuleType = $latestModule.ModuleType
        $returnValue.Author = $latestModule.Author
        $returnValue.InstalledVersion = $latestModule.Version
        $returnValue.InstallationPolicy = $installationPolicyReturnValue
    }
    else {
        Write-Verbose -Message ($localizedData.ModuleNotFound -f $Name)
    }

    return $returnValue
}

<#
    .SYNOPSIS
        This DSC resource provides a mechanism to download PowerShell modules from the PowerShell
        Gallery and install it on your computer.

        Test-TargetResource validates whether the resource is currently in the desired state.

    .PARAMETER Ensure
        Determines whether the module to be installed or uninstalled.

    .PARAMETER Name
        Specifies the name of the PowerShell module to be installed or uninstalled.

    .PARAMETER Repository
        Specifies the name of the module source repository where the module can be found.

    .PARAMETER InstallationPolicy
        Determines whether you trust the source repository where the module resides.

    .PARAMETER RequiredVersion
        Provides the version of the module you want to install or uninstall.

    .PARAMETER MaximumVersion
        Provides the maximum version of the module you want to install or uninstall.

    .PARAMETER MinimumVersion
        Provides the minimum version of the module you want to install or uninstall.

    .PARAMETER Force
        Forces the installation of modules. If a module of the same name and version already exists on the computer,
        this parameter overwrites the existing module with one of the same name that was found by the command.

    .PARAMETER AllowClobber
        Allows the installation of modules regardless of if other existing module on the computer have cmdlets
        of the same name.

    .PARAMETER SkipPublisherCheck
        Allows the installation of modules that have not been catalog signed.
#>
function Test-TargetResource {
    <#
        These suppressions are added because this repository have other Visual Studio Code workspace
        settings than those in DscResource.Tests DSC test framework.
        Only those suppression that contradict this repository guideline is added here.
    #>
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('DscResource.AnalyzerRules\Measure-FunctionBlockBraces', '')]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('DscResource.AnalyzerRules\Measure-IfStatement', '')]
    [CmdletBinding()]
    [OutputType([System.Boolean])]
    param
    (
        [Parameter()]
        [ValidateSet('Present', 'Absent')]
        [System.String]
        $Ensure = 'Present',

        [Parameter(Mandatory = $true)]
        [System.String]
        $Name,

        [Parameter()]
        [System.String]
        $Repository = 'PSGallery',

        [Parameter()]
        [ValidateSet('Trusted', 'Untrusted')]
        [System.String]
        $InstallationPolicy = 'Untrusted',

        [Parameter()]
        [System.String]
        $RequiredVersion,

        [Parameter()]
        [System.String]
        $MaximumVersion,

        [Parameter()]
        [System.String]
        $MinimumVersion,

        [Parameter()]
        [System.Boolean]
        $Force,

        [Parameter()]
        [System.Boolean]
        $AllowClobber,

        [Parameter()]
        [System.Boolean]
        $SkipPublisherCheck
    )

    Write-Verbose -Message ($localizedData.TestTargetResourceMessage -f $Name)

    $extractedArguments = New-SplatParameterHashTable -FunctionBoundParameters $PSBoundParameters `
        -ArgumentNames ('Name', 'Repository', 'MinimumVersion', 'MaximumVersion', 'RequiredVersion')

    $status = Get-TargetResource @extractedArguments

    # The ensure returned from Get-TargetResource is not equal to the desired $Ensure.
    if ($status.Ensure -ieq $Ensure) {
        Write-Verbose -Message ($localizedData.InDesiredState -f $Name)
        return $true
    }
    else {
        Write-Verbose -Message ($localizedData.NotInDesiredState -f $Name)
        return $false
    }
}

<#
    .SYNOPSIS
        This DSC resource provides a mechanism to download PowerShell modules from the PowerShell
        Gallery and install it on your computer.

        Set-TargetResource sets the resource to the desired state. "Make it so".

    .PARAMETER Ensure
        Determines whether the module to be installed or uninstalled.

    .PARAMETER Name
        Specifies the name of the PowerShell module to be installed or uninstalled.

    .PARAMETER Repository
        Specifies the name of the module source repository where the module can be found.

    .PARAMETER InstallationPolicy
        Determines whether you trust the source repository where the module resides.

    .PARAMETER RequiredVersion
        Provides the version of the module you want to install or uninstall.

    .PARAMETER MaximumVersion
        Provides the maximum version of the module you want to install or uninstall.

    .PARAMETER MinimumVersion
        Provides the minimum version of the module you want to install or uninstall.

    .PARAMETER Force
        Forces the installation of modules. If a module of the same name and version already exists on the computer,
        this parameter overwrites the existing module with one of the same name that was found by the command.

    .PARAMETER AllowClobber
        Allows the installation of modules regardless of if other existing module on the computer have cmdlets
        of the same name.

    .PARAMETER SkipPublisherCheck
        Allows the installation of modules that have not been catalog signed.
#>
function Set-TargetResource {
    <#
        These suppressions are added because this repository have other Visual Studio Code workspace
        settings than those in DscResource.Tests DSC test framework.
        Only those suppression that contradict this repository guideline is added here.
    #>
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('DscResource.AnalyzerRules\Measure-ForEachStatement', '')]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('DscResource.AnalyzerRules\Measure-FunctionBlockBraces', '')]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('DscResource.AnalyzerRules\Measure-IfStatement', '')]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('DscResource.AnalyzerRules\Measure-TryStatement', '')]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('DscResource.AnalyzerRules\Measure-CatchClause', '')]
    [CmdletBinding()]
    param
    (
        [Parameter()]
        [ValidateSet('Present', 'Absent')]
        [System.String]
        $Ensure = 'Present',

        [Parameter(Mandatory = $true)]
        [System.String]
        $Name,

        [Parameter()]
        [System.String]
        $Repository = 'PSGallery',

        [Parameter()]
        [ValidateSet('Trusted', 'Untrusted')]
        [System.String]
        $InstallationPolicy = 'Untrusted',

        [Parameter()]
        [System.String]
        $RequiredVersion,

        [Parameter()]
        [System.String]
        $MaximumVersion,

        [Parameter()]
        [System.String]
        $MinimumVersion,

        [Parameter()]
        [System.Boolean]
        $Force,

        [Parameter()]
        [System.Boolean]
        $AllowClobber,

        [Parameter()]
        [System.Boolean]
        $SkipPublisherCheck
    )

    # Validate the repository argument
    if ($PSBoundParameters.ContainsKey('Repository')) {
        Test-ParameterValue -Value $Repository -Type 'PackageSource' -ProviderName 'PowerShellGet' -Verbose
    }

    if ($Ensure -ieq 'Present') {
        # Version check
        $extractedArguments = New-SplatParameterHashTable -FunctionBoundParameters $PSBoundParameters `
            -ArgumentNames ('MinimumVersion', 'MaximumVersion', 'RequiredVersion')

        $null = Test-VersionParameter @extractedArguments

        try {
            $extractedArguments = New-SplatParameterHashTable -FunctionBoundParameters $PSBoundParameters `
                -ArgumentNames ('Name', 'Repository', 'MinimumVersion', 'MaximumVersion', 'RequiredVersion')

            Write-Verbose -Message ($localizedData.StartFindModule -f $Name)

            $modules = Find-Module @extractedArguments -ErrorVariable ev
        }
        catch {
            $errorMessage = $script:localizedData.ModuleNotFoundInRepository -f $Name
            New-InvalidOperationException -Message $errorMessage -ErrorRecord $_
        }

        $trusted = $null
        $moduleFound = $null

        foreach ($m in $modules) {
            # Check for the installation policy.
            $trusted = Get-InstallationPolicy -RepositoryName $m.Repository -ErrorAction SilentlyContinue -WarningAction SilentlyContinue

            # Stop the loop if found a trusted repository.
            if ($trusted) {
                $moduleFound = $m
                break;
            }
        }

        try {
            # The repository is trusted, so we install it.
            if ($trusted) {
                Write-Verbose -Message ($localizedData.StartInstallModule -f $Name, $moduleFound.Version.toString(), $moduleFound.Repository)

                # Extract the installation options.
                $extractedSwitches = New-SplatParameterHashTable -FunctionBoundParameters $PSBoundParameters -ArgumentNames ('Force', 'AllowClobber', 'SkipPublisherCheck')

                $moduleFound | Install-Module @extractedSwitches 2>&1 | out-string | Write-Verbose
            }
            # The repository is untrusted but user's installation policy is trusted, so we install it with a warning.
            elseif ($InstallationPolicy -ieq 'Trusted') {
                Write-Warning -Message ($localizedData.InstallationPolicyWarning -f $Name, $modules[0].Repository, $InstallationPolicy)

                # Extract installation options (Force implied by InstallationPolicy).
                $extractedSwitches = New-SplatParameterHashTable -FunctionBoundParameters $PSBoundParameters -ArgumentNames ('AllowClobber', 'SkipPublisherCheck')

                # If all the repositories are untrusted, we choose the first one.
                $modules[0] | Install-Module @extractedSwitches -Force 2>&1 | out-string | Write-Verbose
            }
            # Both user and repository is untrusted
            else {
                $errorMessage = $script:localizedData.InstallationPolicyFailed -f $InstallationPolicy, 'Untrusted'
                New-InvalidOperationException -Message $errorMessage
            }

            Write-Verbose -Message ($localizedData.InstalledSuccess -f $Name)
        }
        catch {
            $errorMessage = $script:localizedData.FailToInstall -f $Name
            New-InvalidOperationException -Message $errorMessage -ErrorRecord $_
        }
    }
    # Ensure=Absent
    else {

        $extractedArguments = New-SplatParameterHashTable -FunctionBoundParameters $PSBoundParameters `
            -ArgumentNames ('Name', 'Repository', 'MinimumVersion', 'MaximumVersion', 'RequiredVersion')

        # Get the module with the right version and repository properties.
        $modules = Get-RightModule @extractedArguments

        if (-not $modules) {
            $errorMessage = $script:localizedData.ModuleWithRightPropertyNotFound -f $Name
            New-InvalidOperationException -Message $errorMessage
        }

        foreach ($module in $modules) {
            # Get the path where the module is installed.
            $path = $module.ModuleBase

            Write-Verbose -Message ($localizedData.StartUnInstallModule -f $Name)

            try {
                <#
                    There is no Uninstall-Module cmdlet for Windows PowerShell 4.0,
                    so we will remove the ModuleBase folder as an uninstall operation.
                #>
                Microsoft.PowerShell.Management\Remove-Item -Path $path -Force -Recurse

                Write-Verbose -Message ($localizedData.UnInstalledSuccess -f $module.Name)
            }
            catch {
                $errorMessage = $script:localizedData.FailToUninstall -f $module.Name
                New-InvalidOperationException -Message $errorMessage -ErrorRecord $_
            }
        } # foreach
    } # Ensure=Absent
}

<#
    .SYNOPSIS
        This is a helper function. It returns the modules that meet the specified versions and the repository requirements.

    .PARAMETER Name
        Specifies the name of the PowerShell module.

    .PARAMETER RequiredVersion
        Provides the version of the module you want to install or uninstall.

    .PARAMETER MaximumVersion
        Provides the maximum version of the module you want to install or uninstall.

    .PARAMETER MinimumVersion
        Provides the minimum version of the module you want to install or uninstall.

    .PARAMETER Repository
        Specifies the name of the module source repository where the module can be found.
#>
function Get-RightModule {
    <#
        These suppressions are added because this repository have other Visual Studio Code workspace
        settings than those in DscResource.Tests DSC test framework.
        Only those suppression that contradict this repository guideline is added here.
    #>
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('DscResource.AnalyzerRules\Measure-ForEachStatement', '')]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('DscResource.AnalyzerRules\Measure-FunctionBlockBraces', '')]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('DscResource.AnalyzerRules\Measure-IfStatement', '')]
    [CmdletBinding()]
    param
    (
        [Parameter(Mandatory = $true)]
        [ValidateNotNullOrEmpty()]
        [System.String]
        $Name,

        [Parameter()]
        [System.String]
        $RequiredVersion,

        [Parameter()]
        [System.String]
        $MinimumVersion,

        [Parameter()]
        [System.String]
        $MaximumVersion,

        [Parameter()]
        [System.String]
        $Repository
    )

    Write-Verbose -Message ($localizedData.StartGetModule -f $($Name))

    $modules = Microsoft.PowerShell.Core\Get-Module -Name $Name -ListAvailable -ErrorAction SilentlyContinue -WarningAction SilentlyContinue

    if (-not $modules) {
        return $null
    }

    <#
        As Get-Module does not take RequiredVersion, MinimumVersion, MaximumVersion, or Repository,
        below we need to check whether the modules are containing the right version and repository
        location.
    #>

    $extractedArguments = New-SplatParameterHashTable -FunctionBoundParameters $PSBoundParameters `
        -ArgumentNames ('MaximumVersion', 'MinimumVersion', 'RequiredVersion')
    $returnVal = @()

    foreach ($m in $modules) {
        $versionMatch = $false
        $installedVersion = $m.Version

        # Case 1 - a user provides none of RequiredVersion, MinimumVersion, MaximumVersion
        if ($extractedArguments.Count -eq 0) {
            $versionMatch = $true
        }

        # Case 2 - a user provides RequiredVersion
        elseif ($extractedArguments.ContainsKey('RequiredVersion')) {
            # Check if it matches with the installed version
            $versionMatch = ($installedVersion -eq [System.Version] $RequiredVersion)
        }
        else {

            # Case 3 - a user provides MinimumVersion
            if ($extractedArguments.ContainsKey('MinimumVersion')) {
                $versionMatch = ($installedVersion -ge [System.Version] $extractedArguments['MinimumVersion'])
            }

            # Case 4 - a user provides MaximumVersion
            if ($extractedArguments.ContainsKey('MaximumVersion')) {
                $isLessThanMax = ($installedVersion -le [System.Version] $extractedArguments['MaximumVersion'])

                if ($extractedArguments.ContainsKey('MinimumVersion')) {
                    $versionMatch = $versionMatch -and $isLessThanMax
                }
                else {
                    $versionMatch = $isLessThanMax
                }
            }

            # Case 5 - Both MinimumVersion and MaximumVersion are provided. It's covered by the above.
            # Do not return $false yet to allow the foreach to continue
            if (-not $versionMatch) {
                Write-Verbose -Message ($localizedData.VersionMismatch -f $Name, $installedVersion)
                $versionMatch = $false
            }
        }

        # Case 6 - Version matches but need to check if the module is from the right repository.
        if ($versionMatch) {
            # A user does not provide Repository, we are good
            if (-not $PSBoundParameters.ContainsKey('Repository')) {
                Write-Verbose -Message ($localizedData.ModuleFound -f "$Name $installedVersion")
                $returnVal += $m
            }
            else {
                # Check if the Repository matches
                $sourceName = Get-ModuleRepositoryName -Module $m

                if ($Repository -ieq $sourceName) {
                    Write-Verbose -Message ($localizedData.ModuleFound -f "$Name $installedVersion")
                    $returnVal += $m
                }
                else {
                    Write-Verbose -Message ($localizedData.RepositoryMismatch -f $($Name), $($sourceName))
                }
            }
        }
    } # foreach

    return $returnVal
}

<#
    .SYNOPSIS
        This is a helper function that returns the module's repository name.

    .PARAMETER Module
        Specifies the name of the PowerShell module.
#>
function Get-ModuleRepositoryName {
    <#
        These suppressions are added because this repository have other Visual Studio Code workspace
        settings than those in DscResource.Tests DSC test framework.
        Only those suppression that contradict this repository guideline is added here.
    #>
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('DscResource.AnalyzerRules\Measure-FunctionBlockBraces', '')]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('DscResource.AnalyzerRules\Measure-IfStatement', '')]
    [CmdletBinding()]
    param
    (
        [Parameter(Mandatory = $true)]
        [ValidateNotNullOrEmpty()]
        [System.Object]
        $Module
    )

    <#
        RepositorySourceLocation property is supported in PS V5 only. To work with the earlier
        PowerShell version, we need to do a different way. PSGetModuleInfo.xml exists for any
        PowerShell modules downloaded through PSModule provider.
    #>
    $psGetModuleInfoFileName = 'PSGetModuleInfo.xml'
    $psGetModuleInfoPath = Microsoft.PowerShell.Management\Join-Path -Path $Module.ModuleBase -ChildPath $psGetModuleInfoFileName

    Write-Verbose -Message ($localizedData.FoundModulePath -f $psGetModuleInfoPath)

    if (Microsoft.PowerShell.Management\Test-path -Path $psGetModuleInfoPath) {
        $psGetModuleInfo = Microsoft.PowerShell.Utility\Import-Clixml -Path $psGetModuleInfoPath

        return $psGetModuleInfo.Repository
    }
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Dependencies\PowerShellGet\2.2.5\DscResources\MSFT_PSRepository\MSFT_PSRepository.psm1
$resourceModuleRoot = Split-Path -Path (Split-Path -Path $PSScriptRoot -Parent) -Parent

# Import localization helper functions.
$helperName = 'PowerShellGet.LocalizationHelper'
$dscResourcesFolderFilePath = Join-Path -Path $resourceModuleRoot -ChildPath "Modules\$helperName\$helperName.psm1"
Import-Module -Name $dscResourcesFolderFilePath

$script:localizedData = Get-LocalizedData -ResourceName 'MSFT_PSRepository' -ScriptRoot $PSScriptRoot

# Import resource helper functions.
$helperName = 'PowerShellGet.ResourceHelper'
$dscResourcesFolderFilePath = Join-Path -Path $resourceModuleRoot -ChildPath "Modules\$helperName\$helperName.psm1"
Import-Module -Name $dscResourcesFolderFilePath

<#
    .SYNOPSIS
        Returns the current state of the repository.

    .PARAMETER Name
        Specifies the name of the repository to manage.
#>
function Get-TargetResource {
    <#
        These suppressions are added because this repository have other Visual Studio Code workspace
        settings than those in DscResource.Tests DSC test framework.
        Only those suppression that contradict this repository guideline is added here.
    #>
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('DscResource.AnalyzerRules\Measure-FunctionBlockBraces', '')]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('DscResource.AnalyzerRules\Measure-IfStatement', '')]
    [CmdletBinding()]
    [OutputType([System.Collections.Hashtable])]
    param
    (
        [Parameter(Mandatory = $true)]
        [System.String]
        $Name
    )

    $returnValue = @{
        Ensure                    = 'Absent'
        Name                      = $Name
        SourceLocation            = $null
        ScriptSourceLocation      = $null
        PublishLocation           = $null
        ScriptPublishLocation     = $null
        InstallationPolicy        = $null
        PackageManagementProvider = $null
        Trusted                   = $false
        Registered                = $false
    }

    Write-Verbose -Message ($localizedData.GetTargetResourceMessage -f $Name)

    $repository = Get-PSRepository -Name $Name -ErrorAction 'SilentlyContinue'

    if ($repository) {
        $returnValue.Ensure = 'Present'
        $returnValue.SourceLocation = $repository.SourceLocation
        $returnValue.ScriptSourceLocation = $repository.ScriptSourceLocation
        $returnValue.PublishLocation = $repository.PublishLocation
        $returnValue.ScriptPublishLocation = $repository.ScriptPublishLocation
        $returnValue.InstallationPolicy = $repository.InstallationPolicy
        $returnValue.PackageManagementProvider = $repository.PackageManagementProvider
        $returnValue.Trusted = $repository.Trusted
        $returnValue.Registered = $repository.Registered
    }
    else {
        Write-Verbose -Message ($localizedData.RepositoryNotFound -f $Name)
    }

    return $returnValue
}

<#
    .SYNOPSIS
        Determines if the repository is in the desired state.

    .PARAMETER Ensure
        If the repository should be present or absent on the server
        being configured. Default values is 'Present'.

    .PARAMETER Name
        Specifies the name of the repository to manage.

    .PARAMETER SourceLocation
        Specifies the URI for discovering and installing modules from
        this repository. A URI can be a NuGet server feed, HTTP, HTTPS,
        FTP or file location.

    .PARAMETER ScriptSourceLocation
        Specifies the URI for the script source location.

    .PARAMETER PublishLocation
        Specifies the URI of the publish location. For example, for
        NuGet-based repositories, the publish location is similar
        to http://someNuGetUrl.com/api/v2/Packages.

    .PARAMETER ScriptPublishLocation
        Specifies the URI for the script publish location.

    .PARAMETER InstallationPolicy
        Specifies the installation policy. Valid values are  'Trusted'
        or 'Untrusted'. The default value is 'Untrusted'.

    .PARAMETER PackageManagementProvider
        Specifies a OneGet package provider. Default value is 'NuGet'.
#>
function Test-TargetResource {
    <#
        These suppressions are added because this repository have other Visual Studio Code workspace
        settings than those in DscResource.Tests DSC test framework.
        Only those suppression that contradict this repository guideline is added here.
    #>
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('DscResource.AnalyzerRules\Measure-FunctionBlockBraces', '')]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('DscResource.AnalyzerRules\Measure-IfStatement', '')]
    [CmdletBinding()]
    [OutputType([System.Boolean])]
    param
    (
        [Parameter()]
        [ValidateSet('Present', 'Absent')]
        [System.String]
        $Ensure = 'Present',

        [Parameter(Mandatory = $true)]
        [System.String]
        $Name,

        [Parameter()]
        [System.String]
        $SourceLocation,

        [Parameter()]
        [System.String]
        $ScriptSourceLocation,

        [Parameter()]
        [System.String]
        $PublishLocation,

        [Parameter()]
        [System.String]
        $ScriptPublishLocation,

        [Parameter()]
        [ValidateSet('Trusted', 'Untrusted')]
        [System.String]
        $InstallationPolicy = 'Untrusted',

        [Parameter()]
        [System.String]
        $PackageManagementProvider = 'NuGet'
    )

    Write-Verbose -Message ($localizedData.TestTargetResourceMessage -f $Name)

    $returnValue = $false

    $getTargetResourceResult = Get-TargetResource -Name $Name

    if ($Ensure -eq $getTargetResourceResult.Ensure) {
        if ($getTargetResourceResult.Ensure -eq 'Present' ) {
            $returnValue = Test-DscParameterState `
                -CurrentValues $getTargetResourceResult `
                -DesiredValues $PSBoundParameters `
                -ValuesToCheck @(
                'SourceLocation'
                'ScriptSourceLocation'
                'PublishLocation'
                'ScriptPublishLocation'
                'InstallationPolicy'
                'PackageManagementProvider'
            )
        }
        else {
            $returnValue = $true
        }
    }

    if ($returnValue) {
        Write-Verbose -Message ($localizedData.InDesiredState -f $Name)
    }
    else {
        Write-Verbose -Message ($localizedData.NotInDesiredState -f $Name)
    }

    return $returnValue
}

<#
    .SYNOPSIS
        Creates, removes or updates the repository.

    .PARAMETER Ensure
        If the repository should be present or absent on the server
        being configured. Default values is 'Present'.

    .PARAMETER Name
        Specifies the name of the repository to manage.

    .PARAMETER SourceLocation
        Specifies the URI for discovering and installing modules from
        this repository. A URI can be a NuGet server feed, HTTP, HTTPS,
        FTP or file location.

    .PARAMETER ScriptSourceLocation
        Specifies the URI for the script source location.

    .PARAMETER PublishLocation
        Specifies the URI of the publish location. For example, for
        NuGet-based repositories, the publish location is similar
        to http://someNuGetUrl.com/api/v2/Packages.

    .PARAMETER ScriptPublishLocation
        Specifies the URI for the script publish location.

    .PARAMETER InstallationPolicy
        Specifies the installation policy. Valid values are  'Trusted'
        or 'Untrusted'. The default value is 'Untrusted'.

    .PARAMETER PackageManagementProvider
        Specifies a OneGet package provider. Default value is 'NuGet'.
#>
function Set-TargetResource {
    <#
        These suppressions are added because this repository have other Visual Studio Code workspace
        settings than those in DscResource.Tests DSC test framework.
        Only those suppression that contradict this repository guideline is added here.
    #>
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('DscResource.AnalyzerRules\Measure-FunctionBlockBraces', '')]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('DscResource.AnalyzerRules\Measure-IfStatement', '')]
    [CmdletBinding()]
    param
    (
        [Parameter()]
        [ValidateSet('Present', 'Absent')]
        [System.String]
        $Ensure = 'Present',

        [Parameter(Mandatory = $true)]
        [System.String]
        $Name,

        [Parameter()]
        [System.String]
        $SourceLocation,

        [Parameter()]
        [System.String]
        $ScriptSourceLocation,

        [Parameter()]
        [System.String]
        $PublishLocation,

        [Parameter()]
        [System.String]
        $ScriptPublishLocation,

        [Parameter()]
        [ValidateSet('Trusted', 'Untrusted')]
        [System.String]
        $InstallationPolicy = 'Untrusted',

        [Parameter()]
        [System.String]
        $PackageManagementProvider = 'NuGet'
    )

    $getTargetResourceResult = Get-TargetResource -Name $Name

    # Determine if the repository should be present or absent.
    if ($Ensure -eq 'Present') {
        $repositoryParameters = New-SplatParameterHashTable `
            -FunctionBoundParameters $PSBoundParameters `
            -ArgumentNames @(
            'Name'
            'SourceLocation'
            'ScriptSourceLocation'
            'PublishLocation'
            'ScriptPublishLocation'
            'InstallationPolicy'
            'PackageManagementProvider'
        )

        # Determine if the repository is already present.
        if ($getTargetResourceResult.Ensure -eq 'Present') {
            Write-Verbose -Message ($localizedData.RepositoryExist -f $Name)

            # Repository exist, update the properties.
            Set-PSRepository @repositoryParameters -ErrorAction 'Stop'
        }
        else {
            Write-Verbose -Message ($localizedData.RepositoryDoesNotExist -f $Name)

            # Repository did not exist, create the repository.
            Register-PSRepository @repositoryParameters -ErrorAction 'Stop'
        }
    }
    else {
        if ($getTargetResourceResult.Ensure -eq 'Present') {
            Write-Verbose -Message ($localizedData.RemoveExistingRepository -f $Name)

            # Repository did exist, remove the repository.
            Unregister-PSRepository -Name $Name -ErrorAction 'Stop'
        }
    }
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Dependencies\PowerShellGet\2.2.5\Modules\PowerShellGet.LocalizationHelper\PowerShellGet.LocalizationHelper.psm1
<#
    .SYNOPSIS
        Creates and throws an invalid argument exception.

    .PARAMETER Message
        The message explaining why this error is being thrown.

    .PARAMETER ArgumentName
        The name of the invalid argument that is causing this error to be thrown.
#>
function New-InvalidArgumentException {
    [CmdletBinding()]
    param
    (
        [Parameter(Mandatory = $true)]
        [ValidateNotNullOrEmpty()]
        [System.String]
        $Message,

        [Parameter(Mandatory = $true)]
        [ValidateNotNullOrEmpty()]
        [System.String]
        $ArgumentName
    )

    $argumentException = New-Object -TypeName 'ArgumentException' `
        -ArgumentList @($Message, $ArgumentName)

    $newObjectParameters = @{
        TypeName     = 'System.Management.Automation.ErrorRecord'
        ArgumentList = @($argumentException, $ArgumentName, 'InvalidArgument', $null)
    }

    $errorRecord = New-Object @newObjectParameters

    throw $errorRecord
}

<#
    .SYNOPSIS
        Creates and throws an invalid operation exception.

    .PARAMETER Message
        The message explaining why this error is being thrown.

    .PARAMETER ErrorRecord
        The error record containing the exception that is causing this terminating error.
#>
function New-InvalidOperationException {
    [CmdletBinding()]
    param
    (
        [Parameter(Mandatory = $true)]
        [ValidateNotNullOrEmpty()]
        [System.String]
        $Message,

        [Parameter()]
        [ValidateNotNull()]
        [System.Management.Automation.ErrorRecord]
        $ErrorRecord
    )

    if ($null -eq $ErrorRecord) {
        $invalidOperationException = New-Object -TypeName 'InvalidOperationException' `
            -ArgumentList @($Message)
    }
    else {
        $invalidOperationException = New-Object -TypeName 'InvalidOperationException' `
            -ArgumentList @($Message, $ErrorRecord.Exception)
    }

    $newObjectParameters = @{
        TypeName     = 'System.Management.Automation.ErrorRecord'
        ArgumentList = @(
            $invalidOperationException.ToString(),
            'MachineStateIncorrect',
            'InvalidOperation',
            $null
        )
    }

    $errorRecordToThrow = New-Object @newObjectParameters

    throw $errorRecordToThrow
}

<#
    .SYNOPSIS
        Creates and throws an object not found exception.

    .PARAMETER Message
        The message explaining why this error is being thrown.

    .PARAMETER ErrorRecord
        The error record containing the exception that is causing this terminating error.
#>
function New-ObjectNotFoundException {
    [CmdletBinding()]
    param
    (
        [Parameter(Mandatory = $true)]
        [ValidateNotNullOrEmpty()]
        [System.String]
        $Message,

        [Parameter()]
        [ValidateNotNull()]
        [System.Management.Automation.ErrorRecord]
        $ErrorRecord
    )

    if ($null -eq $ErrorRecord) {
        $exception = New-Object -TypeName 'System.Exception' `
            -ArgumentList @($Message)
    }
    else {
        $exception = New-Object -TypeName 'System.Exception' `
            -ArgumentList @($Message, $ErrorRecord.Exception)
    }

    $newObjectParameters = @{
        TypeName     = 'System.Management.Automation.ErrorRecord'
        ArgumentList = @(
            $exception.ToString(),
            'MachineStateIncorrect',
            'ObjectNotFound',
            $null
        )
    }

    $errorRecordToThrow = New-Object @newObjectParameters

    throw $errorRecordToThrow
}

<#
    .SYNOPSIS
        Creates and throws an invalid result exception.

    .PARAMETER Message
        The message explaining why this error is being thrown.

    .PARAMETER ErrorRecord
        The error record containing the exception that is causing this terminating error.
#>
function New-InvalidResultException {
    [CmdletBinding()]
    param
    (
        [Parameter(Mandatory = $true)]
        [ValidateNotNullOrEmpty()]
        [System.String]
        $Message,

        [Parameter()]
        [ValidateNotNull()]
        [System.Management.Automation.ErrorRecord]
        $ErrorRecord
    )

    if ($null -eq $ErrorRecord) {
        $exception = New-Object -TypeName 'System.Exception' `
            -ArgumentList @($Message)
    }
    else {
        $exception = New-Object -TypeName 'System.Exception' `
            -ArgumentList @($Message, $ErrorRecord.Exception)
    }

    $newObjectParameters = @{
        TypeName     = 'System.Management.Automation.ErrorRecord'
        ArgumentList = @(
            $exception.ToString(),
            'MachineStateIncorrect',
            'InvalidResult',
            $null
        )
    }

    $errorRecordToThrow = New-Object @newObjectParameters

    throw $errorRecordToThrow
}

<#
    .SYNOPSIS
        Retrieves the localized string data based on the machine's culture.
        Falls back to en-US strings if the machine's culture is not supported.

    .PARAMETER ResourceName
        The name of the resource as it appears before '.strings.psd1' of the localized string file.
        For example:
            For WindowsOptionalFeature: MSFT_WindowsOptionalFeature
            For Service: MSFT_ServiceResource
            For Registry: MSFT_RegistryResource
            For Helper: SqlServerDscHelper

    .PARAMETER ScriptRoot
        Optional. The root path where to expect to find the culture folder. This is only needed
        for localization in helper modules. This should not normally be used for resources.
#>
function Get-LocalizedData {
    [CmdletBinding()]
    param
    (
        [Parameter(Mandatory = $true)]
        [ValidateNotNullOrEmpty()]
        [System.String]
        $ResourceName,

        [Parameter()]
        [ValidateNotNullOrEmpty()]
        [System.String]
        $ScriptRoot
    )

    if ( -not $ScriptRoot ) {
        $resourceDirectory = Join-Path -Path $PSScriptRoot -ChildPath $ResourceName
        $localizedStringFileLocation = Join-Path -Path $resourceDirectory -ChildPath $PSUICulture
    }
    else {
        $localizedStringFileLocation = Join-Path -Path $ScriptRoot -ChildPath $PSUICulture
    }

    if (-not (Test-Path -Path $localizedStringFileLocation)) {
        # Fallback to en-US
        if ( -not $ScriptRoot ) {
            $localizedStringFileLocation = Join-Path -Path $resourceDirectory -ChildPath 'en-US'
        }
        else {
            $localizedStringFileLocation = Join-Path -Path $ScriptRoot -ChildPath 'en-US'
        }
    }

    Import-LocalizedData `
        -BindingVariable 'localizedData' `
        -FileName "$ResourceName.strings.psd1" `
        -BaseDirectory $localizedStringFileLocation

    return $localizedData
}

Export-ModuleMember -Function @(
    'New-InvalidArgumentException',
    'New-InvalidOperationException',
    'New-ObjectNotFoundException',
    'New-InvalidResultException',
    'Get-LocalizedData'
)

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Dependencies\PowerShellGet\2.2.5\Modules\PowerShellGet.ResourceHelper\PowerShellGet.ResourceHelper.psm1
#
# Copyright (c) Microsoft Corporation.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

<#
    Helper functions for PowerShellGet DSC Resources.
#>

# Import localization helper functions.
$helperName = 'PowerShellGet.LocalizationHelper'
$resourceModuleRoot = Split-Path -Path (Split-Path -Path $PSScriptRoot -Parent) -Parent
$dscResourcesFolderFilePath = Join-Path -Path $resourceModuleRoot -ChildPath "Modules\$helperName\$helperName.psm1"
Import-Module -Name $dscResourcesFolderFilePath

# Import Localization Strings
$script:localizedData = Get-LocalizedData -ResourceName 'PowerShellGet.ResourceHelper' -ScriptRoot $PSScriptRoot

<#
    .SYNOPSIS
        This is a helper function that extract the parameters from a given table.

    .PARAMETER FunctionBoundParameters
        Specifies the hash table containing a set of parameters to be extracted.

    .PARAMETER ArgumentNames
        Specifies a list of arguments you want to extract.
#>
function New-SplatParameterHashTable {
    [CmdletBinding()]
    [OutputType([System.Collections.Hashtable])]
    param
    (
        [Parameter(Mandatory = $true)]
        [System.Collections.Hashtable]
        $FunctionBoundParameters,

        [Parameter(Mandatory = $true)]
        [System.String[]]
        $ArgumentNames
    )

    Write-Verbose -Message ($script:localizedData.CallingFunction -f $($MyInvocation.MyCommand))

    $returnValue = @{}

    foreach ($arg in $ArgumentNames) {
        if ($FunctionBoundParameters.ContainsKey($arg)) {
            # Found an argument we are looking for, so we add it to return collection.
            $returnValue.Add($arg, $FunctionBoundParameters[$arg])
        }
    }

    return $returnValue
}

<#
    .SYNOPSIS
        This is a helper function that validate that a value is correct and used correctly.

    .PARAMETER Value
        Specifies the value to be validated.

    .PARAMETER Type
        Specifies the type of argument.

    .PARAMETER Type
        Specifies the name of the provider.

    .OUTPUTS
        None. Throws an error if the test fails.
#>
function Test-ParameterValue {
    [CmdletBinding()]
    param
    (
        [Parameter(Mandatory = $true)]
        [ValidateNotNullOrEmpty()]
        [System.String]
        $Value,

        [Parameter(Mandatory = $true)]
        [ValidateNotNullOrEmpty()]
        [System.String]
        $Type,

        [Parameter(Mandatory = $true)]
        [ValidateNotNullOrEmpty()]
        [System.String]
        $ProviderName
    )

    Write-Verbose -Message ($script:localizedData.CallingFunction -f $($MyInvocation.MyCommand))

    switch ($Type) {
        'SourceUri' {
            # Checks whether given URI represents specific scheme
            # Most common schemes: file, http, https, ftp
            $scheme = @('http', 'https', 'file', 'ftp')

            $newUri = $Value -as [System.URI]
            $returnValue = ($newUri -and $newUri.AbsoluteURI -and ($scheme -icontains $newUri.Scheme))

            if ($returnValue -eq $false) {
                $errorMessage = $script:localizedData.InValidUri -f $Value
                New-InvalidArgumentException -ArgumentName $Type -Message $errorMessage
            }
        }

        'DestinationPath' {
            $returnValue = Test-Path -Path $Value

            if ($returnValue -eq $false) {
                $errorMessage = $script:localizedData.PathDoesNotExist -f $Value
                New-InvalidArgumentException -ArgumentName $Type -Message $errorMessage
            }
        }

        'PackageSource' {
            # Value can be either the package source Name or source Uri.

            # Check if the source is a Uri.
            $uri = $Value -as [System.URI]

            if ($uri -and $uri.AbsoluteURI) {
                # Check if it's a valid Uri.
                Test-ParameterValue -Value $Value -Type 'SourceUri' -ProviderName $ProviderName
            }
            else {
                # Check if it's a registered package source name.
                $source = PackageManagement\Get-PackageSource -Name $Value -ProviderName $ProviderName -ErrorVariable ev

                if ((-not $source) -or $ev) {
                    # We do not need to throw error here as Get-PackageSource does already.
                    Write-Verbose -Message ($script:localizedData.SourceNotFound -f $source)
                }
            }
        }

        default {
            $errorMessage = $script:localizedData.UnexpectedArgument -f $Type
            New-InvalidArgumentException -ArgumentName $Type -Message $errorMessage
        }
    }
}

<#
    .SYNOPSIS
        This is a helper function that does the version validation.

    .PARAMETER RequiredVersion
        Provides the required version.

    .PARAMETER MaximumVersion
        Provides the maximum version.

    .PARAMETER MinimumVersion
        Provides the minimum version.
#>
function Test-VersionParameter {
    [CmdletBinding()]
    param
    (
        [Parameter()]
        [System.String]
        $RequiredVersion,

        [Parameter()]
        [System.String]
        $MinimumVersion,

        [Parameter()]
        [System.String]
        $MaximumVersion
    )

    Write-Verbose -Message ($localizedData.CallingFunction -f $($MyInvocation.MyCommand))

    $isValid = $false

    # Case 1: No further check required if a user provides either none or one of these: minimumVersion, maximumVersion, and requiredVersion.
    if ($PSBoundParameters.Count -le 1) {
        return $true
    }

    # Case 2: #If no RequiredVersion is provided.
    if (-not $PSBoundParameters.ContainsKey('RequiredVersion')) {
        # If no RequiredVersion, both MinimumVersion and MaximumVersion are provided. Otherwise fall into the Case #1.
        $isValid = $PSBoundParameters['MinimumVersion'] -le $PSBoundParameters['MaximumVersion']
    }

    # Case 3: RequiredVersion is provided.
    #        In this case  MinimumVersion and/or MaximumVersion also are provided. Otherwise fall in to Case #1.
    #        This is an invalid case. When RequiredVersion is provided, others are not allowed. so $isValid is false, which is already set in the init.

    if ($isValid -eq $false) {
        $errorMessage = $script:localizedData.VersionError
        New-InvalidArgumentException `
            -ArgumentName 'RequiredVersion, MinimumVersion or MaximumVersion' `
            -Message $errorMessage
    }
}

<#
    .SYNOPSIS
        This is a helper function that retrieves the InstallationPolicy from the given repository.

    .PARAMETER RepositoryName
        Provides the repository Name.
#>
function Get-InstallationPolicy {
    [CmdletBinding()]
    param
    (
        [Parameter(Mandatory = $true)]
        [ValidateNotNullOrEmpty()]
        [System.String] $RepositoryName
    )

    Write-Verbose -Message ($LocalizedData.CallingFunction -f $($MyInvocation.MyCommand))

    $repositoryObject = PackageManagement\Get-PackageSource -Name $RepositoryName -ErrorAction SilentlyContinue -WarningAction SilentlyContinue

    if ($repositoryObject) {
        return $repositoryObject.IsTrusted
    }
}

<#
    .SYNOPSIS
        This method is used to compare current and desired values for any DSC resource.

    .PARAMETER CurrentValues
        This is hash table of the current values that are applied to the resource.

    .PARAMETER DesiredValues
        This is a PSBoundParametersDictionary of the desired values for the resource.

    .PARAMETER ValuesToCheck
        This is a list of which properties in the desired values list should be checked.
        If this is empty then all values in DesiredValues are checked.
#>
function Test-DscParameterState {
    [CmdletBinding()]
    param
    (
        [Parameter(Mandatory = $true)]
        [System.Collections.Hashtable]
        $CurrentValues,

        [Parameter(Mandatory = $true)]
        [System.Object]
        $DesiredValues,

        [Parameter()]
        [System.Array]
        $ValuesToCheck
    )

    $returnValue = $true

    if (($DesiredValues.GetType().Name -ne 'HashTable') `
            -and ($DesiredValues.GetType().Name -ne 'CimInstance') `
            -and ($DesiredValues.GetType().Name -ne 'PSBoundParametersDictionary')) {
        $errorMessage = $script:localizedData.PropertyTypeInvalidForDesiredValues -f $($DesiredValues.GetType().Name)
        New-InvalidArgumentException -ArgumentName 'DesiredValues' -Message $errorMessage
    }

    if (($DesiredValues.GetType().Name -eq 'CimInstance') -and ($null -eq $ValuesToCheck)) {
        $errorMessage = $script:localizedData.PropertyTypeInvalidForValuesToCheck
        New-InvalidArgumentException -ArgumentName 'ValuesToCheck' -Message $errorMessage
    }

    if (($null -eq $ValuesToCheck) -or ($ValuesToCheck.Count -lt 1)) {
        $keyList = $DesiredValues.Keys
    }
    else {
        $keyList = $ValuesToCheck
    }

    $keyList | ForEach-Object -Process {
        if (($_ -ne 'Verbose')) {
            if (($CurrentValues.ContainsKey($_) -eq $false) `
                    -or ($CurrentValues.$_ -ne $DesiredValues.$_) `
                    -or (($DesiredValues.GetType().Name -ne 'CimInstance' -and $DesiredValues.ContainsKey($_) -eq $true) -and ($null -ne $DesiredValues.$_ -and $DesiredValues.$_.GetType().IsArray))) {
                if ($DesiredValues.GetType().Name -eq 'HashTable' -or `
                        $DesiredValues.GetType().Name -eq 'PSBoundParametersDictionary') {
                    $checkDesiredValue = $DesiredValues.ContainsKey($_)
                }
                else {
                    # If DesiredValue is a CimInstance.
                    $checkDesiredValue = $false
                    if (([System.Boolean]($DesiredValues.PSObject.Properties.Name -contains $_)) -eq $true) {
                        if ($null -ne $DesiredValues.$_) {
                            $checkDesiredValue = $true
                        }
                    }
                }

                if ($checkDesiredValue) {
                    $desiredType = $DesiredValues.$_.GetType()
                    $fieldName = $_
                    if ($desiredType.IsArray -eq $true) {
                        if (($CurrentValues.ContainsKey($fieldName) -eq $false) `
                                -or ($null -eq $CurrentValues.$fieldName)) {
                            Write-Verbose -Message ($script:localizedData.PropertyValidationError -f $fieldName) -Verbose

                            $returnValue = $false
                        }
                        else {
                            $arrayCompare = Compare-Object -ReferenceObject $CurrentValues.$fieldName `
                                -DifferenceObject $DesiredValues.$fieldName
                            if ($null -ne $arrayCompare) {
                                Write-Verbose -Message ($script:localizedData.PropertiesDoesNotMatch -f $fieldName) -Verbose

                                $arrayCompare | ForEach-Object -Process {
                                    Write-Verbose -Message ($script:localizedData.PropertyThatDoesNotMatch -f $_.InputObject, $_.SideIndicator) -Verbose
                                }

                                $returnValue = $false
                            }
                        }
                    }
                    else {
                        switch ($desiredType.Name) {
                            'String' {
                                if (-not [System.String]::IsNullOrEmpty($CurrentValues.$fieldName) -or `
                                        -not [System.String]::IsNullOrEmpty($DesiredValues.$fieldName)) {
                                    Write-Verbose -Message ($script:localizedData.ValueOfTypeDoesNotMatch `
                                            -f $desiredType.Name, $fieldName, $($CurrentValues.$fieldName), $($DesiredValues.$fieldName)) -Verbose

                                    $returnValue = $false
                                }
                            }

                            'Int32' {
                                if (-not ($DesiredValues.$fieldName -eq 0) -or `
                                        -not ($null -eq $CurrentValues.$fieldName)) {
                                    Write-Verbose -Message ($script:localizedData.ValueOfTypeDoesNotMatch `
                                            -f $desiredType.Name, $fieldName, $($CurrentValues.$fieldName), $($DesiredValues.$fieldName)) -Verbose

                                    $returnValue = $false
                                }
                            }

                            { $_ -eq 'Int16' -or $_ -eq 'UInt16'} {
                                if (-not ($DesiredValues.$fieldName -eq 0) -or `
                                        -not ($null -eq $CurrentValues.$fieldName)) {
                                    Write-Verbose -Message ($script:localizedData.ValueOfTypeDoesNotMatch `
                                            -f $desiredType.Name, $fieldName, $($CurrentValues.$fieldName), $($DesiredValues.$fieldName)) -Verbose

                                    $returnValue = $false
                                }
                            }

                            default {
                                Write-Warning -Message ($script:localizedData.UnableToCompareProperty `
                                        -f $fieldName, $desiredType.Name)

                                $returnValue = $false
                            }
                        }
                    }
                }
            }
        }
    }

    return $returnValue
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Dependencies\PowerShellGet\2.2.5\PSModule.psm1
Import-LocalizedData LocalizedData -filename PSGet.Resource.psd1

#########################################################################################
#
# Copyright (c) Microsoft Corporation. All rights reserved.
#
# PowerShellGet Module
#
#########################################################################################

Microsoft.PowerShell.Core\Set-StrictMode -Version Latest

#region script variables

$script:IsInbox = $PSHOME.EndsWith('\WindowsPowerShell\v1.0', [System.StringComparison]::OrdinalIgnoreCase)
$script:IsWindows = (-not (Get-Variable -Name IsWindows -ErrorAction Ignore)) -or $IsWindows
$script:IsLinux = (Get-Variable -Name IsLinux -ErrorAction Ignore) -and $IsLinux
$script:IsMacOS = (Get-Variable -Name IsMacOS -ErrorAction Ignore) -and $IsMacOS
$script:IsCoreCLR = $PSVersionTable.ContainsKey('PSEdition') -and $PSVersionTable.PSEdition -eq 'Core'
$script:IsNanoServer = & {
    if (!$script:IsWindows) {
        return $false
    }

    $serverLevelsPath = 'HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Server\ServerLevels\'
    if (Test-Path -Path $serverLevelsPath) {
        $NanoItem = Get-ItemProperty -Name NanoServer -Path $serverLevelsPath -ErrorAction Ignore
        if ($NanoItem -and ($NanoItem.NanoServer -eq 1)) {
            return $true
        }
    }
    return $false
}

if ($script:IsInbox) {
    $script:ProgramFilesPSPath = Microsoft.PowerShell.Management\Join-Path -Path $env:ProgramFiles -ChildPath "WindowsPowerShell"
}
elseif ($script:IsCoreCLR) {
    if ($script:IsWindows) {
        $script:ProgramFilesPSPath = Microsoft.PowerShell.Management\Join-Path -Path $env:ProgramFiles -ChildPath 'PowerShell'
    }
    else {
        $script:ProgramFilesPSPath = Microsoft.PowerShell.Management\Split-Path -Path ([System.Management.Automation.Platform]::SelectProductNameForDirectory('SHARED_MODULES')) -Parent
    }
}

try {
    $script:MyDocumentsFolderPath = [Environment]::GetFolderPath("MyDocuments")
}
catch {
    $script:MyDocumentsFolderPath = $null
}

if ($script:IsInbox) {
    $script:MyDocumentsPSPath = if ($script:MyDocumentsFolderPath) {
        Microsoft.PowerShell.Management\Join-Path -Path $script:MyDocumentsFolderPath -ChildPath "WindowsPowerShell"
    }
    else {
        Microsoft.PowerShell.Management\Join-Path -Path $env:USERPROFILE -ChildPath "Documents\WindowsPowerShell"
    }
}
elseif ($script:IsCoreCLR) {
    if ($script:IsWindows) {
        $script:MyDocumentsPSPath = if ($script:MyDocumentsFolderPath) {
            Microsoft.PowerShell.Management\Join-Path -Path $script:MyDocumentsFolderPath -ChildPath 'PowerShell'
        }
        else {
            Microsoft.PowerShell.Management\Join-Path -Path $HOME -ChildPath "Documents\PowerShell"
        }
    }
    else {
        $script:MyDocumentsPSPath = Microsoft.PowerShell.Management\Split-Path -Path ([System.Management.Automation.Platform]::SelectProductNameForDirectory('USER_MODULES')) -Parent
    }
}

$script:ProgramFilesModulesPath = Microsoft.PowerShell.Management\Join-Path -Path $script:ProgramFilesPSPath -ChildPath 'Modules'
$script:MyDocumentsModulesPath = Microsoft.PowerShell.Management\Join-Path -Path $script:MyDocumentsPSPath -ChildPath 'Modules'

$script:ProgramFilesScriptsPath = Microsoft.PowerShell.Management\Join-Path -Path $script:ProgramFilesPSPath -ChildPath 'Scripts'
$script:MyDocumentsScriptsPath = Microsoft.PowerShell.Management\Join-Path -Path $script:MyDocumentsPSPath -ChildPath 'Scripts'

$script:PSGetPath = [pscustomobject]@{
    AllUsersModules    = $script:ProgramFilesModulesPath
    AllUsersScripts    = $script:ProgramFilesScriptsPath
    CurrentUserModules = $script:MyDocumentsModulesPath
    CurrentUserScripts = $script:MyDocumentsScriptsPath
    PSTypeName         = 'Microsoft.PowerShell.Commands.PSGetPath'
}

$script:TempPath = [System.IO.Path]::GetTempPath()
$script:PSGetItemInfoFileName = "PSGetModuleInfo.xml"

if ($script:IsWindows) {
    $script:PSGetProgramDataPath = Microsoft.PowerShell.Management\Join-Path -Path $env:ProgramData -ChildPath 'Microsoft\Windows\PowerShell\PowerShellGet\'
    $script:PSGetAppLocalPath = Microsoft.PowerShell.Management\Join-Path -Path $env:LOCALAPPDATA -ChildPath 'Microsoft\Windows\PowerShell\PowerShellGet\'
}
else {
    $script:PSGetProgramDataPath = Microsoft.PowerShell.Management\Join-Path -Path ([System.Management.Automation.Platform]::SelectProductNameForDirectory('CONFIG')) -ChildPath 'PowerShellGet'
    $script:PSGetAppLocalPath = Microsoft.PowerShell.Management\Join-Path -Path ([System.Management.Automation.Platform]::SelectProductNameForDirectory('CACHE')) -ChildPath 'PowerShellGet'
}

$script:PSGetModuleSourcesFilePath = Microsoft.PowerShell.Management\Join-Path -Path $script:PSGetAppLocalPath -ChildPath "PSRepositories.xml"
$script:PSGetModuleSources = $null
$script:PSGetInstalledModules = $null
$script:PSGetSettingsFilePath = Microsoft.PowerShell.Management\Join-Path -Path $script:PSGetAppLocalPath -ChildPath "PowerShellGetSettings.xml"
$script:PSGetSettings = $null

$script:MyDocumentsInstalledScriptInfosPath = Microsoft.PowerShell.Management\Join-Path -Path $script:MyDocumentsScriptsPath -ChildPath 'InstalledScriptInfos'
$script:ProgramFilesInstalledScriptInfosPath = Microsoft.PowerShell.Management\Join-Path -Path $script:ProgramFilesScriptsPath -ChildPath 'InstalledScriptInfos'

$script:IsRunningAsElevated = $true
$script:IsRunningAsElevatedTested = $false

$script:InstalledScriptInfoFileName = 'InstalledScriptInfo.xml'
$script:PSGetInstalledScripts = $null

# Public PSGallery module source name and location
$Script:PSGalleryModuleSource = "PSGallery"
$Script:PSGallerySourceUri = 'https://www.powershellgallery.com/api/v2'
$Script:PSGalleryPublishUri = 'https://www.powershellgallery.com/api/v2/package/'
$Script:PSGalleryScriptSourceUri = 'https://www.powershellgallery.com/api/v2/items/psscript'

# PSGallery V3 Source
$Script:PSGalleryV3SourceUri = 'https://www.powershellgallery.com/api/v3'

$Script:ResponseUri = "ResponseUri"
$Script:StatusCode = "StatusCode"
$Script:Exception = "Exception"

$script:PSModuleProviderName = 'PowerShellGet'
$script:PackageManagementProviderParam = "PackageManagementProvider"
$script:PublishLocation = "PublishLocation"
$script:ScriptSourceLocation = 'ScriptSourceLocation'
$script:ScriptPublishLocation = 'ScriptPublishLocation'
$script:Proxy = 'Proxy'
$script:ProxyCredential = 'ProxyCredential'
$script:Credential = 'Credential'
$script:VSTSAuthenticatedFeedsDocUrl = 'https://go.microsoft.com/fwlink/?LinkID=698608'
$script:Prerelease = "Prerelease"

$script:NuGetProviderName = "NuGet"
$script:NuGetProviderVersion = [Version]'2.8.5.201'

$script:SupportsPSModulesFeatureName = "supports-powershell-modules"
$script:FastPackRefHashtable = @{ }
$script:NuGetBinaryProgramDataPath = if ($script:IsWindows) { "$env:ProgramFiles\PackageManagement\ProviderAssemblies" }
$script:NuGetBinaryLocalAppDataPath = if ($script:IsWindows) { "$env:LOCALAPPDATA\PackageManagement\ProviderAssemblies" }
# go fwlink for 'https://dist.nuget.org/win-x86-commandline/latest/nuget.exe'
$script:NuGetClientSourceURL = 'https://aka.ms/psget-nugetexe'
$script:NuGetExeMinRequiredVersion = [Version]'4.1.0'
$script:NuGetExeName = 'NuGet.exe'
$script:NuGetExePath = $null
$script:NuGetExeVersion = $null
$script:NuGetProvider = $null
$script:DotnetCommandName = 'dotnet'
$script:MinimumDotnetCommandVersion = [Version]'2.0.0'
$script:DotnetInstallUrl = 'https://aka.ms/dotnet-install-script'
$script:DotnetCommandPath = $null
# PowerShellGetFormatVersion will be incremented when we change the .nupkg format structure.
# PowerShellGetFormatVersion is in the form of Major.Minor.
# Minor is incremented for the backward compatible format change.
# Major is incremented for the breaking change.
$script:PSGetRequireLicenseAcceptanceFormatVersion = [Version]'2.0'
$script:CurrentPSGetFormatVersion = $script:PSGetRequireLicenseAcceptanceFormatVersion
$script:PSGetFormatVersion = "PowerShellGetFormatVersion"
$script:SupportedPSGetFormatVersionMajors = @("1", "2")
$script:ModuleReferences = 'Module References'
$script:AllVersions = "AllVersions"
$script:AllowPrereleaseVersions = "AllowPrereleaseVersions"
$script:Filter = "Filter"
$script:IncludeValidSet = @('DscResource', 'Cmdlet', 'Function', 'Workflow', 'RoleCapability')
$script:DscResource = "PSDscResource"
$script:Command = "PSCommand"
$script:Cmdlet = "PSCmdlet"
$script:Function = "PSFunction"
$script:Workflow = "PSWorkflow"
$script:RoleCapability = 'PSRoleCapability'
$script:Includes = "PSIncludes"
$script:Tag = "Tag"
$script:NotSpecified = '_NotSpecified_'
$script:PSGetModuleName = 'PowerShellGet'
$script:FindByCanonicalId = 'FindByCanonicalId'
$script:InstalledLocation = 'InstalledLocation'
$script:PSArtifactType = 'Type'
$script:PSArtifactTypeModule = 'Module'
$script:PSArtifactTypeScript = 'Script'
$script:All = 'All'

$script:Name = 'Name'
$script:Version = 'Version'
$script:Guid = 'Guid'
$script:Path = 'Path'
$script:ScriptBase = 'ScriptBase'
$script:Description = 'Description'
$script:Author = 'Author'
$script:CompanyName = 'CompanyName'
$script:Copyright = 'Copyright'
$script:Tags = 'Tags'
$script:LicenseUri = 'LicenseUri'
$script:ProjectUri = 'ProjectUri'
$script:IconUri = 'IconUri'
$script:RequiredModules = 'RequiredModules'
$script:ExternalModuleDependencies = 'ExternalModuleDependencies'
$script:ReleaseNotes = 'ReleaseNotes'
$script:RequiredScripts = 'RequiredScripts'
$script:ExternalScriptDependencies = 'ExternalScriptDependencies'
$script:DefinedCommands = 'DefinedCommands'
$script:DefinedFunctions = 'DefinedFunctions'
$script:DefinedWorkflows = 'DefinedWorkflows'
$script:TextInfo = (Get-Culture).TextInfo
$script:PrivateData = 'PrivateData'

$script:PSScriptInfoProperties = @($script:Name
    $script:Version,
    $script:Guid,
    $script:Path,
    $script:ScriptBase,
    $script:Description,
    $script:Author,
    $script:CompanyName,
    $script:Copyright,
    $script:Tags,
    $script:ReleaseNotes,
    $script:RequiredModules,
    $script:ExternalModuleDependencies,
    $script:RequiredScripts,
    $script:ExternalScriptDependencies,
    $script:LicenseUri,
    $script:ProjectUri,
    $script:IconUri,
    $script:DefinedCommands,
    $script:DefinedFunctions,
    $script:DefinedWorkflows,
    $script:PrivateData
)

$script:SystemEnvironmentKey = 'HKLM:\System\CurrentControlSet\Control\Session Manager\Environment'
$script:UserEnvironmentKey = 'HKCU:\Environment'
$script:SystemEnvironmentVariableMaximumLength = 1024
$script:UserEnvironmentVariableMaximumLength = 255
$script:EnvironmentVariableTarget = @{ Process = 0; User = 1; Machine = 2 }

# Wildcard pattern matching configuration.
$script:wildcardOptions = [System.Management.Automation.WildcardOptions]::CultureInvariant -bor `
    [System.Management.Automation.WildcardOptions]::IgnoreCase

$script:DynamicOptionTypeMap = @{
    0 = [string]; # String
    1 = [string[]]; # StringArray
    2 = [int]; # Int
    3 = [switch]; # Switch
    4 = [string]; # Folder
    5 = [string]; # File
    6 = [string]; # Path
    7 = [Uri]; # Uri
    8 = [SecureString]; #SecureString
}
#endregion script variables

#region Module message resolvers
$script:PackageManagementMessageResolverScriptBlock = {
    param($i, $Message)
    return (PackageManagementMessageResolver -MsgId $i, -Message $Message)
}

$script:PackageManagementSaveModuleMessageResolverScriptBlock = {
    param($i, $Message)
    $PackageTarget = $LocalizedData.InstallModulewhatIfMessage
    $QuerySaveUntrustedPackage = $LocalizedData.QuerySaveUntrustedPackage

    switch ($i) {
        'ActionInstallPackage' { return "Save-Module" }
        'QueryInstallUntrustedPackage' { return $QuerySaveUntrustedPackage }
        'TargetPackage' { return $PackageTarget }
        Default {
            $Message = $Message -creplace "Install", "Download"
            $Message = $Message -creplace "install", "download"
            return (PackageManagementMessageResolver -MsgId $i, -Message $Message)
        }
    }
}

$script:PackageManagementInstallModuleMessageResolverScriptBlock = {
    param($i, $Message)
    $PackageTarget = $LocalizedData.InstallModulewhatIfMessage

    switch ($i) {
        'ActionInstallPackage' { return "Install-Module" }
        'TargetPackage' { return $PackageTarget }
        Default {
            return (PackageManagementMessageResolver -MsgId $i, -Message $Message)
        }
    }
}

$script:PackageManagementUnInstallModuleMessageResolverScriptBlock = {
    param($i, $Message)
    $PackageTarget = $LocalizedData.InstallModulewhatIfMessage
    switch ($i) {
        'ActionUninstallPackage' { return "Uninstall-Module" }
        'TargetPackageVersion' { return $PackageTarget }
        Default {
            return (PackageManagementMessageResolver -MsgId $i, -Message $Message)
        }
    }
}

$script:PackageManagementUpdateModuleMessageResolverScriptBlock = {
    param($i, $Message)
    $PackageTarget = ($LocalizedData.UpdateModulewhatIfMessage -replace "__OLDVERSION__", $($psgetItemInfo.Version))
    switch ($i) {
        'ActionInstallPackage' { return "Update-Module" }
        'TargetPackage' { return $PackageTarget }
        Default {
            return (PackageManagementMessageResolver -MsgId $i, -Message $Message)
        }
    }
}

# Modules allowed to install non-Microsoft signed modules over Microsoft signed modules
$script:WhitelistedModules = @{
    "Pester"     = $true
    "PSReadline" = $true
}

function PackageManagementMessageResolver($MsgID, $Message) {
    $NoMatchFound = $LocalizedData.NoMatchFound
    $SourceNotFound = $LocalizedData.SourceNotFound
    $ModuleIsNotTrusted = $LocalizedData.ModuleIsNotTrusted
    $RepositoryIsNotTrusted = $LocalizedData.RepositoryIsNotTrusted
    $QueryInstallUntrustedPackage = $LocalizedData.QueryInstallUntrustedPackage

    switch ($MsgID) {
        'NoMatchFound' { return $NoMatchFound }
        'SourceNotFound' { return $SourceNotFound }
        'CaptionPackageNotTrusted' { return $ModuleIsNotTrusted }
        'CaptionSourceNotTrusted' { return $RepositoryIsNotTrusted }
        'QueryInstallUntrustedPackage' { return $QueryInstallUntrustedPackage }
        Default {
            if ($Message) {
                $tempMessage = $Message -creplace "PackageSource", "PSRepository"
                $tempMessage = $tempMessage -creplace "packagesource", "psrepository"
                $tempMessage = $tempMessage -creplace "Package", "Module"
                $tempMessage = $tempMessage -creplace "package", "module"
                $tempMessage = $tempMessage -creplace "Sources", "Repositories"
                $tempMessage = $tempMessage -creplace "sources", "repositories"
                $tempMessage = $tempMessage -creplace "Source", "Repository"
                $tempMessage = $tempMessage -creplace "source", "repository"

                return $tempMessage
            }
        }
    }
}

#endregion Module message resolvers

#region Script message resolvers
$script:PackageManagementMessageResolverScriptBlockForScriptCmdlets = {
    param($i, $Message)
    return (PackageManagementMessageResolverForScripts -MsgId $i, -Message $Message)
}

$script:PackageManagementSaveScriptMessageResolverScriptBlock = {
    param($i, $Message)
    $PackageTarget = $LocalizedData.InstallScriptwhatIfMessage
    $QuerySaveUntrustedPackage = $LocalizedData.QuerySaveUntrustedScriptPackage

    switch ($i) {
        'ActionInstallPackage' { return "Save-Script" }
        'QueryInstallUntrustedPackage' { return $QuerySaveUntrustedPackage }
        'TargetPackage' { return $PackageTarget }
        Default {
            $Message = $Message -creplace "Install", "Download"
            $Message = $Message -creplace "install", "download"
            return (PackageManagementMessageResolverForScripts -MsgId $i, -Message $Message)
        }
    }
}

$script:PackageManagementInstallScriptMessageResolverScriptBlock = {
    param($i, $Message)
    $PackageTarget = $LocalizedData.InstallScriptwhatIfMessage

    switch ($i) {
        'ActionInstallPackage' { return "Install-Script" }
        'TargetPackage' { return $PackageTarget }
        Default {
            return (PackageManagementMessageResolverForScripts -MsgId $i, -Message $Message)
        }
    }
}

$script:PackageManagementUnInstallScriptMessageResolverScriptBlock = {
    param($i, $Message)
    $PackageTarget = $LocalizedData.InstallScriptwhatIfMessage
    switch ($i) {
        'ActionUninstallPackage' { return "Uninstall-Script" }
        'TargetPackageVersion' { return $PackageTarget }
        Default {
            return (PackageManagementMessageResolverForScripts -MsgId $i, -Message $Message)
        }
    }
}

$script:PackageManagementUpdateScriptMessageResolverScriptBlock = {
    param($i, $Message)
    $PackageTarget = ($LocalizedData.UpdateScriptwhatIfMessage -replace "__OLDVERSION__", $($psgetItemInfo.Version))
    switch ($i) {
        'ActionInstallPackage' { return "Update-Script" }
        'TargetPackage' { return $PackageTarget }
        Default {
            return (PackageManagementMessageResolverForScripts -MsgId $i, -Message $Message)
        }
    }
}

function PackageManagementMessageResolverForScripts($MsgID, $Message) {
    $NoMatchFound = $LocalizedData.NoMatchFoundForScriptName
    $SourceNotFound = $LocalizedData.SourceNotFound
    $ScriptIsNotTrusted = $LocalizedData.ScriptIsNotTrusted
    $RepositoryIsNotTrusted = $LocalizedData.RepositoryIsNotTrusted
    $QueryInstallUntrustedPackage = $LocalizedData.QueryInstallUntrustedScriptPackage

    switch ($MsgID) {
        'NoMatchFound' { return $NoMatchFound }
        'SourceNotFound' { return $SourceNotFound }
        'CaptionPackageNotTrusted' { return $ScriptIsNotTrusted }
        'CaptionSourceNotTrusted' { return $RepositoryIsNotTrusted }
        'QueryInstallUntrustedPackage' { return $QueryInstallUntrustedPackage }
        Default {
            if ($Message) {
                $tempMessage = $Message -creplace "PackageSource", "PSRepository"
                $tempMessage = $tempMessage -creplace "packagesource", "psrepository"
                $tempMessage = $tempMessage -creplace "Package", "Script"
                $tempMessage = $tempMessage -creplace "package", "script"
                $tempMessage = $tempMessage -creplace "Sources", "Repositories"
                $tempMessage = $tempMessage -creplace "sources", "repositories"
                $tempMessage = $tempMessage -creplace "Source", "Repository"
                $tempMessage = $tempMessage -creplace "source", "repository"

                return $tempMessage
            }
        }
    }
}

#endregion Script message resolvers

#region Add .Net type for Telemetry APIs and WebProxy

# Check and add InternalWebProxy type
if ( -not ('Microsoft.PowerShell.Commands.PowerShellGet.InternalWebProxy' -as [Type])) {
    $RequiredAssembliesForInternalWebProxy = @(
        [System.Net.IWebProxy].Assembly.FullName,
        [System.Uri].Assembly.FullName
    )

    $InternalWebProxySource = @'
using System;
using System.Net;

namespace Microsoft.PowerShell.Commands.PowerShellGet
{
    /// <summary>
    /// Used by Ping-Endpoint function to supply webproxy to HttpClient
    /// We cannot use System.Net.WebProxy because this is not available on CoreClr
    /// </summary>
    public class InternalWebProxy : IWebProxy
    {
        Uri _proxyUri;
        ICredentials _credentials;

        public InternalWebProxy(Uri uri, ICredentials credentials)
        {
            Credentials = credentials;
            _proxyUri = uri;
        }

        /// <summary>
        /// Credentials used by WebProxy
        /// </summary>
        public ICredentials Credentials
        {
            get
            {
                return _credentials;
            }
            set
            {
                _credentials = value;
            }
        }

        public Uri GetProxy(Uri destination)
        {
            return _proxyUri;
        }

        public bool IsBypassed(Uri host)
        {
            return false;
        }
    }
}
'@

    try {
        $AddType_prams = @{
            TypeDefinition = $InternalWebProxySource
            Language       = 'CSharp'
            ErrorAction    = 'SilentlyContinue'
        }
        if (-not $script:IsCoreCLR -or $script:IsNanoServer) {
            $AddType_prams['ReferencedAssemblies'] = $RequiredAssembliesForInternalWebProxy
        }
        Add-Type @AddType_prams
    }
    catch {
        Write-Warning -Message "InternalWebProxy: $_"
    }
}

# Check and add Telemetry type
if (('Microsoft.PowerShell.Telemetry.Internal.TelemetryAPI' -as [Type]) -and
    -not ('Microsoft.PowerShell.Commands.PowerShellGet.Telemetry' -as [Type])) {
    $RequiredAssembliesForTelemetry = @(
        [System.Management.Automation.PSCmdlet].Assembly.FullName
    )

    $TelemetrySource = @'
using System;
using System.Management.Automation;

namespace Microsoft.PowerShell.Commands.PowerShellGet
{
    public static class Telemetry
    {
        public static void TraceMessageArtifactsNotFound(string[] artifactsNotFound, string operationName)
        {
            Microsoft.PowerShell.Telemetry.Internal.TelemetryAPI.TraceMessage(operationName, new { ArtifactsNotFound = artifactsNotFound });
        }

        public static void TraceMessageNonPSGalleryRegistration(string sourceLocationType, string sourceLocationHash, string installationPolicy, string packageManagementProvider, string publishLocationHash, string scriptSourceLocationHash, string scriptPublishLocationHash, string operationName)
        {
            Microsoft.PowerShell.Telemetry.Internal.TelemetryAPI.TraceMessage(operationName, new { SourceLocationType = sourceLocationType, SourceLocationHash = sourceLocationHash, InstallationPolicy = installationPolicy, PackageManagementProvider = packageManagementProvider, PublishLocationHash = publishLocationHash, ScriptSourceLocationHash = scriptSourceLocationHash, ScriptPublishLocationHash = scriptPublishLocationHash });
        }
    }
}
'@

    try {
        $AddType_prams = @{
            TypeDefinition = $TelemetrySource
            Language       = 'CSharp'
            ErrorAction    = 'SilentlyContinue'
        }
        $AddType_prams['ReferencedAssemblies'] = $RequiredAssembliesForTelemetry
        Add-Type @AddType_prams
    }
    catch {
        Write-Warning -Message "Telemetry: $_"
    }
}
# Turn ON Telemetry if the infrastructure is present on the machine
$script:TelemetryEnabled = $false
if ('Microsoft.PowerShell.Commands.PowerShellGet.Telemetry' -as [Type]) {
    $telemetryMethods = ([Microsoft.PowerShell.Commands.PowerShellGet.Telemetry] | Get-Member -Static).Name
    if ($telemetryMethods.Contains("TraceMessageArtifactsNotFound") -and $telemetryMethods.Contains("TraceMessageNonPSGalleryRegistration")) {
        $script:TelemetryEnabled = $true
    }
}

# Check and add Win32Helpers type
$script:IsSafeX509ChainHandleAvailable = ($null -ne ('Microsoft.Win32.SafeHandles.SafeX509ChainHandle' -as [Type]))
if ($script:IsWindows -and -not ('Microsoft.PowerShell.Commands.PowerShellGet.Win32Helpers' -as [Type])) {
    $RequiredAssembliesForWin32Helpers = @()
    if ($script:IsSafeX509ChainHandleAvailable) {
        # It is not possible to define a single internal SafeHandle class in PowerShellGet namespace for all the supported versions of .Net Framework including .Net Core.
        # SafeHandleZeroOrMinusOneIsInvalid is not a public class on .Net Core,
        # therefore SafeX509ChainHandle will be used if it is available otherwise InternalSafeX509ChainHandle is defined below.
        #
        # ChainContext is not available on .Net Core, we must have to use SafeX509ChainHandle on .Net Core.
        #
        $SafeX509ChainHandleClassName = 'SafeX509ChainHandle'
        $RequiredAssembliesForWin32Helpers += [Microsoft.Win32.SafeHandles.SafeX509ChainHandle].Assembly.FullName
    }
    else {
        # SafeX509ChainHandle is not available on .Net Framework 4.5 or older versions,
        # therefore InternalSafeX509ChainHandle is defined below.
        #
        $SafeX509ChainHandleClassName = 'InternalSafeX509ChainHandle'
    }

    $Win32HelpersSource = @"
using System;
using System.Net;
using Microsoft.Win32.SafeHandles;
using System.Security.Cryptography;
using System.Runtime.InteropServices;
using System.Runtime.ConstrainedExecution;
using System.Runtime.Versioning;
using System.Security;

namespace Microsoft.PowerShell.Commands.PowerShellGet
{
    [StructLayout(LayoutKind.Sequential, CharSet=CharSet.Unicode)]
    public struct CERT_CHAIN_POLICY_PARA {
        public CERT_CHAIN_POLICY_PARA(int size) {
            cbSize = (uint) size;
            dwFlags = 0;
            pvExtraPolicyPara = IntPtr.Zero;
        }
        public uint   cbSize;
        public uint   dwFlags;
        public IntPtr pvExtraPolicyPara;
    }

    [StructLayout(LayoutKind.Sequential, CharSet=CharSet.Unicode)]
    public struct CERT_CHAIN_POLICY_STATUS {
        public CERT_CHAIN_POLICY_STATUS(int size) {
            cbSize = (uint) size;
            dwError = 0;
            lChainIndex = IntPtr.Zero;
            lElementIndex = IntPtr.Zero;
            pvExtraPolicyStatus = IntPtr.Zero;
        }
        public uint   cbSize;
        public uint   dwError;
        public IntPtr lChainIndex;
        public IntPtr lElementIndex;
        public IntPtr pvExtraPolicyStatus;
    }

    // Internal SafeHandleZeroOrMinusOneIsInvalid class to remove the dependency on .Net Framework 4.6.
    public abstract class InternalSafeHandleZeroOrMinusOneIsInvalid : SafeHandle
    {
        protected InternalSafeHandleZeroOrMinusOneIsInvalid(bool ownsHandle)
            : base(IntPtr.Zero, ownsHandle)
        {
        }

        public override bool IsInvalid
        {
            get
            {
                return handle == IntPtr.Zero || handle == new IntPtr(-1);
            }
        }
    }

    // Internal SafeX509ChainHandle class to remove the dependency on .Net Framework 4.6.
    [SecurityCritical]
    public sealed class InternalSafeX509ChainHandle : InternalSafeHandleZeroOrMinusOneIsInvalid {
        private InternalSafeX509ChainHandle () : base(true) {}

        internal InternalSafeX509ChainHandle (IntPtr handle) : base (true) {
            SetHandle(handle);
        }

        internal static InternalSafeX509ChainHandle InvalidHandle {
            get { return new InternalSafeX509ChainHandle(IntPtr.Zero); }
        }

        [SecurityCritical]
        override protected bool ReleaseHandle()
        {
            CertFreeCertificateChain(handle);
            return true;
        }

        [DllImport("Crypt32.dll", SetLastError=true)]
$(if(-not $script:IsCoreCLR)
{
        '
        [SuppressUnmanagedCodeSecurity,
         ResourceExposure(ResourceScope.None),
         ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
        '
})
        private static extern void CertFreeCertificateChain(IntPtr handle);
    }

    public class Win32Helpers
    {
        [DllImport("Crypt32.dll", CharSet=CharSet.Auto, SetLastError=true)]
        public extern static
        bool CertVerifyCertificateChainPolicy(
            [In]     IntPtr                       pszPolicyOID,
            [In]     $SafeX509ChainHandleClassName  pChainContext,
            [In]     ref CERT_CHAIN_POLICY_PARA   pPolicyPara,
            [In,Out] ref CERT_CHAIN_POLICY_STATUS pPolicyStatus);

        [DllImport("Crypt32.dll", CharSet=CharSet.Auto, SetLastError=true)]
        public static extern
        $SafeX509ChainHandleClassName CertDuplicateCertificateChain(
            [In]     IntPtr pChainContext);

$(if($script:IsSafeX509ChainHandleAvailable)
{
@"
        [DllImport("Crypt32.dll", CharSet=CharSet.Auto, SetLastError=true)]
    $(if(-not $script:IsCoreCLR)
    {
    '
        [ResourceExposure(ResourceScope.None)]
    '
    })
        public static extern
        SafeX509ChainHandle CertDuplicateCertificateChain(
            [In]     SafeX509ChainHandle pChainContext);
"@
})

        public static bool IsMicrosoftCertificate([In] $SafeX509ChainHandleClassName pChainContext)
        {
            //-------------------------------------------------------------------------
            //  CERT_CHAIN_POLICY_MICROSOFT_ROOT
            //
            //  Checks if the last element of the first simple chain contains a
            //  Microsoft root public key. If it doesn't contain a Microsoft root
            //  public key, dwError is set to CERT_E_UNTRUSTEDROOT.
            //
            //  pPolicyPara is optional. However,
            //  MICROSOFT_ROOT_CERT_CHAIN_POLICY_ENABLE_TEST_ROOT_FLAG can be set in
            //  the dwFlags in pPolicyPara to also check for the Microsoft Test Roots.
            //
            //  MICROSOFT_ROOT_CERT_CHAIN_POLICY_CHECK_APPLICATION_ROOT_FLAG can be set
            //  in the dwFlags in pPolicyPara to check for the Microsoft root for
            //  application signing instead of the Microsoft product root. This flag
            //  explicitly checks for the application root only and cannot be combined
            //  with the test root flag.
            //
            //  MICROSOFT_ROOT_CERT_CHAIN_POLICY_DISABLE_FLIGHT_ROOT_FLAG can be set
            //  in the dwFlags in pPolicyPara to always disable the Flight root.
            //
            //  pvExtraPolicyPara and pvExtraPolicyStatus aren't used and must be set
            //  to NULL.
            //--------------------------------------------------------------------------
            const uint MICROSOFT_ROOT_CERT_CHAIN_POLICY_ENABLE_TEST_ROOT_FLAG       = 0x00010000;
            const uint MICROSOFT_ROOT_CERT_CHAIN_POLICY_CHECK_APPLICATION_ROOT_FLAG = 0x00020000;
            //const uint MICROSOFT_ROOT_CERT_CHAIN_POLICY_DISABLE_FLIGHT_ROOT_FLAG    = 0x00040000;

            CERT_CHAIN_POLICY_PARA PolicyPara = new CERT_CHAIN_POLICY_PARA(Marshal.SizeOf(typeof(CERT_CHAIN_POLICY_PARA)));
            CERT_CHAIN_POLICY_STATUS PolicyStatus = new CERT_CHAIN_POLICY_STATUS(Marshal.SizeOf(typeof(CERT_CHAIN_POLICY_STATUS)));
            int CERT_CHAIN_POLICY_MICROSOFT_ROOT = 7;

            PolicyPara.dwFlags = (uint) MICROSOFT_ROOT_CERT_CHAIN_POLICY_ENABLE_TEST_ROOT_FLAG;
            bool isMicrosoftRoot = false;

            if(CertVerifyCertificateChainPolicy(new IntPtr(CERT_CHAIN_POLICY_MICROSOFT_ROOT),
                                                pChainContext,
                                                ref PolicyPara,
                                                ref PolicyStatus))
            {
                isMicrosoftRoot = (PolicyStatus.dwError == 0);
            }

            // Also check for the Microsoft root for application signing if the Microsoft product root verification is unsuccessful.
            if(!isMicrosoftRoot)
            {
                // Some Microsoft modules can be signed with Microsoft Application Root instead of Microsoft Product Root,
                // So we need to use the MICROSOFT_ROOT_CERT_CHAIN_POLICY_CHECK_APPLICATION_ROOT_FLAG for the certificate verification.
                // MICROSOFT_ROOT_CERT_CHAIN_POLICY_CHECK_APPLICATION_ROOT_FLAG can not be used
                // with MICROSOFT_ROOT_CERT_CHAIN_POLICY_ENABLE_TEST_ROOT_FLAG,
                // so additional CertVerifyCertificateChainPolicy call is required to verify the given certificate is in Microsoft Application Root.
                //
                CERT_CHAIN_POLICY_PARA PolicyPara2 = new CERT_CHAIN_POLICY_PARA(Marshal.SizeOf(typeof(CERT_CHAIN_POLICY_PARA)));
                CERT_CHAIN_POLICY_STATUS PolicyStatus2 = new CERT_CHAIN_POLICY_STATUS(Marshal.SizeOf(typeof(CERT_CHAIN_POLICY_STATUS)));
                PolicyPara2.dwFlags = (uint) MICROSOFT_ROOT_CERT_CHAIN_POLICY_CHECK_APPLICATION_ROOT_FLAG;

                if(CertVerifyCertificateChainPolicy(new IntPtr(CERT_CHAIN_POLICY_MICROSOFT_ROOT),
                                                    pChainContext,
                                                    ref PolicyPara2,
                                                    ref PolicyStatus2))
                {
                    isMicrosoftRoot = (PolicyStatus2.dwError == 0);
                }
            }

            return isMicrosoftRoot;
        }
    }
}
"@

    try {
        $AddType_prams = @{
            TypeDefinition = $Win32HelpersSource
            Language       = 'CSharp'
            ErrorAction    = 'SilentlyContinue'
        }
        if ((-not $script:IsCoreCLR -or $script:IsNanoServer) -and $RequiredAssembliesForWin32Helpers) {
            $AddType_prams['ReferencedAssemblies'] = $RequiredAssembliesForWin32Helpers
        }
        Add-Type @AddType_prams
    }
    catch {
        Write-Warning -Message "Win32Helpers: $_"
    }
}

#endregion

#region Private Functions
function Add-ArgumentCompleter()
{
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$true)]
        [string[]]$cmdlets,
        
        [Parameter(Mandatory=$true)]
        [string]$parameterName
    )

    try
    {
        if(Get-Command -Name Register-ArgumentCompleter -ErrorAction SilentlyContinue)
        {
            Register-ArgumentCompleter -CommandName $cmdlets -ParameterName $parameterName -ScriptBlock {
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter) 
                
                Get-PSRepository -Name "$wordTocomplete*"-ErrorAction SilentlyContinue -WarningAction SilentlyContinue | Foreach-Object { 
                    [System.Management.Automation.CompletionResult]::new($_.Name, $_.Name, 'ParameterValue', $_.Name) 
                } 
           }
        }
    }
    catch 
    {
        # All this functionality is optional, so suppress errors 
        Write-Debug -Message "Error registering argument completer: $_"      
    }
}
function Compare-PrereleaseVersions
{
    [CmdletBinding()]
    param(
        [ValidateNotNullOrEmpty()]
        [string]
        $FirstItemVersion,

        [string]
        $FirstItemPrerelease,

        [ValidateNotNullOrEmpty()]
        [string]
        $SecondItemVersion,

        [string]
        $SecondItemPrerelease
    )

    <#
        This function compares one item to another to determine if it has a greater version (and/or prerelease).
        It returns true if item TWO is GREATER/newer than item ONE, it returns false otherwise.


        First Order:  Compare Versions
        ===========
        *** Version is never NULL.

        Item #1         Comparison      Item #2
        Version         of Values       Version         Notes about item #2
        -------         ----------      -------         -------------------
        Value           >               Value           An older release version
        Value           <               Value         * A newer release version
        Value           ==              Value           Inconclusive, must compare prerelease strings now



        Second Order:  Compare Prereleases
        =============
        *** Prerelease may be NULL, indicates a release version.

        Item #1         Comparison      Item #2
        Prerelease      of Values       Prerelease      Notes about item #2
        ----------      -----------     ----------      -------------------
        NULL                ==          NULL            Exact same release version
        NULL                >           Value           Older (prerelease) version
        Value               <           NULL          * A newer, release version
        Value               ==          Value           Exact same prerelease (and same version)
        Value               >           Value           An older prerelease
        Value               <           Value         * A newer prerelease


        Item #2 is newer/greater than item #1 in the starred (*) combinations.
        Those are the conditions tested for below.
    #>

    [version]$itemOneVersion = $null
    # try parsing version string
    if (-not ( [System.Version]::TryParse($FirstItemVersion.Trim(), [ref]$itemOneVersion) ))
    {
        $message = $LocalizedData.InvalidVersion -f ($FirstItemVersion)
        Write-Error -Message $message -ErrorId "InvalidVersion" -Category InvalidArgument
        return
    }

    [Version]$itemTwoVersion = $null
    # try parsing version string
    if (-not ( [System.Version]::TryParse($SecondItemVersion.Trim(), [ref]$itemTwoVersion) ))
    {
        $message = $LocalizedData.InvalidVersion -f ($SecondItemVersion)
        Write-Error -Message $message -ErrorId "InvalidVersion" -Category InvalidArgument
        return
    }

    return (($itemOneVersion -lt $itemTwoVersion) -or `
            (($itemOneVersion -eq $itemTwoVersion) -and `
             (($FirstItemPrerelease -and -not $SecondItemPrerelease) -or `
              ($FirstItemPrerelease -lt $SecondItemPrerelease))))
}
function Copy-Module
{
    [CmdletBinding(PositionalBinding=$false)]
    Param
    (
        [Parameter(Mandatory=$true)]
        [ValidateNotNullOrEmpty()]
        [string]
        $SourcePath,

        [Parameter(Mandatory=$true)]
        [ValidateNotNullOrEmpty()]
        [string]
        $DestinationPath,

        [Parameter(Mandatory=$true)]
        [ValidateNotNull()]
        [PSCustomObject]
        $PSGetItemInfo,

        [Parameter(Mandatory=$false)]        
        [Switch]
        $IsSavePackage
    )

    $ev = $null
    if(-not $IsSavePackage)
    {
        $message = $LocalizedData.AdministratorRightsNeededOrSpecifyCurrentUserScope
        $errorId = 'AdministratorRightsNeededOrSpecifyCurrentUserScope'
    }
    else
    {
        $message = $LocalizedData.UnauthorizedAccessError -f $DestinationPath
        $errorId = 'UnauthorizedAccessError'
    }

    if(Microsoft.PowerShell.Management\Test-Path $DestinationPath)
    {
        Microsoft.PowerShell.Management\Remove-Item -Path $DestinationPath `
                                                    -Recurse `
                                                    -Force `
                                                    -ErrorVariable ev `
                                                    -ErrorAction SilentlyContinue `
                                                    -WarningAction SilentlyContinue `
                                                    -Confirm:$false `
                                                    -WhatIf:$false

        if($ev)
        {
            $script:IsRunningAsElevated = $false
            ThrowError -ExceptionName "System.ArgumentException" `
                       -ExceptionMessage $message `
                       -ErrorId $errorId `
                       -CallerPSCmdlet $PSCmdlet `
                       -ErrorCategory InvalidArgument `
                       -ExceptionObject $ev
        }
    }


    # Copy the module to destination
    $null = Microsoft.PowerShell.Management\New-Item -Path $DestinationPath `
                                                     -ItemType Directory `
                                                     -Force `
                                                     -ErrorVariable ev `
                                                     -ErrorAction SilentlyContinue `
                                                     -WarningAction SilentlyContinue `
                                                     -Confirm:$false `
                                                     -WhatIf:$false

    if($ev)
    {
        $script:IsRunningAsElevated = $false
        ThrowError -ExceptionName "System.ArgumentException" `
                   -ExceptionMessage $message `
                   -ErrorId $errorId `
                   -CallerPSCmdlet $PSCmdlet `
                   -ErrorCategory InvalidArgument `
                   -ExceptionObject $ev
    }

    Microsoft.PowerShell.Management\Copy-Item -Path (Microsoft.PowerShell.Management\Join-Path -Path $SourcePath -ChildPath '*') `
                                              -Destination $DestinationPath `
                                              -Force `
                                              -Recurse `
                                              -ErrorVariable ev `
                                              -ErrorAction SilentlyContinue `
                                              -Confirm:$false `
                                              -WhatIf:$false

    if($ev)
    {
        $script:IsRunningAsElevated = $false
        ThrowError -ExceptionName "System.ArgumentException" `
                   -ExceptionMessage $message `
                   -ErrorId $errorId `
                   -CallerPSCmdlet $PSCmdlet `
                   -ErrorCategory InvalidArgument `
                   -ExceptionObject $ev
    }

    # Remove the *.nupkg file
    $NupkgFilePath = Join-PathUtility -Path $DestinationPath -ChildPath "$($PSGetItemInfo.Name).nupkg" -PathType File
    if(Microsoft.PowerShell.Management\Test-Path -Path $NupkgFilePath -PathType Leaf)
    {
        Microsoft.PowerShell.Management\Remove-Item -Path $NupkgFilePath -Force -ErrorAction SilentlyContinue -WarningAction SilentlyContinue -Confirm:$false -WhatIf:$false
    }

    # Create PSGetModuleInfo.xml
    $psgetItemInfopath = Microsoft.PowerShell.Management\Join-Path $DestinationPath $script:PSGetItemInfoFileName

    Microsoft.PowerShell.Utility\Out-File -FilePath $psgetItemInfopath -Force -InputObject ([System.Management.Automation.PSSerializer]::Serialize($PSGetItemInfo))

    [System.IO.File]::SetAttributes($psgetItemInfopath, [System.IO.FileAttributes]::Hidden)
}
function Copy-ScriptFile
{
    [CmdletBinding(PositionalBinding=$false)]
    Param
    (
        [Parameter(Mandatory=$true)]
        [ValidateNotNullOrEmpty()]
        [string]
        $SourcePath,

        [Parameter(Mandatory=$true)]
        [ValidateNotNullOrEmpty()]
        [string]
        $DestinationPath,

        [Parameter(Mandatory=$true)]
        [ValidateNotNull()]
        [PSCustomObject]
        $PSGetItemInfo,

        [Parameter()]
        [string]
        $Scope
    )

    $ev = $null
    $message = $LocalizedData.AdministratorRightsNeededOrSpecifyCurrentUserScope

    # Copy the script file to destination
    if(-not (Microsoft.PowerShell.Management\Test-Path -Path $DestinationPath))
    {
        $null = Microsoft.PowerShell.Management\New-Item -Path $DestinationPath `
                                                         -ItemType Directory `
                                                         -Force `
                                                         -ErrorVariable ev `
                                                         -ErrorAction SilentlyContinue `
                                                         -WarningAction SilentlyContinue `
                                                         -Confirm:$false `
                                                         -WhatIf:$false

        if($ev)
        {
            $script:IsRunningAsElevated = $false
            ThrowError -ExceptionName "System.ArgumentException" `
                       -ExceptionMessage $message `
                       -ErrorId "AdministratorRightsNeededOrSpecifyCurrentUserScope" `
                       -CallerPSCmdlet $PSCmdlet `
                       -ErrorCategory InvalidArgument `
                       -ExceptionObject $ev
        }
    }

    Microsoft.PowerShell.Management\Copy-Item -Path $SourcePath `
                                              -Destination $DestinationPath `
                                              -Force `
                                              -Confirm:$false `
                                              -WhatIf:$false `
                                              -ErrorVariable ev `
                                              -ErrorAction SilentlyContinue

    if($ev)
    {
        $script:IsRunningAsElevated = $false
        ThrowError -ExceptionName "System.ArgumentException" `
                   -ExceptionMessage $message `
                   -ErrorId "AdministratorRightsNeededOrSpecifyCurrentUserScope" `
                   -CallerPSCmdlet $PSCmdlet `
                   -ErrorCategory InvalidArgument `
                   -ExceptionObject $ev
    }

    if($Scope)
    {
        # Create <Name>_InstalledScriptInfo.xml
        $InstalledScriptInfoFileName = "$($PSGetItemInfo.Name)_$script:InstalledScriptInfoFileName"

        if($scope -eq 'AllUsers')
        {
            $scriptInfopath = Microsoft.PowerShell.Management\Join-Path -Path $script:ProgramFilesInstalledScriptInfosPath `
                                                                        -ChildPath $InstalledScriptInfoFileName
        }
        else
        {
            $scriptInfopath = Microsoft.PowerShell.Management\Join-Path -Path $script:MyDocumentsInstalledScriptInfosPath `
                                                                        -ChildPath $InstalledScriptInfoFileName
        }

        Microsoft.PowerShell.Utility\Out-File -FilePath $scriptInfopath `
                                              -Force `
                                              -InputObject ([System.Management.Automation.PSSerializer]::Serialize($PSGetItemInfo))
    }
}
function DeSerialize-PSObject
{
    [CmdletBinding(PositionalBinding=$false)]
    Param
    (
        [Parameter(Mandatory=$true)]
        $Path
    )
    $filecontent = Microsoft.PowerShell.Management\Get-Content -Path $Path
    [System.Management.Automation.PSSerializer]::Deserialize($filecontent)
}
function Get-AuthenticodePublisher
{
    [CmdletBinding()]
    Param
    (
        [Parameter(Mandatory=$true)]
        [System.Management.Automation.Signature]
        $AuthenticodeSignature
    )

    if($AuthenticodeSignature.SignerCertificate)
    {
        $chain = New-Object System.Security.Cryptography.X509Certificates.X509Chain
        $null = $chain.Build($AuthenticodeSignature.SignerCertificate)

        $certStoreLocations = @('cert:\LocalMachine\Root',
                                'cert:\LocalMachine\AuthRoot',
                                'cert:\CurrentUser\Root',
                                'cert:\CurrentUser\AuthRoot')

        foreach($element in $chain.ChainElements.Certificate)
        {
            foreach($certStoreLocation in $certStoreLocations)
            {
                $rootCertificateAuthority = Microsoft.PowerShell.Management\Get-ChildItem -Path $certStoreLocation |
                                                Microsoft.PowerShell.Core\Where-Object { ($_.Subject -eq $element.Subject) -and ($_.thumbprint -eq $element.thumbprint) }
                if($rootCertificateAuthority)
                {
                    # Select-Object writes an error 'System Error' into the error stream.
                    # Using below workaround for getting the first element when there are multiple certificates with the same subject name.
                    if($rootCertificateAuthority.PSTypeNames -contains 'System.Array') {
                        $rootCertificateAuthority = $rootCertificateAuthority[0]
                    }
                    
                    $publisherInfo = @{
                        publisher = $AuthenticodeSignature.SignerCertificate.Subject
                        publisherRootCA = $rootCertificateAuthority.Subject
                    } 

                    Write-Output -InputObject $publisherInfo
                    return
                }
            }
        }
    }
}
function Get-AvailableRoleCapabilityName
{
    [CmdletBinding(PositionalBinding=$false)]
    Param
    (
        [Parameter(Mandatory=$true)]
        [ValidateNotNullOrEmpty()]
        [PSModuleInfo]
        $PSModuleInfo
    )

    $RoleCapabilityNames = @()

    $RoleCapabilitiesDir = Join-PathUtility -Path $PSModuleInfo.ModuleBase -ChildPath 'RoleCapabilities' -PathType Directory
    if(Microsoft.PowerShell.Management\Test-Path -Path $RoleCapabilitiesDir -PathType Container)
    {
        $RoleCapabilityNames = Microsoft.PowerShell.Management\Get-ChildItem -Path $RoleCapabilitiesDir `
                                  -Name -Filter *.psrc |
                                      ForEach-Object {[System.IO.Path]::GetFileNameWithoutExtension($_)}
    }

    return $RoleCapabilityNames
}
function Get-AvailableScriptFilePath
{
    [CmdletBinding(PositionalBinding=$false)]
    Param
    (
        [Parameter()]
        [string]
        $Name
    )

    $scriptInfo = $null
    $scriptFileName = '*.ps1'
    $scriptBasePaths = @($script:ProgramFilesScriptsPath, $script:MyDocumentsScriptsPath)
    $scriptFilePaths = @()
    $wildcardPattern = $null

    if($Name)
    {
        if(Test-WildcardPattern -Name $Name)
        {
            $wildcardPattern = New-Object System.Management.Automation.WildcardPattern $Name,$script:wildcardOptions
        }
        else
        {
            $scriptFileName = "$Name.ps1"
        }

    }

    foreach ($location in $scriptBasePaths)
    {
        $scriptFiles = Get-ChildItem -Path $location `
                                     -Filter $scriptFileName `
                                     -ErrorAction SilentlyContinue `
                                     -WarningAction SilentlyContinue

        if($wildcardPattern)
        {
            $scriptFiles | Microsoft.PowerShell.Core\ForEach-Object {
                                if($wildcardPattern.IsMatch($_.BaseName))
                                {
                                    $scriptFilePaths += $_.FullName
                                }
                           }
        }
        else
        {
            $scriptFiles | Microsoft.PowerShell.Core\ForEach-Object { $scriptFilePaths += $_.FullName }
        }
    }

    return $scriptFilePaths
}
function Get-DynamicParameters
{
    [CmdletBinding()]
    Param
    (
        [Parameter(Mandatory=$true)]
        [ValidateNotNullOrEmpty()]
        [Uri]
        $Location,

        [Parameter(Mandatory=$true)]
        [REF]
        $PackageManagementProvider
    )

    $paramDictionary = New-Object System.Management.Automation.RuntimeDefinedParameterDictionary
    $dynamicOptions = $null

    $loc = Get-LocationString -LocationUri $Location

    if(-not $loc)
    {
        return $paramDictionary
    }

    # Ping and resolve the specified location
    $loc = Resolve-Location -Location $loc `
                            -LocationParameterName 'Location' `
                            -ErrorAction SilentlyContinue `
                            -WarningAction SilentlyContinue
    if(-not $loc)
    {
        return $paramDictionary
    }

    $providers = PackageManagement\Get-PackageProvider | Where-Object { $_.Features.ContainsKey($script:SupportsPSModulesFeatureName) }

    if ($PackageManagementProvider.Value)
    {
        # Skip the PowerShellGet provider
        if($PackageManagementProvider.Value -ne $script:PSModuleProviderName)
        {
            $SelectedProvider = $providers | Where-Object {$_.ProviderName -eq $PackageManagementProvider.Value}

            if($SelectedProvider)
            {
                $res = Get-PackageSource -Location $loc -Provider $PackageManagementProvider.Value -ErrorAction SilentlyContinue

                if($res)
                {
                    $dynamicOptions = $SelectedProvider.DynamicOptions
                }
            }
        }
    }
    else
    {
        $PackageManagementProvider.Value = Get-PackageManagementProviderName -Location $Location
        if($PackageManagementProvider.Value)
        {
            $provider = $providers | Where-Object {$_.ProviderName -eq $PackageManagementProvider.Value}
            $dynamicOptions = $provider.DynamicOptions
        }
    }

    foreach ($option in $dynamicOptions)
    {
        # Skip the Destination parameter
        if( $option.IsRequired -and
            ($option.Name -eq "Destination") )
        {
            continue
        }

        $paramAttribute = New-Object System.Management.Automation.ParameterAttribute
        $paramAttribute.Mandatory = $option.IsRequired

        $message = $LocalizedData.DynamicParameterHelpMessage -f ($option.Name, $PackageManagementProvider.Value, $loc, $option.Name)
        $paramAttribute.HelpMessage = $message

        $attributeCollection = new-object System.Collections.ObjectModel.Collection[System.Attribute]
        $attributeCollection.Add($paramAttribute)

        $ageParam = New-Object System.Management.Automation.RuntimeDefinedParameter($option.Name,
                                                                                    $script:DynamicOptionTypeMap[$option.Type.value__],
                                                                                    $attributeCollection)
        $paramDictionary.Add($option.Name, $ageParam)
    }

    return $paramDictionary
}
function Get-EntityName
{
    param
    (
        [Parameter(Mandatory=$true)]
        $SoftwareIdentity,

        [Parameter(Mandatory=$true)]
        $Role
    )

    foreach( $entity in $SoftwareIdentity.Entities )
    {
        if( $entity.Role -eq $Role)
        {
            $entity.Name
        }
    }
}
function Get-EnvironmentVariable
{
    param
    (
        [parameter(Mandatory = $true)]
        [ValidateNotNullOrEmpty()]
        [String]
        $Name,

        [parameter(Mandatory = $true)]
        [int]
        $Target
    )

    if ($Target -eq $script:EnvironmentVariableTarget.Process)
    {
        return [System.Environment]::GetEnvironmentVariable($Name)
    }
    elseif ($Target -eq $script:EnvironmentVariableTarget.Machine)
    {
        if ($Name -eq "path")
        {
            # if we need the path environment variable, we need it un-expanded, otherwise
            # when writing it back, we would loose all the variables like %systemroot% in it.
            # We use the Win32 API directly using DoNotExpandEnvironmentNames
            # It is unclear whether any code calling this function for %path% needs the expanded version of %path%
            # There are currently no tests for this code
            # Microsoft.PowerShell.Management\Get-ItemProperty is passed through to the PowerShell Registry provider
            # which currently doesn't seem to support anything like: DoNotExpandEnvironmentNames
            $hklmHive = [Microsoft.Win32.Registry]::LocalMachine
            $EnvRegKey = $hklmHive.OpenSubKey("SYSTEM\CurrentControlSet\Control\Session Manager\Environment", $FALSE)
            $itemPropertyValue = $EnvRegKey.GetValue($Name, "", [Microsoft.Win32.RegistryValueOptions]::DoNotExpandEnvironmentNames)
            return $itemPropertyValue
        }
        else
        {
            $itemPropertyValue = Microsoft.PowerShell.Management\Get-ItemProperty -Path $script:SystemEnvironmentKey -Name $Name -ErrorAction SilentlyContinue

            if($itemPropertyValue)
            {
                return $itemPropertyValue.$Name
            }
        }
    }
    elseif ($Target -eq $script:EnvironmentVariableTarget.User)
    {
        $itemPropertyValue = Microsoft.PowerShell.Management\Get-ItemProperty -Path $script:UserEnvironmentKey -Name $Name -ErrorAction SilentlyContinue

        if($itemPropertyValue)
        {
            return $itemPropertyValue.$Name
        }
    }
}
function Get-EscapedString
{
    [CmdletBinding()]
    [OutputType([String])]
    Param
    (
        [Parameter()]
        [string]
        $ElementValue
    )

    return [System.Security.SecurityElement]::Escape($ElementValue)
}
function Get-ExportedDscResources
{
    [CmdletBinding(PositionalBinding=$false)]
    Param
    (
        [Parameter(Mandatory=$true)]
        [ValidateNotNullOrEmpty()]
        [PSModuleInfo]
        $PSModuleInfo
    )

    $dscResources = @()

    if(-not $script:IsCoreCLR -and (Get-Command -Name Get-DscResource -Module PSDesiredStateConfiguration -ErrorAction Ignore))
    {
        $OldPSModulePath = $env:PSModulePath

        try
        {
            $env:PSModulePath = Join-Path -Path $PSHOME -ChildPath "Modules"
            $env:PSModulePath = "$env:PSModulePath;$(Split-Path -Path $PSModuleInfo.ModuleBase -Parent)"

            $dscResources = PSDesiredStateConfiguration\Get-DscResource -ErrorAction SilentlyContinue -WarningAction SilentlyContinue |
                                Microsoft.PowerShell.Core\ForEach-Object {
                                    if($_.Module -and ($_.Module.Name -eq $PSModuleInfo.Name))
                                    {
                                        $_.Name
                                    }
                                }
        }
        finally
        {
            $env:PSModulePath = $OldPSModulePath
        }
    }
    else
    {
        $dscResourcesDir = Join-PathUtility -Path $PSModuleInfo.ModuleBase -ChildPath "DscResources" -PathType Directory
        if(Microsoft.PowerShell.Management\Test-Path $dscResourcesDir)
        {
            $dscResources = Microsoft.PowerShell.Management\Get-ChildItem -Path $dscResourcesDir -Directory -Name
        }
    }

    return $dscResources
}
function Get-ExternalModuleDependencies
{
    Param (
        [Parameter(Mandatory=$true)]
        [PSModuleInfo]
        $PSModuleInfo
    )

    if($PSModuleInfo.PrivateData -and
       ($PSModuleInfo.PrivateData.GetType().ToString() -eq "System.Collections.Hashtable") -and
       $PSModuleInfo.PrivateData["PSData"] -and
       ($PSModuleInfo.PrivateData["PSData"].GetType().ToString() -eq "System.Collections.Hashtable") -and
       $PSModuleInfo.PrivateData.PSData['ExternalModuleDependencies'] -and
       ($PSModuleInfo.PrivateData.PSData['ExternalModuleDependencies'].GetType().ToString() -eq "System.Object[]")
    )
    {
        return $PSModuleInfo.PrivateData.PSData.ExternalModuleDependencies
    }
}
function Get-First
{
    param
    (
        [Parameter(Mandatory=$true)]
        $IEnumerator
    )

    foreach($item in $IEnumerator)
    {
        return $item
    }

    return $null
}
function Get-Hash
# Returns a SHA1 hash of the specified string
{
    [CmdletBinding()]
    Param
    (
        [string]
        $locationString
    )

    if(-not $locationString)
    {
        return ""
    }

    $sha1Object = New-Object System.Security.Cryptography.SHA1Managed
    $stringHash = $sha1Object.ComputeHash([System.Text.Encoding]::UTF8.GetBytes($locationString));
    $stringHashInHex = [System.BitConverter]::ToString($stringHash)

    if ($stringHashInHex)
    {
        # Remove all dashes in the hex string
        return $stringHashInHex.Replace('-', '')
    }

    return ""
}

# Determine scope. We prefer CurrentUser scope even if the older module is installed for AllUsers, unless:
# old module is installed for all users, we are elevated, AND using Windows PowerShell
# This is to mirror newer behavior of Install-Module.
function Get-InstallationScope()
{
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$true)]
        [string]$PreviousInstallLocation,

        [Parameter(Mandatory=$true)]
        [string]$CurrentUserPath
    )

    if ( -not $PreviousInstallLocation.ToString().StartsWith($currentUserPath, [System.StringComparison]::OrdinalIgnoreCase) -and
         -not $script:IsCoreCLR -and
         (Test-RunningAsElevated)) {
        $Scope = "AllUsers"
    }
    else {
        $Scope = "CurrentUser"
    }

    Write-Debug "Get-InstallationScope: $PreviousInstallLocation $($script:IsCoreCLR) $(Test-RunningAsElevated) : $Scope"
    return $Scope
}
function Get-InstalledModuleAuthenticodeSignature
{
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$true)]
        [PSModuleInfo]
        $InstalledModuleInfo,

        [Parameter(Mandatory=$true)]
        [string]
        $InstallLocation
    )

    $ModuleName = $InstalledModuleInfo.Name

    # Priority order for getting the published details of the installed module:
    # 1. Latest version under the $InstallLocation
    # 2. Latest available version in $PSModulePath
    # 3. $InstalledModuleInfo
    $AvailableModules = Microsoft.PowerShell.Core\Get-Module -ListAvailable `
                                                             -Name $ModuleName `
                                                             -ErrorAction SilentlyContinue `
                                                             -WarningAction SilentlyContinue `
                                                             -Verbose:$false |
                            Microsoft.PowerShell.Utility\Sort-Object -Property Version -Descending

    # Remove the version folder on 5.0 to get the actual module base folder without version
    if(Test-ModuleSxSVersionSupport)
    {
        $InstallLocation = Microsoft.PowerShell.Management\Split-Path -Path $InstallLocation
    }

    $SourceModule = $AvailableModules | Microsoft.PowerShell.Core\Where-Object {
                                            $_.ModuleBase.StartsWith($InstallLocation, [System.StringComparison]::OrdinalIgnoreCase)
                                        } | Microsoft.PowerShell.Utility\Select-Object -First 1 -ErrorAction Ignore

    if(-not $SourceModule)
    {
        $SourceModule = $AvailableModules | Microsoft.PowerShell.Utility\Select-Object -First 1 -ErrorAction Ignore
    }
    else
    {
        $SourceModule = $InstalledModuleInfo
    }

    $SignedFilePath = $SourceModule.Path

    $CatalogFileName = "$ModuleName.cat"
    $CatalogFilePath = Microsoft.PowerShell.Management\Join-Path -Path $SourceModule.ModuleBase -ChildPath $CatalogFileName

    if(Microsoft.PowerShell.Management\Test-Path -Path $CatalogFilePath -PathType Leaf)
    {
        $message = $LocalizedData.CatalogFileFound -f ($CatalogFileName, $ModuleName)
        Write-Debug -Message $message

        $SignedFilePath = $CatalogFilePath
    }
    else
    {
        Write-Debug -Message ($LocalizedData.CatalogFileNotFoundInAvailableModule -f ($CatalogFileName, $ModuleName))
    }

    $message = "Using the previously-installed module '{0}' with version '{1}' under '{2}' for getting the publisher details." -f ($SourceModule.Name, $SourceModule.Version, $SourceModule.ModuleBase)
    Write-Debug -Message $message

    $message = "Using the '{0}' file for getting the authenticode signature." -f ($SignedFilePath)
    Write-Debug -Message $message

    $AuthenticodeSignature = Microsoft.PowerShell.Security\Get-AuthenticodeSignature -FilePath $SignedFilePath
    $ModuleDetails = $null

    if($AuthenticodeSignature)
    {
        $ModuleDetails = @{}
        $ModuleDetails['AuthenticodeSignature'] = $AuthenticodeSignature
        $ModuleDetails['Version'] = $SourceModule.Version
        $ModuleDetails['ModuleBase']=$SourceModule.ModuleBase
        $ModuleDetails['IsMicrosoftCertificate'] = Test-MicrosoftCertificate -AuthenticodeSignature $AuthenticodeSignature
        $PublisherDetails = Get-AuthenticodePublisher -AuthenticodeSignature $AuthenticodeSignature
        $ModuleDetails['Publisher'] = if($PublisherDetails) {$PublisherDetails.Publisher}
        $ModuleDetails['RootCertificateAuthority'] = if($PublisherDetails) {$PublisherDetails.PublisherRootCA}
        
        $message = $LocalizedData.SourceModuleDetailsForPublisherValidation -f ($ModuleName, $SourceModule.Version, $SourceModule.ModuleBase, $ModuleDetails.Publisher, $ModuleDetails.RootCertificateAuthority, $ModuleDetails.IsMicrosoftCertificate)
        Write-Debug $message
    }

    return $ModuleDetails
}
function Get-InstalledModuleDetails
{
    [CmdletBinding()]
    param
    (
        [Parameter()]
        [string]
        $Name,

        [Parameter()]
        [string]
        $RequiredVersion,

        [Parameter()]
        [string]
        $MinimumVersion,

        [Parameter()]
        [string]
        $MaximumVersion
    )

    Set-InstalledModulesVariable

    # Keys in $script:PSGetInstalledModules are "<ModuleName><ModuleVersion>",
    # first filter the installed modules using "$Name*" wildcard search
    # then apply $Name wildcard search to get the module name which meets the specified name with wildcards.
    #
    $wildcardPattern = New-Object System.Management.Automation.WildcardPattern "$Name*",$script:wildcardOptions
    $nameWildcardPattern = New-Object System.Management.Automation.WildcardPattern $Name,$script:wildcardOptions

    $script:PSGetInstalledModules.GetEnumerator() | Microsoft.PowerShell.Core\ForEach-Object {
                                                        if($wildcardPattern.IsMatch($_.Key))
                                                        {
                                                            $InstalledModuleDetails = $_.Value

                                                            if(-not $Name -or $nameWildcardPattern.IsMatch($InstalledModuleDetails.PSGetItemInfo.Name))
                                                            {

                                                                if (Test-ItemPrereleaseVersionRequirements -Version $InstalledModuleDetails.PSGetItemInfo.Version `
                                                                                                           -RequiredVersion $RequiredVersion `
                                                                                                           -MinimumVersion $MinimumVersion `
                                                                                                           -MaximumVersion $MaximumVersion)
                                                                {
                                                                    $InstalledModuleDetails
                                                                }
                                                            }
                                                        }
                                                    }
}
function Get-InstalledScriptDetails
{
    [CmdletBinding()]
    param
    (
        [Parameter()]
        [string]
        $Name,

        [Parameter()]
        [string]
        $RequiredVersion,

        [Parameter()]
        [string]
        $MinimumVersion,

        [Parameter()]
        [string]
        $MaximumVersion
    )

    Set-InstalledScriptsVariable

    # Keys in $script:PSGetInstalledScripts are "<ScriptName><ScriptVersion>",
    # first filter the installed scripts using "$Name*" wildcard search
    # then apply $Name wildcard search to get the script name which meets the specified name with wildcards.
    #
    $wildcardPattern = New-Object System.Management.Automation.WildcardPattern "$Name*",$script:wildcardOptions
    $nameWildcardPattern = New-Object System.Management.Automation.WildcardPattern $Name,$script:wildcardOptions

    $script:PSGetInstalledScripts.GetEnumerator() | Microsoft.PowerShell.Core\ForEach-Object {
                                                        if($wildcardPattern.IsMatch($_.Key))
                                                        {
                                                            $InstalledScriptDetails = $_.Value

                                                            if(-not $Name -or $nameWildcardPattern.IsMatch($InstalledScriptDetails.PSGetItemInfo.Name))
                                                            {
                                                                if (Test-ItemPrereleaseVersionRequirements -Version $InstalledScriptDetails.PSGetItemInfo.Version `
                                                                                                           -RequiredVersion $RequiredVersion `
                                                                                                           -MinimumVersion $MinimumVersion `
                                                                                                           -MaximumVersion $MaximumVersion)
                                                                {
                                                                    $InstalledScriptDetails
                                                                }
                                                            }
                                                        }
                                                    }
}
function Get-InstalledScriptFilePath
{
    [CmdletBinding(PositionalBinding=$false)]
    Param
    (
        [Parameter()]
        [string]
        $Name
    )

    $installedScriptFilePaths = @()
    $scriptFilePaths = Get-AvailableScriptFilePath @PSBoundParameters

    foreach ($scriptFilePath in $scriptFilePaths)
    {
        $scriptInfo = Test-ScriptInstalled -Name ([System.IO.Path]::GetFileNameWithoutExtension($scriptFilePath))

        if($scriptInfo)
        {
            $installedScriptInfoFilePath = $null
            $installedScriptInfoFileName = "$($scriptInfo.Name)_$script:InstalledScriptInfoFileName"

            if($scriptInfo.Path.StartsWith($script:ProgramFilesScriptsPath, [System.StringComparison]::OrdinalIgnoreCase))
            {
                $installedScriptInfoFilePath = Microsoft.PowerShell.Management\Join-Path -Path $script:ProgramFilesInstalledScriptInfosPath `
                                                                                         -ChildPath $installedScriptInfoFileName
            }
            elseif($scriptInfo.Path.StartsWith($script:MyDocumentsScriptsPath, [System.StringComparison]::OrdinalIgnoreCase))
            {
                $installedScriptInfoFilePath = Microsoft.PowerShell.Management\Join-Path -Path $script:MyDocumentsInstalledScriptInfosPath `
                                                                                         -ChildPath $installedScriptInfoFileName
            }

            if($installedScriptInfoFilePath -and (Microsoft.PowerShell.Management\Test-Path -Path $installedScriptInfoFilePath -PathType Leaf))
            {
                $installedScriptFilePaths += $scriptInfo.Path
            }
        }
    }

    return $installedScriptFilePaths
}
function Get-LocationString
{
    [CmdletBinding(PositionalBinding=$false)]
    Param
    (
        [Parameter()]
        [Uri]
        $LocationUri
    )

    $LocationString = $null

    if($LocationUri)
    {
        if($LocationUri.Scheme -eq 'file')
        {
            $LocationString = $LocationUri.OriginalString
        }
        elseif($LocationUri.AbsoluteUri)
        {
            $LocationString = $LocationUri.AbsoluteUri
        }
        else
        {
            $LocationString = $LocationUri.ToString()
        }
    }

    return $LocationString
}
function Get-ManifestHashTable
{
    param
    (
        [Parameter(Mandatory=$true)]
        [ValidateNotNullOrEmpty()]
        [string]
        $Path,

        [Parameter()]
        [ValidateNotNullOrEmpty()]
        [System.Management.Automation.PSCmdlet]
        $CallerPSCmdlet
    )

    $Lines = $null

    try
    {
        $Lines = Get-Content -Path $Path -Force
    }
    catch
    {
        if($CallerPSCmdlet)
        {
            $CallerPSCmdlet.ThrowTerminatingError($_.Exception.ErrorRecord)
        }
    }

    if(-not $Lines)
    {
        return
    }

    $scriptBlock = [ScriptBlock]::Create( $Lines -join "`n" )

    $allowedVariables = [System.Collections.Generic.List[String]] @('PSEdition', 'PSScriptRoot')
    $allowedCommands = [System.Collections.Generic.List[String]] @()
    $allowEnvironmentVariables = $false

    try
    {
        $scriptBlock.CheckRestrictedLanguage($allowedCommands, $allowedVariables, $allowEnvironmentVariables)
    }
    catch
    {
        if($CallerPSCmdlet)
        {
            $CallerPSCmdlet.ThrowTerminatingError($_.Exception.ErrorRecord)
        }

        return
    }

    return $scriptBlock.InvokeReturnAsIs()
}
function Get-ModuleDependencies
{
    Param (
        [Parameter(Mandatory=$true)]
        [PSModuleInfo]
        $PSModuleInfo,

        [Parameter(Mandatory=$true)]
        [string]
        $Repository,

        [parameter(Mandatory = $true)]
        [ValidateNotNullOrEmpty()]
        [System.Management.Automation.PSCmdlet]
        $CallerPSCmdlet,

        [Parameter(Mandatory=$false)]
        [pscredential]
        $Credential
    )

    $DependentModuleDetails = @()

    if($PSModuleInfo.RequiredModules -or $PSModuleInfo.NestedModules)
    {
        # PSModuleInfo.RequiredModules doesn't provide the RequiredVersion info from the ModuleSpecification
        # Reading the contents of module manifest file
        # to get the RequiredVersion details.
        $ModuleManifestHashTable = Get-ManifestHashTable -Path $PSModuleInfo.Path

        if($PSModuleInfo.RequiredModules)
        {
            $ModuleManifestRequiredModules = $null

            if($ModuleManifestHashTable)
            {
                $ModuleManifestRequiredModules = $ModuleManifestHashTable.RequiredModules
            }

            $ValidateAndGetRequiredModuleDetails_Params = @{
                ModuleManifestRequiredModules=$ModuleManifestRequiredModules
                RequiredPSModuleInfos=$PSModuleInfo.RequiredModules
                Repository=$Repository
                DependentModuleInfo=$PSModuleInfo
                CallerPSCmdlet=$CallerPSCmdlet
                Verbose=$VerbosePreference
                Debug=$DebugPreference
            }
            if ($PSBoundParameters.ContainsKey('Credential'))
            {
                $ValidateAndGetRequiredModuleDetails_Params.Add('Credential',$Credential)
            }

            $DependentModuleDetails += ValidateAndGet-RequiredModuleDetails @ValidateAndGetRequiredModuleDetails_Params
        }

        if($PSModuleInfo.NestedModules)
        {
            $ModuleManifestRequiredModules = $null

            if($ModuleManifestHashTable)
            {
                $ModuleManifestRequiredModules = $ModuleManifestHashTable.NestedModules
            }

            # A nested module is be considered as a dependency
            # 1) whose module base is not under the specified module base OR
            # 2) whose module base is under the specified module base and it's path doesn't exists
            #
            $RequiredPSModuleInfos = $PSModuleInfo.NestedModules | Microsoft.PowerShell.Core\Where-Object {
                        -not $_.ModuleBase.StartsWith($PSModuleInfo.ModuleBase, [System.StringComparison]::OrdinalIgnoreCase) -or
                        -not $_.Path -or
                        -not (Microsoft.PowerShell.Management\Test-Path -LiteralPath $_.Path)
                    }

            $ValidateAndGetRequiredModuleDetails_Params = @{
                ModuleManifestRequiredModules=$ModuleManifestRequiredModules
                RequiredPSModuleInfos=$RequiredPSModuleInfos
                Repository=$Repository
                DependentModuleInfo=$PSModuleInfo
                CallerPSCmdlet=$CallerPSCmdlet
                Verbose=$VerbosePreference
                Debug=$DebugPreference
            }
            if ($PSBoundParameters.ContainsKey('Credential'))
            {
                $ValidateAndGetRequiredModuleDetails_Params.Add('Credential',$Credential)
            }
            $DependentModuleDetails += ValidateAndGet-RequiredModuleDetails @ValidateAndGetRequiredModuleDetails_Params
        }
    }

    return $DependentModuleDetails
}
function Get-NormalizedVersionString
{
    <#
    .DESCRIPTION
        Latest versions of nuget.exe and dotnet command generate the .nupkg file name with
        semantic version format for the modules/scripts with two part version.
        For example: package 1.0 --> package.1.0.0.nupkg
    #>
    param
    (
        [Parameter(Mandatory = $true)]
        [string]
        $Version
    )

    [Version]$ParsedVersion = $null
    if ([System.Version]::TryParse($Version, [ref]$ParsedVersion)) {
        $Build = $ParsedVersion.Build
        if ($Build -eq -1) {
            $Build = 0
        }

        return "$($ParsedVersion.Major).$($ParsedVersion.Minor).$Build"
    }

    return $Version
}
function Get-OrderedPSScriptInfoObject
{
    [CmdletBinding(PositionalBinding=$false)]
    Param
    (
        [Parameter(Mandatory=$true)]
        [PSCustomObject]
        $PSScriptInfo
    )

    $NewPSScriptInfo = Microsoft.PowerShell.Utility\New-Object PSCustomObject -Property ([ordered]@{
                            $script:Name = $PSScriptInfo.$script:Name
                            $script:Version = $PSScriptInfo.$script:Version
                            $script:Guid = $PSScriptInfo.$script:Guid
                            $script:Path = $PSScriptInfo.$script:Path
                            $script:ScriptBase = $PSScriptInfo.$script:ScriptBase
                            $script:Description = $PSScriptInfo.$script:Description
                            $script:Author = $PSScriptInfo.$script:Author
                            $script:CompanyName = $PSScriptInfo.$script:CompanyName
                            $script:Copyright = $PSScriptInfo.$script:Copyright
                            $script:Tags = $PSScriptInfo.$script:Tags
                            $script:ReleaseNotes = $PSScriptInfo.$script:ReleaseNotes
                            $script:RequiredModules = $PSScriptInfo.$script:RequiredModules
                            $script:ExternalModuleDependencies = $PSScriptInfo.$script:ExternalModuleDependencies
                            $script:RequiredScripts = $PSScriptInfo.$script:RequiredScripts
                            $script:ExternalScriptDependencies = $PSScriptInfo.$script:ExternalScriptDependencies
                            $script:LicenseUri = $PSScriptInfo.$script:LicenseUri
                            $script:ProjectUri = $PSScriptInfo.$script:ProjectUri
                            $script:IconUri = $PSScriptInfo.$script:IconUri
                            $script:DefinedCommands = $PSScriptInfo.$script:DefinedCommands
                            $script:DefinedFunctions = $PSScriptInfo.$script:DefinedFunctions
                            $script:DefinedWorkflows = $PSScriptInfo.$script:DefinedWorkflows
							$script:PrivateData = $PSScriptInfo.$script:PrivateData
                        })

    $NewPSScriptInfo.PSTypeNames.Insert(0, "Microsoft.PowerShell.Commands.PSScriptInfo")

    return $NewPSScriptInfo
}
function Get-PackageManagementProviderName
{
    [CmdletBinding()]
    Param
    (
        [Parameter(Mandatory=$true)]
        [ValidateNotNullOrEmpty()]
        [Uri]
        $Location
    )

    $PackageManagementProviderName = $null
    $loc = Get-LocationString -LocationUri $Location

    $providers = PackageManagement\Get-PackageProvider | Where-Object { $_.Features.ContainsKey($script:SupportsPSModulesFeatureName) }

    foreach($provider in $providers)
    {
        # Skip the PowerShellGet provider
        if($provider.ProviderName -eq $script:PSModuleProviderName)
        {
            continue
        }

        $packageSource = Get-PackageSource -Location $loc -Provider $provider.ProviderName  -ErrorAction SilentlyContinue

        if($packageSource)
        {
            $PackageManagementProviderName = $provider.ProviderName
            break
        }
    }

    return $PackageManagementProviderName
}
function Get-ParametersHashtable
{
    param(
        $Proxy,
        $ProxyCredential
    )

    $ParametersHashtable = @{}
    if($Proxy)
    {
        $ParametersHashtable[$script:Proxy] = $Proxy
    }

    if($ProxyCredential)
    {
        $ParametersHashtable[$script:ProxyCredential] = $ProxyCredential
    }

    return $ParametersHashtable
}
function Get-PrivateData
#Utility function to help form the content string for PrivateData
{
    param
    (
        [System.Collections.Hashtable]
        $PrivateData
    )

    if($PrivateData.Keys.Count -eq 0)
    {
        $content = "
    PSData = @{

        # Tags applied to this module. These help with module discovery in online galleries.
        # Tags = @()

        # A URL to the license for this module.
        # LicenseUri = ''

        # A URL to the main website for this project.
        # ProjectUri = ''

        # A URL to an icon representing this module.
        # IconUri = ''

        # ReleaseNotes of this module
        # ReleaseNotes = ''

        # Prerelease string of this module
        # Prerelease = ''

        # Flag to indicate whether the module requires explicit user acceptance for install/update/save
        # RequireLicenseAcceptance = `$false

        # External dependent modules of this module
        # ExternalModuleDependencies = @()

    } # End of PSData hashtable

} # End of PrivateData hashtable"
        return $content
    }


    #Validate each of the property of PSData is of the desired data type
    $Tags= $PrivateData["Tags"] -join "','" | Foreach-Object {"'$_'"}
    $LicenseUri = $PrivateData["LicenseUri"]| Foreach-Object {"'$_'"}
    $ProjectUri = $PrivateData["ProjectUri"] | Foreach-Object {"'$_'"}
    $IconUri = $PrivateData["IconUri"] | Foreach-Object {"'$_'"}
    $ReleaseNotesEscape = $PrivateData["ReleaseNotes"] -Replace "'","''"
    $ReleaseNotes = $ReleaseNotesEscape | Foreach-Object {"'$_'"}
    $Prerelease = $PrivateData[$script:Prerelease] | Foreach-Object {"'$_'"}
    $RequireLicenseAcceptance = $PrivateData["RequireLicenseAcceptance"]
    $ExternalModuleDependencies = $PrivateData["ExternalModuleDependencies"] -join "','" | Foreach-Object {"'$_'"}
    $DefaultProperties = @("Tags","LicenseUri","ProjectUri","IconUri","ReleaseNotes",$script:Prerelease,"ExternalModuleDependencies","RequireLicenseAcceptance")

    $ExtraProperties = @()
    foreach($key in $PrivateData.Keys)
    {
        if($DefaultProperties -notcontains $key)
        {
            $PropertyString = "#"+"$key"+ " of this module"
            $PropertyString += "`r`n    "
            if(($PrivateData[$key]).GetType().IsArray)
            {
                $PropertyString += $key +" = " +" @("
                $PrivateData[$key] | Foreach-Object { $PropertyString += "'" + $_ +"'" + "," }
                if($PrivateData[$key].Length -ge 1)
                {
                    #Remove extra ,
                    $PropertyString = $PropertyString -Replace ".$"
                }
                $PropertyString += ")"
            }
            else
            {
                $PropertyString += $key +" = " + "'"+$PrivateData[$key]+"'"
            }

            $ExtraProperties += ,$PropertyString
        }
    }

    $ExtraPropertiesString = ""
    $firstProperty = $true
    foreach($property in $ExtraProperties)
    {
        if($firstProperty)
        {
            $firstProperty = $false
        }
        else
        {
            $ExtraPropertiesString += "`r`n`r`n    "
        }
        $ExtraPropertiesString += $Property
    }

    $TagsLine ="# Tags = @()"
    if($Tags -ne "''")
    {
        $TagsLine = "Tags = "+$Tags
    }
    $LicenseUriLine = "# LicenseUri = ''"
    if($LicenseUri -ne "''")
    {
        $LicenseUriLine = "LicenseUri = "+$LicenseUri
    }
    $ProjectUriLine = "# ProjectUri = ''"
    if($ProjectUri -ne "''")
    {
        $ProjectUriLine = "ProjectUri = " +$ProjectUri
    }
    $IconUriLine = "# IconUri = ''"
    if($IconUri -ne "''")
    {
        $IconUriLine = "IconUri = " +$IconUri
    }
    $ReleaseNotesLine = "# ReleaseNotes = ''"
    if($ReleaseNotes -ne "''")
    {
        $ReleaseNotesLine = "ReleaseNotes = "+$ReleaseNotes
    }
    $PrereleaseLine = "# Prerelease = ''"
    if ($Prerelease -ne "''")
    {
        $PrereleaseLine = "Prerelease = " +$Prerelease
    }

    $RequireLicenseAcceptanceLine = "# RequireLicenseAcceptance = `$false"
    if($RequireLicenseAcceptance)
    {
        $RequireLicenseAcceptanceLine = "RequireLicenseAcceptance = `$true"
    }

    $ExternalModuleDependenciesLine ="# ExternalModuleDependencies = @()"
    if($ExternalModuleDependencies -ne "''")
    {
        $ExternalModuleDependenciesLine = "ExternalModuleDependencies = @($ExternalModuleDependencies)"
    }

    if(-not $ExtraPropertiesString -eq "")
    {
        $Content = "
    ExtraProperties

    PSData = @{

        # Tags applied to this module. These help with module discovery in online galleries.
        $TagsLine

        # A URL to the license for this module.
        $LicenseUriLine

        # A URL to the main website for this project.
        $ProjectUriLine

        # A URL to an icon representing this module.
        $IconUriLine

        # ReleaseNotes of this module
        $ReleaseNotesLine

        # Prerelease string of this module
        $PrereleaseLine

        # Flag to indicate whether the module requires explicit user acceptance for install/update/save
        $RequireLicenseAcceptanceLine

        # External dependent modules of this module
        $ExternalModuleDependenciesLine

    } # End of PSData hashtable

} # End of PrivateData hashtable"

        #Replace the Extra PrivateData in the block
        $Content -replace "ExtraProperties", $ExtraPropertiesString
    }
    else
    {
        $content = "
    PSData = @{

        # Tags applied to this module. These help with module discovery in online galleries.
        $TagsLine

        # A URL to the license for this module.
        $LicenseUriLine

        # A URL to the main website for this project.
        $ProjectUriLine

        # A URL to an icon representing this module.
        $IconUriLine

        # ReleaseNotes of this module
        $ReleaseNotesLine

        # Prerelease string of this module
        $PrereleaseLine

        # Flag to indicate whether the module requires explicit user acceptance for install/update/save
        $RequireLicenseAcceptanceLine

        # External dependent modules of this module
        $ExternalModuleDependenciesLine

    } # End of PSData hashtable

 } # End of PrivateData hashtable"
        return $content
    }
}
function Get-ProviderName
{
    [CmdletBinding()]
    Param
    (
        [Parameter(Mandatory=$true)]
        [PSCustomObject]
        $PSCustomObject
    )

    $providerName = $script:NuGetProviderName

    if((Get-Member -InputObject $PSCustomObject -Name PackageManagementProvider))
    {
        $providerName = $PSCustomObject.PackageManagementProvider
    }

    return $providerName
}
function Get-PSScriptInfoString
{
    [CmdletBinding(PositionalBinding=$false)]
    Param
    (
        [Parameter(Mandatory=$true)]
        [ValidateNotNullOrEmpty()]
        [string]
        $Version,

        [Parameter(Mandatory=$true)]
        [ValidateNotNullOrEmpty()]
        [Guid]
        $Guid,

        [Parameter(Mandatory=$true)]
        [ValidateNotNullOrEmpty()]
        [string]
        $Author,

        [Parameter()]
        [String]
        $CompanyName,

        [Parameter()]
        [string]
        $Copyright,

        [Parameter()]
        [String[]]
        $ExternalModuleDependencies,

        [Parameter()]
        [string[]]
        $RequiredScripts,

        [Parameter()]
        [String[]]
        $ExternalScriptDependencies,

        [Parameter()]
        [string[]]
        $Tags,

        [Parameter()]
        [Uri]
        $ProjectUri,

        [Parameter()]
        [Uri]
        $LicenseUri,

        [Parameter()]
        [Uri]
        $IconUri,

        [Parameter()]
        [string[]]
        $ReleaseNotes,

		[Parameter()]
        [string]
        $PrivateData
    )

    Process
    {
        $PSScriptInfoString = @"

<#PSScriptInfo

.VERSION$(if ($Version) {" $Version"})

.GUID$(if ($Guid) {" $Guid"})

.AUTHOR$(if ($Author) {" $Author"})

.COMPANYNAME$(if ($CompanyName) {" $CompanyName"})

.COPYRIGHT$(if ($Copyright) {" $Copyright"})

.TAGS$(if ($Tags) {" $Tags"})

.LICENSEURI$(if ($LicenseUri) {" $LicenseUri"})

.PROJECTURI$(if ($ProjectUri) {" $ProjectUri"})

.ICONURI$(if ($IconUri) {" $IconUri"})

.EXTERNALMODULEDEPENDENCIES$(if ($ExternalModuleDependencies) {" $($ExternalModuleDependencies -join ',')"}) 

.REQUIREDSCRIPTS$(if ($RequiredScripts) {" $($RequiredScripts -join ',')"})

.EXTERNALSCRIPTDEPENDENCIES$(if ($ExternalScriptDependencies) {" $($ExternalScriptDependencies -join ',')"})

.RELEASENOTES
$($ReleaseNotes -join "`r`n")

.PRIVATEDATA$(if ($PrivateData) {" $PrivateData"})

#>
"@
        return $PSScriptInfoString
    }
}
function Get-PublishLocation
{
    [CmdletBinding()]
    Param
    (
        [Parameter()]
        [String]
        $Location
    )

    $PublishLocation = $null

    if($Location)
    {
        # For local dir or SMB-share locations, ScriptPublishLocation is PublishLocation.
        if(Microsoft.PowerShell.Management\Test-Path -Path $Location)
        {
            $PublishLocation = $Location
        }
        else
        {
            $tempPublishLocation = $null

            if($Location.EndsWith('/api/v2', [System.StringComparison]::OrdinalIgnoreCase))
            {
                $tempPublishLocation = $Location + '/package/'
            }
            elseif($Location.EndsWith('/api/v2/', [System.StringComparison]::OrdinalIgnoreCase))
            {
                $tempPublishLocation = $Location + 'package/'
            }

            if($tempPublishLocation)
            {
                $PublishLocation = $tempPublishLocation
            }
        }
    }
    return $PublishLocation
}
function Get-RequiresString
{
    [CmdletBinding()]
    Param
    (
        [Parameter()]
        [Object[]]
        $RequiredModules
    )

    Process
    {
        if($RequiredModules)
        {
            $RequiredModuleStrings = @()

            foreach($requiredModuleObject in $RequiredModules)
            {
                if($requiredModuleObject.GetType().ToString() -eq 'System.Collections.Hashtable')
                {
                    if(($requiredModuleObject.Keys.Count -eq 1) -and
                        (Microsoft.PowerShell.Utility\Get-Member -InputObject $requiredModuleObject -Name 'ModuleName'))
                    {
                        $RequiredModuleStrings += $requiredModuleObject['ModuleName'].ToString()
                    }
                    else
                    {
                        $moduleSpec = New-Object Microsoft.PowerShell.Commands.ModuleSpecification -ArgumentList $requiredModuleObject
                        if (-not (Microsoft.PowerShell.Utility\Get-Variable -Name moduleSpec -ErrorAction SilentlyContinue))
                        {
                            return
                        }

                        $keyvalueStrings = $requiredModuleObject.Keys | Microsoft.PowerShell.Core\ForEach-Object {"$_ = '$( $requiredModuleObject[$_])'"}
                        $RequiredModuleStrings += "@{$($keyvalueStrings -join '; ')}"
                    }
                }
                elseif(($PSVersionTable.PSVersion -eq '3.0.0') -and
                       ($requiredModuleObject.GetType().ToString() -eq 'Microsoft.PowerShell.Commands.ModuleSpecification'))
                {
                    # ModuleSpecification.ToString() is not implemented on PowerShell 3.0.

                    $optionalString = " "

                    if($requiredModuleObject.Version)
                    {
                        $optionalString += "ModuleVersion = '$($requiredModuleObject.Version.ToString())'; "
                    }

                    if($requiredModuleObject.Guid)
                    {
                        $optionalString += "Guid = '$($requiredModuleObject.Guid.ToString())'; "
                    }

                    if($optionalString.Trim())
                    {
                        $moduleSpecString = "@{ ModuleName = '$($requiredModuleObject.Name.ToString())';$optionalString}"
                    }
                    else
                    {
                        $moduleSpecString = $requiredModuleObject.Name.ToString()
                    }

                    $RequiredModuleStrings += $moduleSpecString
                }
                else
                {
                    $RequiredModuleStrings += $requiredModuleObject.ToString()
                }
            }

            $hashRequiresStrings = $RequiredModuleStrings |
                                       Microsoft.PowerShell.Core\ForEach-Object { "#Requires -Module $_" }

            return $hashRequiresStrings
        }
        else
        {
            return ""
        }
    }
}
function Get-ScriptCommentHelpInfoString
{
    [CmdletBinding(PositionalBinding=$false)]
    Param
    (
        [Parameter(Mandatory=$true)]
        [ValidateNotNullOrEmpty()]
        [string]
        $Description,

        [Parameter()]
        [string]
        $Synopsis,

        [Parameter()]
        [string[]]
        $Example,

        [Parameter()]
        [string[]]
        $Inputs,

        [Parameter()]
        [string[]]
        $Outputs,

        [Parameter()]
        [string[]]
        $Notes,

        [Parameter()]
        [string[]]
        $Link,

        [Parameter()]
        [string]
        $Component,

        [Parameter()]
        [string]
        $Role,

        [Parameter()]
        [string]
        $Functionality
    )

    Process
    {
        $ScriptCommentHelpInfoString = "<# `r`n`r`n.DESCRIPTION `r`n $Description `r`n`r`n"

        if("$Synopsis".Trim())
        {
            $ScriptCommentHelpInfoString += ".SYNOPSIS `r`n$Synopsis `r`n`r`n"
        }

        if("$Example".Trim())
        {
            $Example | ForEach-Object {
                           if($_)
                           {
                               $ScriptCommentHelpInfoString += ".EXAMPLE `r`n$_ `r`n`r`n"
                           }
                       }
        }

        if("$Inputs".Trim())
        {
            $Inputs |  ForEach-Object {
                           if($_)
                           {
                               $ScriptCommentHelpInfoString += ".INPUTS `r`n$_ `r`n`r`n"
                           }
                       }
        }

        if("$Outputs".Trim())
        {
            $Outputs |  ForEach-Object {
                           if($_)
                           {
                               $ScriptCommentHelpInfoString += ".OUTPUTS `r`n$_ `r`n`r`n"
                           }
                       }
        }

        if("$Notes".Trim())
        {
            $ScriptCommentHelpInfoString += ".NOTES `r`n$($Notes -join "`r`n") `r`n`r`n"
        }

        if("$Link".Trim())
        {
            $Link |  ForEach-Object {
                         if($_)
                         {
                              $ScriptCommentHelpInfoString += ".LINK `r`n$_ `r`n`r`n"
                         }
                     }
        }

        if("$Component".Trim())
        {
            $ScriptCommentHelpInfoString += ".COMPONENT `r`n$($Component -join "`r`n") `r`n`r`n"
        }

        if("$Role".Trim())
        {
            $ScriptCommentHelpInfoString += ".ROLE `r`n$($Role -join "`r`n") `r`n`r`n"
        }

        if("$Functionality".Trim())
        {
            $ScriptCommentHelpInfoString += ".FUNCTIONALITY `r`n$($Functionality -join "`r`n") `r`n`r`n"
        }

        $ScriptCommentHelpInfoString += "#> `r`n"

        return $ScriptCommentHelpInfoString
    }
}
function Get-ScriptSourceLocation
{
    [CmdletBinding()]
    Param
    (
        [Parameter()]
        [String]
        $Location,

        [Parameter()]
        $Credential,

        [Parameter()]
        $Proxy,

        [Parameter()]
        $ProxyCredential
    )

    $scriptLocation = $null

    if($Location)
    {
        # For local dir or SMB-share locations, ScriptSourceLocation is SourceLocation.
        if(Microsoft.PowerShell.Management\Test-Path -Path $Location)
        {
            $scriptLocation = $Location
        }
        else
        {
            $tempScriptLocation = $null

            if($Location.EndsWith('/api/v2', [System.StringComparison]::OrdinalIgnoreCase))
            {
                $tempScriptLocation = $Location + '/items/psscript/'
            }
            elseif($Location.EndsWith('/api/v2/', [System.StringComparison]::OrdinalIgnoreCase))
            {
                $tempScriptLocation = $Location + 'items/psscript/'
            }

            if($tempScriptLocation)
            {
                # Ping and resolve the specified location
                $scriptLocation = Resolve-Location -Location $tempScriptLocation `
                                                   -LocationParameterName 'ScriptSourceLocation' `
                                                   -Credential $Credential `
                                                   -Proxy $Proxy `
                                                   -ProxyCredential $ProxyCredential `
                                                   -ErrorAction SilentlyContinue `
                                                   -WarningAction SilentlyContinue
            }
        }
    }
    return $scriptLocation
}
function Get-SourceLocation
{
    [CmdletBinding()]
    [OutputType("string")]
    Param
    (
        [Parameter(Mandatory=$true)]
        [ValidateNotNullOrEmpty()]
        [string]
        $SourceName
    )

    Set-ModuleSourcesVariable

    if($script:PSGetModuleSources.Contains($SourceName))
    {
        return $script:PSGetModuleSources[$SourceName].SourceLocation
    }
    else
    {
        return $SourceName
    }
}
function Get-SourceName {
    [CmdletBinding()]
    [OutputType("string")]
    Param
    (
        [Parameter(Mandatory = $true)]
        [ValidateNotNullOrEmpty()]
        [string]
        $Location
    )

    Set-ModuleSourcesVariable

    foreach ($psModuleSource in $script:PSGetModuleSources.Values) {
        if (($psModuleSource.Name -eq $Location) -or
            (Test-EquivalentLocation -LocationA $psModuleSource.SourceLocation -LocationB $Location) -or
            ((Get-Member -InputObject $psModuleSource -Name $script:ScriptSourceLocation) -and
                (Test-EquivalentLocation -LocationA $psModuleSource.ScriptSourceLocation -LocationB $Location))) {
            return $psModuleSource.Name
        }
    }
}
function Get-UrlFromSwid
{
    param
    (
        [Parameter(Mandatory=$true)]
        $SoftwareIdentity,

        [Parameter(Mandatory=$true)]
        $UrlName
    )

    foreach($link in $SoftwareIdentity.Links)
    {
        if( $link.Relationship -eq $UrlName)
        {
            return $link.HRef
        }
    }

    return $null
}
function Get-ValidModuleLocation
{
    [CmdletBinding()]
    Param
    (
        [Parameter(Mandatory=$true)]
        [ValidateNotNullOrEmpty()]
        [string]
        $LocationString,

        [Parameter(Mandatory=$true)]
        [ValidateNotNullOrEmpty()]
        [string]
        $ParameterName,

        [Parameter()]
        $Credential,

        [Parameter()]
        $Proxy,

        [Parameter()]
        $ProxyCredential
    )

    # Get the actual Uri from the Location
    if(-not (Microsoft.PowerShell.Management\Test-Path $LocationString))
    {
        # Append '/api/v2/' to the $LocationString, return if that URI works.
        if(($LocationString -notmatch 'LinkID') -and
           -not ($LocationString.EndsWith('/nuget/v2', [System.StringComparison]::OrdinalIgnoreCase)) -and
           -not ($LocationString.EndsWith('/nuget/v2/', [System.StringComparison]::OrdinalIgnoreCase)) -and
           -not ($LocationString.EndsWith('/nuget', [System.StringComparison]::OrdinalIgnoreCase)) -and
           -not ($LocationString.EndsWith('/nuget/', [System.StringComparison]::OrdinalIgnoreCase)) -and
           -not ($LocationString.EndsWith('index.json', [System.StringComparison]::OrdinalIgnoreCase)) -and
           -not ($LocationString.EndsWith('index.json/', [System.StringComparison]::OrdinalIgnoreCase)) -and
           -not ($LocationString.EndsWith('/api/v2', [System.StringComparison]::OrdinalIgnoreCase)) -and
           -not ($LocationString.EndsWith('/api/v2/', [System.StringComparison]::OrdinalIgnoreCase))
            )
        {
            $tempLocation = $null

            if($LocationString.EndsWith('/', [System.StringComparison]::OrdinalIgnoreCase))
            {
                $tempLocation = $LocationString + 'api/v2/'
            }
            else
            {
                $tempLocation = $LocationString + '/api/v2/'
            }

            if($tempLocation)
            {
                # Ping and resolve the specified location
                $tempLocation = Resolve-Location -Location $tempLocation `
                                                 -LocationParameterName $ParameterName `
                                                 -Credential $Credential `
                                                 -Proxy $Proxy `
                                                 -ProxyCredential $ProxyCredential `
                                                 -ErrorAction SilentlyContinue `
                                                 -WarningAction SilentlyContinue
                if($tempLocation)
                {
                   return $tempLocation
                }
                # No error if we can't resolve the URL appended with '/api/v2/'
            }
        }

        # Ping and resolve the specified location
        $LocationString = Resolve-Location -Location $LocationString `
                                           -LocationParameterName $ParameterName `
                                           -Credential $Credential `
                                           -Proxy $Proxy `
                                           -ProxyCredential $ProxyCredential `
                                           -CallerPSCmdlet $PSCmdlet
    }

    return $LocationString
}
function HttpClientApisAvailable
{
    $HttpClientApisAvailable = $false
    try
    {
        [System.Net.Http.HttpClient]
        $HttpClientApisAvailable = $true
    }
    catch
    {
    }
    return $HttpClientApisAvailable
}
function Install-NuGetClientBinaries
{
    [CmdletBinding()]
    param
    (
        [parameter(Mandatory = $true)]
        [ValidateNotNullOrEmpty()]
        [System.Management.Automation.PSCmdlet]
        $CallerPSCmdlet,

        [parameter()]
        [switch]
        $BootstrapNuGetExe,

        [Parameter()]
        $Proxy,

        [Parameter()]
        $ProxyCredential,

        [parameter()]
        [switch]
        $Force
    )

    if ($script:NuGetProvider -and
        ($script:NuGetExeVersion -and ($script:NuGetExeVersion -ge $script:NuGetExeMinRequiredVersion))   -and
         (-not $BootstrapNuGetExe -or
         (($script:NuGetExePath -and (Microsoft.PowerShell.Management\Test-Path -Path $script:NuGetExePath)) -or
          ($script:DotnetCommandPath -and (Microsoft.PowerShell.Management\Test-Path -Path $script:DotnetCommandPath)))))
    {
        return
    }

    $bootstrapNuGetProvider = (-not $script:NuGetProvider)

    if($bootstrapNuGetProvider)
    {
        # Bootstrap the NuGet provider only if it is not available.
        # By default PackageManagement loads the latest version of the NuGet provider.
        $nugetProvider = PackageManagement\Get-PackageProvider -ErrorAction SilentlyContinue -WarningAction SilentlyContinue |
                            Microsoft.PowerShell.Core\Where-Object {
                                                                     $_.Name -eq $script:NuGetProviderName -and
                                                                     $_.Version -ge $script:NuGetProviderVersion
                                                                   }
        if($nugetProvider)
        {
            $script:NuGetProvider = $nugetProvider

            $bootstrapNuGetProvider = $false
        }
        else
        {
            # User might have installed it in an another console or in the same process, check available NuGet providers and import the required provider.
            $availableNugetProviders = PackageManagement\Get-PackageProvider -Name $script:NuGetProviderName `
                                                                             -ListAvailable `
                                                                             -ErrorAction SilentlyContinue `
                                                                             -WarningAction SilentlyContinue |
                                            Microsoft.PowerShell.Core\Where-Object {
                                                                                       $_.Name -eq $script:NuGetProviderName -and
                                                                                       $_.Version -ge $script:NuGetProviderVersion
                                                                                   }
            if($availableNugetProviders)
            {
                # Force import ensures that nuget provider with minimum version got loaded.
                $null = PackageManagement\Import-PackageProvider -Name $script:NuGetProviderName `
                                                                 -MinimumVersion $script:NuGetProviderVersion `
                                                                 -Force

                $nugetProvider = PackageManagement\Get-PackageProvider -ErrorAction SilentlyContinue -WarningAction SilentlyContinue |
                                    Microsoft.PowerShell.Core\Where-Object {
                                                                             $_.Name -eq $script:NuGetProviderName -and
                                                                             $_.Version -ge $script:NuGetProviderVersion
                                                                           }
                if($nugetProvider)
                {
                    $script:NuGetProvider = $nugetProvider

                    $bootstrapNuGetProvider = $false
                }
            }
        }
    }

    if($script:IsWindows -and -not $script:IsNanoServer) {

        if($BootstrapNuGetExe -and 
        (-not $script:NuGetExePath -or
            -not (Microsoft.PowerShell.Management\Test-Path -Path $script:NuGetExePath)) -or 
            ($script:NuGetExeVersion -and ($script:NuGetExeVersion -lt $script:NuGetExeMinRequiredVersion))   )
        {
            $programDataExePath = Microsoft.PowerShell.Management\Join-Path -Path $script:PSGetProgramDataPath -ChildPath $script:NuGetExeName
            $applocalDataExePath = Microsoft.PowerShell.Management\Join-Path -Path $script:PSGetAppLocalPath -ChildPath $script:NuGetExeName

            # Check if NuGet.exe is available under one of the predefined PowerShellGet locations under ProgramData or LocalAppData
            if( (Microsoft.PowerShell.Management\Test-Path -Path $programDataExePath) -and 
                ($programDataExePath | Microsoft.PowerShell.Core\Get-Command).Version -ge $script:NuGetExeMinRequiredVersion )
            {
                $NugetExePath = $programDataExePath
            }
            elseif( (Microsoft.PowerShell.Management\Test-Path -Path $applocalDataExePath) -and 
                ($applocalDataExePath | Microsoft.PowerShell.Core\Get-Command).Version -ge $script:NuGetExeMinRequiredVersion )
            {
                $NugetExePath = $applocalDataExePath
            }
            else
            {
                # Using Get-Command cmdlet, get the location of NuGet.exe if it is available under $env:PATH.
                # NuGet.exe does not work if it is under $env:WINDIR, so skip it from the Get-Command results.
                $nugetCmd = Microsoft.PowerShell.Core\Get-Command -Name $script:NuGetExeName `
                                                                -ErrorAction Ignore `
                                                                -WarningAction SilentlyContinue |
                                Microsoft.PowerShell.Core\Where-Object {
                                    $_.Path -and
                                    ((Microsoft.PowerShell.Management\Split-Path -Path $_.Path -Leaf) -eq $script:NuGetExeName) -and
                                    (-not $_.Path.StartsWith($env:windir, [System.StringComparison]::OrdinalIgnoreCase))
                                } | Microsoft.PowerShell.Utility\Select-Object -First 1 -ErrorAction Ignore

                if($nugetCmd -and $nugetCmd.Path -and $nugetCmd.FileVersionInfo.FileVersion)
                {
                    $NugetExePath = $nugetCmd.Path
                }
            }

            if ($NugetExePath -and (Microsoft.PowerShell.Management\Test-Path -Path $NugetExePath)) {
                $script:NuGetExePath = $NugetExePath
                $script:NuGetExeVersion = (Get-Command $script:NuGetExePath).FileVersionInfo.FileVersion
                        
                # No need to bootstrap the NuGet.exe if there is a NuGet.exe file that is at least the minimum required version found
                if ($script:NuGetExeVersion -and ($script:NuGetExeVersion -ge $script:NuGetExeMinRequiredVersion)) 
                {
                    $BootstrapNuGetExe = $false
                }
            }
        }
        else
        {
            # No need to bootstrap the NuGet.exe when $BootstrapNuGetExe is false or NuGet.exe path is already assigned.
            $BootstrapNuGetExe = $false
        }
    }


    if($BootstrapNuGetExe) {
        $DotnetCmd = Microsoft.PowerShell.Core\Get-Command -Name $script:DotnetCommandName -ErrorAction Ignore -WarningAction SilentlyContinue |
            Microsoft.PowerShell.Utility\Select-Object -First 1 -ErrorAction Ignore

        if ($DotnetCmd -and $DotnetCmd.Path) {  
            $script:DotnetCommandPath = $DotnetCmd.Path
            $BootstrapNuGetExe = $false
        }
        else {
            if($script:IsWindows) {
                $DotnetCommandPath = Microsoft.PowerShell.Management\Join-Path -Path $env:LocalAppData -ChildPath Microsoft |
                    Microsoft.PowerShell.Management\Join-Path -ChildPath dotnet |
                        Microsoft.PowerShell.Management\Join-Path -ChildPath dotnet.exe

                if($DotnetCommandPath -and
                   -not (Microsoft.PowerShell.Management\Test-Path -LiteralPath $DotnetCommandPath -PathType Leaf)) {
                    $DotnetCommandPath = Microsoft.PowerShell.Management\Join-Path -Path $env:ProgramFiles -ChildPath dotnet |
                        Microsoft.PowerShell.Management\Join-Path -ChildPath dotnet.exe
                }
            }
            else {
                $DotnetCommandPath = '/usr/local/bin/dotnet'
            }

            if($DotnetCommandPath -and (Microsoft.PowerShell.Management\Test-Path -LiteralPath $DotnetCommandPath -PathType Leaf)) {
                $DotnetCommandVersion,$null = (& $DotnetCommandPath '--version') -split '-',2
                if($DotnetCommandVersion -and ($script:MinimumDotnetCommandVersion -le $DotnetCommandVersion)) {
                    $script:DotnetCommandPath = $DotnetCommandPath
                    $BootstrapNuGetExe = $false
                }
            }
        }
    }

    # On non-Windows, dotnet should be installed by the user, throw an error if dotnet is not found using above logic.
    if ($BootstrapNuGetExe -and (-not $script:IsWindows -or $script:IsNanoServer)) {
        $ThrowError_params = @{
            ExceptionName    = 'System.InvalidOperationException'
            ExceptionMessage = ($LocalizedData.CouldNotFindDotnetCommand -f $script:MinimumDotnetCommandVersion, $script:DotnetInstallUrl)
            ErrorId          = 'CouldNotFindDotnetCommand'
            CallerPSCmdlet   = $CallerPSCmdlet
            ErrorCategory    = 'InvalidOperation'
        }

        ThrowError @ThrowError_params
        return
    }

    if(-not $bootstrapNuGetProvider -and -not $BootstrapNuGetExe)
    {
        return
    }


    # We should prompt only once for bootstrapping the NuGet provider and/or NuGet.exes
    if($BootstrapNuGetExe -and $script:NuGetExePath -and $bootstrapNuGetProvider)
    {
        # Should continue message for upgrading NuGet.exe and installing NuGet provider
        $shouldContinueQueryMessage = $LocalizedData.InstallNugetBinariesUpgradeShouldContinueQuery -f @($script:NuGetExeMinRequiredVersion,$script:NuGetProviderVersion,$script:NuGetBinaryProgramDataPath,$script:NuGetBinaryLocalAppDataPath,$script:PSGetProgramDataPath,$script:PSGetAppLocalPath)
        $shouldContinueCaption = $LocalizedData.InstallNuGetBinariesUpgradeShouldContinueCaption
    }
    elseif($BootstrapNuGetExe -and $bootstrapNuGetProvider)
    {
        # Should continue message for installing both NuGet.exe and NuGet provider
        $shouldContinueQueryMessage = $LocalizedData.InstallNuGetBinariesShouldContinueQuery -f @($script:NuGetExeMinRequiredVersion, $script:NuGetProviderVersion, $script:NuGetBinaryProgramDataPath, $script:NuGetBinaryLocalAppDataPath, $script:PSGetProgramDataPath,$script:PSGetAppLocalPath)
        $shouldContinueCaption = $LocalizedData.InstallNuGetBinariesShouldContinueCaption
    }
    elseif($BootstrapNuGetExe -and $script:NuGetExePath)
    {
        # Should continue message for upgrading NuGet.exe
        $shouldContinueQueryMessage = $LocalizedData.InstallNugetExeUpgradeShouldContinueQuery -f @($script:NuGetExeMinRequiredVersion, $script:PSGetProgramDataPath, $script:PSGetAppLocalPath)
        $shouldContinueCaption = $LocalizedData.InstallNuGetExeUpgradeShouldContinueCaption
    }
    elseif($BootstrapNuGetExe)
    {
        # Should continue message for installing NuGet.exe
        $shouldContinueQueryMessage = $LocalizedData.InstallNuGetExeShouldContinueQuery -f @($script:NuGetExeMinRequiredVersion, $script:PSGetProgramDataPath, $script:PSGetAppLocalPath)
        $shouldContinueCaption = $LocalizedData.InstallNuGetExeShouldContinueCaption
    }
    elseif($bootstrapNuGetProvider) {
        # Should continue message for installing NuGet Provider
        $shouldContinueQueryMessage = $LocalizedData.InstallNuGetProviderShouldContinueQuery -f @($script:NuGetProviderVersion,$script:NuGetBinaryProgramDataPath,$script:NuGetBinaryLocalAppDataPath)
        $shouldContinueCaption = $LocalizedData.InstallNuGetProviderShouldContinueCaption
    }


    $AdditionalParams = Get-ParametersHashtable -Proxy $Proxy -ProxyCredential $ProxyCredential

    if($Force -or $psCmdlet.ShouldContinue($shouldContinueQueryMessage, $shouldContinueCaption))
    {
        if($bootstrapNuGetProvider)
        {
            Write-Verbose -Message $LocalizedData.DownloadingNugetProvider

            $scope = 'CurrentUser'
            if(Test-RunningAsElevated)
            {
                $scope = 'AllUsers'
            }

            # Bootstrap the NuGet provider
            $null = PackageManagement\Install-PackageProvider -Name $script:NuGetProviderName `
                                                              -MinimumVersion $script:NuGetProviderVersion `
                                                              -Scope $scope `
                                                              -Force @AdditionalParams

            # Force import ensures that nuget provider with minimum version got loaded.
            $null = PackageManagement\Import-PackageProvider -Name $script:NuGetProviderName `
                                                             -MinimumVersion $script:NuGetProviderVersion `
                                                             -Force

            $nugetProvider = PackageManagement\Get-PackageProvider -Name $script:NuGetProviderName

            if ($nugetProvider)
            {
                $script:NuGetProvider = $nugetProvider
            }
        }

        if($BootstrapNuGetExe -and $script:IsWindows)
        {
            Write-Verbose -Message $LocalizedData.DownloadingNugetExe

            $nugetExeBasePath = $script:PSGetAppLocalPath

            # if the current process is running with elevated privileges,
            # install NuGet.exe to $script:PSGetProgramDataPath
            if(Test-RunningAsElevated)
            {
                $nugetExeBasePath = $script:PSGetProgramDataPath
            }

            if(-not (Microsoft.PowerShell.Management\Test-Path -Path $nugetExeBasePath))
            {
                $null = Microsoft.PowerShell.Management\New-Item -Path $nugetExeBasePath `
                                                                 -ItemType Directory -Force `
                                                                 -ErrorAction SilentlyContinue `
                                                                 -WarningAction SilentlyContinue `
                                                                 -Confirm:$false -WhatIf:$false
            }

            $nugetExeFilePath = Microsoft.PowerShell.Management\Join-Path -Path $nugetExeBasePath -ChildPath $script:NuGetExeName

            # Download the NuGet.exe from https://dist.nuget.org/win-x86-commandline/latest/nuget.exe
            $null = Microsoft.PowerShell.Utility\Invoke-WebRequest -Uri $script:NuGetClientSourceURL `
                                                                   -OutFile $nugetExeFilePath `
                                                                   @AdditionalParams

            if (Microsoft.PowerShell.Management\Test-Path -Path $nugetExeFilePath)
            {
                $script:NuGetExePath = $nugetExeFilePath
                $script:NuGetExeVersion = (Get-Command $nugetExeFilePath).FileVersionInfo.FileVersion
            }
        }
    }

    $message = $null
    $errorId = $null
    $failedToBootstrapNuGetProvider = $false
    $failedToBootstrapNuGetExe = $false


    if($bootstrapNuGetProvider -and -not $script:NuGetProvider)
    {
        $failedToBootstrapNuGetProvider = $true

        $message = $LocalizedData.CouldNotInstallNuGetProvider -f @($script:NuGetProviderVersion)
        $errorId = 'CouldNotInstallNuGetProvider'
    }

    if($BootstrapNuGetExe)
    {
        if(-not $script:NuGetExePath -or
           -not (Microsoft.PowerShell.Management\Test-Path -Path $script:NuGetExePath))
        {
            $failedToBootstrapNuGetExe = $true

            $message = $LocalizedData.CouldNotInstallNuGetExe -f @($script:NuGetExeMinRequiredVersion, $script:MinimumDotnetCommandVersion)
            $errorId = 'CouldNotInstallNuGetExe'
        }
        elseif($script:NuGetExeVersion -and ($script:NuGetExeVersion -lt $script:NuGetExeMinRequiredVersion))
        {
            $failedToBootstrapNuGetExe = $true

            $message = $LocalizedData.CouldNotUpgradeNuGetExe -f @($script:NuGetExeMinRequiredVersion, $script:MinimumDotnetCommandVersion)
            $errorId = 'CouldNotUpgradeNuGetExe'
        }
    }

    # Change the error id and message if both NuGet provider and NuGet.exe are not installed.
    if($failedToBootstrapNuGetProvider -and $failedToBootstrapNuGetExe)
    {
        $message = $LocalizedData.CouldNotInstallNuGetBinaries2 -f @($script:NuGetProviderVersion)
        $errorId = 'CouldNotInstallNuGetBinaries'
    }

    # Throw the error message if one of the above conditions are met
    if($message -and $errorId)
    {
        ThrowError -ExceptionName "System.InvalidOperationException" `
                    -ExceptionMessage $message `
                    -ErrorId $errorId `
                    -CallerPSCmdlet $CallerPSCmdlet `
                    -ErrorCategory InvalidOperation
    }
}
function Install-PackageUtility
{
    [CmdletBinding()]
    param
    (
        [Parameter(Mandatory=$true)]
        [ValidateNotNullOrEmpty()]
        [string]
        $FastPackageReference,

        [Parameter()]
        [ValidateNotNullOrEmpty()]
        [string]
        $Location,

        [Parameter(Mandatory=$true)]
        [ValidateNotNullOrEmpty()]
        $request
    )

    Set-ModuleSourcesVariable

    Write-Debug ($LocalizedData.ProviderApiDebugMessage -f ('Install-PackageUtility'))

    Write-Debug ($LocalizedData.FastPackageReference -f $fastPackageReference)

    $Force = $false
    $SkipPublisherCheck = $false
    $AllowClobber = $false
    $Debug = $false
    $MinimumVersion = ""
    $RequiredVersion = ""
    $IsSavePackage = $false
    $Scope = $null
    $NoPathUpdate = $false
    $AcceptLicense = $false

    # take the fastPackageReference and get the package object again.
    $parts = $fastPackageReference -Split '[|]'

    if( $parts.Length -eq 5 )
    {
        $providerName = $parts[0]
        $packageName = $parts[1]
        $version = $parts[2]
        $sourceLocation= $parts[3]
        $artifactType = $parts[4]

        $result = ValidateAndGet-VersionPrereleaseStrings -Version $version -CallerPSCmdlet $PSCmdlet
        if (-not $result)
        {
            # ValidateAndGet-VersionPrereleaseStrings throws the error.
            # returning to avoid further execution when different values are specified for -ErrorAction parameter
            return
        }
        $galleryItemVersion = $result["Version"]
        $galleryItemPrerelease = $result["Prerelease"]
        $galleryItemFullVersion = $result["FullVersion"]

        # The default destination location for Modules and Scripts is ProgramFiles path
        $scriptDestination = $script:ProgramFilesScriptsPath
        $moduleDestination = $script:programFilesModulesPath
        $Scope = 'AllUsers'

        if($artifactType -eq $script:PSArtifactTypeScript)
        {
            $AdminPrivilegeErrorMessage = $LocalizedData.InstallScriptAdminPrivilegeRequiredForAllUsersScope -f @($script:ProgramFilesScriptsPath, $script:MyDocumentsScriptsPath)
            $AdminPrivilegeErrorId = 'InstallScriptAdminPrivilegeRequiredForAllUsersScope'
        }
        else
        {
            $AdminPrivilegeErrorMessage = $LocalizedData.InstallModuleAdminPrivilegeRequiredForAllUsersScope -f @($script:programFilesModulesPath, $script:MyDocumentsModulesPath)
            $AdminPrivilegeErrorId = 'InstallModuleAdminPrivilegeRequiredForAllUsersScope'
        }

        $installUpdate = $false

        $options = $request.Options

        if($options)
        {
            foreach( $o in $options.Keys )
            {
                Write-Debug ("OPTION: {0} => {1}" -f ($o, $request.Options[$o]) )
            }

            if($options.ContainsKey('Scope'))
            {
                $Scope = $options['Scope']
                Write-Verbose ($LocalizedData.SpecifiedInstallationScope -f $Scope)

                if($Scope -eq "CurrentUser")
                {
                    $scriptDestination = $script:MyDocumentsScriptsPath
                    $moduleDestination = $script:MyDocumentsModulesPath
                }
                elseif($Scope -eq "AllUsers")
                {
                    $scriptDestination = $script:ProgramFilesScriptsPath
                    $moduleDestination = $script:programFilesModulesPath

                    if(-not (Test-RunningAsElevated))
                    {
                        # Throw an error when Install-Module/Script is used as a non-admin user and '-Scope AllUsers'
                        ThrowError -ExceptionName "System.ArgumentException" `
                                    -ExceptionMessage $AdminPrivilegeErrorMessage `
                                    -ErrorId $AdminPrivilegeErrorId `
                                    -CallerPSCmdlet $PSCmdlet `
                                    -ErrorCategory InvalidArgument
                    }
                }
            }
            elseif($Location)
            {
                $IsSavePackage = $true
                $Scope = $null

                $moduleDestination = $Location
                $scriptDestination = $Location
            }
            elseif(-not $script:IsCoreCLR -and (Test-RunningAsElevated))
            {
                # If Windows and elevated default scope will be all users
                $scriptDestination = $script:ProgramFilesScriptsPath
                $moduleDestination = $script:ProgramFilesModulesPath
            }
            else
            {
                # If non-Windows or non-elevated default scope will be current user
                $scriptDestination = $script:MyDocumentsScriptsPath
                $moduleDestination = $script:MyDocumentsModulesPath
            }

            if($options.ContainsKey('SkipPublisherCheck'))
            {
                $SkipPublisherCheck = $options['SkipPublisherCheck']

                if($SkipPublisherCheck.GetType().ToString() -eq 'System.String')
                {
                    if($SkipPublisherCheck -eq 'true')
                    {
                        $SkipPublisherCheck = $true
                    }
                    else
                    {
                        $SkipPublisherCheck = $false
                    }
                }
            }

            if($options.ContainsKey('AllowClobber'))
            {
                $AllowClobber = $options['AllowClobber']

                if($AllowClobber.GetType().ToString() -eq 'System.String')
                {
                    if($AllowClobber -eq 'false')
                    {
                        $AllowClobber = $false
                    }
                    elseif($AllowClobber -eq 'true')
                    {
                        $AllowClobber = $true
                    }
                }
            }

            if($options.ContainsKey('Force'))
            {
                $Force = $options['Force']

                if($Force.GetType().ToString() -eq 'System.String')
                {
                    if($Force -eq 'false')
                    {
                        $Force = $false
                    }
                    elseif($Force -eq 'true')
                    {
                        $Force = $true
                    }
                }
            }

            if($options.ContainsKey('AcceptLicense'))
            {
                $AcceptLicense = $options['AcceptLicense']

                if($AcceptLicense.GetType().ToString() -eq 'System.String')
                {
                    if($AcceptLicense -eq 'false')
                    {
                        $AcceptLicense = $false
                    }
                    elseif($AcceptLicense -eq 'true')
                    {
                        $AcceptLicense = $true
                    }
                }
            }

            if($options.ContainsKey('Debug'))
            {
                $Debug = $options['Debug']

                if($Debug.GetType().ToString() -eq 'System.String')
                {
                    if($Debug -eq 'false')
                    {
                        $Debug = $false
                    }
                    elseif($Debug -eq 'true')
                    {
                        $Debug = $true
                    }
                }
            }

            if($options.ContainsKey('NoPathUpdate'))
            {
                $NoPathUpdate = $options['NoPathUpdate']

                if($NoPathUpdate.GetType().ToString() -eq 'System.String')
                {
                    if($NoPathUpdate -eq 'false')
                    {
                        $NoPathUpdate = $false
                    }
                    elseif($NoPathUpdate -eq 'true')
                    {
                        $NoPathUpdate = $true
                    }
                }
            }

            if($options.ContainsKey('MinimumVersion'))
            {
                $MinimumVersion = $options['MinimumVersion']
            }

            if($options.ContainsKey('RequiredVersion'))
            {
                $RequiredVersion = $options['RequiredVersion']
            }

            if($options.ContainsKey('InstallUpdate'))
            {
                $installUpdate = $options['InstallUpdate']

                if($installUpdate.GetType().ToString() -eq 'System.String')
                {
                    if($installUpdate -eq 'false')
                    {
                        $installUpdate = $false
                    }
                    elseif($installUpdate -eq 'true')
                    {
                        $installUpdate = $true
                    }
                }
            }

            if($Scope -and ($artifactType -eq $script:PSArtifactTypeScript) -and (-not $installUpdate))
            {
                ValidateAndSet-PATHVariableIfUserAccepts -Scope $Scope `
                                                         -ScopePath $scriptDestination `
                                                         -Request $request `
                                                         -NoPathUpdate:$NoPathUpdate `
                                                         -Force:$Force
            }

            if($artifactType -eq $script:PSArtifactTypeModule)
            {
                $message = $LocalizedData.ModuleDestination -f @($moduleDestination)
            }
            else
            {
                $message = $LocalizedData.ScriptDestination -f @($scriptDestination, $moduleDestination)
            }
            Write-Verbose $message
        }

        Write-Debug "ArtifactType is $artifactType"

        if($artifactType -eq $script:PSArtifactTypeModule)
        {
            # Test if module is already installed
            $InstalledModuleInfo = if(-not $IsSavePackage){ Test-ModuleInstalled -Name $packageName -RequiredVersion $RequiredVersion }

            if(-not $Force -and $InstalledModuleInfo)
            {
                $installedModPrerelease = $null
                if ((Get-Member -InputObject $InstalledModuleInfo -Name PrivateData -ErrorAction SilentlyContinue) -and `
                    $InstalledModuleInfo.PrivateData -and `
                    $InstalledModuleInfo.PrivateData.GetType().ToString() -eq "System.Collections.Hashtable" -and `
                    ($InstalledModuleInfo.PrivateData.ContainsKey('PSData')) -and `
                    $InstalledModuleInfo.PrivateData.PSData.GetType().ToString() -eq "System.Collections.Hashtable" -and `
                    ($InstalledModuleInfo.PrivateData.PSData.ContainsKey('Prerelease')))
                {
                    $installedModPrerelease = $InstalledModuleInfo.PrivateData.PSData.Prerelease
                }

                $result = ValidateAndGet-VersionPrereleaseStrings -Version $InstalledModuleInfo.Version -Prerelease $installedModPrerelease -CallerPSCmdlet $PSCmdlet
                if (-not $result)
                {
                    # ValidateAndGet-VersionPrereleaseStrings throws the error.
                    # returning to avoid further execution when different values are specified for -ErrorAction parameter
                    return
                }
                $installedModuleVersion = $result["Version"]
                $installedModulePrerelease = $result["Prerelease"]
                $installedModuleFullVersion = $result["FullVersion"]

                if($RequiredVersion -and (Test-ModuleSxSVersionSupport))
                {
                    # Check if the module with the required version is already installed otherwise proceed to install/update.
                    if($InstalledModuleInfo)
                    {
                        $message = $LocalizedData.ModuleWithRequiredVersionAlreadyInstalled -f ($InstalledModuleInfo.Version, $InstalledModuleInfo.Name, $InstalledModuleInfo.ModuleBase, $InstalledModuleInfo.Version)
                        Write-Error -Message $message -ErrorId "ModuleWithRequiredVersionAlreadyInstalled" -Category InvalidOperation
                        return
                    }
                }
                else
                {
                    if(-not $installUpdate)
                    {
                        if ($MinimumVersion)
                        {
                            $result = ValidateAndGet-VersionPrereleaseStrings -Version $MinimumVersion -CallerPSCmdlet $PSCmdlet
                            if (-not $result)
                            {
                                # ValidateAndGet-VersionPrereleaseStrings throws the error.
                                # returning to avoid further execution when different values are specified for -ErrorAction parameter
                                return
                            }
                            $minVersion = $result["Version"]
                            $minPrerelease = $result["Prerelease"]
                            $minFullVersion = $result["FullVersion"]
                        }
                        else
                        {
                            $minVersion = $null
                            $minPrerelease = $null
                            $minFullVersion = $null
                        }

                        if( (-not $MinimumVersion -and ($galleryItemFullVersion -ne $InstalledModuleFullVersion)) -or
                            ($MinimumVersion -and (Compare-PrereleaseVersions -FirstItemVersion $installedModuleVersion `
                                                                              -FirstItemPrerelease $installedModulePrerelease `
                                                                              -SecondItemVersion $minVersion `
                                                                              -SecondItemPrerelease $minPrerelease)))
                        {
                            if($PSVersionTable.PSVersion -ge '5.0.0')
                            {
                                $message = $LocalizedData.ModuleAlreadyInstalledSxS -f ($InstalledModuleFullVersion, $InstalledModuleInfo.Name, $InstalledModuleInfo.ModuleBase, $galleryItemFullVersion, $InstalledModuleFullVersion, $galleryItemFullVersion)
                            }
                            else
                            {
                                $message = $LocalizedData.ModuleAlreadyInstalled -f ($InstalledModuleFullVersion, $InstalledModuleInfo.Name, $InstalledModuleInfo.ModuleBase, $InstalledModuleFullVersion, $galleryItemFullVersion)
                            }
                            Write-Error -Message $message -ErrorId "ModuleAlreadyInstalled" -Category InvalidOperation
                        }
                        else
                        {
                            $message = $LocalizedData.ModuleAlreadyInstalledVerbose -f ($InstalledModuleFullVersion, $InstalledModuleInfo.Name, $InstalledModuleInfo.ModuleBase)
                            Write-Verbose $message
                        }

                        return
                    }
                    else
                    {
                        if (Compare-PrereleaseVersions -FirstItemVersion $installedModuleVersion `
                                                       -FirstItemPrerelease $installedModulePrerelease `
                                                       -SecondItemVersion $galleryItemVersion.ToString() `
                                                       -SecondItemPrerelease $galleryItemPrerelease)
                        {
                            $message = $LocalizedData.FoundModuleUpdate -f ($InstalledModuleInfo.Name, $galleryItemFullVersion)
                            Write-Verbose $message
                        }
                        else
                        {
                            $message = $LocalizedData.NoUpdateAvailable -f ($InstalledModuleInfo.Name)
                            Write-Verbose $message
                            return
                        }
                    }
                }
            }
        }

        if($artifactType -eq $script:PSArtifactTypeScript)
        {
            # Test if script is already installed
            $InstalledScriptInfo = if(-not $IsSavePackage){ Test-ScriptInstalled -Name $packageName }

            Write-Debug "InstalledScriptInfo is $InstalledScriptInfo"

            if(-not $Force -and $InstalledScriptInfo)
            {
                $result = ValidateAndGet-VersionPrereleaseStrings -Version $InstalledScriptInfo.Version -CallerPSCmdlet $PSCmdlet
                if (-not $result)
                {
                    # ValidateAndGet-VersionPrereleaseStrings throws the error.
                    # returning to avoid further execution when different values are specified for -ErrorAction parameter
                    return
                }
                $installedScriptInfoVersion = $result["Version"]
                $installedScriptInfoPrerelease = $result["Prerelease"]
                $installedScriptFullVersion = $result["FullVersion"]

                if(-not $installUpdate)
                {
                    if ($MinimumVersion)
                    {
                        $result = ValidateAndGet-VersionPrereleaseStrings -Version $MinimumVersion -CallerPSCmdlet $PSCmdlet
                        if (-not $result)
                        {
                            # ValidateAndGet-VersionPrereleaseStrings throws the error.
                            # returning to avoid further execution when different values are specified for -ErrorAction parameter
                            return
                        }
                        $minVersion = $result["Version"]
                        $minPrerelease = $result["Prerelease"]
                        $minFullVersion = $result["FullVersion"]
                    }
                    else
                    {
                        $minVersion = $null
                        $minPrerelease = $null
                        $minFullVersion = $null
                    }


                    if( (-not $MinimumVersion -and ($galleryItemFullVersion -ne $installedScriptFullVersion)) -or
                        ($MinimumVersion -and (Compare-PrereleaseVersions -FirstItemVersion $installedScriptInfoVersion `
                                                                          -FirstItemPrerelease $installedScriptInfoPrerelease `
                                                                          -SecondItemVersion $minVersion `
                                                                          -SecondItemPrerelease $minPrerelease) ))
                    {
                        $message = $LocalizedData.ScriptAlreadyInstalled -f ($installedScriptFullVersion, $InstalledScriptInfo.Name, $InstalledScriptInfo.ScriptBase, $installedScriptFullVersion, $galleryItemFullVersion)
                        Write-Error -Message $message -ErrorId "ScriptAlreadyInstalled" -Category InvalidOperation
                    }
                    else
                    {
                        $message = $LocalizedData.ScriptAlreadyInstalledVerbose -f ($installedScriptFullVersion, $InstalledScriptInfo.Name, $InstalledScriptInfo.ScriptBase)
                        Write-Verbose $message
                    }

                    return
                }
                else
                {
                    if (Compare-PrereleaseVersions -FirstItemVersion $installedScriptInfoVersion.ToString() `
                                                   -FirstItemPrerelease $installedScriptInfoPrerelease `
                                                   -SecondItemVersion $galleryItemVersion.ToString() `
                                                   -SecondItemPrerelease $galleryItemPrerelease)
                    {
                        $message = $LocalizedData.FoundScriptUpdate -f ($InstalledScriptInfo.Name, $version)
                        Write-Verbose $message
                    }
                    else
                    {
                        $message = $LocalizedData.NoScriptUpdateAvailable -f ($InstalledScriptInfo.Name)
                        Write-Verbose $message
                        return
                    }
                }
            }

            # Throw an error if there is a command with the same name and -force is not specified.
            if(-not $installUpdate -and
               -not $IsSavePackage -and
               -not $Force)
            {
                $cmd = Microsoft.PowerShell.Core\Get-Command -Name $packageName `
                                                             -ErrorAction Ignore `
                                                             -WarningAction SilentlyContinue
                if($cmd)
                {
                    $message = $LocalizedData.CommandAlreadyAvailable -f ($packageName)
                    Write-Error -Message $message -ErrorId CommandAlreadyAvailableWitScriptName -Category InvalidOperation
                    return
                }
            }
        }

        # create a temp folder and download the module
        $tempDestination = Microsoft.PowerShell.Management\Join-Path -Path $script:TempPath -ChildPath "$(Microsoft.PowerShell.Utility\Get-Random)"
        $null = Microsoft.PowerShell.Management\New-Item -Path $tempDestination -ItemType Directory -Force -Confirm:$false -WhatIf:$false

        try
        {
            $provider = $request.SelectProvider($providerName)
            if(-not $provider)
            {
                Write-Error -Message ($LocalizedData.PackageManagementProviderIsNotAvailable -f $providerName)
                return
            }

            if($request.IsCanceled)
            {
                return
            }

            Write-Verbose ($LocalizedData.SpecifiedLocationAndOGP -f ($provider.ProviderName, $providerName))

            $InstalledItemsList = $null
            $pkg = $script:FastPackRefHashtable[$fastPackageReference]

            # If an item has dependencies, prepare the list of installed items and
            # pass it to the NuGet provider to not download the already installed items.
            if($pkg.Dependencies.count -and
               -not $IsSavePackage -and
               -not $Force)
            {
                $InstalledItemsList = Microsoft.PowerShell.Core\Get-Module -ListAvailable |
                                        Microsoft.PowerShell.Core\ForEach-Object {"$($_.Name)!#!$($_.Version)".ToLower()}

                if($artifactType -eq $script:PSArtifactTypeScript)
                {
                    $InstalledItemsList += $script:PSGetInstalledScripts.GetEnumerator() |
                                               Microsoft.PowerShell.Core\ForEach-Object {
                                                   "$($_.Value.PSGetItemInfo.Name)!#!$($_.Value.PSGetItemInfo.Version)".ToLower()
                                               }
                }

                $InstalledItemsList | Select-Object -Unique -ErrorAction Ignore

                if($Debug)
                {
                    $InstalledItemsList | Microsoft.PowerShell.Core\ForEach-Object { Write-Debug -Message "Locally available Item: $_"}
                }
            }

            $ProviderOptions = @{
                                    Destination=$tempDestination;
                                }

            if($InstalledItemsList)
            {
                $ProviderOptions['InstalledPackages'] = $InstalledItemsList
            }

            $newRequest = $request.CloneRequest( $ProviderOptions, @($SourceLocation), $request.Credential )

            if($artifactType -eq $script:PSArtifactTypeModule)
            {
                $message = $LocalizedData.DownloadingModuleFromGallery -f ($packageName, $galleryItemFullVersion, $sourceLocation)
            }
            else
            {
                $message = $LocalizedData.DownloadingScriptFromGallery -f ($packageName, $galleryItemFullVersion, $sourceLocation)
            }
            Write-Verbose $message

            $installedPkgs = $provider.InstallPackage($script:FastPackRefHashtable[$fastPackageReference], $newRequest)

            $YesToAll = $false
            $NoToAll = $false
           
            foreach($pkg in $installedPkgs)
            {
                if($request.IsCanceled)
                {
                    return
                }

                $result = ValidateAndGet-VersionPrereleaseStrings -Version $pkg.Version -CallerPSCmdlet $PSCmdlet
                if (-not $result)
                {
                    # ValidateAndGet-VersionPrereleaseStrings throws the error.
                    # returning to avoid further execution when different values are specified for -ErrorAction parameter
                    return
                }
                $pkgVersion = $result["Version"]
                $pkgPrerelease = $result["Prerelease"]
                $pkgFullVersion = $result["FullVersion"]

                $destinationModulePath = Microsoft.PowerShell.Management\Join-Path -Path $moduleDestination -ChildPath $pkg.Name

                # Side-by-Side module version is available on PowerShell 5.0 or later versions only
                # By default, PowerShell module versions will be installed/updated Side-by-Side.
                if(Test-ModuleSxSVersionSupport)
                {
                    $destinationModulePath = Microsoft.PowerShell.Management\Join-Path -Path $destinationModulePath -ChildPath $pkgVersion
                }

                $destinationscriptPath = $scriptDestination

                # Get actual artifact type from the package
                $packageType = $script:PSArtifactTypeModule
                $installLocation = $destinationModulePath
                # Below logic handles the package folder name with version.
                $tempPackagePath = Microsoft.PowerShell.Management\Join-Path -Path $tempDestination -ChildPath "$($pkg.Name).$($pkg.Version)"
                if(-not (Microsoft.PowerShell.Management\Test-Path -Path $tempPackagePath -PathType Container))
                {
                    $message = $LocalizedData.UnableToDownloadThePackage -f ($provider.ProviderName, $pkg.Name, $pkg.Version, $tempPackagePath)
                    Write-Error -Message $message -ErrorId 'UnableToDownloadThePackage' -Category InvalidOperation
                    return
                }

                $packageFiles = Microsoft.PowerShell.Management\Get-ChildItem -Path $tempPackagePath -Recurse -Exclude "*.nupkg","*.nuspec"

                if($packageFiles -and $packageFiles.GetType().ToString() -eq 'System.IO.FileInfo' -and $packageFiles.Name -eq "$($pkg.Name).ps1")
                {
                    $packageType = $script:PSArtifactTypeScript
                    $installLocation = $destinationscriptPath
                }

                $AdditionalParams = @{}

                if(-not $IsSavePackage)
                {
                    # During the install operation:
                    #     InstalledDate should be the current Get-Date value
                    #     UpdatedDate should be null
                    #
                    # During the update operation:
                    #     InstalledDate should be from the previous version's InstalledDate otherwise current Get-Date value
                    #     UpdatedDate should be the current Get-Date value
                    #
                    $InstalledDate = Microsoft.PowerShell.Utility\Get-Date

                    if($installUpdate)
                    {
                        $AdditionalParams['UpdatedDate'] = Microsoft.PowerShell.Utility\Get-Date

                        $InstalledItemDetails = $null
                        if($packageType -eq $script:PSArtifactTypeModule)
                        {
                            $InstalledItemDetails = Get-InstalledModuleDetails -Name $pkg.Name | Select-Object -Last 1 -ErrorAction Ignore
                        }
                        elseif($packageType -eq $script:PSArtifactTypeScript)
                        {
                            $InstalledItemDetails = Get-InstalledScriptDetails -Name $pkg.Name | Select-Object -Last 1 -ErrorAction Ignore
                        }

                        if($InstalledItemDetails -and
                           $InstalledItemDetails.PSGetItemInfo -and
                           (Get-Member -InputObject $InstalledItemDetails.PSGetItemInfo -Name 'InstalledDate') -and
                           $InstalledItemDetails.PSGetItemInfo.InstalledDate)
                        {
                            $InstalledDate = $InstalledItemDetails.PSGetItemInfo.InstalledDate
                        }
                    }

                    $AdditionalParams['InstalledDate'] = $InstalledDate
                }

                # construct the PSGetItemInfo from SoftwareIdentity and persist it
                $psgItemInfo = New-PSGetItemInfo -SoftwareIdentity $pkg `
                                                 -PackageManagementProviderName $provider.ProviderName `
                                                 -SourceLocation $sourceLocation `
                                                 -Type $packageType `
                                                 -InstalledLocation $installLocation `
                                                 @AdditionalParams

                if($packageType -eq $script:PSArtifactTypeModule)
                {
                    if ($psgItemInfo.PowerShellGetFormatVersion -and
                        ($script:SupportedPSGetFormatVersionMajors -notcontains $psgItemInfo.PowerShellGetFormatVersion.Major))
                    {
                        $message = $LocalizedData.NotSupportedPowerShellGetFormatVersion -f ($psgItemInfo.Name, $psgItemInfo.PowerShellGetFormatVersion, $psgItemInfo.Name)
                        Write-Error -Message $message -ErrorId "NotSupportedPowerShellGetFormatVersion" -Category InvalidOperation
                        continue
                    }

                    $sourceModulePath = $tempPackagePath
                    if($psgItemInfo.PowerShellGetFormatVersion -eq "1.0")
                    {
                        $sourceModulePath = Microsoft.PowerShell.Management\Join-Path -Path $sourceModulePath -ChildPath 'Content' |
                            Microsoft.PowerShell.Management\Join-Path -ChildPath '*' |
                                Microsoft.PowerShell.Management\Join-Path -ChildPath $script:ModuleReferences |
                                    Microsoft.PowerShell.Management\Join-Path -ChildPath $pkg.Name
                    }

                    #Prompt if module requires license Acceptance
                    $requireLicenseAcceptance = $false
                    if($psgItemInfo.PowerShellGetFormatVersion -and
                       $psgItemInfo.PowerShellGetFormatVersion -ge $script:PSGetRequireLicenseAcceptanceFormatVersion)
                     {
                        if($psgItemInfo.AdditionalMetadata -and $psgItemInfo.AdditionalMetadata.requireLicenseAcceptance)
                        {
                              $requireLicenseAcceptance = $psgItemInfo.AdditionalMetadata.requireLicenseAcceptance
                        }
                    }

                    if($requireLicenseAcceptance -eq $true)
                    {
                        if($Force -and -not($AcceptLicense))
                        {
                            $message = $LocalizedData.ForceAcceptLicense -f $pkg.Name

                            ThrowError -ExceptionName "System.ArgumentException" `
                                       -ExceptionMessage $message `
                                       -ErrorId "ForceAcceptLicense" `
                                       -CallerPSCmdlet $PSCmdlet `
                                       -ErrorCategory InvalidArgument
                        }

                        If (-not ($YesToAll -or $NoToAll -or $AcceptLicense))
                        {
                            $LicenseFilePath = Join-PathUtility -Path $sourceModulePath -ChildPath 'License.txt' -PathType File
                            if(-not(Test-Path -Path $LicenseFilePath -PathType Leaf))
                            {
                                $message = $LocalizedData.LicenseTxtNotFound

                                ThrowError -ExceptionName "System.ArgumentException" `
                                           -ExceptionMessage $message `
                                           -ErrorId "LicenseTxtNotFound" `
                                           -CallerPSCmdlet $PSCmdlet `
                                           -ErrorCategory ObjectNotFound
                            }
                            $FormattedEula = (Get-Content -Path $LicenseFilePath) -Join "`r`n"
                            $message = $FormattedEula + "`r`n" + ($LocalizedData.AcceptanceLicenseQuery -f $pkg.Name)
                            $title = $LocalizedData.AcceptLicense
                            $result = $request.ShouldContinue($message, $title, [ref]$yesToAll, [ref]$NoToAll)
                            if(($result -eq $false) -or ($NoToAll -eq $true))
                            {
                                Write-Warning -Message $LocalizedData.UserDeclinedLicenseAcceptance
                                return
                            }
                        }
                    }

                    $CurrentModuleInfo = $null

                    # Validate the module
                    if(-not $IsSavePackage)
                    {
                        $CurrentModuleInfo = Test-ValidManifestModule -ModuleBasePath $sourceModulePath `
                                                                      -ModuleName $pkg.Name `
                                                                      -InstallLocation $InstallLocation `
                                                                      -AllowClobber:$AllowClobber `
                                                                      -SkipPublisherCheck:$SkipPublisherCheck `
                                                                      -IsUpdateOperation:$installUpdate

                        if(-not $CurrentModuleInfo)
                        {
                            Write-Verbose -Message ($LocalizedData.ModuleValidationFailed -f $ModuleName,$ModuleBasePath)
                            # This Install-Package provider API gets called once per an item/package/SoftwareIdentity.
                            # Return if there is an error instead of continuing further to install the dependencies or current module.
                            #
                            return
                        }
                    }

                    # Test if module is already installed
                    $InstalledModuleInfo2 = if(-not $IsSavePackage){ Test-ModuleInstalled -Name $pkg.Name -RequiredVersion $pkgFullVersion }

                    if($pkg.Name -ne $packageName)
                    {
                        if(-not $Force -and $InstalledModuleInfo2)
                        {
                            $result = ValidateAndGet-VersionPrereleaseStrings -Version $InstalledModuleInfo2.Version -CallerPSCmdlet $PSCmdlet
                            if (-not $result)
                            {
                                # ValidateAndGet-VersionPrereleaseStrings throws the error.
                                # returning to avoid further execution when different values are specified for -ErrorAction parameter
                                return
                            }
                            $installedModuleVersion = $result["Version"]
                            $installedModulePrerelease = $result["Prerelease"]
                            $installedModuleFullVersion = $result["FullVersion"]

                            if(Test-ModuleSxSVersionSupport)
                            {
                                if($pkgFullVersion -eq $installedModuleFullVersion)
                                {
                                    if(-not $installUpdate)
                                    {
                                        $message = $LocalizedData.ModuleWithRequiredVersionAlreadyInstalled -f ($installedModuleFullVersion, $InstalledModuleInfo2.Name, $InstalledModuleInfo2.ModuleBase, $InstalledModuleFullVersion)
                                    }
                                    else
                                    {
                                        $message = $LocalizedData.NoUpdateAvailable -f ($pkg.Name)
                                    }

                                    Write-Verbose $message
                                    Continue
                                }
                            }
                            else
                            {
                                if(-not $installUpdate)
                                {
                                    $message = $LocalizedData.ModuleAlreadyInstalledVerbose -f ($InstalledModuleFullVersion, $InstalledModuleInfo2.Name, $InstalledModuleInfo2.ModuleBase)
                                    Write-Verbose $message
                                    Continue
                                }
                                else
                                {
                                    if(Compare-PrereleaseVersions -FirstItemVersion $installedModuleVersion.ToString() `
                                                                  -FirstItemPrerelease $installedModPrerelease `
                                                                  -SecondItemVersion $pkgVersion.ToString() `
                                                                  -SecondItemPrerelease $pkgPrerelease)
                                    {
                                        $message = $LocalizedData.FoundModuleUpdate -f ($pkg.Name, $pkgFullVersion)
                                        Write-Verbose $message
                                    }
                                    else
                                    {
                                        $message = $LocalizedData.NoUpdateAvailable -f ($pkg.Name)
                                        Write-Verbose $message
                                        Continue
                                    }
                                }
                            }
                        }

                        if($IsSavePackage)
                        {
                            $DependencyInstallMessage = $LocalizedData.SavingDependencyModule -f ($pkg.Name, $pkgFullVersion, $packageName)
                        }
                        else
                        {
                            $DependencyInstallMessage = $LocalizedData.InstallingDependencyModule -f ($pkg.Name, $pkgFullVersion, $packageName)
                        }

                        Write-Verbose  $DependencyInstallMessage
                    }

                    # check if module is in use
                    if($InstalledModuleInfo2)
                    {
                        $moduleInUse = Test-ModuleInUse -ModuleBasePath $InstalledModuleInfo2.ModuleBase `
                                                        -ModuleName $InstalledModuleInfo2.Name `
                                                        -ModuleVersion $InstalledModuleInfo2.Version `
                                                        -Verbose:$VerbosePreference `
                                                        -WarningAction $WarningPreference `
                                                        -ErrorAction $ErrorActionPreference `
                                                        -Debug:$DebugPreference

                        if($moduleInUse)
                        {
                            $message = $LocalizedData.ModuleIsInUse -f ($psgItemInfo.Name)
                            Write-Verbose $message
                            continue
                        }
                    }

                    # Use the actual module version retrieved from the module manifest.
                    if($CurrentModuleInfo -and (Test-ModuleSxSVersionSupport) -and -not $pkgPrerelease)
                    {
                        $destinationModulePath = Microsoft.PowerShell.Management\Join-Path -Path $moduleDestination -ChildPath $pkg.Name |
                            Microsoft.PowerShell.Management\Join-Path -ChildPath $CurrentModuleInfo.Version
                        $installLocation = $destinationModulePath
                        $psgItemInfo.InstalledLocation = $installLocation
                        $psgItemInfo.Version = $CurrentModuleInfo.Version
                    }

                    Copy-Module -SourcePath $sourceModulePath -DestinationPath $destinationModulePath -PSGetItemInfo $psgItemInfo -IsSavePackage:$IsSavePackage

                    if(-not $IsSavePackage)
                    {
                        # Write warning messages if externally managed module dependencies are not installed.
                        $ExternalModuleDependencies = Get-ExternalModuleDependencies -PSModuleInfo $CurrentModuleInfo
                        foreach($ExternalDependency in $ExternalModuleDependencies)
                        {
                            $depModuleInfo = Test-ModuleInstalled -Name $ExternalDependency

                            if(-not $depModuleInfo)
                            {
                                Write-Warning -Message ($LocalizedData.MissingExternallyManagedModuleDependency -f $ExternalDependency,$pkg.Name,$ExternalDependency)
                            }
                            else
                            {
                                Write-Verbose -Message ($LocalizedData.ExternallyManagedModuleDependencyIsInstalled -f $ExternalDependency)
                            }
                        }
                    }

                    if($IsSavePackage)
                    {
                        $message = $LocalizedData.ModuleSavedSuccessfully -f ($psgItemInfo.Name, $installLocation)
                    }
                    else
                    {
                        $message = $LocalizedData.ModuleInstalledSuccessfully -f ($psgItemInfo.Name, $installLocation)
                    }
                    Write-Verbose $message
                }


                if($packageType -eq $script:PSArtifactTypeScript)
                {
                    if ($psgItemInfo.PowerShellGetFormatVersion -and
                        ($script:SupportedPSGetFormatVersionMajors -notcontains $psgItemInfo.PowerShellGetFormatVersion.Major))
                    {
                        $message = $LocalizedData.NotSupportedPowerShellGetFormatVersionScripts -f ($psgItemInfo.Name, $psgItemInfo.PowerShellGetFormatVersion, $psgItemInfo.Name)
                        Write-Error -Message $message -ErrorId "NotSupportedPowerShellGetFormatVersion" -Category InvalidOperation
                        continue
                    }

                    $sourceScriptPath = Join-PathUtility -Path $tempPackagePath -ChildPath "$($pkg.Name).ps1" -PathType File

                    $currentScriptInfo = $null
                    if(-not $IsSavePackage)
                    {
                        # Validate the script
                        $currentScriptInfo = Test-ScriptFileInfo -Path $sourceScriptPath -ErrorAction SilentlyContinue

                        if(-not $currentScriptInfo)
                        {
                            $message = $LocalizedData.InvalidPowerShellScriptFile -f ($pkg.Name)
                            Write-Error -Message $message -ErrorId "InvalidPowerShellScriptFile" -Category InvalidOperation -TargetObject $pkg.Name
                            continue
                        }

                        # Use the version extracted from the script file.
                        $psgItemInfo.Version = $currentScriptInfo.Version
                    }

                    # Test if script is already installed
                    $InstalledScriptInfo2 = if(-not $IsSavePackage){ Test-ScriptInstalled -Name $pkg.Name }


                    if($pkg.Name -ne $packageName)
                    {
                        if(-not $Force -and $InstalledScriptInfo2)
                        {
                            $result = ValidateAndGet-VersionPrereleaseStrings -Version $InstalledScriptInfo2.Version -CallerPSCmdlet $PSCmdlet
                            if (-not $result)
                            {
                                # ValidateAndGet-VersionPrereleaseStrings throws the error.
                                # returning to avoid further execution when different values are specified for -ErrorAction parameter
                                return
                            }
                            $installedScriptFullVersion = $result["FullVersion"]

                            if(-not $installUpdate)
                            {
                                $message = $LocalizedData.ScriptAlreadyInstalledVerbose -f ($InstalledScriptFullVersion, $InstalledScriptInfo2.Name, $InstalledScriptInfo2.ScriptBase)
                                Write-Verbose $message
                                Continue
                            }
                            else
                            {
                                if(Compare-PrereleaseVersions -FirstItemVersion $installedScriptInfoVersion.ToString() `
                                                              -FirstItemPrerelease $installedScriptInfoPrerelease `
                                                              -SecondItemVersion $pkgVersion `
                                                              -SecondItemPrerelease $pkgPrerelease)
                                {
                                    $message = $LocalizedData.FoundScriptUpdate -f ($pkg.Name, $pkgFullVersion)
                                    Write-Verbose $message
                                }
                                else
                                {
                                    $message = $LocalizedData.NoScriptUpdateAvailable -f ($pkg.Name)
                                    Write-Verbose $message
                                    Continue
                                }
                            }
                        }

                        if($IsSavePackage)
                        {
                            $DependencyInstallMessage = $LocalizedData.SavingDependencyScript -f ($pkg.Name, $pkgFullVersion, $packageName)
                        }
                        else
                        {
                            $DependencyInstallMessage = $LocalizedData.InstallingDependencyScript -f ($pkg.Name, $pkgFullVersion, $packageName)
                        }

                        Write-Verbose  $DependencyInstallMessage
                    }

                    Write-Debug "SourceScriptPath is $sourceScriptPath and DestinationscriptPath is $destinationscriptPath"
                    Copy-ScriptFile -SourcePath $sourceScriptPath -DestinationPath $destinationscriptPath -PSGetItemInfo $psgItemInfo -Scope $Scope

                    if(-not $IsSavePackage)
                    {
                        # Write warning messages if externally managed module dependencies are not installed.
                        foreach($ExternalDependency in $currentScriptInfo.ExternalModuleDependencies)
                        {
                            $depModuleInfo = Test-ModuleInstalled -Name $ExternalDependency

                            if(-not $depModuleInfo)
                            {
                                Write-Warning -Message ($LocalizedData.ScriptMissingExternallyManagedModuleDependency -f $ExternalDependency,$pkg.Name,$ExternalDependency)
                            }
                            else
                            {
                                Write-Verbose -Message ($LocalizedData.ExternallyManagedModuleDependencyIsInstalled -f $ExternalDependency)
                            }
                        }

                        # Write warning messages if externally managed script dependencies are not installed.
                        foreach($ExternalDependency in $currentScriptInfo.ExternalScriptDependencies)
                        {
                            $depScriptInfo = Test-ScriptInstalled -Name $ExternalDependency

                            if(-not $depScriptInfo)
                            {
                                Write-Warning -Message ($LocalizedData.ScriptMissingExternallyManagedScriptDependency -f $ExternalDependency,$pkg.Name,$ExternalDependency)
                            }
                            else
                            {
                                Write-Verbose -Message ($LocalizedData.ScriptExternallyManagedScriptDependencyIsInstalled -f $ExternalDependency)
                            }
                        }
                    }

                    # Remove the old scriptfile if it's path different from the required destination script path when -Force is specified
                    if($Force -and
                        $InstalledScriptInfo2 -and
                        -not $destinationscriptPath.StartsWith($InstalledScriptInfo2.ScriptBase, [System.StringComparison]::OrdinalIgnoreCase))
                    {
                        Microsoft.PowerShell.Management\Remove-Item -Path $InstalledScriptInfo2.Path `
                                                                    -Force `
                                                                    -ErrorAction SilentlyContinue `
                                                                    -WarningAction SilentlyContinue `
                                                                    -Confirm:$false -WhatIf:$false
                    }

                    if($IsSavePackage)
                    {
                        $message = $LocalizedData.ScriptSavedSuccessfully -f ($psgItemInfo.Name, $installLocation)
                    }
                    else
                    {
                        $message = $LocalizedData.ScriptInstalledSuccessfully -f ($psgItemInfo.Name, $installLocation)
                    }
                    Write-Verbose $message
                }

                $sid = New-SoftwareIdentityFromPackage -Package $pkg `
                    -SourceLocation $sourceLocation `
                    -PackageManagementProviderName $provider.ProviderName `
                    -Request $request `
                    -Type $packageType `
                    -InstalledLocation $installLocation `
                    @AdditionalParams

                Write-Output -InputObject $sid
            }
        }
        finally
        {
            Microsoft.PowerShell.Management\Remove-Item $tempDestination -Force -Recurse -ErrorAction SilentlyContinue -WarningAction SilentlyContinue -Confirm:$false -WhatIf:$false
        }
    }
}
function Join-PathUtility
{
    <#
    .DESCRIPTION
        Utility to get the case-sensitive path, if exists.
        Otherwise, returns the output of Join-Path cmdlet.
        This is required for getting the case-sensitive paths on non-Windows platforms.
    #>
    param
    (
        [Parameter(Mandatory = $true)]
        [string]
        $Path,

        [Parameter(Mandatory = $false)]
        [string]
        $ChildPath,

        [Parameter(Mandatory = $true)]
        [string]
        [ValidateSet('File', 'Directory', 'Any')]
        $PathType = 'Any'
    )

    $JoinedPath = Microsoft.PowerShell.Management\Join-Path -Path $Path -ChildPath $ChildPath
    if(Microsoft.PowerShell.Management\Test-Path -Path $Path -PathType Container) {
        $GetChildItem_params = @{
            Path = $Path
            ErrorAction = 'SilentlyContinue'
            WarningAction = 'SilentlyContinue'
        }
        if($PathType -eq 'File') {
            $GetChildItem_params['File'] = $true
        }
        elseif($PathType -eq 'Directory') {
            $GetChildItem_params['Directory'] = $true
        }

        $FoundPath = Microsoft.PowerShell.Management\Get-ChildItem @GetChildItem_params |
            Where-Object {$_.Name -eq $ChildPath} |
                ForEach-Object {$_.FullName} |
                    Select-Object -First 1 -ErrorAction SilentlyContinue

        if($FoundPath) {
            $JoinedPath = $FoundPath
        }
    }

    return $JoinedPath
}
function Log-ArtifactNotFoundInPSGallery
{
    [CmdletBinding()]
    Param
    (
        [Parameter()]
        [string[]]
        $SearchedName,

        [Parameter()]
        [string[]]
        $FoundName,

        [Parameter(Mandatory=$true)]
        [string]
        $operationName
    )

    if (-not $script:TelemetryEnabled)
    {
        return
    }

    if(-not $SearchedName)
    {
        return
    }

    $SearchedNameNoWildCards = @()

    # Ignore wild cards
    foreach ($artifactName in $SearchedName)
    {
        if (-not (Test-WildcardPattern $artifactName))
        {
            $SearchedNameNoWildCards += $artifactName
        }
    }

    # Find artifacts searched, but not found in the specified gallery
    $notFoundArtifacts = @()
    foreach ($element in $SearchedNameNoWildCards)
    {
        if (-not ($FoundName -contains $element))
        {
            $notFoundArtifacts += $element
        }
    }

    # Perform Telemetry only if searched artifacts are not available in specified Gallery
    if ($notFoundArtifacts)
    {
        [Microsoft.PowerShell.Commands.PowerShellGet.Telemetry]::TraceMessageArtifactsNotFound($notFoundArtifacts, $operationName)
    }
}
function Log-NonPSGalleryRegistration
# Function to record non-PSGallery registration for telemetry
# Function consumes the type of registration (i.e hosted (http(s)), non-hosted (file/unc)), locations, installation policy, provider and event name
{
    [CmdletBinding()]
    Param
    (
        [Parameter()]
        [string]
        $sourceLocation,

        [Parameter()]
        [string]
        $installationPolicy,

        [Parameter()]
        [string]
        $packageManagementProvider,

        [Parameter()]
        [string]
        $publishLocation,

        [Parameter()]
        [string]
        $scriptSourceLocation,

        [Parameter()]
        [string]
        $scriptPublishLocation,

        [Parameter(Mandatory=$true)]
        [string]
        $operationName
    )

    if (-not $script:TelemetryEnabled)
    {
        return
    }

    # Initialize source location type - this can be hosted (http(s)) or not hosted (unc/file)
    $sourceLocationType = "NON_WEB_HOSTED"
    if (Test-WebUri -uri $sourceLocation)
    {
        $sourceLocationType = "WEB_HOSTED"
    }

    # Create a hash of the source location
    # We cannot log the actual source location, since this might contain PII (Personally identifiable information) data
    $sourceLocationHash = Get-Hash -locationString $sourceLocation
    $publishLocationHash = Get-Hash -locationString $publishLocation
    $scriptSourceLocationHash = Get-Hash -locationString $scriptSourceLocation
    $scriptPublishLocationHash = Get-Hash -locationString $scriptPublishLocation

    # Log the telemetry event
    [Microsoft.PowerShell.Commands.PowerShellGet.Telemetry]::TraceMessageNonPSGalleryRegistration($sourceLocationType, $sourceLocationHash, $installationPolicy, $packageManagementProvider, $publishLocationHash, $scriptSourceLocationHash, $scriptPublishLocationHash, $operationName)
}
function New-FastPackageReference
{
    param
    (
        [Parameter(Mandatory=$true)]
        [string]
        $ProviderName,

        [Parameter(Mandatory=$true)]
        [string]
        $PackageName,

        [Parameter(Mandatory=$true)]
        [string]
        $Version,

        [Parameter(Mandatory=$true)]
        [string]
        $Source,

        [Parameter(Mandatory=$true)]
        [string]
        $ArtifactType
    )

    return "$ProviderName|$PackageName|$Version|$Source|$ArtifactType"
}
function New-ModuleSourceFromPackageSource
{
    param
    (
        [Parameter(Mandatory=$true)]
        $PackageSource
    )

    $moduleSource = Microsoft.PowerShell.Utility\New-Object PSCustomObject -Property ([ordered]@{
            Name = $PackageSource.Name
            SourceLocation =  $PackageSource.Location
            Trusted=$PackageSource.IsTrusted
            Registered=$PackageSource.IsRegistered
            InstallationPolicy = $PackageSource.Details['InstallationPolicy']
            PackageManagementProvider=$PackageSource.Details['PackageManagementProvider']
            PublishLocation=$PackageSource.Details[$script:PublishLocation]
            ScriptSourceLocation=$PackageSource.Details[$script:ScriptSourceLocation]
            ScriptPublishLocation=$PackageSource.Details[$script:ScriptPublishLocation]
            ProviderOptions = @{}
        })

    $PackageSource.Details.GetEnumerator() | Microsoft.PowerShell.Core\ForEach-Object {
                                                if($_.Key -ne 'PackageManagementProvider' -and
                                                   $_.Key -ne $script:PublishLocation -and
                                                   $_.Key -ne $script:ScriptPublishLocation -and
                                                   $_.Key -ne $script:ScriptSourceLocation -and
                                                   $_.Key -ne 'InstallationPolicy')
                                                {
                                                    $moduleSource.ProviderOptions[$_.Key] = $_.Value
                                                }
                                             }

    $moduleSource.PSTypeNames.Insert(0, "Microsoft.PowerShell.Commands.PSRepository")

    # return the module source object.
    Write-Output -InputObject $moduleSource
}
function New-NugetPackage {
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory = $true)]
        [string]$NuspecPath,

        [Parameter(Mandatory = $true)]
        [string]$NugetPackageRoot,

        [Parameter()]
        [string]$OutputPath = $NugetPackageRoot,

        [Parameter(Mandatory = $true, ParameterSetName = "UseNuget")]
        [string]$NugetExePath,

        [Parameter(ParameterSetName = "UseDotnetCli")]
        [switch]$UseDotnetCli

    )
    Set-StrictMode -Off

    Write-Verbose "Calling New-NugetPackage"

    if (-Not(Test-Path -Path $NuspecPath -PathType Leaf)) {
        throw "A nuspec file does not exist at $NuspecPath, provide valid path to a .nuspec"
    }

    if (-Not(Test-Path -Path $NugetPackageRoot)) {
        throw "NugetPackageRoot $NugetPackageRoot does not exist"
    }

    $processStartInfo = New-Object System.Diagnostics.ProcessStartInfo

    if ($PSCmdlet.ParameterSetName -eq "UseNuget") {
        if (-Not(Test-Path -Path $NuGetExePath)) {
            throw "Nuget.exe does not exist at $NugetExePath, provide a valid path to nuget.exe"
        }
        $ProcessName = $NugetExePath

        $ArgumentList = @("pack")
        $ArgumentList += "`"$NuspecPath`""
        $ArgumentList += "-outputdirectory `"$OutputPath`" -noninteractive"

        $tempPath = $null
    }
    else {
        # use Dotnet CLI

        #perform dotnet pack using a temporary project file.
        $ProcessName = (Get-Command -Name "dotnet").Source
        $tempPath = Join-Path -Path ([System.IO.Path]::GetTempPath()) -ChildPath ([System.Guid]::NewGuid()).Guid
        New-Item -ItemType Directory -Path $tempPath -Force | Out-Null

        $CsprojContent = @"
<Project Sdk="Microsoft.NET.Sdk">
<PropertyGroup>
    <AssemblyName>NotUsed</AssemblyName>
    <Description>Temp project used for creating nupkg file.</Description>
    <TargetFramework>netcoreapp2.0</TargetFramework>
    <IsPackable>true</IsPackable>
</PropertyGroup>
</Project>
"@
        $projectFile = New-Item -ItemType File -Path $tempPath -Name "Temp.csproj"
        Set-Content -Value $CsprojContent -Path $projectFile

        $ArgumentList = @("pack")
        $ArgumentList += "`"$projectFile`""
        $ArgumentList += "/p:NuspecFile=`"$NuspecPath`""
        $ArgumentList += "--output `"$OutputPath`""
    }

    # run the packing program
    $processStartInfo = New-Object System.Diagnostics.ProcessStartInfo
    $processStartInfo.FileName = $ProcessName
    $processStartInfo.Arguments = $ArgumentList
    $processStartInfo.RedirectStandardError = $true
    $processStartInfo.RedirectStandardOutput = $true
    $processStartInfo.UseShellExecute = $false

    Write-Verbose "Calling $ProcessName $($ArgumentList -join ' ')"
    $process = New-Object System.Diagnostics.Process
    $process.StartInfo = $processStartInfo

    $process.Start() | Out-Null

    # read output incrementally, it'll block if it writes too much
    $outputLines = @()
    Write-Verbose "$ProcessName output:"
    while (! $process.HasExited) {
        $output = $process.StandardOutput.ReadLine()
        Write-Verbose "`t$output"
        $outputLines += $output
    }

    # get any remaining output
    $process.WaitForExit()
    $outputLines += $process.StandardOutput.ReadToEnd()

    $stdOut = $outputLines -join "`n"

    Write-Verbose "finished running $($processStartInfo.FileName) with exit code $($process.ExitCode)"

    if (($tempPath -ne $null) -and (Test-Path -Path $tempPath)) {
        Remove-Item -Path $tempPath -Force -Recurse
    }

    if (-Not ($process.ExitCode -eq 0 )) {
        # nuget writes errors to stdErr, dotnet writes them to stdOut
        if ($UseDotnetCli) {
            $errors = $stdOut
        }
        else {
            $errors = $process.StandardError.ReadToEnd()
        }
        throw "$ProcessName failed to pack: error $errors"
    }

    $stdOut -match "Successfully created package '(.*.nupkg)'" | Out-Null
    $nupkgFullFile = $matches[1]

    Write-Verbose "Created Nuget Package $nupkgFullFile"
    Write-Output $nupkgFullFile
}
function New-NuspecFile {
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory = $true)]
        [string]$OutputPath,

        [Parameter(Mandatory = $true)]
        [string]$Id,

        [Parameter(Mandatory = $true)]
        [string]$Version,

        [Parameter(Mandatory = $true)]
        [string]$Description,

        [Parameter(Mandatory = $true)]
        [string[]]$Authors,

        [Parameter()]
        [string[]]$Owners,

        [Parameter()]
        [string]$ReleaseNotes,

        [Parameter()]
        [bool]$RequireLicenseAcceptance,

        [Parameter()]
        [string]$Copyright,

        [Parameter()]
        [string[]]$Tags,

        [Parameter()]
        [string]$LicenseUrl,

        [Parameter()]
        [string]$ProjectUrl,

        [Parameter()]
        [string]$IconUrl,

        [Parameter()]
        [PSObject[]]$Dependencies,

        [Parameter()]
        [PSObject[]]$Files

    )
    Set-StrictMode -Off

    Write-Verbose "Calling New-NuspecFile"

    $nameSpaceUri = "http://schemas.microsoft.com/packaging/2011/08/nuspec.xsd"
    [xml]$xml = New-Object System.Xml.XmlDocument

    $xmlDeclaration = $xml.CreateXmlDeclaration("1.0", "utf-8", $null)
    $xml.AppendChild($xmlDeclaration) | Out-Null

    #create top-level elements
    $packageElement = $xml.CreateElement("package", $nameSpaceUri)
    $metaDataElement = $xml.CreateElement("metadata", $nameSpaceUri)

    # warn we're over 4000 characters for standard nuget servers
    $tagsString = $Tags -Join " "
    if ($tagsString.Length -gt 4000) {
        Write-Warning -Message "Tag list exceeded 4000 characters and may not be accepted by some Nuget feeds."
    }

    $metaDataElementsHash = [ordered]@{
        id                       = $Id
        version                  = $Version
        description              = $Description
        authors                  = $Authors -Join ","
        owners                   = $Owners -Join ","
        releaseNotes             = $ReleaseNotes
        requireLicenseAcceptance = $RequireLicenseAcceptance.ToString().ToLower()
        copyright                = $Copyright
        tags                     = $tagsString
    }

    if ($LicenseUrl) { $metaDataElementsHash.Add("licenseUrl", $LicenseUrl) }
    if ($ProjectUrl) { $metaDataElementsHash.Add("projectUrl", $ProjectUrl) }
    if ($IconUrl) { $metaDataElementsHash.Add("iconUrl", $IconUrl) }

    foreach ($key in $metaDataElementsHash.Keys) {
        $element = $xml.CreateElement($key, $nameSpaceUri)
        $elementInnerText = $metaDataElementsHash.item($key)
        $element.InnerText = $elementInnerText

        $metaDataElement.AppendChild($element) | Out-Null
    }


    if ($Dependencies) {
        $dependenciesElement = $xml.CreateElement("dependencies", $nameSpaceUri)

        foreach ($dependency in $Dependencies) {
            $element = $xml.CreateElement("dependency", $nameSpaceUri)
            $element.SetAttribute("id", $dependency.id)
            if ($dependency.version) { $element.SetAttribute("version", $dependency.version) }

            $dependenciesElement.AppendChild($element) | Out-Null
        }
        $metaDataElement.AppendChild($dependenciesElement) | Out-Null
    }

    if ($Files) {
        $filesElement = $xml.CreateElement("files", $nameSpaceUri)

        foreach ($file in $Files) {
            $element = $xml.CreateElement("file", $nameSpaceUri)
            $element.SetAttribute("src", $file.src)
            if ($file.target) { $element.SetAttribute("target", $file.target) }
            if ($file.exclude) { $element.SetAttribute("exclude", $file.exclude) }

            $filesElement.AppendChild($element) | Out-Null
        }
    }

    $packageElement.AppendChild($metaDataElement) | Out-Null
    if ($filesElement) { $packageElement.AppendChild($filesElement) | Out-Null }

    $xml.AppendChild($packageElement) | Out-Null

    $nuspecFullName = Join-Path -Path $OutputPath -ChildPath "$Id.nuspec"
    $xml.save($nuspecFullName)

    Write-Output $nuspecFullName
}
function New-PackageSourceFromModuleSource
{
    param
    (
        [Parameter(Mandatory=$true)]
        $ModuleSource
    )

    $ScriptSourceLocation = $null
    if(Get-Member -InputObject $ModuleSource -Name $script:ScriptSourceLocation)
    {
        $ScriptSourceLocation = $ModuleSource.ScriptSourceLocation
    }

    $ScriptPublishLocation = $ModuleSource.PublishLocation
    if(Get-Member -InputObject $ModuleSource -Name $script:ScriptPublishLocation)
    {
        $ScriptPublishLocation = $ModuleSource.ScriptPublishLocation
    }

    $packageSourceDetails = @{}
    $packageSourceDetails["InstallationPolicy"] = $ModuleSource.InstallationPolicy
    $packageSourceDetails["PackageManagementProvider"] = (Get-ProviderName -PSCustomObject $ModuleSource)
    $packageSourceDetails[$script:PublishLocation] = $ModuleSource.PublishLocation
    $packageSourceDetails[$script:ScriptSourceLocation] = $ScriptSourceLocation
    $packageSourceDetails[$script:ScriptPublishLocation] = $ScriptPublishLocation

    $ModuleSource.ProviderOptions.GetEnumerator() | Microsoft.PowerShell.Core\ForEach-Object {
                                                        $packageSourceDetails[$_.Key] = $_.Value
                                                    }

    # create a new package source
    $src =  New-PackageSource -Name $ModuleSource.Name `
                              -Location $ModuleSource.SourceLocation `
                              -Trusted $ModuleSource.Trusted `
                              -Registered $ModuleSource.Registered `
                              -Details $packageSourceDetails

    Write-Verbose ( $LocalizedData.RepositoryDetails -f ($src.Name, $src.Location, $src.IsTrusted, $src.IsRegistered) )

    # return the package source object.
    Write-Output -InputObject $src
}
function New-PSGetItemInfo
{
    param
    (
        [Parameter(Mandatory=$true)]
        $SoftwareIdentity,

        [Parameter()]
        $PackageManagementProviderName,

        [Parameter()]
        [string]
        $SourceLocation,

        [Parameter(Mandatory=$true)]
        [string]
        $Type,

        [Parameter()]
        [string]
        $InstalledLocation,

        [Parameter()]
        [System.DateTime]
        $InstalledDate,

        [Parameter()]
        [System.DateTime]
        $UpdatedDate
    )

    foreach($swid in $SoftwareIdentity)
    {

        if($SourceLocation)
        {
            $sourceName = (Get-SourceName -Location $SourceLocation)
        }
        else
        {
            # First get the source name from the Metadata
            # if not exists, get the source name from $swid.Source
            # otherwise default to $swid.Source
            $sourceName = (Get-First $swid.Metadata["SourceName"])

            if(-not $sourceName)
            {
                $sourceName = (Get-SourceName -Location $swid.Source)
            }

            if(-not $sourceName)
            {
                $sourceName = $swid.Source
            }

            $SourceLocation = Get-SourceLocation -SourceName $sourceName
        }

        $published = (Get-First $swid.Metadata["published"])
        $PublishedDate = New-Object System.DateTime

        $InstalledDateString = (Get-First $swid.Metadata['installeddate'])
        if(-not $InstalledDate -and $InstalledDateString)
        {
            $InstalledDate = New-Object System.DateTime
            if(-not (([System.DateTime]::TryParse($InstalledDateString, [System.Globalization.DateTimeFormatInfo]::InvariantInfo, [System.Globalization.DateTimeStyles]::None, ([ref]$InstalledDate))) -or
                     ([System.DateTime]::TryParse($InstalledDateString, ([ref]$InstalledDate)))))
            {
                $InstalledDate = $null
            }
        }

        $UpdatedDateString = (Get-First $swid.Metadata['updateddate'])
        if(-not $UpdatedDate -and $UpdatedDateString)
        {
            $UpdatedDate = New-Object System.DateTime
            if(-not (([System.DateTime]::TryParse($UpdatedDateString, [System.Globalization.DateTimeFormatInfo]::InvariantInfo, [System.Globalization.DateTimeStyles]::None, ([ref]$UpdatedDate))) -or
                     ([System.DateTime]::TryParse($UpdatedDateString, ([ref]$UpdatedDate)))))
            {
                $UpdatedDate = $null
            }
        }

        $tags = (Get-First $swid.Metadata["tags"]) -split " "
        $userTags = @()

        $exportedDscResources = @()
        $exportedRoleCapabilities = @()
        $exportedCmdlets = @()
        $exportedFunctions = @()
        $exportedWorkflows = @()
        $exportedCommands = @()

        $exportedRoleCapabilities += (Get-First $swid.Metadata['RoleCapabilities']) -split " " | Microsoft.PowerShell.Core\Where-Object { $_.Trim() }
        $exportedDscResources += (Get-First $swid.Metadata["DscResources"]) -split " " | Microsoft.PowerShell.Core\Where-Object { $_.Trim() }
        $exportedCmdlets += (Get-First $swid.Metadata["Cmdlets"]) -split " " | Microsoft.PowerShell.Core\Where-Object { $_.Trim() }
        $exportedFunctions += (Get-First $swid.Metadata["Functions"]) -split " " | Microsoft.PowerShell.Core\Where-Object { $_.Trim() }
        $exportedWorkflows += (Get-First $swid.Metadata["Workflows"]) -split " " | Microsoft.PowerShell.Core\Where-Object { $_.Trim() }
        $exportedCommands += $exportedCmdlets + $exportedFunctions + $exportedWorkflows
        $PSGetFormatVersion = $null

        ForEach($tag in $tags)
        {
            if(-not $tag.Trim())
            {
                continue
            }

            $parts = $tag -split "_",2
            if($parts.Count -ne 2)
            {
                $userTags += $tag
                continue
            }

            Switch($parts[0])
            {
                $script:Command            { $exportedCommands += $parts[1]; break }
                $script:DscResource        { $exportedDscResources += $parts[1]; break }
                $script:Cmdlet             { $exportedCmdlets += $parts[1]; break }
                $script:Function           { $exportedFunctions += $parts[1]; break }
                $script:Workflow           { $exportedWorkflows += $parts[1]; break }
                $script:RoleCapability     { $exportedRoleCapabilities += $parts[1]; break }
                $script:PSGetFormatVersion { $PSGetFormatVersion = $parts[1]; break }
                $script:Includes           { break }
                Default                    { $userTags += $tag; break }
            }
        }

        $ArtifactDependencies = @()
        Foreach ($dependencyString in $swid.Dependencies)
        {
            [Uri]$packageId = $null
            if([Uri]::TryCreate($dependencyString, [System.UriKind]::Absolute, ([ref]$packageId)))
            {
                $segments = $packageId.Segments
                $Version = $null
                $DependencyName = $null
                if ($segments)
                {
                    $DependencyName = [Uri]::UnescapeDataString($segments[0].Trim('/', '\'))
                    $Version = if($segments.Count -gt 1){[Uri]::UnescapeDataString($segments[1])}
                }

                $dep = [ordered]@{
                            Name=$DependencyName
                        }

                if($Version)
                {
                    # Required/exact version is represented in NuGet as "[2.0]"
                    if ($Version -match "\[+[0-9.]+\]")
                    {
                        $dep["RequiredVersion"] = $Version.Trim('[', ']')
                    }
                    elseif ($Version -match "\[+[0-9., ]+\]")
                    {
                        # Minimum and Maximum version range is represented in NuGet as "[1.0, 2.0]"
                        $versionRange = $Version.Trim('[', ']') -split ',' | Microsoft.PowerShell.Core\Where-Object {$_}
                        if($versionRange -and $versionRange.count -eq 2)
                        {
                            $dep["MinimumVersion"] = $versionRange[0].Trim()
                            $dep["MaximumVersion"] = $versionRange[1].Trim()
                        }
                    }
                    elseif ($Version -match "\(+[0-9., ]+\]")
                    {
                        # Maximum version is represented in NuGet as "(, 2.0]"
                        $maximumVersion = $Version.Trim('(', ']') -split ',' | Microsoft.PowerShell.Core\Where-Object {$_}

                        if($maximumVersion)
                        {
                            $dep["MaximumVersion"] = $maximumVersion.Trim()
                        }
                    }
                    else
                    {
                        $dep['MinimumVersion'] = $Version
                    }
                }

                $dep["CanonicalId"]=$dependencyString

                $ArtifactDependencies += $dep
            }
        }

        $additionalMetadata =  Microsoft.PowerShell.Utility\New-Object PSCustomObject -Property ([ordered]@{})
        foreach ( $key in $swid.Metadata.Keys.LocalName)
        {
            Microsoft.PowerShell.Utility\Add-Member -InputObject $additionalMetadata `
                                                    -MemberType NoteProperty `
                                                    -Name $key `
                                                    -Value (Get-First $swid.Metadata[$key])
        }

        if (-not (Get-Member -InputObject $additionalMetadata -Name "IsPrerelease") )
        {
            if ($swid.Version -match '-')
            {
                Microsoft.PowerShell.Utility\Add-Member -InputObject $additionalMetadata `
                                                        -MemberType NoteProperty `
                                                        -Name 'IsPrerelease' `
                                                        -Value $true
            }
            else {
                Microsoft.PowerShell.Utility\Add-Member -InputObject $additionalMetadata `
                                                        -MemberType NoteProperty `
                                                        -Name 'IsPrerelease' `
                                                        -Value $false
            }
        }

        if(Get-Member -InputObject $additionalMetadata -Name 'ItemType')
        {
            $Type = $additionalMetadata.'ItemType'
        }
        elseif($userTags -contains 'PSModule')
        {
            $Type = $script:PSArtifactTypeModule
        }
        elseif($userTags -contains 'PSScript')
        {
            $Type = $script:PSArtifactTypeScript
        }


        $PSGetItemInfo = Microsoft.PowerShell.Utility\New-Object PSCustomObject -Property ([ordered]@{
                Name = $swid.Name
                Version = $swid.Version
                Type = $Type
                Description = (Get-First $swid.Metadata["description"])
                Author = (Get-EntityName -SoftwareIdentity $swid -Role "author")
                CompanyName = (Get-EntityName -SoftwareIdentity $swid -Role "owner")
                Copyright = (Get-First $swid.Metadata["copyright"])
                PublishedDate = if([System.DateTime]::TryParse($published, ([ref]$PublishedDate))){$PublishedDate};
                InstalledDate = $InstalledDate;
                UpdatedDate = $UpdatedDate;
                LicenseUri = (Get-UrlFromSwid -SoftwareIdentity $swid -UrlName "license")
                ProjectUri = (Get-UrlFromSwid -SoftwareIdentity $swid -UrlName "project")
                IconUri = (Get-UrlFromSwid -SoftwareIdentity $swid -UrlName "icon")
                Tags = $userTags

                Includes = @{
                                DscResource = $exportedDscResources
                                Command     = $exportedCommands
                                Cmdlet      = $exportedCmdlets
                                Function    = $exportedFunctions
                                Workflow    = $exportedWorkflows
                                RoleCapability = $exportedRoleCapabilities
                            }

                PowerShellGetFormatVersion=[Version]$PSGetFormatVersion

                ReleaseNotes = (Get-First $swid.Metadata["releaseNotes"])

                Dependencies = $ArtifactDependencies

                RepositorySourceLocation = $SourceLocation
                Repository = $sourceName
                PackageManagementProvider = if($PackageManagementProviderName) { $PackageManagementProviderName } else { (Get-First $swid.Metadata["PackageManagementProvider"]) }

				AdditionalMetadata = $additionalMetadata
            })

        if(-not $InstalledLocation)
        {
            $InstalledLocation = (Get-First $swid.Metadata[$script:InstalledLocation])
        }

        if($InstalledLocation)
        {
            Microsoft.PowerShell.Utility\Add-Member -InputObject $PSGetItemInfo -MemberType NoteProperty -Name $script:InstalledLocation -Value $InstalledLocation
        }

        $PSGetItemInfo.PSTypeNames.Insert(0, "Microsoft.PowerShell.Commands.PSRepositoryItemInfo")
        $PSGetItemInfo
    }
}
function New-PSScriptInfoObject
{
    [CmdletBinding(PositionalBinding=$false)]
    Param
    (
        [Parameter(Mandatory=$true)]
        [string]
        $Path
    )

    $PSScriptInfo = Microsoft.PowerShell.Utility\New-Object PSCustomObject -Property ([ordered]@{})
    $script:PSScriptInfoProperties | Microsoft.PowerShell.Core\ForEach-Object {
                                            Microsoft.PowerShell.Utility\Add-Member -InputObject $PSScriptInfo `
                                                                                    -MemberType NoteProperty `
                                                                                    -Name $_ `
                                                                                    -Value $null
                                        }

    $PSScriptInfo.$script:Name = [System.IO.Path]::GetFileNameWithoutExtension($Path)
    $PSScriptInfo.$script:Path = $Path
    $PSScriptInfo.$script:ScriptBase = (Microsoft.PowerShell.Management\Split-Path -Path $Path -Parent)

    return $PSScriptInfo
}
function New-SoftwareIdentityFromPackage
{
    param
    (
        [Parameter(Mandatory=$true)]
        $Package,

        [Parameter(Mandatory=$true)]
        [string]
        $PackageManagementProviderName,

        [Parameter(Mandatory=$true)]
        [string]
        $SourceLocation,

        [Parameter()]
        [switch]
        $IsFromTrustedSource,

        [Parameter(Mandatory=$true)]
        $request,

        [Parameter(Mandatory=$true)]
        [string]
        $Type,

        [Parameter()]
        [string]
        $InstalledLocation,

        [Parameter()]
        [System.DateTime]
        $InstalledDate,

        [Parameter()]
        [System.DateTime]
        $UpdatedDate
    )

    $fastPackageReference = New-FastPackageReference -ProviderName $PackageManagementProviderName `
                                                     -PackageName $Package.Name `
                                                     -Version $Package.Version `
                                                     -Source $SourceLocation `
                                                     -ArtifactType $Type

    $links = New-Object -TypeName  System.Collections.ArrayList
    foreach($lnk in $Package.Links)
    {
        if( $lnk.Relationship -eq "icon" -or $lnk.Relationship -eq "license" -or $lnk.Relationship -eq "project" )
        {
            $links.Add( (New-Link -Href $lnk.HRef -RelationShip $lnk.Relationship )  )
        }
    }

    $entities = New-Object -TypeName  System.Collections.ArrayList
    foreach( $entity in $Package.Entities )
    {
        if( $entity.Role -eq "author" -or $entity.Role -eq "owner" )
        {
            $entities.Add( (New-Entity -Name $entity.Name -Role $entity.Role -RegId $entity.RegId -Thumbprint $entity.Thumbprint)  )
        }
    }

    $deps = (new-Object -TypeName  System.Collections.ArrayList)
    foreach( $dep in $pkg.Dependencies )
    {
        # Add each dependency and say it's from this provider.
        $newDep = New-Dependency -ProviderName $script:PSModuleProviderName `
                                 -PackageName $request.Services.ParsePackageName($dep) `
                                 -Version $request.Services.ParsePackageVersion($dep) `
                                 -Source $SourceLocation

        $deps.Add( $newDep )
    }


    $details =  New-Object -TypeName  System.Collections.Hashtable

	foreach ( $key in $Package.Metadata.Keys.LocalName)
	{
		if (!$details.ContainsKey($key))
		{
			$details.Add($key, (Get-First $Package.Metadata[$key]) )
		}
	}

    $details.Add( "PackageManagementProvider" , $PackageManagementProviderName )

    if($InstalledLocation)
    {
        $details.Add( $script:InstalledLocation , $InstalledLocation )
    }

    if($InstalledDate)
    {
        $details.Add( 'installeddate' , $InstalledDate.ToString('O', [System.Globalization.DateTimeFormatInfo]::InvariantInfo) )
    }

    if($UpdatedDate)
    {
        $details.Add( 'updateddate' , $UpdatedDate.ToString('O', [System.Globalization.DateTimeFormatInfo]::InvariantInfo) )
    }

    # Initialize package source name to the source location
    $sourceNameForSoftwareIdentity = $SourceLocation

    $sourceName = (Get-SourceName -Location $SourceLocation)

    if($sourceName)
    {
        $details.Add( "SourceName" , $sourceName )

        # Override the source name only if we are able to map source location to source name
        $sourceNameForSoftwareIdentity = $sourceName
    }

    $params = @{FastPackageReference = $fastPackageReference;
                Name = $Package.Name;
                Version = $Package.Version;
                versionScheme  = "MultiPartNumeric";
                Source = $sourceNameForSoftwareIdentity;
                Summary = $Package.Summary;
                SearchKey = $Package.Name;
                FullPath = $Package.FullPath;
                FileName = $Package.Name;
                Details = $details;
                Entities = $entities;
                Links = $links;
                Dependencies = $deps;
               }

    if($IsFromTrustedSource)
    {
        $params["FromTrustedSource"] = $true
    }

    $sid = New-SoftwareIdentity @params

    return $sid
}
function New-SoftwareIdentityFromPSGetItemInfo
{
    param
    (
        [Parameter(Mandatory=$true)]
        $PSGetItemInfo
    )

    $SourceLocation = $psgetItemInfo.RepositorySourceLocation

    if(Get-Member -InputObject $PSGetItemInfo -Name $script:PSArtifactType)
    {
        $artifactType = $psgetItemInfo.Type
    }
    else
    {
        $artifactType = $script:PSArtifactTypeModule
    }

    $fastPackageReference = New-FastPackageReference -ProviderName (Get-ProviderName -PSCustomObject $psgetItemInfo) `
                                                     -PackageName $psgetItemInfo.Name `
                                                     -Version $psgetItemInfo.Version `
                                                     -Source $SourceLocation `
                                                     -ArtifactType $artifactType

    $links = New-Object -TypeName  System.Collections.ArrayList
    if($psgetItemInfo.IconUri)
    {
        $links.Add( (New-Link -Href $psgetItemInfo.IconUri -RelationShip "icon") )
    }

    if($psgetItemInfo.LicenseUri)
    {
        $links.Add( (New-Link -Href $psgetItemInfo.LicenseUri -RelationShip "license") )
    }

    if($psgetItemInfo.ProjectUri)
    {
        $links.Add( (New-Link -Href $psgetItemInfo.ProjectUri -RelationShip "project") )
    }

    $entities = New-Object -TypeName  System.Collections.ArrayList
    if($psgetItemInfo.Author -and $psgetItemInfo.Author.ToString())
    {
        $entities.Add( (New-Entity -Name $psgetItemInfo.Author -Role 'author') )
    }

    if($psgetItemInfo.CompanyName -and $psgetItemInfo.CompanyName.ToString())
    {
        $entities.Add( (New-Entity -Name $psgetItemInfo.CompanyName -Role 'owner') )
    }

    $details =  @{
                    description    = $psgetItemInfo.Description
                    copyright      = $psgetItemInfo.Copyright
                    published      = $psgetItemInfo.PublishedDate.ToString()
                    installeddate  = $null
                    updateddate    = $null
                    tags           = $psgetItemInfo.Tags
                    releaseNotes   = $psgetItemInfo.ReleaseNotes
                    PackageManagementProvider = (Get-ProviderName -PSCustomObject $psgetItemInfo)
                 }

    if((Get-Member -InputObject $psgetItemInfo -Name 'InstalledDate') -and $psgetItemInfo.InstalledDate)
    {
        $details['installeddate'] = $psgetItemInfo.InstalledDate.ToString('O', [System.Globalization.DateTimeFormatInfo]::InvariantInfo)
    }

    if((Get-Member -InputObject $psgetItemInfo -Name 'UpdatedDate') -and $psgetItemInfo.UpdatedDate)
    {
        $details['updateddate'] = $psgetItemInfo.UpdatedDate.ToString('O', [System.Globalization.DateTimeFormatInfo]::InvariantInfo)
    }

    if(Get-Member -InputObject $psgetItemInfo -Name $script:InstalledLocation)
    {
        $details[$script:InstalledLocation] = $psgetItemInfo.InstalledLocation
    }

    $details[$script:PSArtifactType] = $artifactType

    $sourceName = Get-SourceName -Location $SourceLocation
    if($sourceName)
    {
        $details["SourceName"] = $sourceName
    }

    $params = @{
                FastPackageReference = $fastPackageReference;
                Name = $psgetItemInfo.Name;
                Version = $psgetItemInfo.Version;
                versionScheme  = "MultiPartNumeric";
                Source = $SourceLocation;
                Summary = $psgetItemInfo.Description;
                Details = $details;
                Entities = $entities;
                Links = $links
               }

    if($sourceName -and $script:PSGetModuleSources[$sourceName].Trusted)
    {
        $params["FromTrustedSource"] = $true
    }

    $sid = New-SoftwareIdentity @params

    return $sid
}
function Ping-Endpoint
{
    [CmdletBinding()]
    param
    (
        [Parameter()]
        [ValidateNotNullOrEmpty()]
        [string]
        $Endpoint,

        [Parameter()]
        $Credential,

        [Parameter()]
        $Proxy,

        [Parameter()]
        $ProxyCredential,

        [Parameter()]
        [switch]
        $AllowAutoRedirect = $true
    )

    $results = @{}

    $WebProxy = $null
    if($Proxy -and ('Microsoft.PowerShell.Commands.PowerShellGet.InternalWebProxy' -as [Type]))
    {
        $ProxyNetworkCredential = $null
        if($ProxyCredential)
        {
            $ProxyNetworkCredential = $ProxyCredential.GetNetworkCredential()
        }

        $WebProxy = New-Object Microsoft.PowerShell.Commands.PowerShellGet.InternalWebProxy -ArgumentList $Proxy,$ProxyNetworkCredential
    }

    if(HttpClientApisAvailable)
    {
        $response = $null
        try
        {
            $handler = New-Object System.Net.Http.HttpClientHandler

            if($Credential)
            {
                $handler.Credentials = $Credential.GetNetworkCredential()
            }
            else
            {
                $handler.UseDefaultCredentials = $true
            }

            if($WebProxy)
            {
                $handler.Proxy = $WebProxy
            }

            $httpClient = New-Object System.Net.Http.HttpClient -ArgumentList $handler
            $response = $httpclient.GetAsync($endpoint)
        }
        catch
        {
        }

        if ($response -ne $null -and $response.result -ne $null)
        {
            $results.Add($Script:ResponseUri,$response.Result.RequestMessage.RequestUri.AbsoluteUri.ToString())
            $results.Add($Script:StatusCode,$response.result.StatusCode.value__)
        }
    }
    else
    {
        $iss = [System.Management.Automation.Runspaces.InitialSessionState]::Create()
        $iss.types.clear()
        $iss.formats.clear()
        $iss.LanguageMode = "FullLanguage"

        $EndPoint = [System.Management.Automation.Language.CodeGeneration]::EscapeSingleQuotedStringContent($EndPoint)

        $WebRequestcmd =  @'
            param($Credential, $WebProxy)

            try
            {{
                $request = [System.Net.WebRequest]::Create('{0}')
                $request.Method = 'GET'
                $request.Timeout = 30000
                if($Credential)
                {{
                    $request.Credentials = $Credential.GetNetworkCredential()
                }}
                else
                {{
                    $request.Credentials = [System.Net.CredentialCache]::DefaultNetworkCredentials
                }}

                $request.AllowAutoRedirect = ${1}

                if($WebProxy)
                {{
                    $request.Proxy = $WebProxy
                }}

                $response = [System.Net.HttpWebResponse]$request.GetResponse()
                if($response.StatusCode.value__ -eq 302)
                {{
                    $response.Headers["Location"].ToString()
                }}
                else
                {{
                    $response
                }}
                $response.Close()
            }}
            catch [System.Net.WebException]
            {{
                "Error:System.Net.WebException"
            }}
'@ -f $EndPoint, $AllowAutoRedirect

        $ps = [powershell]::Create($iss).AddScript($WebRequestcmd)

        if($WebProxy)
        {
            $null = $ps.AddParameter('WebProxy', $WebProxy)
        }

        if($Credential)
        {
            $null = $ps.AddParameter('Credential', $Credential)
        }

        $response = $ps.Invoke()
        $ps.dispose()
        if ($response -ne "Error:System.Net.WebException")
        {
            if($AllowAutoRedirect)
            {
                $results.Add($Script:ResponseUri,$response.ResponseUri.ToString())
                $results.Add($Script:StatusCode,$response.StatusCode.value__)
            }
            else
            {
                $results.Add($Script:ResponseUri,[String]$response)
            }
        }
    }
    return $results
}
function Publish-NugetPackage {
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory = $true)]
        [string]$NupkgPath,

        [Parameter(Mandatory = $true)]
        [string]$Destination,

        [Parameter(Mandatory = $true)]
        [string]$NugetApiKey,

        [Parameter(ParameterSetName = "UseNuget")]
        [string]$NugetExePath,

        [Parameter(ParameterSetName = "UseDotnetCli")]
        [switch]$UseDotnetCli
    )
    Set-StrictMode -Off

    Write-Verbose "Calling Publish-NugetPackage -NupkgPath $NupkgPath -Destination $Destination -NugetExePath $NugetExePath -UseDotnetCli:$UseDotnetCli"
    $Destination = $Destination.TrimEnd("\")

    if ($PSCmdlet.ParameterSetName -eq "UseNuget") {
        $ArgumentList = @('push')
        $ArgumentList += "`"$NupkgPath`""
        $ArgumentList += @('-source', "`"$Destination`"")
        $ArgumentList += @('-apikey', "`"$NugetApiKey`"")
        $ArgumentList += '-NonInteractive'

        #use processstartinfo and process objects here as it allows stderr redirection in memory rather than file.
        $processStartInfo = New-Object System.Diagnostics.ProcessStartInfo
        $processStartInfo.FileName = $NugetExePath
        $processStartInfo.RedirectStandardError = $true
        $processStartInfo.RedirectStandardOutput = $true
        $processStartInfo.UseShellExecute = $false
        $processStartInfo.Arguments = $ArgumentList

        $process = New-Object System.Diagnostics.Process
        $process.StartInfo = $processStartInfo
        $process.Start() | Out-Null
        $process.WaitForExit()

        if (-Not ($process.ExitCode -eq 0 )) {
            $stdErr = $process.StandardError.ReadToEnd()
            throw "nuget.exe failed to push $stdErr"
        }
    }

    if ($PSCmdlet.ParameterSetName -eq "UseDotnetCli") {
        #perform dotnet pack using a temporary project file.
        $dotnetCliPath = (Get-Command -Name "dotnet").Source

        $ArgumentList = @('nuget')
        $ArgumentList += 'push'
        $ArgumentList += "`"$NupkgPath`""
        $ArgumentList += @('--source', "`"$Destination`"")
        $ArgumentList += @('--api-key', "`"$NugetApiKey`"")

        #use processstartinfo and process objects here as it allows stdout redirection in memory rather than file.
        $processStartInfo = New-Object System.Diagnostics.ProcessStartInfo
        $processStartInfo.FileName = $dotnetCliPath
        $processStartInfo.RedirectStandardError = $true
        $processStartInfo.RedirectStandardOutput = $true
        $processStartInfo.UseShellExecute = $false
        $processStartInfo.Arguments = $ArgumentList

        $process = New-Object System.Diagnostics.Process
        $process.StartInfo = $processStartInfo
        $process.Start() | Out-Null
        $process.WaitForExit()

        if (-Not ($process.ExitCode -eq 0)) {
            $stdOut = $process.StandardOutput.ReadToEnd()
            throw "dotnet cli failed to nuget push $stdOut"
        }
    }

    $stdOut = $process.StandardOutput.ReadToEnd()
    Write-Verbose -Message $stdOut
}
function Publish-PSArtifactUtility {
    [CmdletBinding(PositionalBinding = $false)]
    Param
    (
        [Parameter(Mandatory = $true, ParameterSetName = 'PublishModule')]
        [ValidateNotNullOrEmpty()]
        [PSModuleInfo]
        $PSModuleInfo,

        [Parameter(Mandatory = $true, ParameterSetName = 'PublishScript')]
        [ValidateNotNullOrEmpty()]
        [PSCustomObject]
        $PSScriptInfo,

        [Parameter(Mandatory = $true, ParameterSetName = 'PublishModule')]
        [ValidateNotNullOrEmpty()]
        [string]
        $ManifestPath,

        [Parameter(Mandatory = $true)]
        [ValidateNotNullOrEmpty()]
        [string]
        $Destination,

        [Parameter(Mandatory = $true)]
        [ValidateNotNullOrEmpty()]
        [string]
        $Repository,

        [Parameter(Mandatory = $true)]
        [ValidateNotNullOrEmpty()]
        [string]
        $NugetApiKey,

        [Parameter(Mandatory = $false)]
        [pscredential]
        $Credential,

        [Parameter(Mandatory = $true)]
        [ValidateNotNullOrEmpty()]
        [string]
        $NugetPackageRoot,

        [Parameter(ParameterSetName = 'PublishModule')]
        [Version]
        $FormatVersion,

        [Parameter(ParameterSetName = 'PublishModule')]
        [string]
        $ReleaseNotes,

        [Parameter(ParameterSetName = 'PublishModule')]
        [string[]]
        $Tags,

        [Parameter(ParameterSetName = 'PublishModule')]
        [switch]
        $SkipAutomaticTags,

        [Parameter(ParameterSetName = 'PublishModule')]
        [Uri]
        $LicenseUri,

        [Parameter(ParameterSetName = 'PublishModule')]
        [Uri]
        $IconUri,

        [Parameter(ParameterSetName = 'PublishModule')]
        [Uri]
        $ProjectUri,

        [Parameter(ParameterSetName = 'PublishModule')]
        [string[]]
        $Exclude
    )

    Write-Verbose "Calling Publish-PSArtifactUtility"
    Install-NuGetClientBinaries -CallerPSCmdlet $PSCmdlet -BootstrapNuGetExe

    $PSArtifactType = $script:PSArtifactTypeModule
    $Name = $null
    $Description = $null
    $Version = ""
    $Author = $null
    $CompanyName = $null
    $Copyright = $null
    $requireLicenseAcceptance = "false"

    if ($PSModuleInfo) {
        $Name = $PSModuleInfo.Name
        $Description = $PSModuleInfo.Description
        $Version = $PSModuleInfo.Version
        $Author = $PSModuleInfo.Author
        $CompanyName = $PSModuleInfo.CompanyName
        $Copyright = $PSModuleInfo.Copyright

        if ($PSModuleInfo.PrivateData -and
            ($PSModuleInfo.PrivateData.GetType().ToString() -eq "System.Collections.Hashtable") -and
            $PSModuleInfo.PrivateData["PSData"] -and
            ($PSModuleInfo.PrivateData["PSData"].GetType().ToString() -eq "System.Collections.Hashtable")
        ) {
            if ( -not $Tags -and $PSModuleInfo.PrivateData.PSData["Tags"]) {
                $Tags = $PSModuleInfo.PrivateData.PSData.Tags
            }

            if ( -not $ReleaseNotes -and $PSModuleInfo.PrivateData.PSData["ReleaseNotes"]) {
                $ReleaseNotes = $PSModuleInfo.PrivateData.PSData.ReleaseNotes
            }

            if ( -not $LicenseUri -and $PSModuleInfo.PrivateData.PSData["LicenseUri"]) {
                $LicenseUri = $PSModuleInfo.PrivateData.PSData.LicenseUri
            }

            if ( -not $IconUri -and $PSModuleInfo.PrivateData.PSData["IconUri"]) {
                $IconUri = $PSModuleInfo.PrivateData.PSData.IconUri
            }

            if ( -not $ProjectUri -and $PSModuleInfo.PrivateData.PSData["ProjectUri"]) {
                $ProjectUri = $PSModuleInfo.PrivateData.PSData.ProjectUri
            }

            if ($PSModuleInfo.PrivateData.PSData["Prerelease"]) {
                $psmoduleInfoPrereleaseString = $PSModuleInfo.PrivateData.PSData.Prerelease
                if ($psmoduleInfoPrereleaseString -and $psmoduleInfoPrereleaseString.StartsWith("-")) {
                    $Version = [string]$Version + $psmoduleInfoPrereleaseString
                }
                else {
                    $Version = [string]$Version + "-" + $psmoduleInfoPrereleaseString
                }
            }

            if ($PSModuleInfo.PrivateData.PSData["RequireLicenseAcceptance"]) {
                $requireLicenseAcceptance = $PSModuleInfo.PrivateData.PSData.requireLicenseAcceptance.ToString().ToLower()
                if ($requireLicenseAcceptance -eq "true") {
                    if ($FormatVersion -and ($FormatVersion.Major -lt $script:PSGetRequireLicenseAcceptanceFormatVersion.Major)) {
                        $message = $LocalizedData.requireLicenseAcceptanceNotSupported -f ($FormatVersion)
                        ThrowError -ExceptionName "System.InvalidOperationException" `
                            -ExceptionMessage $message `
                            -ErrorId "requireLicenseAcceptanceNotSupported" `
                            -CallerPSCmdlet $PSCmdlet `
                            -ErrorCategory InvalidData
                    }

                    if (-not $LicenseUri) {
                        $message = $LocalizedData.LicenseUriNotSpecified
                        ThrowError -ExceptionName "System.InvalidOperationException" `
                            -ExceptionMessage $message `
                            -ErrorId "LicenseUriNotSpecified" `
                            -CallerPSCmdlet $PSCmdlet `
                            -ErrorCategory InvalidData
                    }

                    $LicenseFilePath = Join-PathUtility -Path $NugetPackageRoot -ChildPath 'License.txt' -PathType File
                    if (-not $LicenseFilePath -or -not (Test-Path -Path $LicenseFilePath -PathType Leaf)) {
                        $message = $LocalizedData.LicenseTxtNotFound
                        ThrowError -ExceptionName "System.InvalidOperationException" `
                            -ExceptionMessage $message `
                            -ErrorId "LicenseTxtNotFound" `
                            -CallerPSCmdlet $PSCmdlet `
                            -ErrorCategory InvalidData
                    }

                    if ((Get-Content -LiteralPath $LicenseFilePath) -eq $null) {
                        $message = $LocalizedData.LicenseTxtEmpty
                        ThrowError -ExceptionName "System.InvalidOperationException" `
                            -ExceptionMessage $message `
                            -ErrorId "LicenseTxtEmpty" `
                            -CallerPSCmdlet $PSCmdlet `
                            -ErrorCategory InvalidData
                    }

                    #RequireLicenseAcceptance is true, License uri and license.txt exist. Bump Up the FormatVersion
                    if (-not $FormatVersion) {
                        $FormatVersion = $script:CurrentPSGetFormatVersion
                    }
                }
                elseif ($requireLicenseAcceptance -ne "false") {
                    $InvalidValueForRequireLicenseAcceptance = $LocalizedData.InvalidValueBoolean -f ($requireLicenseAcceptance, "requireLicenseAcceptance")
                    Write-Warning -Message $InvalidValueForRequireLicenseAcceptance
                }
            }
        }
    }
    else {
        $PSArtifactType = $script:PSArtifactTypeScript

        $Name = $PSScriptInfo.Name
        $Description = $PSScriptInfo.Description
        $Version = $PSScriptInfo.Version
        $Author = $PSScriptInfo.Author
        $CompanyName = $PSScriptInfo.CompanyName
        $Copyright = $PSScriptInfo.Copyright

        if ($PSScriptInfo.'Tags') {
            $Tags = $PSScriptInfo.Tags
        }

        if ($PSScriptInfo.'ReleaseNotes') {
            $ReleaseNotes = $PSScriptInfo.ReleaseNotes
        }

        if ($PSScriptInfo.'LicenseUri') {
            $LicenseUri = $PSScriptInfo.LicenseUri
        }

        if ($PSScriptInfo.'IconUri') {
            $IconUri = $PSScriptInfo.IconUri
        }

        if ($PSScriptInfo.'ProjectUri') {
            $ProjectUri = $PSScriptInfo.ProjectUri
        }
    }

    $nuspecFiles = ""
    if ($Exclude) {
        $nuspecFileExcludePattern = $Exclude -Join ";"
        $nuspecFiles = @{ src = "**/*.*"; exclude = $nuspecFileExcludePattern }
    }

    # Add PSModule and PSGet format version tags
    if (-not $Tags) {
        $Tags = @()
    }

    if ($FormatVersion) {
        $Tags += "$($script:PSGetFormatVersion)_$FormatVersion"
    }

    $DependentModuleDetails = @()

    if ($PSScriptInfo) {
        $Tags += "PSScript"

        if ($PSScriptInfo.DefinedCommands -and -not $SkipAutomaticTags) {
            if ($PSScriptInfo.DefinedFunctions) {
                $Tags += "$($script:Includes)_Function"
                $Tags += $PSScriptInfo.DefinedFunctions | Microsoft.PowerShell.Core\ForEach-Object { "$($script:Function)_$_" }
            }

            if ($PSScriptInfo.DefinedWorkflows) {
                $Tags += "$($script:Includes)_Workflow"
                $Tags += $PSScriptInfo.DefinedWorkflows | Microsoft.PowerShell.Core\ForEach-Object { "$($script:Workflow)_$_" }
            }

            $Tags += $PSScriptInfo.DefinedCommands | Microsoft.PowerShell.Core\ForEach-Object { "$($script:Command)_$_" }
        }

        # Populate the dependencies elements from RequiredModules and RequiredScripts
        #
        $ValidateAndGetScriptDependencies_Params = @{
            Repository          = $Repository
            DependentScriptInfo = $PSScriptInfo
            CallerPSCmdlet      = $PSCmdlet
            Verbose             = $VerbosePreference
            Debug               = $DebugPreference
        }
        if ($PSBoundParameters.ContainsKey('Credential')) {
            $ValidateAndGetScriptDependencies_Params.Add('Credential', $Credential)
        }
        $DependentModuleDetails += ValidateAndGet-ScriptDependencies @ValidateAndGetScriptDependencies_Params
    }
    else {
        $Tags += "PSModule"

        $ModuleManifestHashTable = Get-ManifestHashTable -Path $ManifestPath

        if (-not $SkipAutomaticTags) {
            if ($PSModuleInfo.ExportedCommands.Count) {
                if ($PSModuleInfo.ExportedCmdlets.Count) {
                    $Tags += "$($script:Includes)_Cmdlet"
                    $Tags += $PSModuleInfo.ExportedCmdlets.Keys | Microsoft.PowerShell.Core\ForEach-Object { "$($script:Cmdlet)_$_" }

                    #if CmdletsToExport field in manifest file is "*", we suggest the user to include all those cmdlets for best practice
                    if ($ModuleManifestHashTable -and $ModuleManifestHashTable.ContainsKey('CmdletsToExport') -and ($ModuleManifestHashTable.CmdletsToExport -eq "*")) {
                        $WarningMessage = $LocalizedData.ShouldIncludeCmdletsToExport -f ($ManifestPath)
                        Write-Warning -Message $WarningMessage
                    }
                }

                if ($PSModuleInfo.ExportedFunctions.Count) {
                    $Tags += "$($script:Includes)_Function"
                    $Tags += $PSModuleInfo.ExportedFunctions.Keys | Microsoft.PowerShell.Core\ForEach-Object { "$($script:Function)_$_" }

                    if ($ModuleManifestHashTable -and $ModuleManifestHashTable.ContainsKey('FunctionsToExport') -and ($ModuleManifestHashTable.FunctionsToExport -eq "*")) {
                        $WarningMessage = $LocalizedData.ShouldIncludeFunctionsToExport -f ($ManifestPath)
                        Write-Warning -Message $WarningMessage
                    }
                }

                $Tags += $PSModuleInfo.ExportedCommands.Keys | Microsoft.PowerShell.Core\ForEach-Object { "$($script:Command)_$_" }
            }

            $dscResourceNames = Get-ExportedDscResources -PSModuleInfo $PSModuleInfo
            if ($dscResourceNames) {
                $Tags += "$($script:Includes)_DscResource"

                $Tags += $dscResourceNames | Microsoft.PowerShell.Core\ForEach-Object { "$($script:DscResource)_$_" }

                #If DscResourcesToExport is commented out or "*" is used, we will write-warning
                if ($ModuleManifestHashTable -and
                    ($ModuleManifestHashTable.ContainsKey("DscResourcesToExport") -and
                        $ModuleManifestHashTable.DscResourcesToExport -eq "*") -or
                    -not $ModuleManifestHashTable.ContainsKey("DscResourcesToExport")) {
                    $WarningMessage = $LocalizedData.ShouldIncludeDscResourcesToExport -f ($ManifestPath)
                    Write-Warning -Message $WarningMessage
                }
            }

            $RoleCapabilityNames = Get-AvailableRoleCapabilityName -PSModuleInfo $PSModuleInfo
            if ($RoleCapabilityNames) {
                $Tags += "$($script:Includes)_RoleCapability"

                $Tags += $RoleCapabilityNames | Microsoft.PowerShell.Core\ForEach-Object { "$($script:RoleCapability)_$_" }
            }
        }

        # Populate the module dependencies elements from RequiredModules and
        # NestedModules properties of the current PSModuleInfo
        $GetModuleDependencies_Params = @{
            PSModuleInfo   = $PSModuleInfo
            Repository     = $Repository
            CallerPSCmdlet = $PSCmdlet
            Verbose        = $VerbosePreference
            Debug          = $DebugPreference
        }
        if ($PSBoundParameters.ContainsKey('Credential')) {
            $GetModuleDependencies_Params.Add('Credential', $Credential)
        }
        $DependentModuleDetails = Get-ModuleDependencies @GetModuleDependencies_Params
    }

    $dependencies = @()
    ForEach ($Dependency in $DependentModuleDetails) {
        $ModuleName = $Dependency.Name
        $VersionString = ""

        # Version format in NuSpec:
        # "[2.0]" --> (== 2.0) Required Version
        # "2.0" --> (>= 2.0) Minimum Version
        #
        # When only MaximumVersion is specified in the ModuleSpecification
        # (,1.0]  = x <= 1.0
        #
        # When both Minimum and Maximum versions are specified in the ModuleSpecification
        # [1.0,2.0] = 1.0 <= x <= 2.0

        if ($Dependency.Keys -Contains "RequiredVersion") {
            $VersionString = "[$($Dependency.RequiredVersion)]"
        }
        elseif ($Dependency.Keys -Contains 'MinimumVersion' -and $Dependency.Keys -Contains 'MaximumVersion') {
            $VersionString = "[$($Dependency.MinimumVersion),$($Dependency.MaximumVersion)]"
        }
        elseif ($Dependency.Keys -Contains 'MaximumVersion') {
            $VersionString = "(,$($Dependency.MaximumVersion)]"
        }
        elseif ($Dependency.Keys -Contains 'MinimumVersion') {
            $VersionString = "$($Dependency.MinimumVersion)"
        }

        $props = @{
            id      = $ModuleName
            version = $VersionString
        }

        $dependencyObject = New-Object -TypeName PSCustomObject -Property $props
        $dependencies += $dependencyObject
    }

    $params = @{
        OutputPath               = $NugetPackageRoot
        Id                       = $Name
        Version                  = $Version
        Authors                  = $Author
        Owners                   = $CompanyName
        Description              = $Description
        ReleaseNotes             = $ReleaseNotes
        RequireLicenseAcceptance = ($requireLicenseAcceptance -eq $true)
        Copyright                = $Copyright
        Tags                     = $Tags
        LicenseUrl               = $LicenseUri
        ProjectUrl               = $ProjectUri
        IconUrl                  = $IconUri
        Dependencies             = $dependencies
    }

    if ($nuspecFiles) {
        $params.Add('Files', $nuspecFiles)
    }

    try {
        $NuspecFullName = New-NuspecFile @params
    }
    catch {
        Write-Error -Message "Failed to create nuspec file $_.Exception" -ErrorAction Stop
    }

    try {
        if ($DotnetCommandPath) {
            $NupkgFullName = New-NugetPackage -NuspecPath $NuspecFullName -NugetPackageRoot $NugetPackageRoot -UseDotnetCli -Verbose:$VerbosePreference
        }
        elseif ($NuGetExePath) {
            $NupkgFullName = New-NugetPackage -NuspecPath $NuspecFullName -NugetPackageRoot $NugetPackageRoot -NugetExePath $NuGetExePath -Verbose:$VerbosePreference
        }

        Write-Verbose -Message "Successfully created nuget package at $NupkgFullName"
    }
    catch {
        if ($PSArtifactType -eq $script:PSArtifactTypeModule) {
            $message = $LocalizedData.FailedToCreateCompressedModule -f ($_.Exception.message)
            $errorId = "FailedToCreateCompressedModule"
        }
        else {
            $message = $LocalizedData.FailedToCreateCompressedScript -f ($_.Exception.message)
            $errorId = "FailedToCreateCompressedScript"
        }

        Write-Error -Message $message -ErrorId $errorId -Category InvalidOperation -ErrorAction Stop
    }

    try {
        if ($DotnetCommandPath) {
            Publish-NugetPackage -NupkgPath $NupkgFullName -Destination $Destination -NugetApiKey $NugetApiKey -UseDotnetCli -Verbose:$VerbosePreference
        }
        elseif ($NuGetExePath) {
            Publish-NugetPackage -NupkgPath $NupkgFullName -Destination $Destination -NugetApiKey $NugetApiKey -NugetExePath $NuGetExePath -Verbose:$VerbosePreference
        }

        if ($PSArtifactType -eq "Module") {
            $message = $LocalizedData.PublishedSuccessfully -f ($Name, $Destination, $Name)
        }
        if ($PSArtifactType -eq "Script") {
            $message = $LocalizedData.PublishedScriptSuccessfully -f ($Name, $Destination, $Name)
        }

        Write-Verbose -Message $message
    }
    catch {
        if ( $NugetApiKey -eq "VSTS" -and ($_.Exception.Message -match "Cannot prompt for input in non-interactive mode.")) {
            $message = $LocalizedData.RegisterVSTSFeedAsNuGetPackageSource -f ($Destination, $script:VSTSAuthenticatedFeedsDocUrl)
        }
        else {
            $message = $_.Exception.message
        }

        if ($PSArtifactType -eq "Module") {
            $errorMessage = $LocalizedData.FailedToPublish -f ($Name, $message)
            $errorId = "FailedToPublishTheModule"
        }

        if ($PSArtifactType -eq "Script") {
            $errorMessage = $LocalizedData.FailedToPublishScript -f ($Name, $message)
            $errorId = "FailedToPublishTheScript"
        }

        Write-Error -Message $errorMessage -ErrorId $errorId -Category InvalidOperation -ErrorAction Stop
    }
}
function Resolve-Location
{
    [CmdletBinding()]
    [OutputType([string])]
    Param
    (
        [Parameter(Mandatory=$true)]
        [string]
        $Location,

        [Parameter(Mandatory=$true)]
        [string]
        $LocationParameterName,

        [Parameter()]
        $Credential,

        [Parameter()]
        $Proxy,

        [Parameter()]
        $ProxyCredential,

        [Parameter()]
        [System.Management.Automation.PSCmdlet]
        $CallerPSCmdlet
    )

    # Ping and resolve the specified location
    if(-not (Test-WebUri -uri $Location))
    {
        if(Microsoft.PowerShell.Management\Test-Path -LiteralPath $Location)
        {
            return $Location
        }
        elseif($CallerPSCmdlet)
        {
            $message = $LocalizedData.PathNotFound -f ($Location)
            ThrowError -ExceptionName "System.ArgumentException" `
                       -ExceptionMessage $message `
                       -ErrorId "PathNotFound" `
                       -CallerPSCmdlet $CallerPSCmdlet `
                       -ErrorCategory InvalidArgument `
                       -ExceptionObject $Location
        }
    }
    else
    {
        $pingResult = Ping-Endpoint -Endpoint $Location -Credential $Credential -Proxy $Proxy -ProxyCredential $ProxyCredential
        $statusCode = $null
        $exception = $null
        $resolvedLocation = $null
        if($pingResult -and $pingResult.ContainsKey($Script:ResponseUri))
        {
            $resolvedLocation = $pingResult[$Script:ResponseUri]
        }

        if($pingResult -and $pingResult.ContainsKey($Script:StatusCode))
        {
            $statusCode = $pingResult[$Script:StatusCode]
        }

        Write-Debug -Message "Ping-Endpoint: location=$Location, statuscode=$statusCode, resolvedLocation=$resolvedLocation"

        if((($statusCode -eq 200) -or ($statusCode -eq 401) -or ($statusCode -eq 407)) -and $resolvedLocation)
        {
            return $resolvedLocation
        }
        elseif($CallerPSCmdlet)
        {
            $message = $LocalizedData.InvalidWebUri -f ($Location, $LocationParameterName)
            ThrowError -ExceptionName "System.ArgumentException" `
                       -ExceptionMessage $message `
                       -ErrorId "InvalidWebUri" `
                       -CallerPSCmdlet $CallerPSCmdlet `
                       -ErrorCategory InvalidArgument `
                       -ExceptionObject $Location
        }
    }
}
function Resolve-PathHelper
{
    param
    (
        [Parameter()]
        [ValidateNotNullOrEmpty()]
        [string[]]
        $path,

        [Parameter()]
        [switch]
        $isLiteralPath,

        [Parameter()]
        [ValidateNotNullOrEmpty()]
        [System.Management.Automation.PSCmdlet]
        $callerPSCmdlet
    )

    $resolvedPaths =@()

    foreach($currentPath in $path)
    {
        try
        {
            if($isLiteralPath)
            {
                $currentResolvedPaths = Microsoft.PowerShell.Management\Resolve-Path -LiteralPath $currentPath -ErrorAction Stop
            }
            else
            {
                $currentResolvedPaths = Microsoft.PowerShell.Management\Resolve-Path -Path $currentPath -ErrorAction Stop
            }
        }
        catch
        {
            $errorMessage = ($LocalizedData.PathNotFound -f $currentPath)
            ThrowError  -ExceptionName "System.InvalidOperationException" `
                        -ExceptionMessage $errorMessage `
                        -ErrorId "PathNotFound" `
                        -CallerPSCmdlet $callerPSCmdlet `
                        -ErrorCategory InvalidOperation
        }

        foreach($currentResolvedPath in $currentResolvedPaths)
        {
            $resolvedPaths += $currentResolvedPath.ProviderPath
        }
    }

    $resolvedPaths
}
function Save-ModuleSources
{
    if($script:PSGetModuleSources)
    {
        if(-not (Microsoft.PowerShell.Management\Test-Path $script:PSGetAppLocalPath))
        {
            $null = Microsoft.PowerShell.Management\New-Item -Path $script:PSGetAppLocalPath `
                                                             -ItemType Directory -Force `
                                                             -ErrorAction SilentlyContinue `
                                                             -WarningAction SilentlyContinue `
                                                             -Confirm:$false -WhatIf:$false
        }
        Microsoft.PowerShell.Utility\Out-File -FilePath $script:PSGetModuleSourcesFilePath -Force -InputObject ([System.Management.Automation.PSSerializer]::Serialize($script:PSGetModuleSources))
   }
}
function Save-PSGetSettings
{
    if($script:PSGetSettings)
    {
        if(-not (Microsoft.PowerShell.Management\Test-Path -Path $script:PSGetAppLocalPath))
        {
            $null = Microsoft.PowerShell.Management\New-Item -Path $script:PSGetAppLocalPath `
                                                             -ItemType Directory `
                                                             -Force `
                                                             -ErrorAction SilentlyContinue `
                                                             -WarningAction SilentlyContinue `
                                                             -Confirm:$false `
                                                             -WhatIf:$false
        }

        Microsoft.PowerShell.Utility\Out-File -FilePath $script:PSGetSettingsFilePath -Force `
            -InputObject ([System.Management.Automation.PSSerializer]::Serialize($script:PSGetSettings))

        Write-Debug "In Save-PSGetSettings, persisted the $script:PSGetSettingsFilePath file"
   }
}
function Send-EnvironmentChangeMessage
# Broadcast the Environment variable changes, so that other processes pick changes to Environment variables without having to reboot or logoff/logon.
{
    if($Script:IsWindows)
    {
        if (-not ('Microsoft.PowerShell.Commands.PowerShellGet.Win32.NativeMethods' -as [type]))
        {
            Add-Type -Namespace Microsoft.PowerShell.Commands.PowerShellGet.Win32 `
                     -Name NativeMethods `
                     -MemberDefinition @'
                        [DllImport("user32.dll", SetLastError = true, CharSet = CharSet.Auto)]
                        public static extern IntPtr SendMessageTimeout(
                            IntPtr hWnd,
                            uint Msg,
                            UIntPtr wParam,
                            string lParam,
                            uint fuFlags,
                            uint uTimeout,
                            out UIntPtr lpdwResult);
'@
        }

        $HWND_BROADCAST = [System.IntPtr]0xffff
        $WM_SETTINGCHANGE = 0x1a
        $result = [System.UIntPtr]::zero

        $returnValue = [Microsoft.PowerShell.Commands.PowerShellGet.Win32.NativeMethods]::SendMessageTimeout($HWND_BROADCAST,
                                                                                                            $WM_SETTINGCHANGE,
                                                                                                            [System.UIntPtr]::Zero,
                                                                                                            'Environment',
                                                                                                            2,
                                                                                                            5000,
                                                                                                            [ref]$result)
        if($returnValue)
        {
            Write-Verbose -Message $LocalizedData.SentEnvironmentVariableChangeMessage
        }
        else
        {
            Write-Warning -Message $LocalizedData.UnableToSendEnvironmentVariableChangeMessage
        }
    }
}
function Set-EnvironmentVariable
{
    param
    (
        [parameter(Mandatory = $true)]
        [ValidateNotNullOrEmpty()]
        [String]
        $Name,

        [parameter()]
        [String]
        $Value,

        [parameter(Mandatory = $true)]
        [int]
        $Target
    )

    if ($Target -eq $script:EnvironmentVariableTarget.Process)
    {
        [System.Environment]::SetEnvironmentVariable($Name, $Value)

        return
    }
    elseif ($Target -eq $script:EnvironmentVariableTarget.Machine)
    {
        if ($Name.Length -ge $script:SystemEnvironmentVariableMaximumLength)
        {
            $message = $LocalizedData.InvalidEnvironmentVariableName -f ($Name, $script:SystemEnvironmentVariableMaximumLength)
            ThrowError -ExceptionName "System.ArgumentException" `
                        -ExceptionMessage $message `
                        -ErrorId 'InvalidEnvironmentVariableName' `
                        -ErrorCategory InvalidArgument `
                        -ExceptionObject $Name
            return
        }

        $Path = $script:SystemEnvironmentKey
    }
    elseif ($Target -eq $script:EnvironmentVariableTarget.User)
    {
        if ($Name.Length -ge $script:UserEnvironmentVariableMaximumLength)
        {
            $message = $LocalizedData.InvalidEnvironmentVariableName -f ($Name, $script:UserEnvironmentVariableMaximumLength)
            ThrowError -ExceptionName "System.ArgumentException" `
                        -ExceptionMessage $message `
                        -ErrorId 'InvalidEnvironmentVariableName' `
                        -ErrorCategory InvalidArgument `
                        -ExceptionObject $Name
            return
        }

        $Path = $script:UserEnvironmentKey
    }

    if (!$Value)
    {
        Microsoft.PowerShell.Management\Remove-ItemProperty $Path -Name $Name -ErrorAction SilentlyContinue
    }
    else
    {
        Microsoft.PowerShell.Management\Set-ItemProperty $Path -Name $Name -Value $Value
    }

    # Broadcast the Environment variable changes, so that other processes pick changes to Environment variables without having to reboot or logoff/logon.
    Send-EnvironmentChangeMessage
}
function Set-InstalledModulesVariable
{
    # Initialize list of modules installed by the PowerShellGet provider
    $script:PSGetInstalledModules = [ordered]@{}

    $modulePaths = @($script:ProgramFilesModulesPath, $script:MyDocumentsModulesPath)

    foreach ($location in $modulePaths)
    {
        # find all modules installed using PowerShellGet
        $GetChildItemParams = @{
            Path = $location
            Recurse = $true
            Force = $true
            Filter = $script:PSGetItemInfoFileName
            ErrorAction = 'SilentlyContinue'
            WarningAction = 'SilentlyContinue'
        }

        if($script:IsWindows)
        {
            $GetChildItemParams['Attributes'] = 'Hidden'
        }

        $moduleBases = Get-ChildItem @GetChildItemParams | Foreach-Object { $_.Directory }


        foreach ($moduleBase in $moduleBases)
        {
            $PSGetItemInfoPath = Microsoft.PowerShell.Management\Join-Path $moduleBase.FullName $script:PSGetItemInfoFileName

            # Check if this module got installed using PSGet, read its contents to create a SoftwareIdentity object
            if (Microsoft.PowerShell.Management\Test-Path $PSGetItemInfoPath)
            {
                $psgetItemInfo = DeSerialize-PSObject -Path $PSGetItemInfoPath

                # Add InstalledLocation if this module was installed with older version of PowerShellGet
                if(-not (Get-Member -InputObject $psgetItemInfo -Name $script:InstalledLocation))
                {
                    Microsoft.PowerShell.Utility\Add-Member -InputObject $psgetItemInfo `
                                                            -MemberType NoteProperty `
                                                            -Name $script:InstalledLocation `
                                                            -Value $moduleBase.FullName
                }

                $package = New-SoftwareIdentityFromPSGetItemInfo -PSGetItemInfo $psgetItemInfo

                if($package)
                {
                    $script:PSGetInstalledModules["$($psgetItemInfo.Name)$($psgetItemInfo.Version)"] = @{
                                                                                                            SoftwareIdentity = $package
                                                                                                            PSGetItemInfo = $psgetItemInfo
                                                                                                        }
                }
            }
        }
    }
}
function Set-InstalledScriptsVariable
{
    # Initialize list of scripts installed by the PowerShellGet provider
    $script:PSGetInstalledScripts = [ordered]@{}
    $scriptPaths = @($script:ProgramFilesInstalledScriptInfosPath, $script:MyDocumentsInstalledScriptInfosPath)

    foreach ($location in $scriptPaths)
    {
        # find all scripts installed using PowerShellGet
        $scriptInfoFiles = Get-ChildItem -Path $location `
                                         -Filter "*$script:InstalledScriptInfoFileName" `
                                         -ErrorAction SilentlyContinue `
                                         -WarningAction SilentlyContinue

        if($scriptInfoFiles)
        {
            foreach ($scriptInfoFile in $scriptInfoFiles)
            {
                $psgetItemInfo = DeSerialize-PSObject -Path $scriptInfoFile.FullName

                $scriptFilePath = Microsoft.PowerShell.Management\Join-Path -Path $psgetItemInfo.InstalledLocation `
                                                                            -ChildPath "$($psgetItemInfo.Name).ps1"

                # Remove the InstalledScriptInfo.xml file if the actual script file was manually uninstalled by the user
                if(-not (Microsoft.PowerShell.Management\Test-Path -Path $scriptFilePath -PathType Leaf))
                {
                    Microsoft.PowerShell.Management\Remove-Item -Path $scriptInfoFile.FullName -Force -ErrorAction SilentlyContinue

                    continue
                }

                $package = New-SoftwareIdentityFromPSGetItemInfo -PSGetItemInfo $psgetItemInfo

                if($package)
                {
                    $script:PSGetInstalledScripts["$($psgetItemInfo.Name)$($psgetItemInfo.Version)"] = @{
                                                                                                            SoftwareIdentity = $package
                                                                                                            PSGetItemInfo = $psgetItemInfo
                                                                                                        }
                }
            }
        }
    }
}
function Set-ModuleSourcesVariable
{
    [CmdletBinding()]
    param(
        [switch]
        $Force,

        $Proxy,

        $ProxyCredential
    )

    if(-not $script:PSGetModuleSources -or $Force)
    {
        $isPersistRequired = $false
        if(Microsoft.PowerShell.Management\Test-Path $script:PSGetModuleSourcesFilePath)
        {
            $script:PSGetModuleSources = DeSerialize-PSObject -Path $script:PSGetModuleSourcesFilePath
        }
        else
        {
            $script:PSGetModuleSources = [ordered]@{}

            if(-not $script:PSGetModuleSources.Contains($Script:PSGalleryModuleSource))
            {
                $null = Set-PSGalleryRepository -Proxy $Proxy -ProxyCredential $ProxyCredential
            }
        }

        # Already registered repositories may not have the ScriptSourceLocation property, try to populate it from the existing SourceLocation
        # Also populate the PublishLocation and ScriptPublishLocation from the SourceLocation if PublishLocation is empty/null.
        #
        $script:PSGetModuleSources.Keys | Microsoft.PowerShell.Core\ForEach-Object {
                                              $moduleSource = $script:PSGetModuleSources[$_]

                                              if(-not (Get-Member -InputObject $moduleSource -Name $script:ScriptSourceLocation))
                                              {
                                                  $scriptSourceLocation = Get-ScriptSourceLocation -Location $moduleSource.SourceLocation -Proxy $Proxy -ProxyCredential $ProxyCredential

                                                  Microsoft.PowerShell.Utility\Add-Member -InputObject $script:PSGetModuleSources[$_] `
                                                                                          -MemberType NoteProperty `
                                                                                          -Name $script:ScriptSourceLocation `
                                                                                          -Value $scriptSourceLocation

                                                  if(Get-Member -InputObject $moduleSource -Name $script:PublishLocation)
                                                  {
                                                      if(-not $moduleSource.PublishLocation)
                                                      {
                                                          $script:PSGetModuleSources[$_].PublishLocation = Get-PublishLocation -Location $moduleSource.SourceLocation
                                                      }

                                                      Microsoft.PowerShell.Utility\Add-Member -InputObject $script:PSGetModuleSources[$_] `
                                                                                              -MemberType NoteProperty `
                                                                                              -Name $script:ScriptPublishLocation `
                                                                                              -Value $moduleSource.PublishLocation
                                                  }

                                                  $isPersistRequired = $true
                                              }
                                          }

        if($isPersistRequired)
        {
            Save-ModuleSources
        }
    }
}
function Set-PSGalleryRepository
{
    [CmdletBinding()]
    param(
        [Parameter()]
        [switch]
        $Trusted,

        [Parameter()]
        $Proxy,

        [Parameter()]
        $ProxyCredential
    )

    $psgalleryLocation = Resolve-Location -Location $Script:PSGallerySourceUri `
                                          -LocationParameterName 'SourceLocation' `
                                          -Proxy $Proxy `
                                          -ProxyCredential $ProxyCredential `
                                          -ErrorAction SilentlyContinue `
                                          -WarningAction SilentlyContinue

    $scriptSourceLocation = Resolve-Location -Location $Script:PSGalleryScriptSourceUri `
                                             -LocationParameterName 'ScriptSourceLocation' `
                                             -Proxy $Proxy `
                                             -ProxyCredential $ProxyCredential `
                                             -ErrorAction SilentlyContinue `
                                             -WarningAction SilentlyContinue
    if($psgalleryLocation)
    {
        $result = Ping-Endpoint -Endpoint $Script:PSGalleryPublishUri -AllowAutoRedirect:$false -Proxy $Proxy -ProxyCredential $ProxyCredential
        if ($result.ContainsKey($Script:ResponseUri) -and $result[$Script:ResponseUri])
        {
                $script:PSGalleryPublishUri = $result[$Script:ResponseUri]
        }

        $repository = Microsoft.PowerShell.Utility\New-Object PSCustomObject -Property ([ordered]@{
                Name = $Script:PSGalleryModuleSource
                SourceLocation =  $psgalleryLocation
                PublishLocation = $Script:PSGalleryPublishUri
                ScriptSourceLocation = $scriptSourceLocation
                ScriptPublishLocation = $Script:PSGalleryPublishUri
                Trusted=$Trusted
                Registered=$true
                InstallationPolicy = if($Trusted) {'Trusted'} else {'Untrusted'}
                PackageManagementProvider=$script:NuGetProviderName
                ProviderOptions = @{}
            })

        $repository.PSTypeNames.Insert(0, "Microsoft.PowerShell.Commands.PSRepository")
        $script:PSGetModuleSources[$Script:PSGalleryModuleSource] = $repository

        Save-ModuleSources

        return $repository
    }
}
function Set-PSGetSettingsVariable
{
    [CmdletBinding()]
    param([switch]$Force)

    if(-not $script:PSGetSettings -or $Force)
    {
        if(Microsoft.PowerShell.Management\Test-Path -Path $script:PSGetSettingsFilePath)
        {
            $script:PSGetSettings = DeSerialize-PSObject -Path $script:PSGetSettingsFilePath
        }
        else
        {
            $script:PSGetSettings = [ordered]@{}
        }
    }
}

# Compare 2 strings, ignoring any trailing slashes or backslashes.
# This is not exactly the same as URL or path equivalence but it should work in practice
function Test-EquivalentLocation {
    [CmdletBinding()]
    [OutputType("bool")]
    param(
        [Parameter(Mandatory = $false)]
        [string]$LocationA,

        [Parameter(Mandatory = $false)]
        [string]$LocationB
    )

    $LocationA = $LocationA.TrimEnd("\/")
    $LocationB = $LocationB.TrimEnd("\/")
    return $LocationA -eq $LocationB
}
function Test-FileInUse
{
    [CmdletBinding()]
    [OutputType([bool])]
    param
    (
        [string]
        $FilePath
    )

    if(Microsoft.PowerShell.Management\Test-Path -LiteralPath $FilePath -PathType Leaf)
    {
        # Attempts to open a file and handles the exception if the file is already open/locked
        try
        {
            $fileInfo = New-Object System.IO.FileInfo $FilePath
            $fileStream = $fileInfo.Open( [System.IO.FileMode]::Open, [System.IO.FileAccess]::ReadWrite, [System.IO.FileShare]::None )

            if ($fileStream)
            {
                $fileStream.Close()
            }
        }
        catch
        {
            Write-Debug "In Test-FileInUse function, unable to open the $FilePath file in ReadWrite access. $_"
            return $true
        }
    }

    return $false
}
function Test-ItemPrereleaseVersionRequirements
# Returns true if it meets the Required, Minimum, and Maximum version bounds.
{
    [CmdletBinding()]
    param(

        [ValidateNotNullOrEmpty()]
        [string]
        $Version,

        [string]
        $RequiredVersion,

        [string]
        $MinimumVersion,

        [string]
        $MaximumVersion
    )

    $result = ValidateAndGet-VersionPrereleaseStrings -Version $Version -CallerPSCmdlet $PSCmdlet
    if (-not $result)
    {
        # ValidateAndGet-VersionPrereleaseStrings throws the error.
        # returning to avoid further execution when different values are specified for -ErrorAction parameter
        return
    }
    $psgetitemVersion = $result["Version"]
    $psgetitemPrerelease = $result["Prerelease"]
    $psgetitemFullVersion = $result["FullVersion"]

    if($RequiredVersion)
    {
        $reqResult = ValidateAndGet-VersionPrereleaseStrings -Version $RequiredVersion -CallerPSCmdlet $PSCmdlet
        if (-not $reqResult)
        {
            # ValidateAndGet-VersionPrereleaseStrings throws the error.
            # returning to avoid further execution when different values are specified for -ErrorAction parameter
            return
        }
        $reqFullVersion = $reqResult["FullVersion"]

        return ($reqFullVersion -eq $psgetitemFullVersion)
    }
    else
    {
        $minimumBoundMet = $false
        if ($MinimumVersion)
        {
            $minResult = ValidateAndGet-VersionPrereleaseStrings -Version $MinimumVersion -CallerPSCmdlet $PSCmdlet
            if (-not $minResult)
            {
                # ValidateAndGet-VersionPrereleaseStrings throws the error.
                # returning to avoid further execution when different values are specified for -ErrorAction parameter
                return
            }
            $minVersion = $minResult["Version"]
            $minPrerelease = $minResult["Prerelease"]

            # minimum bound is met if PSGet item version is greater than or equal to minimum version
            if (-not (Compare-PrereleaseVersions -FirstItemVersion $psgetitemVersion `
                                                 -FirstItemPrerelease $psgetitemPrerelease `
                                                 -SecondItemVersion $minVersion `
                                                 -SecondItemPrerelease $minPrerelease ))
            {
                $minimumBoundMet = $true
            }
        }
        else
        {
            $minimumBoundMet = $true
        }

        $maximumBoundMet = $false
        if ($MaximumVersion)
        {
            $maxResult = ValidateAndGet-VersionPrereleaseStrings -Version $MaximumVersion -CallerPSCmdlet $PSCmdlet
            if (-not $maxResult)
            {
                # ValidateAndGet-VersionPrereleaseStrings throws the error.
                # returning to avoid further execution when different values are specified for -ErrorAction parameter
                return
            }
            $maxVersion = $maxResult["Version"]
            $maxPrerelease = $maxResult["Prerelease"]

            # maximum bound is met if PSGet item version is less than or equal to maximum version
            if (-not (Compare-PrereleaseVersions -FirstItemVersion $maxVersion `
                                                 -FirstItemPrerelease $maxPrerelease `
                                                 -SecondItemVersion $psgetitemVersion `
                                                 -SecondItemPrerelease $psgetitemPrerelease ))
            {
                $maximumBoundMet = $true
            }
        }
        else
        {
            $maximumBoundMet = $true
        }

        return ($minimumBoundMet -and $maximumBoundMet)
    }
}
function Test-MicrosoftCertificate
{
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$true)]
        [System.Management.Automation.Signature]
        $AuthenticodeSignature
    )

    $IsMicrosoftCertificate = $false

    if($AuthenticodeSignature.SignerCertificate -and
       ('Microsoft.PowerShell.Commands.PowerShellGet.Win32Helpers' -as [Type]))
    {
        $X509Chain = $null
        $SafeX509ChainHandle = $null

        try
        {
            $X509Chain = New-Object System.Security.Cryptography.X509Certificates.X509Chain
            $null = $X509Chain.Build($AuthenticodeSignature.SignerCertificate)

            if($script:IsSafeX509ChainHandleAvailable)
            {
                $SafeX509ChainHandle = [Microsoft.PowerShell.Commands.PowerShellGet.Win32Helpers]::CertDuplicateCertificateChain($X509Chain.SafeHandle)
            }
            else
            {
                $SafeX509ChainHandle = [Microsoft.PowerShell.Commands.PowerShellGet.Win32Helpers]::CertDuplicateCertificateChain($X509Chain.ChainContext)
            }

            $IsMicrosoftCertificate = [Microsoft.PowerShell.Commands.PowerShellGet.Win32Helpers]::IsMicrosoftCertificate($SafeX509ChainHandle)
        }
        catch
        {
            Write-Debug "Exception in Test-MicrosoftCertificate function:  $_"
        }
        finally
        {
            if($SafeX509ChainHandle) { $SafeX509ChainHandle.Dispose() }

            # On .NET Framework 4.5.2 and earlier versions,
            # the X509Chain class does not implement the IDisposable interface and
            # therefore does not have a Dispose method.
            if($X509Chain -and (Get-Member -InputObject $X509Chain -Name Dispose -ErrorAction SilentlyContinue)) { $X509Chain.Dispose() }
        }
    }

    return $IsMicrosoftCertificate
}
function Test-ModuleInstalled
{
    [CmdletBinding(PositionalBinding=$false)]
    [OutputType("PSModuleInfo")]
    Param
    (
        [Parameter(Mandatory=$true)]
        [ValidateNotNullOrEmpty()]
        [string]
        $Name,

        [Parameter()]
        [string]
        $RequiredVersion
    )

    # Check if module is already installed
    $availableModule = Microsoft.PowerShell.Core\Get-Module -ListAvailable -Name $Name -Verbose:$false |
                           Microsoft.PowerShell.Core\Where-Object {
                               -not (Test-ModuleSxSVersionSupport) `
                               -or (-not $RequiredVersion) `
                               -or ($RequiredVersion.Trim() -eq $_.Version.ToString()) `
                               -or (Test-ItemPrereleaseVersionRequirements -Version $_.Version -RequiredVersion $RequiredVersion)
                            } | Microsoft.PowerShell.Utility\Select-Object -Unique -First 1 -ErrorAction Ignore

    return $availableModule
}
function Test-ModuleInUse
{
    [CmdletBinding()]
    [OutputType([bool])]
    Param
    (
        [Parameter(Mandatory=$true)]
        [ValidateNotNullOrEmpty()]
        [string]
        $ModuleBasePath,

        [Parameter(Mandatory=$true)]
        [ValidateNotNullOrEmpty()]
        [string]
        $ModuleName,

        [Parameter(Mandatory=$true)]
        [ValidateNotNullOrEmpty()]
        [string]
        $ModuleVersion
    )

    $FileList = Get-ChildItem -Path $ModuleBasePath `
                              -File `
                              -Recurse `
                              -ErrorAction SilentlyContinue `
                              -WarningAction SilentlyContinue
    $IsModuleInUse = $false

    foreach($file in $FileList)
    {
        $IsModuleInUse = Test-FileInUse -FilePath $file.FullName

        if($IsModuleInUse)
        {
            break
        }
    }

    if($IsModuleInUse)
    {
        $message = $LocalizedData.ModuleVersionInUse -f ($ModuleVersion, $ModuleName)
        Write-Error -Message $message -ErrorId 'ModuleIsInUse' -Category InvalidOperation

        return $true
    }

    return $false
}
function Test-ModuleSxSVersionSupport
{
    # Side-by-Side module version is available on PowerShell 5.0 or later versions only
    # By default, PowerShell module versions will be installed/updated Side-by-Side.
    $PSVersionTable.PSVersion -ge '5.0.0'
}
function Test-RunningAsElevated
# Check if current user is running with elevated privileges
{
    [CmdletBinding()]
    [OutputType([bool])]
    Param()

    if(-not $script:IsRunningAsElevatedTested -and $script:IsRunningAsElevated)
    {
        if($script:IsWindows)
        {
            $wid=[System.Security.Principal.WindowsIdentity]::GetCurrent()
            $prp=new-object System.Security.Principal.WindowsPrincipal($wid)
            $adm=[System.Security.Principal.WindowsBuiltInRole]::Administrator
            $script:IsRunningAsElevated = $prp.IsInRole($adm)
        }
        elseif($script:IsCoreCLR)
        {
            # Permission models on *nix can be very complex, to the point that you could never possibly guess without simply trying what you need to try;
            # This is totally different from Windows where you can know what you can or cannot do with/without admin rights.
            $script:IsRunningAsElevated = $true
        }

        $script:IsRunningAsElevatedTested = $true
    }

    return $script:IsRunningAsElevated
}
function Test-ScriptInstalled
{
    [CmdletBinding(PositionalBinding=$false)]
    Param
    (
        [Parameter(Mandatory=$true)]
        [ValidateNotNullOrEmpty()]
        [string]
        $Name,

        [Parameter()]
        [string]
        $RequiredVersion
    )

    $scriptInfo = $null
    $scriptFileName = "$Name.ps1"
    $scriptPaths = @($script:ProgramFilesScriptsPath, $script:MyDocumentsScriptsPath)
    $scriptInfos = @()

    if ($RequiredVersion)
    {
        $reqResult = ValidateAndGet-VersionPrereleaseStrings -Version $RequiredVersion -CallerPSCmdlet $PSCmdlet
        if (-not $reqResult)
        {
            return
        }
        $reqFullVersion = $reqResult["FullVersion"]
    }


    foreach ($location in $scriptPaths)
    {
        $scriptFilePath = Microsoft.PowerShell.Management\Join-Path -Path $location -ChildPath $scriptFileName

        if(Microsoft.PowerShell.Management\Test-Path -Path $scriptFilePath -PathType Leaf)
        {
            $scriptInfo = $null
            try
            {
                $scriptInfo = Test-ScriptFileInfo -Path $scriptFilePath -ErrorAction SilentlyContinue -WarningAction SilentlyContinue
            }
            catch
            {
                # Ignore any terminating error from the Test-ScriptFileInfo cmdlet,
                # if it does not contain valid Script metadata
                Write-Verbose -Message "$_"
            }

            if($scriptInfo)
            {
                $scriptInfos += $scriptInfo
            }
            else
            {
                # Since the script file doesn't contain the valid script metadata,
                # create dummy PSScriptInfo object with 0.0 version
                $scriptInfo = New-PSScriptInfoObject -Path $scriptFilePath
                $scriptInfo.$script:Version = [Version]'0.0'

                $scriptInfos += $scriptInfo
            }
        }
    }

    $scriptInfo = $scriptInfos | Microsoft.PowerShell.Core\Where-Object {
                                                                $thisResult = ValidateAndGet-VersionPrereleaseStrings -Version $_.Version -CallerPSCmdlet $PSCmdlet
                                                                if (-not $thisResult)
                                                                {
                                                                    return
                                                                }
                                                                $thisFullVersion = $thisResult["FullVersion"]
                                                                (-not $RequiredVersion) -or ($reqFullVersion -eq $thisFullVersion)
                                                            } | Microsoft.PowerShell.Utility\Select-Object -First 1 -ErrorAction Ignore

    return $scriptInfo
}
function Test-ValidManifestModule
{
    [CmdletBinding()]
    [OutputType([bool])]
    Param
    (
        [Parameter(Mandatory=$true)]
        [ValidateNotNullOrEmpty()]
        [string]
        $ModuleBasePath,

        [Parameter(Mandatory=$true)]
        [ValidateNotNullOrEmpty()]
        [string]
        $ModuleName,

        [Parameter(Mandatory=$true)]
        [ValidateNotNullOrEmpty()]
        [string]
        $InstallLocation,

        [Parameter()]
        [Switch]
        $SkipPublisherCheck,

        [Parameter()]
        [Switch]
        $AllowClobber,

        [Parameter()]
        [Switch]
        $IsUpdateOperation
    )

    Write-Verbose -Message ($LocalizedData.ValidatingTheModule -f $ModuleName,$ModuleBasePath)
    $manifestPath = Join-PathUtility -Path $ModuleBasePath -ChildPath "$ModuleName.psd1" -PathType File
    $PSModuleInfo = $null

    if(-not (Microsoft.PowerShell.Management\Test-Path $manifestPath -PathType Leaf))
    {
        $message = $LocalizedData.PathNotFound -f ($manifestPath)
        ThrowError -ExceptionName 'System.InvalidOperationException' `
                    -ExceptionMessage $message `
                    -ErrorId 'PathNotFound' `
                    -CallerPSCmdlet $PSCmdlet `
                    -ErrorCategory InvalidOperation
    }

    $PSModuleInfo = Microsoft.PowerShell.Core\Test-ModuleManifest -Path $manifestPath -ErrorAction SilentlyContinue -WarningAction SilentlyContinue

    if(-not $PSModuleInfo)
    {
        $message = $LocalizedData.InvalidPSModule -f ($moduleName)
        ThrowError -ExceptionName 'System.InvalidOperationException' `
                    -ExceptionMessage $message `
                    -ErrorId 'InvalidManifestModule' `
                    -CallerPSCmdlet $PSCmdlet `
                    -ErrorCategory InvalidOperation
    }
    else
    {
        Write-Verbose -Message ($LocalizedData.ValidatedModuleManifestFile -f $ModuleBasePath)
    }

    if($script:IsWindows)
    {
        Write-Verbose -Message ($LocalizedData.ValidateModuleAuthenticodeSignature -f $ModuleName)
        $ValidationResult = Validate-ModuleAuthenticodeSignature -CurrentModuleInfo $PSModuleInfo `
                                                                    -InstallLocation $InstallLocation `
                                                                    -IsUpdateOperation:$IsUpdateOperation `
                                                                    -SkipPublisherCheck:$SkipPublisherCheck
        
        if($ValidationResult)
        {
            # Checking for the possible command clobbering.
            Write-Verbose -Message ($LocalizedData.ValidateModuleCommandAlreadyAvailable -f $ModuleName)
            $ValidationResult = Validate-ModuleCommandAlreadyAvailable -CurrentModuleInfo $PSModuleInfo `
                                                                        -InstallLocation $InstallLocation `
                                                                        -AllowClobber:$AllowClobber `
                                                                        -IsUpdateOperation:$IsUpdateOperation
        }

        if(-not $ValidationResult)
        {
            $PSModuleInfo = $null
        }
    }

    return $PSModuleInfo
}
function Test-WebUri
{
    [CmdletBinding()]
    [OutputType([bool])]
    Param
    (
        [Parameter(Mandatory=$true)]
        [ValidateNotNullOrEmpty()]
        [Uri]
        $uri
    )

    return ($uri.AbsoluteURI -ne $null) -and ($uri.Scheme -match '[http|https]')
}
function Test-WildcardPattern
{
    [CmdletBinding()]
    [OutputType([bool])]
    param(
        [Parameter(Mandatory=$true)]
        [ValidateNotNull()]
        $Name
    )

    return [System.Management.Automation.WildcardPattern]::ContainsWildcardCharacters($Name)
}
function ThrowError
# Utility to throw an errorrecord
{
    param
    (
        [parameter(Mandatory = $true)]
        [ValidateNotNullOrEmpty()]
        [System.Management.Automation.PSCmdlet]
        $CallerPSCmdlet,

        [parameter(Mandatory = $true)]
        [ValidateNotNullOrEmpty()]
        [System.String]
        $ExceptionName,

        [parameter(Mandatory = $true)]
        [ValidateNotNullOrEmpty()]
        [System.String]
        $ExceptionMessage,

        [System.Object]
        $ExceptionObject,

        [parameter(Mandatory = $true)]
        [ValidateNotNullOrEmpty()]
        [System.String]
        $ErrorId,

        [parameter(Mandatory = $true)]
        [ValidateNotNull()]
        [System.Management.Automation.ErrorCategory]
        $ErrorCategory
    )

    $exception = New-Object $ExceptionName $ExceptionMessage;
    $errorRecord = New-Object System.Management.Automation.ErrorRecord $exception, $ErrorId, $ErrorCategory, $ExceptionObject
    $CallerPSCmdlet.ThrowTerminatingError($errorRecord)
}
function Validate-ModuleAuthenticodeSignature
{
    [CmdletBinding()]
    param
    (
        [Parameter(Mandatory=$true)]
        $CurrentModuleInfo,

        [Parameter(Mandatory=$true)]
        [ValidateNotNullOrEmpty()]
        [string]
        $InstallLocation,

        [Parameter()]
        [Switch]
        $IsUpdateOperation,

        [Parameter()]
        [Switch]
        $SkipPublisherCheck
    )

    # Skip the publisher check when -SkipPublisherCheck is specified and
    # it is not an update operation.
    if(-not $IsUpdateOperation -and $SkipPublisherCheck)
    {
        $Message = $LocalizedData.SkippingPublisherCheck -f ($CurrentModuleInfo.Version, $CurrentModuleInfo.Name)
        Write-Verbose -Message $message

        return $true
    }

    $InstalledModuleDetails = $null
    $InstalledModuleInfo = Test-ModuleInstalled -Name $CurrentModuleInfo.Name
    if($InstalledModuleInfo)
    {
        $InstalledModuleDetails = Get-InstalledModuleAuthenticodeSignature -InstalledModuleInfo $InstalledModuleInfo `
                                                                           -InstallLocation $InstallLocation
    }

    # Validate the catalog signature for the current module being installed.
    $ev = $null
    $CurrentModuleDetails = ValidateAndGet-AuthenticodeSignature -ModuleInfo $CurrentModuleInfo -ErrorVariable ev

    if($ev)
    {
        Write-Debug "$ev"
        return $false
    }

    if($InstalledModuleInfo)
    {
        $CurrentModuleAuthenticodePublisher = $null
        $CurrentModuleRootCA = $null
        $IsCurrentModuleSignedByMicrosoft = $false

        if($CurrentModuleDetails)
        {
            $CurrentModuleAuthenticodePublisher = $CurrentModuleDetails.Publisher
            $CurrentModuleRootCA = $CurrentModuleDetails.RootCertificateAuthority
            $IsCurrentModuleSignedByMicrosoft = $CurrentModuleDetails.IsMicrosoftCertificate

            $message = $LocalizedData.NewModuleVersionDetailsForPublisherValidation -f ($CurrentModuleInfo.Name,
                                                                                        $CurrentModuleInfo.Version,
                                                                                        $CurrentModuleDetails.Publisher,
                                                                                        $CurrentModuleDetails.RootCertificateAuthority,
                                                                                        $CurrentModuleDetails.IsMicrosoftCertificate)
            Write-Verbose $message
        }

        $InstalledModuleAuthenticodePublisher = $null
        $InstalledModuleRootCA = $null
        $IsInstalledModuleSignedByMicrosoft = $false
        $InstalledModuleVersion = [Version]'0.0'

        if($InstalledModuleDetails)
        {
            $InstalledModuleAuthenticodePublisher = $InstalledModuleDetails.Publisher
            $InstalledModuleRootCA = $InstalledModuleDetails.RootCertificateAuthority
            $IsInstalledModuleSignedByMicrosoft = $InstalledModuleDetails.IsMicrosoftCertificate
            $InstalledModuleVersion = $InstalledModuleDetails.Version

            $message = $LocalizedData.SourceModuleDetailsForPublisherValidation -f ($CurrentModuleInfo.Name,
                                                                                    $InstalledModuleDetails.Version,
                                                                                    $InstalledModuleDetails.ModuleBase,
                                                                                    $InstalledModuleDetails.Publisher,
                                                                                    $InstalledModuleDetails.RootCertificateAuthority,
                                                                                    $InstalledModuleDetails.IsMicrosoftCertificate)
            Write-Verbose $message
        }

        Write-Debug -Message "Previously-installed module publisher: $InstalledModuleAuthenticodePublisher"
        Write-Debug -Message "Current module publisher: $CurrentModuleAuthenticodePublisher"
        Write-Debug -Message "Is previously-installed module signed by Microsoft: $IsInstalledModuleSignedByMicrosoft"
        Write-Debug -Message "Is current module signed by Microsoft: $IsCurrentModuleSignedByMicrosoft"

        if($InstalledModuleAuthenticodePublisher)
        {
            if(-not $CurrentModuleAuthenticodePublisher)
            {
                $Message = $LocalizedData.ModuleIsNotCatalogSigned -f ($CurrentModuleInfo.Version, $CurrentModuleInfo.Name, "$($CurrentModuleInfo.Name).cat", $InstalledModuleAuthenticodePublisher, $InstalledModuleDetails.Version, $InstalledModuleDetails.ModuleBase)
                ThrowError -ExceptionName 'System.InvalidOperationException' `
                            -ExceptionMessage $message `
                            -ErrorId 'ModuleIsNotCatalogSigned' `
                            -CallerPSCmdlet $PSCmdlet `
                            -ErrorCategory InvalidOperation
                return $false
            }
            elseif(($InstalledModuleAuthenticodePublisher -eq $CurrentModuleAuthenticodePublisher) -and
                    $InstalledModuleRootCA -and $CurrentModuleRootCA -and 
                    ($InstalledModuleRootCA -eq $CurrentModuleRootCA))
            {
                $Message = $LocalizedData.AuthenticodeIssuerMatch -f ($CurrentModuleAuthenticodePublisher, $CurrentModuleInfo.Name, $CurrentModuleInfo.Version, $InstalledModuleAuthenticodePublisher, $InstalledModuleInfo.Name, $InstalledModuleVersion)
                Write-Verbose -Message $message
            }
            elseif($IsInstalledModuleSignedByMicrosoft)
            {
                if($IsCurrentModuleSignedByMicrosoft)
                {
                    $Message = $LocalizedData.PublishersMatch -f ($CurrentModuleAuthenticodePublisher, $CurrentModuleInfo.Name, $CurrentModuleInfo.Version, $InstalledModuleAuthenticodePublisher, $InstalledModuleInfo.Name, $InstalledModuleVersion)
                    Write-Verbose -Message $message
                }
                else
                {
                    if (-not $script:WhitelistedModules.ContainsKey($CurrentModuleInfo.Name)) {
                        $Message = $LocalizedData.PublishersMismatch -f ($InstalledModuleInfo.Name, $InstalledModuleVersion, $CurrentModuleInfo.Name, $CurrentModuleAuthenticodePublisher, $CurrentModuleInfo.Version)
                        ThrowError -ExceptionName 'System.InvalidOperationException' `
                                -ExceptionMessage $message `
                                -ErrorId 'PublishersMismatch' `
                                -CallerPSCmdlet $PSCmdlet `
                                -ErrorCategory InvalidOperation

                        return $false
                    }

                    $Message = $LocalizedData.PublishersMismatchAsWarning -f ($InstalledModuleInfo.Name, $InstalledModuleVersion, $InstalledModuleAuthenticodePublisher, $CurrentModuleInfo.Version, $CurrentModuleAuthenticodePublisher)
                    Write-Warning $Message
                    return $true
                }
            }
            else
            {
                $Message = $LocalizedData.AuthenticodeIssuerMismatch -f ($CurrentModuleAuthenticodePublisher, $CurrentModuleInfo.Name, $CurrentModuleInfo.Version, $CurrentModuleRootCA, $InstalledModuleAuthenticodePublisher, $InstalledModuleInfo.Name, $InstalledModuleVersion, $InstalledModuleRootCA)
                ThrowError -ExceptionName 'System.InvalidOperationException' `
                            -ExceptionMessage $message `
                            -ErrorId 'AuthenticodeIssuerMismatch' `
                            -CallerPSCmdlet $PSCmdlet `
                            -ErrorCategory InvalidOperation
                return $false
            }
        }
    }

    return $true
}
function Validate-ModuleCommandAlreadyAvailable
{
    [CmdletBinding()]
    param
    (
        [Parameter(Mandatory=$true)]
        [PSModuleInfo]
        $CurrentModuleInfo,

        [Parameter(Mandatory=$true)]
        [ValidateNotNullOrEmpty()]
        [string]
        $InstallLocation,

        [Parameter()]
        [Switch]
        $AllowClobber,

        [Parameter()]
        [Switch]
        $IsUpdateOperation
    )

    <#
        Install-Module must generate an error message when there is a conflict.
        User can specify -AllowClobber to avoid the message.
        Scenario: A large module could be separated into 2 smaller modules.
        Reason 1: the consumer might have to change code (aka: import-module) to use the command from the new module.
        Reason 2: it is too confusing to troubleshoot this problem if the user isn't informed right away.
    #>
    # When new module has some commands, no clobber error if
    # - AllowClobber is specified, or
    # - Installing to the same module base, or
    # - Update operation
    if($CurrentModuleInfo.ExportedCommands.Keys.Count -and
       -not $AllowClobber -and
       -not $IsUpdateOperation)
    {
        # Remove the version folder on 5.0 to get the actual module base folder without version
        if(Test-ModuleSxSVersionSupport)
        {
            $InstallLocation = Microsoft.PowerShell.Management\Split-Path -Path $InstallLocation
        }

        $InstalledModuleInfo = Test-ModuleInstalled -Name $CurrentModuleInfo.Name
        if(-not $InstalledModuleInfo -or -not $InstalledModuleInfo.ModuleBase.StartsWith($InstallLocation, [System.StringComparison]::OrdinalIgnoreCase))
        {
            # Throw an error if there is a command with the same name from a different source.
            $CommandNames = $CurrentModuleInfo.ExportedCommands.Values.Name

            # construct a hash with all of the commands in this module.
            $CommandNameHash = @{}
            $CommandNames | % { $CommandNameHash[$_] = 1 }
            
            $AvailableCommands = Microsoft.PowerShell.Core\Get-Command  `
                                                                      -ErrorAction Ignore `
                                                                      -WarningAction SilentlyContinue |
                                    Microsoft.PowerShell.Core\Where-Object { ($CommandNameHash.ContainsKey($_.Name)) -and
                                                                             ($_.ModuleName -ne $script:PSModuleProviderName) -and
                                                                             ($_.ModuleName -ne 'PSModule') -and
                                                                             ($_.ModuleName -ne $CurrentModuleInfo.Name) }
            if($AvailableCommands)
            {
                $AvailableCommandsList = ($AvailableCommands.Name | Microsoft.PowerShell.Utility\Select-Object -Unique -ErrorAction Ignore) -join ","
                $message = $LocalizedData.ModuleCommandAlreadyAvailable -f ($AvailableCommandsList, $CurrentModuleInfo.Name)
                ThrowError -ExceptionName 'System.InvalidOperationException' `
                           -ExceptionMessage $message `
                           -ErrorId 'CommandAlreadyAvailable' `
                           -CallerPSCmdlet $PSCmdlet `
                           -ErrorCategory InvalidOperation

                return $false
            }
        }
    }

    return $true
}
function Validate-ScriptFileInfoParameters
{
    [CmdletBinding(PositionalBinding=$false)]
    Param
    (
        [Parameter(Mandatory=$true)]
        [PSCustomObject]
        $Parameters
    )

    $hasErrors = $false

    $Parameters.Keys | ForEach-Object {

                                    $parameterName = $_

                                    $parameterValue = $($Parameters[$parameterName])

                                    if("$parameterValue" -match '<#' -or "$parameterValue" -match '#>')
                                    {
                                        $message = $LocalizedData.InvalidParameterValue -f ($parameterValue, $parameterName)
                                        Write-Error -Message $message -ErrorId 'InvalidParameterValue' -Category InvalidArgument

                                        $hasErrors = $true
                                    }
                                }
    return (-not $hasErrors)
}
function Validate-VersionParameters
{
    [CmdletBinding()]
    Param(
        [parameter(Mandatory = $true)]
        [ValidateNotNullOrEmpty()]
        [System.Management.Automation.PSCmdlet]
        $CallerPSCmdlet,

        [Parameter()]
        [String[]]
        $Name,

        [Parameter()]
        [string]
        $MinimumVersion,

        [Parameter()]
        [string]
        $RequiredVersion,

        [Parameter()]
        [string]
        $MaximumVersion,

        [Parameter()]
        [Switch]
        $AllVersions,

        [Parameter()]
        [Switch]
        $AllowPrerelease,

        [Parameter()]
        [Switch]
        $TestWildcardsInName
    )

    if ($MinimumVersion)
    {
        $minResult = ValidateAndGet-VersionPrereleaseStrings -Version $MinimumVersion -CallerPSCmdlet $PSCmdlet
        if (-not $minResult)
        {
            # ValidateAndGet-VersionPrereleaseStrings throws the error.
            # returning to avoid further execution when different values are specified for -ErrorAction parameter
            return
        }

        $minimumVersionVer = $minResult["Version"]
        $minimumVersionPrerelease = $minResult["Prerelease"]
    }
    if ($MaximumVersion)
    {
        $maxResult = ValidateAndGet-VersionPrereleaseStrings -Version $MaximumVersion -CallerPSCmdlet $PSCmdlet
        if (-not $maxResult)
        {
            # ValidateAndGet-VersionPrereleaseStrings throws the error.
            # returning to avoid further execution when different values are specified for -ErrorAction parameter
            return
        }

        $maximumVersionVer = $maxResult["Version"]
        $maximumVersionPrerelease = $maxResult["Prerelease"]
    }
    if ($RequiredVersion)
    {
        $reqResult = ValidateAndGet-VersionPrereleaseStrings -Version $RequiredVersion -CallerPSCmdlet $PSCmdlet
        if (-not $reqResult)
        {
            # ValidateAndGet-VersionPrereleaseStrings throws the error.
            # returning to avoid further execution when different values are specified for -ErrorAction parameter
            return
        }
    }

    if($TestWildcardsInName -and $Name -and (Test-WildcardPattern -Name "$Name"))
    {
        ThrowError -ExceptionName "System.ArgumentException" `
                   -ExceptionMessage ($LocalizedData.NameShouldNotContainWildcardCharacters -f "$($Name -join ',')") `
                   -ErrorId 'NameShouldNotContainWildcardCharacters' `
                   -CallerPSCmdlet $CallerPSCmdlet `
                   -ErrorCategory InvalidArgument `
                   -ExceptionObject $Name
    }
    elseif($AllVersions -and ($RequiredVersion -or $MinimumVersion -or $MaximumVersion))
    {
        ThrowError -ExceptionName "System.ArgumentException" `
                   -ExceptionMessage $LocalizedData.AllVersionsCannotBeUsedWithOtherVersionParameters `
                   -ErrorId 'AllVersionsCannotBeUsedWithOtherVersionParameters' `
                   -CallerPSCmdlet $CallerPSCmdlet `
                   -ErrorCategory InvalidArgument
    }
    elseif($RequiredVersion -and ($MinimumVersion -or $MaximumVersion))
    {
        ThrowError -ExceptionName "System.ArgumentException" `
                   -ExceptionMessage $LocalizedData.VersionRangeAndRequiredVersionCannotBeSpecifiedTogether `
                   -ErrorId "VersionRangeAndRequiredVersionCannotBeSpecifiedTogether" `
                   -CallerPSCmdlet $CallerPSCmdlet `
                   -ErrorCategory InvalidArgument
    }
    elseif($MinimumVersion -and $MaximumVersion -and (Compare-PrereleaseVersions -FirstItemVersion $maximumVersionVer `
                                                                                 -FirstItemPrerelease $maximumVersionPrerelease `
                                                                                 -SecondItemVersion $minimumVersionVer `
                                                                                 -SecondItemPrerelease $minimumVersionPrerelease))
    {
        $Message = $LocalizedData.MinimumVersionIsGreaterThanMaximumVersion -f ($MinimumVersion, $MaximumVersion)
        ThrowError -ExceptionName "System.ArgumentException" `
                    -ExceptionMessage $Message `
                    -ErrorId "MinimumVersionIsGreaterThanMaximumVersion" `
                    -CallerPSCmdlet $CallerPSCmdlet `
                    -ErrorCategory InvalidArgument
    }
    elseif( (($MinimumVersion -match '-') -or ($MaximumVersion -match '-') -or ($RequiredVersion -match '-')) -and -not $AllowPrerelease)
    {
        ThrowError -ExceptionName "System.ArgumentException" `
                   -ExceptionMessage $LocalizedData.AllowPrereleaseRequiredToUsePrereleaseStringInVersion `
                   -ErrorId "AllowPrereleaseRequiredToUsePrereleaseStringInVersion" `
                   -CallerPSCmdlet $CallerPSCmdlet `
                   -ErrorCategory InvalidArgument
    }
    elseif($AllVersions -or $AllowPrerelease -or $RequiredVersion -or $MinimumVersion -or $MaximumVersion)
    {
        if(-not $Name -or $Name.Count -ne 1 -or (Test-WildcardPattern -Name $Name[0]))
        {
            ThrowError -ExceptionName "System.ArgumentException" `
                       -ExceptionMessage $LocalizedData.VersionParametersAreAllowedOnlyWithSingleName `
                       -ErrorId "VersionParametersAreAllowedOnlyWithSingleName" `
                       -CallerPSCmdlet $CallerPSCmdlet `
                       -ErrorCategory InvalidArgument
        }
    }

    return $true
}
function ValidateAndAdd-PSScriptInfoEntry
{
    [CmdletBinding()]
    Param
    (
        [Parameter(Mandatory=$true)]
        [PSCustomObject]
        $PSScriptInfo,

        [Parameter(Mandatory=$true)]
        [string]
        $PropertyName,

        [Parameter()]
        $PropertyValue,

        [parameter(Mandatory = $true)]
        [ValidateNotNullOrEmpty()]
        [System.Management.Automation.PSCmdlet]
        $CallerPSCmdlet
    )

    $Value = $PropertyValue
    $KeyName = $PropertyName

    # return if $KeyName value is not null in $PSScriptInfo
    if(-not $value -or -not $KeyName -or (Get-Member -InputObject $PSScriptInfo -Name $KeyName) -and $PSScriptInfo."$KeyName")
    {
        return
    }

    switch($PropertyName)
    {
        # Validate the property value and also use proper key name as users can specify the property name in any case.
        $script:Version {
                            $KeyName = $script:Version
                            $result = ValidateAndGet-VersionPrereleaseStrings -Version $Value -CallerPSCmdlet $CallerPSCmdlet
                            if (-not $result)
                            {
                                # ValidateAndGet-VersionPrereleaseStrings throws the error.
                                # returning to avoid further execution when different values are specified for -ErrorAction parameter
                                return
                            }
                            $Version = $result["Version"]
                            $Prerelease = $result["Prerelease"]
                            $fullVersion = $result["FullVersion"]
                            $Value = if ($Prerelease) { $fullVersion } else { $Version }
                            break
                        }

        $script:Author  { $KeyName = $script:Author }

        $script:Guid  {
                        $KeyName = $script:Guid

                        [Guid]$guid = [System.Guid]::Empty
                        if([System.Guid]::TryParse($Value, ([ref]$guid)))
                        {
                            $Value = $guid
                        }
                        else
                        {
                            $message = $LocalizedData.InvalidGuid -f ($Value)
                            ThrowError -ExceptionName 'System.ArgumentException' `
                                       -ExceptionMessage $message `
                                       -ErrorId 'InvalidGuid' `
                                       -CallerPSCmdlet $CallerPSCmdlet `
                                       -ErrorCategory InvalidArgument `
                                       -ExceptionObject $Value
                            return
                        }

                        break
                     }

        $script:Description { $KeyName = $script:Description }

        $script:CompanyName { $KeyName = $script:CompanyName }

        $script:Copyright { $KeyName = $script:Copyright }

        $script:Tags {
                        $KeyName = $script:Tags
                        $Value = $Value -split '[,\s+]' | Microsoft.PowerShell.Core\Where-Object {$_}
                        break
                     }

        $script:LicenseUri {
                                $KeyName = $script:LicenseUri
                                if(-not (Test-WebUri -Uri $Value))
                                {
                                    $message = $LocalizedData.InvalidWebUri -f ($LicenseUri, "LicenseUri")
                                    ThrowError -ExceptionName "System.ArgumentException" `
                                                -ExceptionMessage $message `
                                                -ErrorId "InvalidWebUri" `
                                                -CallerPSCmdlet $CallerPSCmdlet `
                                                -ErrorCategory InvalidArgument `
                                                -ExceptionObject $Value
                                    return
                                }

                                $Value = [Uri]$Value
                           }

        $script:ProjectUri {
                                $KeyName = $script:ProjectUri
                                if(-not (Test-WebUri -Uri $Value))
                                {
                                    $message = $LocalizedData.InvalidWebUri -f ($ProjectUri, "ProjectUri")
                                    ThrowError -ExceptionName "System.ArgumentException" `
                                                -ExceptionMessage $message `
                                                -ErrorId "InvalidWebUri" `
                                                -CallerPSCmdlet $CallerPSCmdlet `
                                                -ErrorCategory InvalidArgument `
                                                -ExceptionObject $Value
                                    return
                                }

                                $Value = [Uri]$Value
                           }

        $script:IconUri {
                            $KeyName = $script:IconUri
                            if(-not (Test-WebUri -Uri $Value))
                            {
                                $message = $LocalizedData.InvalidWebUri -f ($IconUri, "IconUri")
                                ThrowError -ExceptionName "System.ArgumentException" `
                                            -ExceptionMessage $message `
                                            -ErrorId "InvalidWebUri" `
                                            -CallerPSCmdlet $CallerPSCmdlet `
                                            -ErrorCategory InvalidArgument `
                                            -ExceptionObject $Value
                                return
                            }

                            $Value = [Uri]$Value
                        }

        $script:ExternalModuleDependencies {
                                               $KeyName = $script:ExternalModuleDependencies
                                               $Value = $Value -split '[,\s+]' | Microsoft.PowerShell.Core\Where-Object {$_}
                                           }

        $script:ReleaseNotes { $KeyName = $script:ReleaseNotes }

        $script:RequiredModules { $KeyName = $script:RequiredModules }

        $script:RequiredScripts {
                                    $KeyName = $script:RequiredScripts
                                    $Value = $Value -split ',(?=[^\[^\(]\w(?!\w+[\)\]]))|\s' | Microsoft.PowerShell.Core\Where-Object {$_}
                                }

        $script:ExternalScriptDependencies {
                                               $KeyName = $script:ExternalScriptDependencies
                                               $Value = $Value -split '[,\s+]' | Microsoft.PowerShell.Core\Where-Object {$_}
                                           }

        $script:DefinedCommands  { $KeyName = $script:DefinedCommands }

        $script:DefinedFunctions { $KeyName = $script:DefinedFunctions }

        $script:DefinedWorkflows { $KeyName = $script:DefinedWorkflows }

		$script:PrivateData { $KeyName = $script:PrivateData }
    }

    Microsoft.PowerShell.Utility\Add-Member -InputObject $PSScriptInfo `
                                            -MemberType NoteProperty `
                                            -Name $KeyName `
                                            -Value $Value `
                                            -Force
}
function ValidateAndGet-AuthenticodeSignature
{
    [CmdletBinding()]
    Param
    (
        [Parameter(Mandatory=$true)]
        [PSModuleInfo]
        $ModuleInfo
    )

    $ModuleDetails = $null
    $AuthenticodeSignature = $null

    $ModuleName = $ModuleInfo.Name
    $ModuleBasePath = $ModuleInfo.ModuleBase
    $ModuleManifestName = "$ModuleName.psd1"
    $CatalogFileName = "$ModuleName.cat"
    $CatalogFilePath = Microsoft.PowerShell.Management\Join-Path -Path $ModuleBasePath -ChildPath $CatalogFileName

    if(Microsoft.PowerShell.Management\Test-Path -Path $CatalogFilePath -PathType Leaf)
    {
        $message = $LocalizedData.CatalogFileFound -f ($CatalogFileName, $ModuleName)
        Write-Verbose -Message $message

        $AuthenticodeSignature = Microsoft.PowerShell.Security\Get-AuthenticodeSignature -FilePath $CatalogFilePath

        if(-not $AuthenticodeSignature -or ($AuthenticodeSignature.Status -ne "Valid"))
        {
            $message = $LocalizedData.InvalidModuleAuthenticodeSignature -f ($ModuleName, $CatalogFileName)
            ThrowError -ExceptionName 'System.InvalidOperationException' `
                        -ExceptionMessage $message `
                        -ErrorId 'InvalidAuthenticodeSignature' `
                        -CallerPSCmdlet $PSCmdlet `
                        -ErrorCategory InvalidOperation

            return
        }

        Write-Verbose -Message ($LocalizedData.ValidAuthenticodeSignature -f @($CatalogFileName, $ModuleName))

        if(Get-Command -Name Test-FileCatalog -Module Microsoft.PowerShell.Security -ErrorAction Ignore)
        {
            Write-Verbose -Message ($LocalizedData.ValidatingCatalogSignature -f @($ModuleName, $CatalogFileName))

            # Skip the PSGetModuleInfo.xml and ModuleName.cat files in the catalog validation
            $TestFileCatalogResult = Microsoft.PowerShell.Security\Test-FileCatalog -Path $ModuleBasePath `
                                                                                    -CatalogFilePath $CatalogFilePath `
                                                                                    -FilesToSkip $script:PSGetItemInfoFileName,'*.cat','*.nupkg','*.nuspec' `
                                                                                    -Detailed `
                                                                                    -ErrorAction SilentlyContinue
            if(-not $TestFileCatalogResult -or
                ($TestFileCatalogResult.Status -ne "Valid") -or
                ($TestFileCatalogResult.Signature.Status -ne "Valid"))
            {
                $message = $LocalizedData.InvalidCatalogSignature -f ($ModuleName, $CatalogFileName)
                ThrowError -ExceptionName 'System.InvalidOperationException' `
                            -ExceptionMessage $message `
                            -ErrorId 'InvalidCatalogSignature' `
                            -CallerPSCmdlet $PSCmdlet `
                            -ErrorCategory InvalidOperation
                return
            }
            else
            {
                Write-Verbose -Message ($LocalizedData.ValidCatalogSignature -f @($CatalogFileName, $ModuleName))
            }
        }
    }
    else
    {
        Write-Verbose -Message ($LocalizedData.CatalogFileNotFoundInNewModule -f ($CatalogFileName, $ModuleName))

        $message = "Using the '{0}' file for getting the authenticode signature." -f ($ModuleManifestName)
        Write-Debug -Message $message

        $AuthenticodeSignature = Microsoft.PowerShell.Security\Get-AuthenticodeSignature -FilePath $ModuleInfo.Path

        if($AuthenticodeSignature)
        {
            if($AuthenticodeSignature.Status -eq "Valid")
            {
                Write-Verbose -Message ($LocalizedData.ValidAuthenticodeSignatureInFile -f @($ModuleManifestName, $ModuleName))
            }
            elseif($AuthenticodeSignature.Status -ne "NotSigned")
            {
                $message = $LocalizedData.InvalidModuleAuthenticodeSignature -f ($ModuleName, $ModuleManifestName)
                ThrowError -ExceptionName 'System.InvalidOperationException' `
                           -ExceptionMessage $message `
                           -ErrorId 'InvalidAuthenticodeSignature' `
                           -CallerPSCmdlet $PSCmdlet `
                           -ErrorCategory InvalidOperation
                return
            }
        }
    }

    if($AuthenticodeSignature)
    {
        $ModuleDetails = @{}
        $ModuleDetails['AuthenticodeSignature'] = $AuthenticodeSignature
        $ModuleDetails['Version'] = $ModuleInfo.Version
        $ModuleDetails['ModuleBase']=$ModuleInfo.ModuleBase
        $ModuleDetails['IsMicrosoftCertificate'] = Test-MicrosoftCertificate -AuthenticodeSignature $AuthenticodeSignature
        $PublisherDetails = Get-AuthenticodePublisher -AuthenticodeSignature $AuthenticodeSignature
        $ModuleDetails['Publisher'] = if($PublisherDetails) {$PublisherDetails.Publisher}
        $ModuleDetails['RootCertificateAuthority'] = if($PublisherDetails) {$PublisherDetails.PublisherRootCA}

        $message = $LocalizedData.NewModuleVersionDetailsForPublisherValidation -f ($ModuleInfo.Name, $ModuleInfo.Version, $ModuleDetails.Publisher, $ModuleDetails.RootCertificateAuthority, $ModuleDetails.IsMicrosoftCertificate)
        Write-Debug $message
    }

    return $ModuleDetails
}
function ValidateAndGet-NuspecVersionString
{
    param(
        [Parameter(Mandatory=$true)]
        [string]
        $Version
    )

    $versionPattern = '^((?<MinRule>[\[\(])?((?<MinVersion>[^:\(\[\)\]\,]+))?((?<Comma>[\,])?(?<MaxVersion>[^:\(\[\)\]\,]+)?)?(?<MaxRule>[\]\)])?)$'
    $VersionInfo = @{}

    if ( -not ($Version -match $versionPattern))
    {
        $message = $LocalizedData.FailedToParseRequiredScriptsVersion -f ('Invalid Version format', $Version, $LocalizedData.RequiredScriptVersoinFormat)
        Write-Verbose $message
        ThrowError -ExceptionName "System.ArgumentException" `
                    -ExceptionMessage $message `
                    -ErrorId "UnableToResolveScriptDependency" `
                    -CallerPSCmdlet $CallerPSCmdlet `
                    -ErrorCategory InvalidOperation
    }

    if ($Matches.Keys -Contains 'MinRule' -xor $Matches.Keys -Contains 'MaxRule')
    {
        $message = $LocalizedData.FailedToParseRequiredScriptsVersion -f ('Minimum and Maximum inclusive/exclusive condition mismatch', $Version, $LocalizedData.RequiredScriptVersoinFormat)
        Write-Verbose $message
        ThrowError -ExceptionName "System.ArgumentException" `
                    -ExceptionMessage $message `
                    -ErrorId "UnableToResolveScriptDependency" `
                    -CallerPSCmdlet $CallerPSCmdlet `
                    -ErrorCategory InvalidOperation
    }

    if (-not ($Matches.Keys -Contains 'MinVersion' -or $Matches.Keys -Contains 'MaxVersion'))
    {
        $message = $LocalizedData.FailedToParseRequiredScriptsVersion -f ('No version.', $Version, $LocalizedData.RequiredScriptVersoinFormat)
        Write-Verbose $message
        ThrowError -ExceptionName "System.ArgumentException" `
                    -ExceptionMessage $message `
                    -ErrorId "UnableToResolveScriptDependency" `
                    -CallerPSCmdlet $CallerPSCmdlet `
                    -ErrorCategory InvalidOperation
    }

    if ((-not ($Matches.Keys -Contains 'MinRule' -and $Matches.Keys -Contains 'MaxRule')) -and $Matches.Keys -Contains 'Comma')
    {
        $message = $LocalizedData.FailedToParseRequiredScriptsVersion -f ('Invalid version format', $Version, $LocalizedData.RequiredScriptVersoinFormat)
        Write-Verbose $message
        ThrowError -ExceptionName "System.ArgumentException" `
                    -ExceptionMessage $message `
                    -ErrorId "UnableToResolveScriptDependency" `
                    -CallerPSCmdlet $CallerPSCmdlet `
                    -ErrorCategory InvalidOperation
    }

    if ($Matches.Keys -Contains 'MaxRule' -and -not ($Matches['MaxRule'] -eq ']') )
    {
        $message = $LocalizedData.FailedToParseRequiredScriptsVersion -f ('Maximum version condition should be inclusive', $Version, $LocalizedData.RequiredScriptVersoinFormat)
        Write-Verbose $message
        ThrowError -ExceptionName "System.ArgumentException" `
                    -ExceptionMessage $message `
                    -ErrorId "UnableToResolveScriptDependency" `
                    -CallerPSCmdlet $CallerPSCmdlet `
                    -ErrorCategory InvalidOperation
    }

    if ($Matches.Keys -Contains 'MinVersion' -and $Matches.Keys -Contains 'MaxVersion')
    {
        if ($Matches.Keys -Contains 'MinRule' -and $Matches.Keys -Contains 'MaxRule')
        {
            if ($Matches['MinRule'] -eq '[')
            {
                $VersionInfo['MinimumVersion'] = $Matches['MinVersion']
                $VersionInfo['MaximumVersion'] = $Matches['MaxVersion']
            }
            else
            {
                $message = $LocalizedData.FailedToParseRequiredScriptsVersion -f ('Minimum version condition should be inclusive', $Version, $LocalizedData.RequiredScriptVersoinFormat)
                Write-Verbose $message
                ThrowError -ExceptionName "System.ArgumentException" `
                            -ExceptionMessage $message `
                            -ErrorId "UnableToResolveScriptDependency" `
                            -CallerPSCmdlet $CallerPSCmdlet `
                            -ErrorCategory InvalidOperation
            }
        }
        else
        {
            $message = $LocalizedData.FailedToParseRequiredScriptsVersion -f ('Minimum and Maximum inclusive/exclusive condition mismatch', $Version, $LocalizedData.RequiredScriptVersoinFormat)
            Write-Verbose $message
            ThrowError -ExceptionName "System.ArgumentException" `
                        -ExceptionMessage $message `
                        -ErrorId "UnableToResolveScriptDependency" `
                        -CallerPSCmdlet $CallerPSCmdlet `
                        -ErrorCategory InvalidOperation
        }

        return $VersionInfo
    }

    if ($Matches.Keys -Contains 'MinVersion')
    {
        if ($Matches.Keys -Contains 'MinRule' -and $Matches.Keys -Contains 'MaxRule')
        {
            if (($Matches['MinRule'] -eq '[') -and ($Matches['MaxRule'] -eq ']'))
            {
                $VersionInfo['RequiredVersion'] = $Matches['MinVersion']
                return $VersionInfo
            }
        }
        else
        {
            $VersionInfo['MinimumVersion'] = $Matches['MinVersion']
            return $VersionInfo
        }

        $message = $LocalizedData.FailedToParseRequiredScriptsVersion -f ("Minimum and Maximum version rules should be inclusive for 'RequiredVersion'", $Version, $LocalizedData.RequiredScriptVersoinFormat)
        Write-Verbose $message
        ThrowError -ExceptionName "System.ArgumentException" `
                    -ExceptionMessage $message `
                    -ErrorId "UnableToResolveScriptDependency" `
                    -CallerPSCmdlet $CallerPSCmdlet `
                    -ErrorCategory InvalidOperation
    }

    if ($Matches.Keys -Contains 'MaxVersion')
    {
        $VersionInfo['MaximumVersion'] = $Matches['MaxVersion']
        return $VersionInfo
    }

    $message = $LocalizedData.FailedToParseRequiredScriptsVersion -f ("Failed to parse version string", $Version, $LocalizedData.RequiredScriptVersoinFormat)
    Write-Verbose $message
    ThrowError -ExceptionName "System.ArgumentException" `
                -ExceptionMessage $message `
                -ErrorId "UnableToResolveScriptDependency" `
                -CallerPSCmdlet $CallerPSCmdlet `
                -ErrorCategory InvalidOperation
}
function ValidateAndGet-RequiredModuleDetails
{
    param(
        [Parameter()]
        $ModuleManifestRequiredModules,

        [Parameter()]
        [PSModuleInfo[]]
        $RequiredPSModuleInfos,

        [Parameter(Mandatory=$true)]
        [string]
        $Repository,

        [Parameter(Mandatory=$true)]
        [PSModuleInfo]
        $DependentModuleInfo,

        [parameter(Mandatory = $true)]
        [ValidateNotNullOrEmpty()]
        [System.Management.Automation.PSCmdlet]
        $CallerPSCmdlet,

        [Parameter(Mandatory = $false)]
        [pscredential]
        $Credential
    )

    $RequiredModuleDetails = @()

    if(-not $RequiredPSModuleInfos)
    {
        return $RequiredModuleDetails
    }

    if($ModuleManifestRequiredModules)
    {
        ForEach($RequiredModule in $ModuleManifestRequiredModules)
        {
            $ModuleName = $null
            $VersionString = $null

            $ReqModuleInfo = @{}

            $FindModuleArguments = @{
                                        Repository = $Repository
                                        Verbose = $VerbosePreference
                                        ErrorAction = 'SilentlyContinue'
                                        WarningAction = 'SilentlyContinue'
                                        Debug = $DebugPreference
                                    }
            if ($PSBoundParameters.ContainsKey('Credential'))
            {
                $FindModuleArguments.Add('Credential',$Credential)
            }

            # ModuleSpecification case
            if($RequiredModule.GetType().ToString() -eq 'System.Collections.Hashtable')
            {
                $ModuleName = $RequiredModule.ModuleName

                # Version format in NuSpec:
                # "[2.0]" --> (== 2.0) Required Version
                # "2.0" --> (>= 2.0) Minimum Version
                if($RequiredModule.Keys -Contains "RequiredVersion")
                {
                    $FindModuleArguments['RequiredVersion'] = $RequiredModule.RequiredVersion
                    $ReqModuleInfo['RequiredVersion'] = $RequiredModule.RequiredVersion
                }
                elseif($RequiredModule.Keys -Contains "ModuleVersion")
                {
                    $FindModuleArguments['MinimumVersion'] = $RequiredModule.ModuleVersion
                    $ReqModuleInfo['MinimumVersion'] = $RequiredModule.ModuleVersion
                }

                if($RequiredModule.Keys -Contains 'MaximumVersion' -and $RequiredModule.MaximumVersion)
                {
                    # * can be specified in the MaximumVersion of a ModuleSpecification to convey that maximum possible value of that version part.
                    # like 1.0.0.* --> 1.0.0.99999999
                    # replace * with 99999999, PowerShell core takes care validating the * to be the last character in the version string.
                    $maximumVersion = $RequiredModule.MaximumVersion -replace '\*','99999999'

                    $FindModuleArguments['MaximumVersion'] = $maximumVersion
                    $ReqModuleInfo['MaximumVersion'] = $maximumVersion
                }
            }
            else
            {
                # Just module name was specified
                $ModuleName = $RequiredModule.ToString()
            }

            if((Get-ExternalModuleDependencies -PSModuleInfo $DependentModuleInfo) -contains $ModuleName)
            {
                Write-Verbose -Message ($LocalizedData.SkippedModuleDependency -f $ModuleName)

                continue
            }

            # Skip this module name if it's name is not in $RequiredPSModuleInfos.
            # This is required when a ModuleName is part of the NestedModules list of the actual module.
            # $ModuleName is packaged as part of the actual module When $RequiredPSModuleInfos doesn't contain it's name.
            if($RequiredPSModuleInfos.Name -notcontains $ModuleName)
            {
                continue
            }

            $ReqModuleInfo['Name'] = $ModuleName

            # Add the dependency only if the module is available on the gallery
            # Otherwise Module installation will fail as all required modules need to be available on
            # the same Repository
            $FindModuleArguments['Name'] = $ModuleName

            $psgetItemInfo = Find-Module @FindModuleArguments  |
                                        Microsoft.PowerShell.Core\Where-Object {$_.Name -eq $ModuleName} |
                                            Microsoft.PowerShell.Utility\Select-Object -Last 1 -ErrorAction Ignore

            if(-not $psgetItemInfo)
            {
                $message = $LocalizedData.UnableToResolveModuleDependency -f ($ModuleName, $DependentModuleInfo.Name, $Repository, $ModuleName, $Repository, $ModuleName, $ModuleName)
                ThrowError -ExceptionName "System.InvalidOperationException" `
                            -ExceptionMessage $message `
                            -ErrorId "UnableToResolveModuleDependency" `
                            -CallerPSCmdlet $CallerPSCmdlet `
                            -ErrorCategory InvalidOperation
            }

            $RequiredModuleDetails += $ReqModuleInfo
        }
    }
    else
    {
        # If Import-LocalizedData cmdlet was failed to read the .psd1 contents
        # use provided $RequiredPSModuleInfos (PSModuleInfo.RequiredModules or PSModuleInfo.NestedModules of the actual dependent module)

        $FindModuleArguments = @{
                                    Repository = $Repository
                                    Verbose = $VerbosePreference
                                    ErrorAction = 'SilentlyContinue'
                                    WarningAction = 'SilentlyContinue'
                                    Debug = $DebugPreference
                                }
        if ($PSBoundParameters.ContainsKey('Credential'))
        {
            $FindModuleArguments.Add('Credential',$Credential)
        }

        ForEach($RequiredModuleInfo in $RequiredPSModuleInfos)
        {
            $ModuleName = $requiredModuleInfo.Name

            if((Get-ExternalModuleDependencies -PSModuleInfo $DependentModuleInfo) -contains $ModuleName)
            {
                Write-Verbose -Message ($LocalizedData.SkippedModuleDependency -f $ModuleName)

                continue
            }

            $FindModuleArguments['Name'] = $ModuleName
            $FindModuleArguments['MinimumVersion'] = $requiredModuleInfo.Version

            $psgetItemInfo = Find-Module @FindModuleArguments |
                                        Microsoft.PowerShell.Core\Where-Object {$_.Name -eq $ModuleName} |
                                            Microsoft.PowerShell.Utility\Select-Object -Last 1 -ErrorAction Ignore

            if(-not $psgetItemInfo)
            {
                $message = $LocalizedData.UnableToResolveModuleDependency -f ($ModuleName, $DependentModuleInfo.Name, $Repository, $ModuleName, $Repository, $ModuleName, $ModuleName)
                ThrowError -ExceptionName "System.InvalidOperationException" `
                            -ExceptionMessage $message `
                            -ErrorId "UnableToResolveModuleDependency" `
                            -CallerPSCmdlet $PSCmdlet `
                            -ErrorCategory InvalidOperation
            }

            $RequiredModuleDetails += @{
                                            Name=$_.Name
                                            MinimumVersion=$_.Version
                                       }
        }
    }

    return $RequiredModuleDetails
}
function ValidateAndGet-ScriptDependencies
{
    param(
        [Parameter(Mandatory=$true)]
        [string]
        $Repository,

        [Parameter(Mandatory=$true)]
        [PSCustomObject]
        $DependentScriptInfo,

        [parameter(Mandatory = $true)]
        [ValidateNotNullOrEmpty()]
        [System.Management.Automation.PSCmdlet]
        $CallerPSCmdlet,

        [Parameter()]
        [PSCredential]
        $Credential
    )

    $DependenciesDetails = @()

    # Validate dependent modules
    $RequiredModuleSpecification = $DependentScriptInfo.RequiredModules
    if($RequiredModuleSpecification)
    {
        ForEach($moduleSpecification in $RequiredModuleSpecification)
        {
            $ModuleName = $moduleSpecification.Name

            $FindModuleArguments = @{
                                        Repository = $Repository
                                        Verbose = $VerbosePreference
                                        ErrorAction = 'SilentlyContinue'
                                        WarningAction = 'SilentlyContinue'
                                        Debug = $DebugPreference
                                    }
            if ($PSBoundParameters.ContainsKey('Credential'))
            {
                $FindModuleArguments.Add('Credential',$Credential)
            }

            if($DependentScriptInfo.ExternalModuleDependencies -contains $ModuleName)
            {
                Write-Verbose -Message ($LocalizedData.SkippedModuleDependency -f $ModuleName)

                continue
            }

            $FindModuleArguments['Name'] = $ModuleName
            $ReqModuleInfo = @{}
            $ReqModuleInfo['Name'] = $ModuleName

            if($moduleSpecification.Version)
            {
                $FindModuleArguments['MinimumVersion'] = $moduleSpecification.Version
                $ReqModuleInfo['MinimumVersion'] = $moduleSpecification.Version
            }
            elseif((Get-Member -InputObject $moduleSpecification -Name RequiredVersion) -and $moduleSpecification.RequiredVersion)
            {
                $FindModuleArguments['RequiredVersion'] = $moduleSpecification.RequiredVersion
                $ReqModuleInfo['RequiredVersion'] = $moduleSpecification.RequiredVersion
            }

            if((Get-Member -InputObject $moduleSpecification -Name MaximumVersion) -and $moduleSpecification.MaximumVersion)
            {
                # * can be specified in the MaximumVersion of a ModuleSpecification to convey that maximum possible value of that version part.
                # like 1.0.0.* --> 1.0.0.99999999
                # replace * with 99999999, PowerShell core takes care validating the * to be the last character in the version string.
                $maximumVersion = $moduleSpecification.MaximumVersion -replace '\*','99999999'
                $FindModuleArguments['MaximumVersion'] = $maximumVersion
                $ReqModuleInfo['MaximumVersion'] = $maximumVersion
            }

            $psgetItemInfo = Find-Module @FindModuleArguments  |
                                        Microsoft.PowerShell.Core\Where-Object {$_.Name -eq $ModuleName} |
                                            Microsoft.PowerShell.Utility\Select-Object -Last 1 -ErrorAction Ignore

            if(-not $psgetItemInfo)
            {
                $message = $LocalizedData.UnableToResolveScriptDependency -f ('module', $ModuleName, $DependentScriptInfo.Name, $Repository, 'ExternalModuleDependencies')
                ThrowError -ExceptionName "System.InvalidOperationException" `
                            -ExceptionMessage $message `
                            -ErrorId "UnableToResolveScriptDependency" `
                            -CallerPSCmdlet $CallerPSCmdlet `
                            -ErrorCategory InvalidOperation
            }

            $DependenciesDetails += $ReqModuleInfo
        }
    }

    # Validate dependent scrips
    $RequiredScripts = $DependentScriptInfo.RequiredScripts
    if($RequiredScripts)
    {
        ForEach($requiredScript in $RequiredScripts)
        {
            $FindScriptArguments = @{
                                        Repository = $Repository
                                        Verbose = $VerbosePreference
                                        ErrorAction = 'SilentlyContinue'
                                        WarningAction = 'SilentlyContinue'
                                        Debug = $DebugPreference
                                    }
            $ReqScriptInfo = @{}

            if ($PSBoundParameters.ContainsKey('Credential'))
            {
                $FindScriptArguments.Add('Credential',$Credential)
            }

            if (-not ($requiredScript -match '^(?<ScriptName>[^:]+)(:(?<Version>[^:\s]+))?$'))
            {
                $message = $LocalizedData.FailedToParseRequiredScripts -f ($requiredScript)

                ThrowError `
                    -ExceptionName "System.ArgumentException" `
                    -ExceptionMessage $message `
                    -ErrorId "FailedToParseRequiredScripts" `
                    -CallerPSCmdlet $CallerPSCmdlet `
                    -ErrorCategory InvalidOperation
            }

            $scriptName = $Matches['ScriptName']
            if ($DependentScriptInfo.ExternalScriptDependencies -contains $scriptName)
            {
                Write-Verbose -Message ($LocalizedData.SkippedScriptDependency -f $scriptName)

                continue
            }

            if ($Matches.Keys -Contains 'Version')
            {
                $ReqScriptInfo = ValidateAndGet-NuspecVersionString -Version $Matches['Version']

                if($ReqScriptInfo.Keys -Contains 'RequiredVersion')
                {
                    $FindScriptArguments['RequiredVersion'] = $ReqScriptInfo['RequiredVersion']
                }
                elseif($ReqScriptInfo.Keys -Contains 'MinimumVersion')
                {
                    $FindScriptArguments['MinimumVersion'] = $ReqScriptInfo['MinimumVersion']
                }
                if($ReqScriptInfo.Keys -Contains 'MaximumVersion')
                {
                    $FindScriptArguments['MaximumVersion'] = $ReqScriptInfo['MaximumVersion']
                }
            }

            $ReqScriptInfo['Name'] = $scriptName
            $FindScriptArguments['Name'] = $scriptName
            $psgetItemInfo = Find-Script @FindScriptArguments  |
                                        Microsoft.PowerShell.Core\Where-Object {$_.Name -eq $scriptName} |
                                            Microsoft.PowerShell.Utility\Select-Object -Last 1 -ErrorAction Ignore

            if(-not $psgetItemInfo)
            {
                $message = $LocalizedData.UnableToResolveScriptDependency -f ('script', $scriptName, $DependentScriptInfo.Name, $Repository, 'ExternalScriptDependencies')
                ThrowError -ExceptionName "System.InvalidOperationException" `
                            -ExceptionMessage $message `
                            -ErrorId "UnableToResolveScriptDependency" `
                            -CallerPSCmdlet $CallerPSCmdlet `
                            -ErrorCategory InvalidOperation
            }

            $DependenciesDetails += $ReqScriptInfo
        }
    }

    return $DependenciesDetails
}
function ValidateAndGet-VersionPrereleaseStrings
# Separates Version from Prerelease string (if needed) and validates each.
{
    Param
    (
        [Parameter(Mandatory=$true)]
        [ValidateNotNullOrEmpty()]
        [string]
        $Version,

        [string]
        $Prerelease,

        [parameter(Mandatory = $true)]
        [ValidateNotNullOrEmpty()]
        [System.Management.Automation.PSCmdlet]
        $CallerPSCmdlet
    )

    # Scripts scenario
    if ($Version -match '-' -and -not $Prerelease)
    {
        $Version,$Prerelease = $Version -split '-',2
    }

    # Remove leading hyphen (if present) and trim whitespace
    if ($Prerelease -and $Prerelease.StartsWith('-') )
    {
        $Prerelease = $Prerelease -split '-',2 | Select-Object -Skip 1
    }
    if ($Prerelease)
    {
        $Prerelease = $Prerelease.Trim()
    }

    # only these characters are allowed in a prerelease string
    $validCharacters = "^[a-zA-Z0-9]+$"
    $prereleaseStringValid = $Prerelease -match $validCharacters
    if ($Prerelease -and -not $prereleaseStringValid)
    {
        $message = $LocalizedData.InvalidCharactersInPrereleaseString -f $Prerelease
        ThrowError -ExceptionName "System.ArgumentException" `
                   -ExceptionMessage $message `
                   -ErrorId "InvalidCharactersInPrereleaseString" `
                   -CallerPSCmdlet $CallerPSCmdlet `
                   -ErrorCategory InvalidOperation `
                   -ExceptionObject $Prerelease
    }

    # Validate that Version contains exactly 3 parts
    if ($Prerelease -and -not ($Version.ToString().Split('.').Count -eq 3))
    {
        $message = $LocalizedData.IncorrectVersionPartsCountForPrereleaseStringUsage -f $Version
        ThrowError -ExceptionName "System.ArgumentException" `
                   -ExceptionMessage $message `
                   -ErrorId "IncorrectVersionPartsCountForPrereleaseStringUsage" `
                   -CallerPSCmdlet $CallerPSCmdlet `
                   -ErrorCategory InvalidOperation `
                   -ExceptionObject $Version
    }

    # try parsing version string
    [Version]$VersionVersion = $null
    if (-not ( [System.Version]::TryParse($Version, [ref]$VersionVersion) ))
    {
        $message = $LocalizedData.InvalidVersion -f ($Version)
        ThrowError -ExceptionName "System.ArgumentException" `
                   -ExceptionMessage $message `
                   -ErrorId "InvalidVersion" `
                   -CallerPSCmdlet $CallerPSCmdlet `
                   -ErrorCategory InvalidArgument `
                   -ExceptionObject $Version
    }

    $fullVersion = if ($Prerelease) { "$VersionVersion-$Prerelease" } else { "$VersionVersion" }

    $results = @{
        Version = "$VersionVersion"
        Prerelease = $Prerelease
        FullVersion = $fullVersion
    }
    return $results
}
function ValidateAndSet-PATHVariableIfUserAccepts
{
    [CmdletBinding()]
    Param
    (
        [Parameter(Mandatory=$true)]
        [string]
        $Scope,

        [Parameter(Mandatory=$true)]
        [string]
        $ScopePath,

        [Parameter()]
        [Switch]
        $NoPathUpdate,

        [Parameter()]
        [Switch]
        $Force,

        [Parameter()]
        $Request
    )

    if(-not $script:IsWindows)
    {
        return
    }

    Set-PSGetSettingsVariable

    # Check and add the scope path to PATH environment variable if USER accepts the prompt.
    if($Scope -eq 'AllUsers')
    {
        $envVariableTarget = $script:EnvironmentVariableTarget.Machine
        $scriptPATHPromptQuery=$LocalizedData.ScriptPATHPromptQuery -f $ScopePath
        $scopeSpecificKey = 'AllUsersScope_AllowPATHChangeForScripts'
    }
    else
    {
        $envVariableTarget = $script:EnvironmentVariableTarget.User
        $scriptPATHPromptQuery=$LocalizedData.ScriptPATHPromptQuery -f $ScopePath
        $scopeSpecificKey = 'CurrentUserScope_AllowPATHChangeForScripts'
    }

    $AlreadyPromptedForScope = $script:PSGetSettings.Contains($scopeSpecificKey)
    Write-Debug "Already prompted for the current scope:$AlreadyPromptedForScope"

    if(-not $AlreadyPromptedForScope)
    {
        # Read the file contents once again to ensure that it was not set in another PowerShell Session
        Set-PSGetSettingsVariable -Force

        $AlreadyPromptedForScope = $script:PSGetSettings.Contains($scopeSpecificKey)
        Write-Debug "After reading contents of PowerShellGetSettings.xml file, the Already prompted for the current scope:$AlreadyPromptedForScope"

        if($AlreadyPromptedForScope)
        {
            return
        }

        $userResponse = $false

        if(-not $NoPathUpdate)
        {
            $scopePathEndingWithBackSlash = "$scopePath\"

            # Check and add the $scopePath to $env:Path value
            if( (($env:PATH -split ';') -notcontains $scopePath) -and
                (($env:PATH -split ';') -notcontains $scopePathEndingWithBackSlash))
            {
                if($Force)
                {
                    $userResponse = $true
                }
                else
                {
                    $scriptPATHPromptCaption = $LocalizedData.ScriptPATHPromptCaption

                    if($Request)
                    {
                        $userResponse = $Request.ShouldContinue($scriptPATHPromptQuery, $scriptPATHPromptCaption)
                    }
                    else
                    {
                        $userResponse = $PSCmdlet.ShouldContinue($scriptPATHPromptQuery, $scriptPATHPromptCaption)
                    }
                }

                if($userResponse)
                {
                    $currentPATHValue = Get-EnvironmentVariable -Name 'PATH' -Target $envVariableTarget

                    if((($currentPATHValue -split ';') -notcontains $scopePath) -and
                       (($currentPATHValue -split ';') -notcontains $scopePathEndingWithBackSlash))
                    {
                        # To ensure that the installed script is immediately usable,
                        # we need to add the scope path to the PATH enviroment variable.
                        Set-EnvironmentVariable -Name 'PATH' `
                                                -Value "$currentPATHValue;$scopePath" `
                                                -Target $envVariableTarget

                        Write-Verbose ($LocalizedData.AddedScopePathToPATHVariable -f ($scopePath,$Scope))
                    }

                    # Process specific PATH
                    # Check and add the $scopePath to $env:Path value of current process
                    # so that installed scripts can be used in the current process.
                    $target = $script:EnvironmentVariableTarget.Process
                    $currentPATHValue = Get-EnvironmentVariable -Name 'PATH' -Target $target

                    if((($currentPATHValue -split ';') -notcontains $scopePath) -and
                       (($currentPATHValue -split ';') -notcontains $scopePathEndingWithBackSlash))
                    {
                        # To ensure that the installed script is immediately usable,
                        # we need to add the scope path to the PATH enviroment variable.
                        Set-EnvironmentVariable -Name 'PATH' `
                                                -Value "$currentPATHValue;$scopePath" `
                                                -Target $target

                        Write-Verbose ($LocalizedData.AddedScopePathToProcessSpecificPATHVariable -f ($scopePath,$Scope))
                    }
                }
            }
        }

        # Add user's response to the PowerShellGet.settings file
        $script:PSGetSettings[$scopeSpecificKey] = $userResponse

        Save-PSGetSettings
    }
}

#endregion

#region Public Functions
function Find-Command
{
    <#
    .ExternalHelp PSModule-help.xml
    #>
    [CmdletBinding(HelpUri = 'https://go.microsoft.com/fwlink/?LinkId=733636')]
    [outputtype('PSCustomObject[]')]
    Param
    (
        [Parameter(Position = 0)]
        [ValidateNotNullOrEmpty()]
        [string[]]
        $Name,

        [Parameter()]
        [ValidateNotNullOrEmpty()]
        [string]
        $ModuleName,

        [Parameter()]
        [ValidateNotNull()]
        [string]
        $MinimumVersion,

        [Parameter()]
        [ValidateNotNull()]
        [string]
        $MaximumVersion,

        [Parameter()]
        [ValidateNotNull()]
        [string]
        $RequiredVersion,

        [Parameter()]
        [switch]
        $AllVersions,

        [Parameter()]
        [switch]
        $AllowPrerelease,

        [Parameter()]
        [ValidateNotNull()]
        [string[]]
        $Tag,

        [Parameter()]
        [ValidateNotNull()]
        [string]
        $Filter,

        [Parameter(ValueFromPipelineByPropertyName=$true)]
        [ValidateNotNullOrEmpty()]
        [Uri]
        $Proxy,

        [Parameter(ValueFromPipelineByPropertyName=$true)]
        [PSCredential]
        $ProxyCredential,

        [Parameter()]
        [ValidateNotNullOrEmpty()]
        [string[]]
        $Repository
    )


    Process
    {
        if($PSBoundParameters.ContainsKey('Name'))
        {
            $PSBoundParameters['Command'] = $Name
            $null = $PSBoundParameters.Remove('Name')
        }
        else
        {
            $PSBoundParameters['Includes'] = @('Cmdlet','Function')
        }

        if($PSBoundParameters.ContainsKey('ModuleName'))
        {
            $PSBoundParameters['Name'] = $ModuleName
            $null = $PSBoundParameters.Remove('ModuleName')
        }


        PowerShellGet\Find-Module @PSBoundParameters |
            Microsoft.PowerShell.Core\ForEach-Object {
                $psgetModuleInfo = $_
                $psgetModuleInfo.Includes.Command | Microsoft.PowerShell.Core\ForEach-Object {
                    if(($_ -eq "*") -or ($Name -and ($Name -notcontains $_)))
                    {
                        return
                    }

                    $psgetCommandInfo = Microsoft.PowerShell.Utility\New-Object PSCustomObject -Property ([ordered]@{
                            Name            = $_
                            Version         = $psgetModuleInfo.Version
                            ModuleName      = $psgetModuleInfo.Name
                            Repository      = $psgetModuleInfo.Repository
                            PSGetModuleInfo = $psgetModuleInfo
                    })

                    $psgetCommandInfo.PSTypeNames.Insert(0, 'Microsoft.PowerShell.Commands.PSGetCommandInfo')
                    $psgetCommandInfo
                }
            }
    }
}
function Find-DscResource
{
    <#
    .ExternalHelp PSModule-help.xml
    #>
    [CmdletBinding(HelpUri = 'https://go.microsoft.com/fwlink/?LinkId=517196')]
    [outputtype('PSCustomObject[]')]
    Param
    (
        [Parameter(Position = 0)]
        [ValidateNotNullOrEmpty()]
        [string[]]
        $Name,

        [Parameter()]
        [ValidateNotNullOrEmpty()]
        [string]
        $ModuleName,

        [Parameter()]
        [ValidateNotNull()]
        [string]
        $MinimumVersion,

        [Parameter()]
        [ValidateNotNull()]
        [string]
        $MaximumVersion,

        [Parameter()]
        [ValidateNotNull()]
        [string]
        $RequiredVersion,

        [Parameter()]
        [switch]
        $AllVersions,

        [Parameter()]
        [switch]
        $AllowPrerelease,

        [Parameter()]
        [ValidateNotNull()]
        [string[]]
        $Tag,

        [Parameter()]
        [ValidateNotNull()]
        [string]
        $Filter,

        [Parameter(ValueFromPipelineByPropertyName=$true)]
        [ValidateNotNullOrEmpty()]
        [Uri]
        $Proxy,

        [Parameter(ValueFromPipelineByPropertyName=$true)]
        [PSCredential]
        $ProxyCredential,

        [Parameter()]
        [ValidateNotNullOrEmpty()]
        [string[]]
        $Repository
    )


    Process
    {
        $PSBoundParameters['Includes'] = 'DscResource'

        if($PSBoundParameters.ContainsKey('Name'))
        {
            $PSBoundParameters['DscResource'] = $Name
            $null = $PSBoundParameters.Remove('Name')
        }

        if($PSBoundParameters.ContainsKey('ModuleName'))
        {
            $PSBoundParameters['Name'] = $ModuleName
            $null = $PSBoundParameters.Remove('ModuleName')
        }

        PowerShellGet\Find-Module @PSBoundParameters |
        Microsoft.PowerShell.Core\ForEach-Object {
            $psgetModuleInfo = $_
            $psgetModuleInfo.Includes.DscResource | Microsoft.PowerShell.Core\ForEach-Object {
                if($Name -and ($Name -notcontains $_))
                {
                    return
                }

                $psgetDscResourceInfo = Microsoft.PowerShell.Utility\New-Object PSCustomObject -Property ([ordered]@{
                        Name            = $_
                        Version         = $psgetModuleInfo.Version
                        ModuleName      = $psgetModuleInfo.Name
                        Repository      = $psgetModuleInfo.Repository
                        PSGetModuleInfo = $psgetModuleInfo
                })

                $psgetDscResourceInfo.PSTypeNames.Insert(0, 'Microsoft.PowerShell.Commands.PSGetDscResourceInfo')
                $psgetDscResourceInfo
            }
        }
    }
}
function Find-Module {
    <#
    .ExternalHelp PSModule-help.xml
    #>
    [CmdletBinding(HelpUri = 'https://go.microsoft.com/fwlink/?LinkID=398574')]
    [outputtype("PSCustomObject[]")]
    Param
    (
        [Parameter(ValueFromPipelineByPropertyName = $true,
            Position = 0)]
        [ValidateNotNullOrEmpty()]
        [string[]]
        $Name,

        [Parameter(ValueFromPipelineByPropertyName = $true)]
        [ValidateNotNull()]
        [string]
        $MinimumVersion,

        [Parameter(ValueFromPipelineByPropertyName = $true)]
        [ValidateNotNull()]
        [string]
        $MaximumVersion,

        [Parameter(ValueFromPipelineByPropertyName = $true)]
        [ValidateNotNull()]
        [string]
        $RequiredVersion,

        [Parameter()]
        [switch]
        $AllVersions,

        [Parameter()]
        [switch]
        $IncludeDependencies,

        [Parameter()]
        [ValidateNotNull()]
        [string]
        $Filter,

        [Parameter()]
        [ValidateNotNull()]
        [string[]]
        $Tag,

        [Parameter()]
        [ValidateNotNull()]
        [ValidateSet('DscResource', 'Cmdlet', 'Function', 'RoleCapability')]
        [string[]]
        $Includes,

        [Parameter()]
        [ValidateNotNull()]
        [string[]]
        $DscResource,

        [Parameter()]
        [ValidateNotNull()]
        [string[]]
        $RoleCapability,

        [Parameter()]
        [ValidateNotNull()]
        [string[]]
        $Command,

        [Parameter(ValueFromPipelineByPropertyName = $true)]
        [ValidateNotNullOrEmpty()]
        [Uri]
        $Proxy,

        [Parameter(ValueFromPipelineByPropertyName = $true)]
        [PSCredential]
        $ProxyCredential,

        [Parameter()]
        [ValidateNotNullOrEmpty()]
        [string[]]
        $Repository,

        [Parameter(ValueFromPipelineByPropertyName = $true)]
        [PSCredential]
        $Credential,

        [Parameter()]
        [switch]
        $AllowPrerelease
    )

    Begin {
        # Change security protocol to TLS 1.2
        $script:securityProtocol = [Net.ServicePointManager]::SecurityProtocol
        [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12

        Install-NuGetClientBinaries -CallerPSCmdlet $PSCmdlet -Proxy $Proxy -ProxyCredential $ProxyCredential
    }

    Process {
        $ValidationResult = Validate-VersionParameters -CallerPSCmdlet $PSCmdlet `
            -Name $Name `
            -MinimumVersion $MinimumVersion `
            -MaximumVersion $MaximumVersion `
            -RequiredVersion $RequiredVersion `
            -AllVersions:$AllVersions `
            -AllowPrerelease:$AllowPrerelease

        if (-not $ValidationResult) {
            # Validate-VersionParameters throws the error.
            # returning to avoid further execution when different values are specified for -ErrorAction parameter
            return
        }

        $PSBoundParameters["Provider"] = $script:PSModuleProviderName
        $PSBoundParameters[$script:PSArtifactType] = $script:PSArtifactTypeModule
        if ($AllowPrerelease) {
            $PSBoundParameters[$script:AllowPrereleaseVersions] = $true
        }
        $null = $PSBoundParameters.Remove("AllowPrerelease")

        if ($PSBoundParameters.ContainsKey("Repository")) {
            $PSBoundParameters["Source"] = $Repository
            $null = $PSBoundParameters.Remove("Repository")

            $ev = $null
            $null = Get-PSRepository -Name $Repository -ErrorVariable ev -verbose:$false
            if ($ev) { return }
        }

        $PSBoundParameters["MessageResolver"] = $script:PackageManagementMessageResolverScriptBlock

        $modulesFoundInPSGallery = @()

        # No Telemetry must be performed if PSGallery is not in the supplied list of Repositories
        $isRepositoryNullOrPSGallerySpecified = $false
        if ($Repository -and ($Repository -Contains $Script:PSGalleryModuleSource)) {
            $isRepositoryNullOrPSGallerySpecified = $true
        }
        elseif (-not $Repository) {
            $psgalleryRepo = Get-PSRepository -Name $Script:PSGalleryModuleSource `
                -ErrorAction SilentlyContinue `
                -WarningAction SilentlyContinue
            if ($psgalleryRepo) {
                $isRepositoryNullOrPSGallerySpecified = $true
            }
        }

        PackageManagement\Find-Package @PSBoundParameters | Microsoft.PowerShell.Core\ForEach-Object {

            $psgetItemInfo = New-PSGetItemInfo -SoftwareIdentity $_ -Type $script:PSArtifactTypeModule

            if ($psgetItemInfo.Type -eq $script:PSArtifactTypeModule) {
                if ($AllVersions -and -not $AllowPrerelease) {
                    # If AllVersions is specified but not AllowPrerelease, we should only return stable release versions.
                    # PackageManagement returns ALL versions (including prerelease) when AllVersions is specified, regardless of the value of AllowPrerelease.
                    # Filtering results returned from PackageManagement based on flags.
                    if ($psgetItemInfo.AdditionalMetadata -and $psgetItemInfo.AdditionalMetadata.IsPrerelease -eq 'false') {
                        $psgetItemInfo
                    }
                }
                else {
                    $psgetItemInfo
                }
            }
            elseif ($PSBoundParameters['Name'] -and -not (Test-WildcardPattern -Name ($Name | Microsoft.PowerShell.Core\Where-Object { $psgetItemInfo.Name -like $_ }))) {
                $message = $LocalizedData.MatchInvalidType -f ($psgetItemInfo.Name, $psgetItemInfo.Type, $script:PSArtifactTypeModule)
                Write-Error -Message $message `
                    -ErrorId 'MatchInvalidType' `
                    -Category InvalidArgument `
                    -TargetObject $Name
            }

            if ($psgetItemInfo -and
                $isRepositoryNullOrPSGallerySpecified -and
                $script:TelemetryEnabled -and
                ($psgetItemInfo.Repository -eq $Script:PSGalleryModuleSource)) {
                $modulesFoundInPSGallery += $psgetItemInfo.Name
            }
        }


        # Perform Telemetry if Repository is not supplied or Repository contains PSGallery
        # We are only interested in finding modules not in PSGallery
        if ($isRepositoryNullOrPSGallerySpecified) {
            Log-ArtifactNotFoundInPSGallery -SearchedName $Name -FoundName $modulesFoundInPSGallery -operationName 'PSGET_FIND_MODULE'
        }
    }

    End {
        # Change back to user specified security protocol
        [Net.ServicePointManager]::SecurityProtocol = $script:securityProtocol
    }
}
function Find-RoleCapability
{
    <#
    .ExternalHelp PSModule-help.xml
    #>
    [CmdletBinding(HelpUri = 'https://go.microsoft.com/fwlink/?LinkId=718029')]
    [outputtype('PSCustomObject[]')]
    Param
    (
        [Parameter(Position = 0)]
        [ValidateNotNullOrEmpty()]
        [string[]]
        $Name,

        [Parameter()]
        [ValidateNotNullOrEmpty()]
        [string]
        $ModuleName,

        [Parameter()]
        [ValidateNotNull()]
        [string]
        $MinimumVersion,

        [Parameter()]
        [ValidateNotNull()]
        [string]
        $MaximumVersion,

        [Parameter()]
        [ValidateNotNull()]
        [string]
        $RequiredVersion,

        [Parameter()]
        [switch]
        $AllVersions,

        [Parameter()]
        [switch]
        $AllowPrerelease,

        [Parameter()]
        [ValidateNotNull()]
        [string[]]
        $Tag,

        [Parameter()]
        [ValidateNotNull()]
        [string]
        $Filter,

        [Parameter(ValueFromPipelineByPropertyName=$true)]
        [ValidateNotNullOrEmpty()]
        [Uri]
        $Proxy,

        [Parameter(ValueFromPipelineByPropertyName=$true)]
        [PSCredential]
        $ProxyCredential,

        [Parameter()]
        [ValidateNotNullOrEmpty()]
        [string[]]
        $Repository
    )


    Process
    {
        $PSBoundParameters['Includes'] = 'RoleCapability'

        if($PSBoundParameters.ContainsKey('Name'))
        {
            $PSBoundParameters['RoleCapability'] = $Name
            $null = $PSBoundParameters.Remove('Name')
        }

        if($PSBoundParameters.ContainsKey('ModuleName'))
        {
            $PSBoundParameters['Name'] = $ModuleName
            $null = $PSBoundParameters.Remove('ModuleName')
        }

        PowerShellGet\Find-Module @PSBoundParameters |
            Microsoft.PowerShell.Core\ForEach-Object {
                $psgetModuleInfo = $_
                $psgetModuleInfo.Includes.RoleCapability | Microsoft.PowerShell.Core\ForEach-Object {
                    if($Name -and ($Name -notcontains $_))
                    {
                        return
                    }

                    $psgetRoleCapabilityInfo = Microsoft.PowerShell.Utility\New-Object PSCustomObject -Property ([ordered]@{
                            Name            = $_
                            Version         = $psgetModuleInfo.Version
                            ModuleName      = $psgetModuleInfo.Name
                            Repository      = $psgetModuleInfo.Repository
                            PSGetModuleInfo = $psgetModuleInfo
                    })

                    $psgetRoleCapabilityInfo.PSTypeNames.Insert(0, 'Microsoft.PowerShell.Commands.PSGetRoleCapabilityInfo')
                    $psgetRoleCapabilityInfo
                }
            }
    }
}
function Find-Script {
    <#
    .ExternalHelp PSModule-help.xml
    #>
    [CmdletBinding(HelpUri = 'https://go.microsoft.com/fwlink/?LinkId=619785')]
    [outputtype("PSCustomObject[]")]
    Param
    (
        [Parameter(ValueFromPipelineByPropertyName = $true,
            Position = 0)]
        [ValidateNotNullOrEmpty()]
        [string[]]
        $Name,

        [Parameter(ValueFromPipelineByPropertyName = $true)]
        [ValidateNotNull()]
        [string]
        $MinimumVersion,

        [Parameter(ValueFromPipelineByPropertyName = $true)]
        [ValidateNotNull()]
        [string]
        $MaximumVersion,

        [Parameter(ValueFromPipelineByPropertyName = $true)]
        [ValidateNotNull()]
        [string]
        $RequiredVersion,

        [Parameter()]
        [switch]
        $AllVersions,

        [Parameter()]
        [switch]
        $IncludeDependencies,

        [Parameter()]
        [ValidateNotNull()]
        [string]
        $Filter,

        [Parameter()]
        [ValidateNotNull()]
        [string[]]
        $Tag,

        [Parameter()]
        [ValidateNotNull()]
        [ValidateSet('Function', 'Workflow')]
        [string[]]
        $Includes,

        [Parameter()]
        [ValidateNotNull()]
        [string[]]
        $Command,

        [Parameter(ValueFromPipelineByPropertyName = $true)]
        [ValidateNotNullOrEmpty()]
        [Uri]
        $Proxy,

        [Parameter(ValueFromPipelineByPropertyName = $true)]
        [PSCredential]
        $ProxyCredential,

        [Parameter()]
        [ValidateNotNullOrEmpty()]
        [string[]]
        $Repository,

        [Parameter(ValueFromPipelineByPropertyName = $true)]
        [PSCredential]
        $Credential,

        [Parameter()]
        [switch]
        $AllowPrerelease
    )

    Begin {
        # Change security protocol to TLS 1.2
        $script:securityProtocol = [Net.ServicePointManager]::SecurityProtocol
        [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12

        Install-NuGetClientBinaries -CallerPSCmdlet $PSCmdlet -Proxy $Proxy -ProxyCredential $ProxyCredential
    }

    Process {
        $ValidationResult = Validate-VersionParameters -CallerPSCmdlet $PSCmdlet `
            -Name $Name `
            -MinimumVersion $MinimumVersion `
            -MaximumVersion $MaximumVersion `
            -RequiredVersion $RequiredVersion `
            -AllVersions:$AllVersions `
            -AllowPrerelease:$AllowPrerelease

        if (-not $ValidationResult) {
            # Validate-VersionParameters throws the error.
            # returning to avoid further execution when different values are specified for -ErrorAction parameter
            return
        }

        $PSBoundParameters['Provider'] = $script:PSModuleProviderName
        $PSBoundParameters[$script:PSArtifactType] = $script:PSArtifactTypeScript
        if ($AllowPrerelease) {
            $PSBoundParameters[$script:AllowPrereleaseVersions] = $true
        }
        $null = $PSBoundParameters.Remove("AllowPrerelease")

        if ($PSBoundParameters.ContainsKey("Repository")) {
            $PSBoundParameters["Source"] = $Repository
            $null = $PSBoundParameters.Remove("Repository")

            $ev = $null
            $repositories = Get-PSRepository -Name $Repository -ErrorVariable ev -verbose:$false
            if ($ev) { return }

            $RepositoriesWithoutScriptSourceLocation = $false
            foreach ($repo in $repositories) {
                if (-not $repo.ScriptSourceLocation) {
                    $message = $LocalizedData.ScriptSourceLocationIsMissing -f ($repo.Name)
                    Write-Error -Message $message `
                        -ErrorId 'ScriptSourceLocationIsMissing' `
                        -Category InvalidArgument `
                        -TargetObject $repo.Name `
                        -Exception 'System.ArgumentException'

                    $RepositoriesWithoutScriptSourceLocation = $true
                }
            }

            if ($RepositoriesWithoutScriptSourceLocation) {
                return
            }
        }

        $PSBoundParameters["MessageResolver"] = $script:PackageManagementMessageResolverScriptBlockForScriptCmdlets

        $scriptsFoundInPSGallery = @()

        # No Telemetry must be performed if PSGallery is not in the supplied list of Repositories
        $isRepositoryNullOrPSGallerySpecified = $false
        if ($Repository -and ($Repository -Contains $Script:PSGalleryModuleSource)) {
            $isRepositoryNullOrPSGallerySpecified = $true
        }
        elseif (-not $Repository) {
            $psgalleryRepo = Get-PSRepository -Name $Script:PSGalleryModuleSource `
                -ErrorAction SilentlyContinue `
                -WarningAction SilentlyContinue
            # And check for IsDefault?
            if ($psgalleryRepo) {
                $isRepositoryNullOrPSGallerySpecified = $true
            }
        }

        PackageManagement\Find-Package @PSBoundParameters | Microsoft.PowerShell.Core\ForEach-Object {
            $psgetItemInfo = New-PSGetItemInfo -SoftwareIdentity $_ -Type $script:PSArtifactTypeScript

            if ($psgetItemInfo.Type -eq $script:PSArtifactTypeScript) {
                if ($AllVersions -and -not $AllowPrerelease) {
                    # If AllVersions is specified but not AllowPrerelease, we should only return stable release versions.
                    # PackageManagement returns ALL versions (including prerelease) when AllVersions is specified, regardless of the value of AllowPrerelease.
                    # Filtering results returned from PackageManagement based on flags.
                    if ($psgetItemInfo.AdditionalMetadata -and $psgetItemInfo.AdditionalMetadata.IsPrerelease -eq $false) {
                        $psgetItemInfo
                    }
                }
                else {
                    $psgetItemInfo
                }
            }
            elseif ($PSBoundParameters['Name'] -and -not (Test-WildcardPattern -Name ($Name | Microsoft.PowerShell.Core\Where-Object { $psgetItemInfo.Name -like $_ }))) {
                $message = $LocalizedData.MatchInvalidType -f ($psgetItemInfo.Name, $psgetItemInfo.Type, $script:PSArtifactTypeScript)
                Write-Error -Message $message `
                    -ErrorId 'MatchInvalidType' `
                    -Category InvalidArgument `
                    -TargetObject $Name
            }

            if ($psgetItemInfo -and
                $isRepositoryNullOrPSGallerySpecified -and
                $script:TelemetryEnabled -and
                ($psgetItemInfo.Repository -eq $Script:PSGalleryModuleSource)) {
                $scriptsFoundInPSGallery += $psgetItemInfo.Name
            }
        }

        # Perform Telemetry if Repository is not supplied or Repository contains PSGallery
        # We are only interested in finding artifacts not in PSGallery
        if ($isRepositoryNullOrPSGallerySpecified) {
            Log-ArtifactNotFoundInPSGallery -SearchedName $Name -FoundName $scriptsFoundInPSGallery -operationName PSGET_FIND_SCRIPT
        }
    }

    End {
        # Change back to user specified security protocol
        [Net.ServicePointManager]::SecurityProtocol = $script:securityProtocol
    }
}

function Get-CredsFromCredentialProvider {
    [CmdletBinding()]
    Param
    (
        [Parameter()]
        [ValidateNotNullOrEmpty()]
        [Uri]
        $SourceLocation,

        [Parameter()]
        [bool]
        $isRetry = $false
    )


    Write-Verbose "PowerShellGet Calling 'CallCredProvider' on $SourceLocation"
    # Example query: https://pkgs.dev.azure.com/onegettest/_packaging/onegettest/nuget/v2
    $regex = [regex] '^(\S*pkgs.dev.azure.com\S*/v2)$|^(\S*pkgs.visualstudio.com\S*/v2)$'

    if (!($SourceLocation -match $regex)) {
        return $null;
    }

    # Find credential provider
    # Option 1. Use env var 'NUGET_PLUGIN_PATHS' to find credential provider
    # See: https://docs.microsoft.com/en-us/nuget/reference/extensibility/nuget-cross-platform-plugins#plugin-installation-and-discovery
    # Note: OSX and Linux can only use option 1
    # Nuget prioritizes credential providers stored in the NUGET_PLUGIN_PATHS env var
    $credProviderPath = $null
    $defaultEnvPath = "NUGET_PLUGIN_PATHS"
    $nugetPluginPath = Get-Childitem env:$defaultEnvPath -ErrorAction SilentlyContinue
    $callDotnet = $true;

    if ($nugetPluginPath -and $nugetPluginPath.value) {
        # Obtion 1a) The environment variable NUGET_PLUGIN_PATHS should contain a full path to the executable,
        # .exe in the .NET Framework case and .dll in the .NET Core case
        $credProviderPath = $nugetPluginPath.value
        $extension = $credProviderPath.Substring($credProviderPath.get_Length() - 4)
        if ($extension -eq ".exe") {
            $callDotnet = $false
        }
    }
    else {
        # Option 1b) Find User-location - The NuGet Home location - %UserProfile%/.nuget/plugins/
        $path = "$($env:UserProfile)/.nuget/plugins/netcore/CredentialProvider.Microsoft/CredentialProvider.Microsoft.dll";

        if ($script:IsLinux -or $script:IsMacOS) {
            $path = "$($HOME)/.nuget/plugins/netcore/CredentialProvider.Microsoft/CredentialProvider.Microsoft.dll";
        }
        if (Test-Path $path -PathType Leaf) {
            $credProviderPath = $path
        }
    }

    # Option 2. Use Visual Studio path to find credential provider
    # Visual Studio comes pre-installed with the Azure Artifacts credential provider, so we'll search for that file using vswhere.exe
    # If Windows (ie not unix), we'll use vswhere.exe to find installation path of VsWhere
    # If credProviderPath is already set we can skip option 2
    if (!$credProviderPath -and $script:IsWindows) {
        if (${Env:ProgramFiles(x86)}) {
            $programFiles = ${Env:ProgramFiles(x86)}
        }
        elseif ($Env:Programfiles) {
            $programFiles = $Env:Programfiles
        }
        else {
            return $null
        }

        $vswhereExePath = "$($programFiles)\\Microsoft Visual Studio\\Installer\\vswhere.exe"
        if (!(Test-Path $vswhereExePath -PathType Leaf)) {
            return $null
        }

        $RedirectedOutput = Join-Path ([System.IO.Path]::GetTempPath()) 'RedirectedOutput.txt'
        Start-Process $vswhereExePath `
            -Wait `
            -WorkingDirectory $PSHOME `
            -RedirectStandardOutput $RedirectedOutput `
            -NoNewWindow

        $content = Get-Content $RedirectedOutput
        Remove-Item $RedirectedOutput -Force -Recurse -ErrorAction SilentlyContinue

        $vsInstallationPath = ""
        if ([System.Text.RegularExpressions.Regex]::IsMatch($content, "installationPath")) {
            $vsInstallationPath = [System.Text.RegularExpressions.Regex]::Match($content, "(?<=installationPath: ).*(?= installationVersion:)");
            $vsInstallationPath = $vsInstallationPath.ToString()
        }

        # Then use the installation path discovered by vswhere.exe to create the path to search for credential provider
        # ex: "C:\Program Files (x86)\Microsoft Visual Studio\2017\Enterprise" + "\Common7\IDE\CommonExtensions\Microsoft\NuGet\Plugins\CredentialProvider.Microsoft\CredentialProvider.Microsoft.exe"
        if ($vsInstallationPath) {
            $credProviderPath = ($vsInstallationPath + '\Common7\IDE\CommonExtensions\Microsoft\NuGet\Plugins\CredentialProvider.Microsoft\CredentialProvider.Microsoft.exe')
            if (!(Test-Path $credProviderPath -PathType Leaf)) {
                return $null
            }
            $callDotnet = $false;
        }
    }

    if (!(Test-Path $credProviderPath -PathType Leaf)) {
        return $null
    }

    $filename = $credProviderPath
    $arguments = "-U $SourceLocation"
    if ($callDotnet) {
        $filename = "dotnet"
        $arguments = "$credProviderPath $arguments"
    }
    $argumentsNoRetry = $arguments
    if ($isRetry) {
        $arguments = "$arguments -I";
        Write-Debug "Credential provider is re-running with -IsRetry"
    }

    Write-Debug "Credential provider path is: $credProviderPath"
    # Using a process to run CredentialProvider.Microsoft.exe with arguments -V verbose -U query (and -IsRetry when appropriate)
    # See: https://github.com/Microsoft/artifacts-credprovider
    Start-Process $filename -ArgumentList "$arguments -V minimal" `
        -Wait `
        -WorkingDirectory $PSHOME `
        -NoNewWindow

    # This should never run IsRetry
    $RedirectedOutput = Join-Path ([System.IO.Path]::GetTempPath()) 'RedirectedOutput.txt'
    Start-Process $filename -ArgumentList "$argumentsNoRetry -V verbose" `
        -Wait `
        -WorkingDirectory $PSHOME `
        -RedirectStandardOutput $RedirectedOutput `
        -NoNewWindow

    $content = Get-Content $RedirectedOutput
    Remove-Item $RedirectedOutput -Force -Recurse -ErrorAction SilentlyContinue

    $username = [System.Text.RegularExpressions.Regex]::Match($content, '(?<=Username: )\S*')
    $password = [System.Text.RegularExpressions.Regex]::Match($content, '(?<=Password: ).*')

    if ($username -and $password) {
        $secstr = ConvertTo-SecureString $password -AsPlainText -Force
        $credential = new-object -typename System.Management.Automation.PSCredential -argumentlist $username, $secstr

        return $credential
    }

    return $null
}
function Get-InstalledModule
{
    <#
    .ExternalHelp PSModule-help.xml
    #>
    [CmdletBinding(HelpUri='https://go.microsoft.com/fwlink/?LinkId=526863')]
    Param
    (
        [Parameter(ValueFromPipelineByPropertyName=$true,
                   Position=0)]
        [ValidateNotNullOrEmpty()]
        [String[]]
        $Name,

        [Parameter(ValueFromPipelineByPropertyName=$true)]
        [ValidateNotNull()]
        [string]
        $MinimumVersion,

        [Parameter(ValueFromPipelineByPropertyName=$true)]
        [ValidateNotNull()]
        [string]
        $RequiredVersion,

        [Parameter(ValueFromPipelineByPropertyName=$true)]
        [ValidateNotNull()]
        [string]
        $MaximumVersion,

        [Parameter()]
        [switch]
        $AllVersions,

        [Parameter()]
        [switch]
        $AllowPrerelease
    )

    Process
    {
        $ValidationResult = Validate-VersionParameters -CallerPSCmdlet $PSCmdlet `
                                                       -Name $Name `
                                                       -MinimumVersion $MinimumVersion `
                                                       -MaximumVersion $MaximumVersion `
                                                       -RequiredVersion $RequiredVersion `
                                                       -AllVersions:$AllVersions `
                                                       -AllowPrerelease:$AllowPrerelease

        if(-not $ValidationResult)
        {
            # Validate-VersionParameters throws the error.
            # returning to avoid further execution when different values are specified for -ErrorAction parameter
            return
        }

        $PSBoundParameters["Provider"] = $script:PSModuleProviderName
        $PSBoundParameters["MessageResolver"] = $script:PackageManagementMessageResolverScriptBlock
        $PSBoundParameters[$script:PSArtifactType] = $script:PSArtifactTypeModule
        if($AllowPrerelease) {
            $PSBoundParameters[$script:AllowPrereleaseVersions] = $true
        }
        $null = $PSBoundParameters.Remove("AllowPrerelease")

        PackageManagement\Get-Package @PSBoundParameters | Microsoft.PowerShell.Core\ForEach-Object {New-PSGetItemInfo -SoftwareIdentity $_ -Type $script:PSArtifactTypeModule}
    }
}
function Get-InstalledScript
{
    <#
    .ExternalHelp PSModule-help.xml
    #>
    [CmdletBinding(HelpUri='https://go.microsoft.com/fwlink/?LinkId=619790')]
    Param
    (
        [Parameter(ValueFromPipelineByPropertyName=$true,
                   Position=0)]
        [ValidateNotNullOrEmpty()]
        [String[]]
        $Name,

        [Parameter(ValueFromPipelineByPropertyName=$true)]
        [ValidateNotNull()]
        [string]
        $MinimumVersion,

        [Parameter(ValueFromPipelineByPropertyName=$true)]
        [ValidateNotNull()]
        [string]
        $RequiredVersion,

        [Parameter(ValueFromPipelineByPropertyName=$true)]
        [ValidateNotNull()]
        [string]
        $MaximumVersion,

        [Parameter()]
        [Switch]
        $AllowPrerelease
    )

    Process
    {
        $ValidationResult = Validate-VersionParameters -CallerPSCmdlet $PSCmdlet `
                                                       -Name $Name `
                                                       -MinimumVersion $MinimumVersion `
                                                       -MaximumVersion $MaximumVersion `
                                                       -RequiredVersion $RequiredVersion `
                                                       -AllowPrerelease:$AllowPrerelease

        if(-not $ValidationResult)
        {
            # Validate-VersionParameters throws the error.
            # returning to avoid further execution when different values are specified for -ErrorAction parameter
            return
        }

        $PSBoundParameters["Provider"] = $script:PSModuleProviderName
        $PSBoundParameters["MessageResolver"] = $script:PackageManagementMessageResolverScriptBlockForScriptCmdlets
        $PSBoundParameters[$script:PSArtifactType] = $script:PSArtifactTypeScript
        if($AllowPrerelease) {
            $PSBoundParameters[$script:AllowPrereleaseVersions] = $true
        }
        $null = $PSBoundParameters.Remove("AllowPrerelease")

        PackageManagement\Get-Package @PSBoundParameters | Microsoft.PowerShell.Core\ForEach-Object {New-PSGetItemInfo -SoftwareIdentity $_ -Type $script:PSArtifactTypeScript}
    }
}
function Get-PSRepository {
    <#
    .ExternalHelp PSModule-help.xml
    #>
    [CmdletBinding(HelpUri = 'https://go.microsoft.com/fwlink/?LinkID=517127')]
    Param
    (
        [Parameter(ValueFromPipelineByPropertyName = $true)]
        [ValidateNotNullOrEmpty()]
        [string[]]
        $Name
    )

    Begin {
    }

    Process {
        $PSBoundParameters["Provider"] = $script:PSModuleProviderName
        $PSBoundParameters["MessageResolver"] = $script:PackageManagementMessageResolverScriptBlock

        if ($Name) {
            foreach ($sourceName in $Name) {
                $PSBoundParameters["Name"] = $sourceName

                $packageSources = PackageManagement\Get-PackageSource @PSBoundParameters

                $packageSources | Microsoft.PowerShell.Core\ForEach-Object { New-ModuleSourceFromPackageSource -PackageSource $_ }
            }
        }
        else {
            $packageSources = PackageManagement\Get-PackageSource @PSBoundParameters

            $packageSources | Microsoft.PowerShell.Core\ForEach-Object { New-ModuleSourceFromPackageSource -PackageSource $_ }
        }
    }
}
function Install-Module {
    <#
    .ExternalHelp PSModule-help.xml
    #>
    [CmdletBinding(DefaultParameterSetName = 'NameParameterSet',
        HelpUri = 'https://go.microsoft.com/fwlink/?LinkID=398573',
        SupportsShouldProcess = $true)]
    Param
    (
        [Parameter(Mandatory = $true,
            ValueFromPipelineByPropertyName = $true,
            Position = 0,
            ParameterSetName = 'NameParameterSet')]
        [ValidateNotNullOrEmpty()]
        [string[]]
        $Name,

        [Parameter(Mandatory = $true,
            ValueFromPipeline = $true,
            ValueFromPipelineByPropertyName = $true,
            Position = 0,
            ParameterSetName = 'InputObject')]
        [ValidateNotNull()]
        [PSCustomObject[]]
        $InputObject,

        [Parameter(ValueFromPipelineByPropertyName = $true,
            ParameterSetName = 'NameParameterSet')]
        [ValidateNotNull()]
        [string]
        $MinimumVersion,

        [Parameter(ValueFromPipelineByPropertyName = $true,
            ParameterSetName = 'NameParameterSet')]
        [ValidateNotNull()]
        [string]
        $MaximumVersion,

        [Parameter(ValueFromPipelineByPropertyName = $true,
            ParameterSetName = 'NameParameterSet')]
        [ValidateNotNull()]
        [string]
        $RequiredVersion,

        [Parameter(ParameterSetName = 'NameParameterSet')]
        [ValidateNotNullOrEmpty()]
        [string[]]
        $Repository,

        [Parameter(ValueFromPipelineByPropertyName = $true)]
        [PSCredential]
        $Credential,

        [Parameter()]
        [ValidateSet("CurrentUser", "AllUsers")]
        [string]
        $Scope,

        [Parameter(ValueFromPipelineByPropertyName = $true)]
        [ValidateNotNullOrEmpty()]
        [Uri]
        $Proxy,

        [Parameter(ValueFromPipelineByPropertyName = $true)]
        [PSCredential]
        $ProxyCredential,

        [Parameter()]
        [switch]
        $AllowClobber,

        [Parameter()]
        [switch]
        $SkipPublisherCheck,

        [Parameter()]
        [switch]
        $Force,

        [Parameter(ParameterSetName = 'NameParameterSet')]
        [switch]
        $AllowPrerelease,

        [Parameter()]
        [switch]
        $AcceptLicense,

        [Parameter()]
        [switch]
        $PassThru
    )

    Begin {
        # Change security protocol to TLS 1.2
        $script:securityProtocol = [Net.ServicePointManager]::SecurityProtocol
        [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12

        if ($Scope -eq "AllUsers" -and -not (Test-RunningAsElevated)) {
            # Throw an error when Install-Module is used as a non-admin user and '-Scope AllUsers'
            $message = $LocalizedData.InstallModuleAdminPrivilegeRequiredForAllUsersScope -f @($script:programFilesModulesPath, $script:MyDocumentsModulesPath)

            ThrowError -ExceptionName "System.ArgumentException" `
                -ExceptionMessage $message `
                -ErrorId "InstallModuleAdminPrivilegeRequiredForAllUsersScope" `
                -CallerPSCmdlet $PSCmdlet `
                -ErrorCategory InvalidArgument
        }

        # If no scope is specified, default installation will be to AllUsers only
        # If running admin on Windows with PowerShell less than v6.
        if (-not $Scope) {
            $Scope = "CurrentUser"
            if (-not $script:IsCoreCLR -and (Test-RunningAsElevated)) {
                $Scope = "AllUsers"
            }
        }

        Install-NuGetClientBinaries -CallerPSCmdlet $PSCmdlet -Proxy $Proxy -ProxyCredential $ProxyCredential

        # Module names already tried in the current pipeline for InputObject parameterset
        $moduleNamesInPipeline = @()
        $YesToAll = $false
        $NoToAll = $false
        $SourceSGrantedTrust = @()
        $SourcesDeniedTrust = @()
    }

    Process {
        $RepositoryIsNotTrusted = $LocalizedData.RepositoryIsNotTrusted
        $QueryInstallUntrustedPackage = $LocalizedData.QueryInstallUntrustedPackage
        $PackageTarget = $LocalizedData.InstallModulewhatIfMessage

        $PSBoundParameters["Provider"] = $script:PSModuleProviderName
        $PSBoundParameters["MessageResolver"] = $script:PackageManagementInstallModuleMessageResolverScriptBlock
        $PSBoundParameters[$script:PSArtifactType] = $script:PSArtifactTypeModule
        $PSBoundParameters['Scope'] = $Scope
        if ($AllowPrerelease) {
            $PSBoundParameters[$script:AllowPrereleaseVersions] = $true
        }
        $null = $PSBoundParameters.Remove("AllowPrerelease")
        $null = $PSBoundParameters.Remove("PassThru")

        if ($PSCmdlet.ParameterSetName -eq "NameParameterSet") {
            $ValidationResult = Validate-VersionParameters -CallerPSCmdlet $PSCmdlet `
                -Name $Name `
                -TestWildcardsInName `
                -MinimumVersion $MinimumVersion `
                -MaximumVersion $MaximumVersion `
                -RequiredVersion $RequiredVersion `
                -AllowPrerelease:$AllowPrerelease

            if (-not $ValidationResult) {
                # Validate-VersionParameters throws the error.
                # returning to avoid further execution when different values are specified for -ErrorAction parameter
                return
            }

            if ($PSBoundParameters.ContainsKey("Repository")) {
                $PSBoundParameters["Source"] = $Repository
                $null = $PSBoundParameters.Remove("Repository")

                $ev = $null
                $null = Get-PSRepository -Name $Repository -ErrorVariable ev -verbose:$false
                if ($ev) { return }
            }

            $installedPackages = PackageManagement\Install-Package @PSBoundParameters

            if ($PassThru) {
                $installedPackages | Microsoft.PowerShell.Core\ForEach-Object { New-PSGetItemInfo -SoftwareIdentity $_ -Type $script:PSArtifactTypeModule }
            }
        }
        elseif ($PSCmdlet.ParameterSetName -eq "InputObject") {
            $null = $PSBoundParameters.Remove("InputObject")

            foreach ($inputValue in $InputObject) {
                if (($inputValue.PSTypeNames -notcontains "Microsoft.PowerShell.Commands.PSRepositoryItemInfo") -and
                    ($inputValue.PSTypeNames -notcontains "Deserialized.Microsoft.PowerShell.Commands.PSRepositoryItemInfo") -and
                    ($inputValue.PSTypeNames -notcontains "Microsoft.PowerShell.Commands.PSGetCommandInfo") -and
                    ($inputValue.PSTypeNames -notcontains "Deserialized.Microsoft.PowerShell.Commands.PSGetCommandInfo") -and
                    ($inputValue.PSTypeNames -notcontains "Microsoft.PowerShell.Commands.PSGetDscResourceInfo") -and
                    ($inputValue.PSTypeNames -notcontains "Deserialized.Microsoft.PowerShell.Commands.PSGetDscResourceInfo") -and
                    ($inputValue.PSTypeNames -notcontains "Microsoft.PowerShell.Commands.PSGetRoleCapabilityInfo") -and
                    ($inputValue.PSTypeNames -notcontains "Deserialized.Microsoft.PowerShell.Commands.PSGetRoleCapabilityInfo")) {
                    ThrowError -ExceptionName "System.ArgumentException" `
                        -ExceptionMessage $LocalizedData.InvalidInputObjectValue `
                        -ErrorId "InvalidInputObjectValue" `
                        -CallerPSCmdlet $PSCmdlet `
                        -ErrorCategory InvalidArgument `
                        -ExceptionObject $inputValue
                }

                if ( ($inputValue.PSTypeNames -contains "Microsoft.PowerShell.Commands.PSGetDscResourceInfo") -or
                    ($inputValue.PSTypeNames -contains "Deserialized.Microsoft.PowerShell.Commands.PSGetDscResourceInfo") -or
                    ($inputValue.PSTypeNames -contains "Microsoft.PowerShell.Commands.PSGetCommandInfo") -or
                    ($inputValue.PSTypeNames -contains "Deserialized.Microsoft.PowerShell.Commands.PSGetCommandInfo") -or
                    ($inputValue.PSTypeNames -contains "Microsoft.PowerShell.Commands.PSGetRoleCapabilityInfo") -or
                    ($inputValue.PSTypeNames -contains "Deserialized.Microsoft.PowerShell.Commands.PSGetRoleCapabilityInfo")) {
                    $psgetModuleInfo = $inputValue.PSGetModuleInfo
                }
                else {
                    $psgetModuleInfo = $inputValue
                }

                # Skip the module name if it is already tried in the current pipeline
                if ($moduleNamesInPipeline -contains $psgetModuleInfo.Name) {
                    continue
                }

                $moduleNamesInPipeline += $psgetModuleInfo.Name

                if ($psgetModuleInfo.PowerShellGetFormatVersion -and
                    ($script:SupportedPSGetFormatVersionMajors -notcontains $psgetModuleInfo.PowerShellGetFormatVersion.Major)) {
                    $message = $LocalizedData.NotSupportedPowerShellGetFormatVersion -f ($psgetModuleInfo.Name, $psgetModuleInfo.PowerShellGetFormatVersion, $psgetModuleInfo.Name)
                    Write-Error -Message $message -ErrorId "NotSupportedPowerShellGetFormatVersion" -Category InvalidOperation
                    continue
                }

                $PSBoundParameters["Name"] = $psgetModuleInfo.Name
                $PSBoundParameters["RequiredVersion"] = $psgetModuleInfo.Version
                if (($psgetModuleInfo.AdditionalMetadata) -and
                    (Get-Member -InputObject $psgetModuleInfo.AdditionalMetadata -Name "IsPrerelease") -and
                    ($psgetModuleInfo.AdditionalMetadata.IsPrerelease -eq "true")) {
                    $PSBoundParameters[$script:AllowPrereleaseVersions] = $true
                }
                elseif ($PSBoundParameters.ContainsKey($script:AllowPrereleaseVersions)) {
                    $null = $PSBoundParameters.Remove($script:AllowPrereleaseVersions)
                }
                $PSBoundParameters['Source'] = $psgetModuleInfo.Repository
                $PSBoundParameters["PackageManagementProvider"] = (Get-ProviderName -PSCustomObject $psgetModuleInfo)

                #Check if module is already installed
                $InstalledModuleInfo = Test-ModuleInstalled -Name $psgetModuleInfo.Name -RequiredVersion $psgetModuleInfo.Version
                if (-not $Force -and $null -ne $InstalledModuleInfo) {
                    $message = $LocalizedData.ModuleAlreadyInstalledVerbose -f ($InstalledModuleInfo.Version, $InstalledModuleInfo.Name, $InstalledModuleInfo.ModuleBase)
                    Write-Verbose -Message $message
                }
                else {
                    $source = $psgetModuleInfo.Repository
                    $installationPolicy = (Get-PSRepository -Name $source).InstallationPolicy
                    $ShouldProcessMessage = $PackageTarget -f ($psgetModuleInfo.Name, $psgetModuleInfo.Version)

                    if ($psCmdlet.ShouldProcess($ShouldProcessMessage)) {
                        if ($installationPolicy.Equals("Untrusted", [StringComparison]::OrdinalIgnoreCase)) {
                            if (-not($YesToAll -or $NoToAll -or $SourceSGrantedTrust.Contains($source) -or $sourcesDeniedTrust.Contains($source) -or $Force)) {
                                $message = $QueryInstallUntrustedPackage -f ($psgetModuleInfo.Name, $psgetModuleInfo.RepositorySourceLocation)
                                if ($PSVersionTable.PSVersion -ge '5.0.0') {
                                    $sourceTrusted = $psCmdlet.ShouldContinue("$message", "$RepositoryIsNotTrusted", $true, [ref]$YesToAll, [ref]$NoToAll)
                                }
                                else {
                                    $sourceTrusted = $psCmdlet.ShouldContinue("$message", "$RepositoryIsNotTrusted", [ref]$YesToAll, [ref]$NoToAll)
                                }

                                if ($sourceTrusted) {
                                    $SourceSGrantedTrust += $source
                                }
                                else {
                                    $SourcesDeniedTrust += $source
                                }
                            }
                        }

                        if ($installationPolicy.Equals("trusted", [StringComparison]::OrdinalIgnoreCase) -or $SourceSGrantedTrust.Contains($source) -or $YesToAll -or $Force) {
                            $PSBoundParameters["Force"] = $true
                            $installedPackages = PackageManagement\Install-Package @PSBoundParameters

                            if ($PassThru) {
                                $installedPackages | Microsoft.PowerShell.Core\ForEach-Object { New-PSGetItemInfo -SoftwareIdentity $_ -Type $script:PSArtifactTypeModule }
                            }
                        }
                    }
                }
            }
        }
    }

    End {
        # Change back to user specified security protocol
        [Net.ServicePointManager]::SecurityProtocol = $script:securityProtocol
    }
}
function Install-Script {
    <#
    .ExternalHelp PSModule-help.xml
    #>
    [CmdletBinding(DefaultParameterSetName = 'NameParameterSet',
        HelpUri = 'https://go.microsoft.com/fwlink/?LinkId=619784',
        SupportsShouldProcess = $true)]
    Param
    (
        [Parameter(Mandatory = $true,
            ValueFromPipelineByPropertyName = $true,
            Position = 0,
            ParameterSetName = 'NameParameterSet')]
        [ValidateNotNullOrEmpty()]
        [string[]]
        $Name,

        [Parameter(Mandatory = $true,
            ValueFromPipeline = $true,
            ValueFromPipelineByPropertyName = $true,
            Position = 0,
            ParameterSetName = 'InputObject')]
        [ValidateNotNull()]
        [PSCustomObject[]]
        $InputObject,

        [Parameter(ValueFromPipelineByPropertyName = $true,
            ParameterSetName = 'NameParameterSet')]
        [ValidateNotNull()]
        [string]
        $MinimumVersion,

        [Parameter(ValueFromPipelineByPropertyName = $true,
            ParameterSetName = 'NameParameterSet')]
        [ValidateNotNull()]
        [string]
        $MaximumVersion,

        [Parameter(ValueFromPipelineByPropertyName = $true,
            ParameterSetName = 'NameParameterSet')]
        [ValidateNotNull()]
        [string]
        $RequiredVersion,

        [Parameter(ParameterSetName = 'NameParameterSet')]
        [ValidateNotNullOrEmpty()]
        [string[]]
        $Repository,

        [Parameter()]
        [ValidateSet("CurrentUser", "AllUsers")]
        [string]
        $Scope,

        [Parameter()]
        [Switch]
        $NoPathUpdate,

        [Parameter(ValueFromPipelineByPropertyName = $true)]
        [ValidateNotNullOrEmpty()]
        [Uri]
        $Proxy,

        [Parameter(ValueFromPipelineByPropertyName = $true)]
        [PSCredential]
        $ProxyCredential,

        [Parameter(ValueFromPipelineByPropertyName = $true)]
        [PSCredential]
        $Credential,

        [Parameter()]
        [switch]
        $Force,

        [Parameter(ParameterSetName = 'NameParameterSet')]
        [switch]
        $AllowPrerelease,

        [Parameter()]
        [switch]
        $AcceptLicense,

        [Parameter()]
        [switch]
        $PassThru
    )

    Begin {
        # Change security protocol to TLS 1.2
        $script:securityProtocol = [Net.ServicePointManager]::SecurityProtocol
        [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12

        if ($Scope -eq "AllUsers" -and -not (Test-RunningAsElevated)) {
            # Throw an error when Install-Script is used as a non-admin user and '-Scope AllUsers'
            $message = $LocalizedData.InstallScriptAdminPrivilegeRequiredForAllUsersScope -f @($script:ProgramFilesScriptsPath, $script:MyDocumentsScriptsPath)

            ThrowError -ExceptionName "System.ArgumentException" `
                -ExceptionMessage $message `
                -ErrorId "InstallScriptAdminPrivilegeRequiredForAllUsersScope" `
                -CallerPSCmdlet $PSCmdlet `
                -ErrorCategory InvalidArgument
        }

        # If no scope is specified, default installation will be to AllUsers only
        # If running admin on Windows with PowerShell less than v6.
        if (-not $Scope) {
            $Scope = "CurrentUser"
            if (-not $script:IsCoreCLR -and (Test-RunningAsElevated)) {
                $Scope = "AllUsers"
            }
        }

        # Check and add the scope path to PATH environment variable
        if ($Scope -eq 'AllUsers') {
            $scopePath = $script:ProgramFilesScriptsPath
        }
        else {
            $scopePath = $script:MyDocumentsScriptsPath
        }

        ValidateAndSet-PATHVariableIfUserAccepts -Scope $Scope `
            -ScopePath $scopePath `
            -NoPathUpdate:$NoPathUpdate `
            -Force:$Force

        Install-NuGetClientBinaries -CallerPSCmdlet $PSCmdlet -Proxy $Proxy -ProxyCredential $ProxyCredential

        # Script names already tried in the current pipeline for InputObject parameterset
        $scriptNamesInPipeline = @()

        $YesToAll = $false
        $NoToAll = $false
        $SourceSGrantedTrust = @()
        $SourcesDeniedTrust = @()
    }

    Process {
        $RepositoryIsNotTrusted = $LocalizedData.RepositoryIsNotTrusted
        $QueryInstallUntrustedPackage = $LocalizedData.QueryInstallUntrustedScriptPackage
        $PackageTarget = $LocalizedData.InstallScriptwhatIfMessage

        $PSBoundParameters["Provider"] = $script:PSModuleProviderName
        $PSBoundParameters["MessageResolver"] = $script:PackageManagementInstallScriptMessageResolverScriptBlock
        $PSBoundParameters[$script:PSArtifactType] = $script:PSArtifactTypeScript
        $PSBoundParameters['Scope'] = $Scope
        if ($AllowPrerelease) {
            $PSBoundParameters[$script:AllowPrereleaseVersions] = $true
        }
        $null = $PSBoundParameters.Remove("AllowPrerelease")
        $null = $PSBoundParameters.Remove("PassThru")

        if ($PSCmdlet.ParameterSetName -eq "NameParameterSet") {
            $ValidationResult = Validate-VersionParameters -CallerPSCmdlet $PSCmdlet `
                -Name $Name `
                -TestWildcardsInName `
                -MinimumVersion $MinimumVersion `
                -MaximumVersion $MaximumVersion `
                -RequiredVersion $RequiredVersion `
                -AllowPrerelease:$AllowPrerelease

            if (-not $ValidationResult) {
                # Validate-VersionParameters throws the error.
                # returning to avoid further execution when different values are specified for -ErrorAction parameter
                return
            }

            if ($PSBoundParameters.ContainsKey("Repository")) {
                $PSBoundParameters["Source"] = $Repository
                $null = $PSBoundParameters.Remove("Repository")

                $ev = $null
                $repositories = Get-PSRepository -Name $Repository -ErrorVariable ev -verbose:$false
                if ($ev) { return }

                $RepositoriesWithoutScriptSourceLocation = $false
                foreach ($repo in $repositories) {
                    if (-not $repo.ScriptSourceLocation) {
                        $message = $LocalizedData.ScriptSourceLocationIsMissing -f ($repo.Name)
                        Write-Error -Message $message `
                            -ErrorId 'ScriptSourceLocationIsMissing' `
                            -Category InvalidArgument `
                            -TargetObject $repo.Name `
                            -Exception 'System.ArgumentException'

                        $RepositoriesWithoutScriptSourceLocation = $true
                    }
                }

                if ($RepositoriesWithoutScriptSourceLocation) {
                    return
                }
            }

            if (-not $Force) {
                foreach ($scriptName in $Name) {
                    # Throw an error if there is a command with the same name and -force is not specified.
                    $cmd = Microsoft.PowerShell.Core\Get-Command -Name $scriptName `
                        -ErrorAction Ignore `
                        -WarningAction SilentlyContinue
                    if ($cmd) {
                        # Check if this script was already installed, may be with -Force
                        $InstalledScriptInfo = Test-ScriptInstalled -Name $scriptName `
                            -ErrorAction SilentlyContinue `
                            -WarningAction SilentlyContinue
                        if (-not $InstalledScriptInfo) {
                            $message = $LocalizedData.CommandAlreadyAvailable -f ($scriptName)
                            Write-Error -Message $message -ErrorId CommandAlreadyAvailableWitScriptName -Category InvalidOperation

                            # return if only single name is specified
                            if ($scriptName -eq $Name) {
                                return
                            }
                        }
                    }
                }
            }

            $installedPackages = PackageManagement\Install-Package @PSBoundParameters

            if ($PassThru) {
                $installedPackages | Microsoft.PowerShell.Core\ForEach-Object { New-PSGetItemInfo -SoftwareIdentity $_ -Type $script:PSArtifactTypeScript }
            }
        }
        elseif ($PSCmdlet.ParameterSetName -eq "InputObject") {
            $null = $PSBoundParameters.Remove("InputObject")

            foreach ($inputValue in $InputObject) {

                if (($inputValue.PSTypeNames -notcontains "Microsoft.PowerShell.Commands.PSRepositoryItemInfo") -and
                    ($inputValue.PSTypeNames -notcontains "Deserialized.Microsoft.PowerShell.Commands.PSRepositoryItemInfo")) {
                    ThrowError -ExceptionName "System.ArgumentException" `
                        -ExceptionMessage $LocalizedData.InvalidInputObjectValue `
                        -ErrorId "InvalidInputObjectValue" `
                        -CallerPSCmdlet $PSCmdlet `
                        -ErrorCategory InvalidArgument `
                        -ExceptionObject $inputValue
                }

                $psRepositoryItemInfo = $inputValue

                # Skip the script name if it is already tried in the current pipeline
                if ($scriptNamesInPipeline -contains $psRepositoryItemInfo.Name) {
                    continue
                }

                $scriptNamesInPipeline += $psRepositoryItemInfo.Name

                if ($psRepositoryItemInfo.PowerShellGetFormatVersion -and
                    ($script:SupportedPSGetFormatVersionMajors -notcontains $psRepositoryItemInfo.PowerShellGetFormatVersion.Major)) {
                    $message = $LocalizedData.NotSupportedPowerShellGetFormatVersionScripts -f ($psRepositoryItemInfo.Name, $psRepositoryItemInfo.PowerShellGetFormatVersion, $psRepositoryItemInfo.Name)
                    Write-Error -Message $message -ErrorId "NotSupportedPowerShellGetFormatVersion" -Category InvalidOperation
                    continue
                }

                $PSBoundParameters["Name"] = $psRepositoryItemInfo.Name
                $PSBoundParameters["RequiredVersion"] = $psRepositoryItemInfo.Version
                if (($psRepositoryItemInfo.AdditionalMetadata) -and
                    (Get-Member -InputObject $psRepositoryItemInfo.AdditionalMetadata -Name "IsPrerelease") -and
                    ($psRepositoryItemInfo.AdditionalMetadata.IsPrerelease -eq "true")) {
                    $PSBoundParameters[$script:AllowPrereleaseVersions] = $true
                }
                elseif ($PSBoundParameters.ContainsKey($script:AllowPrereleaseVersions)) {
                    $null = $PSBoundParameters.Remove($script:AllowPrereleaseVersions)
                }
                $PSBoundParameters['Source'] = $psRepositoryItemInfo.Repository
                $PSBoundParameters["PackageManagementProvider"] = (Get-ProviderName -PSCustomObject $psRepositoryItemInfo)

                $InstalledScriptInfo = Test-ScriptInstalled -Name $psRepositoryItemInfo.Name
                if (-not $Force -and $InstalledScriptInfo) {
                    $message = $LocalizedData.ScriptAlreadyInstalledVerbose -f ($InstalledScriptInfo.Version, $InstalledScriptInfo.Name, $InstalledScriptInfo.ScriptBase)
                    Write-Verbose -Message $message
                }
                else {
                    # Throw an error if there is a command with the same name and -force is not specified.
                    if (-not $Force) {
                        $cmd = Microsoft.PowerShell.Core\Get-Command -Name $psRepositoryItemInfo.Name `
                            -ErrorAction Ignore `
                            -WarningAction SilentlyContinue
                        if ($cmd) {
                            $message = $LocalizedData.CommandAlreadyAvailable -f ($psRepositoryItemInfo.Name)
                            Write-Error -Message $message -ErrorId CommandAlreadyAvailableWitScriptName -Category InvalidOperation

                            continue
                        }
                    }

                    $source = $psRepositoryItemInfo.Repository
                    $installationPolicy = (Get-PSRepository -Name $source).InstallationPolicy
                    $ShouldProcessMessage = $PackageTarget -f ($psRepositoryItemInfo.Name, $psRepositoryItemInfo.Version)

                    if ($psCmdlet.ShouldProcess($ShouldProcessMessage)) {
                        if ($installationPolicy.Equals("Untrusted", [StringComparison]::OrdinalIgnoreCase)) {
                            if (-not($YesToAll -or $NoToAll -or $SourceSGrantedTrust.Contains($source) -or $sourcesDeniedTrust.Contains($source) -or $Force)) {
                                $message = $QueryInstallUntrustedPackage -f ($psRepositoryItemInfo.Name, $psRepositoryItemInfo.RepositorySourceLocation)

                                if ($PSVersionTable.PSVersion -ge '5.0.0') {
                                    $sourceTrusted = $psCmdlet.ShouldContinue("$message", "$RepositoryIsNotTrusted", $true, [ref]$YesToAll, [ref]$NoToAll)
                                }
                                else {
                                    $sourceTrusted = $psCmdlet.ShouldContinue("$message", "$RepositoryIsNotTrusted", [ref]$YesToAll, [ref]$NoToAll)
                                }

                                if ($sourceTrusted) {
                                    $SourcesGrantedTrust += $source
                                }
                                else {
                                    $SourcesDeniedTrust += $source
                                }
                            }
                        }
                    }
                    if ($installationPolicy.Equals("trusted", [StringComparison]::OrdinalIgnoreCase) -or $SourcesGrantedTrust.Contains($source) -or $YesToAll -or $Force) {
                        $PSBoundParameters["Force"] = $true
                        $installedPackages = PackageManagement\Install-Package @PSBoundParameters

                        if ($PassThru) {
                            $installedPackages | Microsoft.PowerShell.Core\ForEach-Object { New-PSGetItemInfo -SoftwareIdentity $_ -Type $script:PSArtifactTypeScript }
                        }
                    }
                }
            }
        }
    }

    End {
        # Change back to user specified security protocol
        [Net.ServicePointManager]::SecurityProtocol = $script:securityProtocol
    }
}
function New-ScriptFileInfo
{
    <#
    .ExternalHelp PSModule-help.xml
    #>
    [CmdletBinding(PositionalBinding=$false,
                   SupportsShouldProcess=$true,
                   HelpUri='https://go.microsoft.com/fwlink/?LinkId=619792')]
    Param
    (
        [Parameter(Mandatory=$false,
                   Position=0,
                   ValueFromPipelineByPropertyName=$true)]
        [ValidateNotNullOrEmpty()]
        [string]
        $Path,

        [Parameter()]
        [ValidateNotNullOrEmpty()]
        [string]
        $Version,

        [Parameter()]
        [ValidateNotNullOrEmpty()]
        [string]
        $Author,

        [Parameter(Mandatory=$true)]
        [ValidateNotNullOrEmpty()]
        [string]
        $Description,

        [Parameter()]
        [ValidateNotNullOrEmpty()]
        [Guid]
        $Guid,

        [Parameter()]
        [ValidateNotNullOrEmpty()]
        [string]
        $CompanyName,

        [Parameter()]
        [ValidateNotNullOrEmpty()]
        [string]
        $Copyright,

        [Parameter()]
        [ValidateNotNullOrEmpty()]
        [Object[]]
        $RequiredModules,

        [Parameter()]
        [ValidateNotNullOrEmpty()]
        [String[]]
        $ExternalModuleDependencies,

        [Parameter()]
        [ValidateNotNullOrEmpty()]
        [string[]]
        $RequiredScripts,

        [Parameter()]
        [ValidateNotNullOrEmpty()]
        [String[]]
        $ExternalScriptDependencies,

        [Parameter()]
        [ValidateNotNullOrEmpty()]
        [string[]]
        $Tags,

        [Parameter()]
        [ValidateNotNullOrEmpty()]
        [Uri]
        $ProjectUri,

        [Parameter()]
        [ValidateNotNullOrEmpty()]
        [Uri]
        $LicenseUri,

        [Parameter()]
        [ValidateNotNullOrEmpty()]
        [Uri]
        $IconUri,

        [Parameter()]
        [string[]]
        $ReleaseNotes,

		[Parameter()]
		[ValidateNotNullOrEmpty()]
        [string]
        $PrivateData,

        [Parameter()]
        [switch]
        $PassThru,

        [Parameter()]
        [switch]
        $Force
    )

    Process
    {
        if($Path)
        {
            if(-not $Path.EndsWith('.ps1', [System.StringComparison]::OrdinalIgnoreCase))
            {
                $errorMessage = ($LocalizedData.InvalidScriptFilePath -f $Path)
                ThrowError  -ExceptionName 'System.ArgumentException' `
                            -ExceptionMessage $errorMessage `
                            -ErrorId 'InvalidScriptFilePath' `
                            -CallerPSCmdlet $PSCmdlet `
                            -ExceptionObject $Path `
                            -ErrorCategory InvalidArgument
                return
            }

            if(-not $Force -and (Microsoft.PowerShell.Management\Test-Path -Path $Path))
            {
                $errorMessage = ($LocalizedData.ScriptFileExist -f $Path)
                ThrowError  -ExceptionName 'System.ArgumentException' `
                            -ExceptionMessage $errorMessage `
                            -ErrorId 'ScriptFileExist' `
                            -CallerPSCmdlet $PSCmdlet `
                            -ExceptionObject $Path `
                            -ErrorCategory InvalidArgument
                return
            }
        }
        elseif(-not $PassThru)
        {
            ThrowError  -ExceptionName 'System.ArgumentException' `
                        -ExceptionMessage $LocalizedData.MissingTheRequiredPathOrPassThruParameter `
                        -ErrorId 'MissingTheRequiredPathOrPassThruParameter' `
                        -CallerPSCmdlet $PSCmdlet `
                        -ErrorCategory InvalidArgument
            return
        }

        if(-not $Version)
        {
            $Version = '1.0'
        }
        else
        {
            $result = ValidateAndGet-VersionPrereleaseStrings -Version $Version -CallerPSCmdlet $PSCmdlet
            if (-not $result)
            {
                # ValidateAndGet-VersionPrereleaseStrings throws the error.
                # returning to avoid further execution when different values are specified for -ErrorAction parameter
                return
            }
        }

        if(-not $Author)
        {
            if($script:IsWindows)
            {
                $Author = (Get-EnvironmentVariable -Name 'USERNAME' -Target $script:EnvironmentVariableTarget.Process -ErrorAction SilentlyContinue)
            }
            else
            {
                $Author = $env:USER
            }
        }

        if(-not $Guid)
        {
            $Guid = [System.Guid]::NewGuid()
        }

        $params = @{
            Version = $Version
            Author = $Author
            Guid = $Guid
            CompanyName = $CompanyName
            Copyright = $Copyright
            ExternalModuleDependencies = $ExternalModuleDependencies
            RequiredScripts = $RequiredScripts
            ExternalScriptDependencies = $ExternalScriptDependencies
            Tags = $Tags
            ProjectUri = $ProjectUri
            LicenseUri = $LicenseUri
            IconUri = $IconUri
            ReleaseNotes = $ReleaseNotes
			PrivateData = $PrivateData
        }

        if(-not (Validate-ScriptFileInfoParameters -parameters $params))
        {
            return
        }

        if("$Description" -match '<#' -or "$Description" -match '#>')
        {
            $message = $LocalizedData.InvalidParameterValue -f ($Description, 'Description')
            Write-Error -Message $message -ErrorId 'InvalidParameterValue' -Category InvalidArgument

            return
        }

        $PSScriptInfoString = Get-PSScriptInfoString @params

        $requiresStrings = Get-RequiresString -RequiredModules $RequiredModules

        $ScriptCommentHelpInfoString = Get-ScriptCommentHelpInfoString -Description $Description

        $ScriptMetadataString = $PSScriptInfoString
        $ScriptMetadataString += "`r`n"

        if("$requiresStrings".Trim())
        {
            $ScriptMetadataString += "`r`n"
            $ScriptMetadataString += $requiresStrings -join "`r`n"
            $ScriptMetadataString += "`r`n"
        }

        $ScriptMetadataString += "`r`n"
        $ScriptMetadataString += $ScriptCommentHelpInfoString
        $ScriptMetadataString += "Param()`r`n`r`n"

        $tempScriptFilePath = Microsoft.PowerShell.Management\Join-Path -Path $script:TempPath -ChildPath "$(Get-Random).ps1"

        try
        {
            Microsoft.PowerShell.Management\Set-Content -Value $ScriptMetadataString -Path $tempScriptFilePath -Force -WhatIf:$false -Confirm:$false

            $scriptInfo = Test-ScriptFileInfo -Path $tempScriptFilePath

            if(-not $scriptInfo)
            {
                # Above Test-ScriptFileInfo cmdlet writes the errors
                return
            }

    	    if($Path -and ($Force -or $PSCmdlet.ShouldProcess($Path, ($LocalizedData.NewScriptFileInfowhatIfMessage -f $Path) )))
    	    {
                Microsoft.PowerShell.Management\Copy-Item -Path $tempScriptFilePath -Destination $Path -Force -WhatIf:$false -Confirm:$false
            }

            if($PassThru)
            {
                Write-Output -InputObject $ScriptMetadataString
            }
        }
        finally
        {
            Microsoft.PowerShell.Management\Remove-Item -Path $tempScriptFilePath -Force -WhatIf:$false -Confirm:$false -ErrorAction SilentlyContinue -WarningAction SilentlyContinue
        }
    }
}
function Publish-Module {
    <#
    .ExternalHelp PSModule-help.xml
    #>
    [CmdletBinding(SupportsShouldProcess = $true,
        PositionalBinding = $false,
        HelpUri = 'https://go.microsoft.com/fwlink/?LinkID=398575',
        DefaultParameterSetName = "ModuleNameParameterSet")]
    Param
    (
        [Parameter(Mandatory = $true,
            ParameterSetName = "ModuleNameParameterSet",
            ValueFromPipelineByPropertyName = $true)]
        [ValidateNotNullOrEmpty()]
        [string]
        $Name,

        [Parameter(Mandatory = $true,
            ParameterSetName = "ModulePathParameterSet",
            ValueFromPipelineByPropertyName = $true)]
        [ValidateNotNullOrEmpty()]
        [string]
        $Path,

        [Parameter(ParameterSetName = "ModuleNameParameterSet")]
        [ValidateNotNullOrEmpty()]
        [string]
        $RequiredVersion,

        [Parameter()]
        [ValidateNotNullOrEmpty()]
        [string]
        $NuGetApiKey,

        [Parameter()]
        [ValidateNotNullOrEmpty()]
        [string]
        $Repository = $Script:PSGalleryModuleSource,

        [Parameter(ValueFromPipelineByPropertyName = $true)]
        [PSCredential]
        $Credential,

        [Parameter()]
        [ValidateSet("2.0")]
        [Version]
        $FormatVersion,

        [Parameter()]
        [string[]]
        $ReleaseNotes,

        [Parameter()]
        [ValidateNotNullOrEmpty()]
        [string[]]
        $Tags,

        [Parameter()]
        [ValidateNotNullOrEmpty()]
        [Uri]
        $LicenseUri,

        [Parameter()]
        [ValidateNotNullOrEmpty()]
        [Uri]
        $IconUri,

        [Parameter()]
        [ValidateNotNullOrEmpty()]
        [Uri]
        $ProjectUri,

        [Parameter(ParameterSetName = "ModuleNameParameterSet")]
        [ValidateNotNullOrEmpty()]
        [string[]]
        $Exclude,

        [Parameter()]
        [switch]
        $Force,

        [Parameter(ParameterSetName = "ModuleNameParameterSet")]
        [switch]
        $AllowPrerelease,

        [Parameter()]
        [switch]
        $SkipAutomaticTags
    )

    Begin {
        # Change security protocol to TLS 1.2
        $script:securityProtocol = [Net.ServicePointManager]::SecurityProtocol
        [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12

        if ($LicenseUri -and -not (Test-WebUri -uri $LicenseUri)) {
            $message = $LocalizedData.InvalidWebUri -f ($LicenseUri, "LicenseUri")
            ThrowError -ExceptionName "System.ArgumentException" `
                -ExceptionMessage $message `
                -ErrorId "InvalidWebUri" `
                -CallerPSCmdlet $PSCmdlet `
                -ErrorCategory InvalidArgument `
                -ExceptionObject $LicenseUri
        }

        if ($IconUri -and -not (Test-WebUri -uri $IconUri)) {
            $message = $LocalizedData.InvalidWebUri -f ($IconUri, "IconUri")
            ThrowError -ExceptionName "System.ArgumentException" `
                -ExceptionMessage $message `
                -ErrorId "InvalidWebUri" `
                -CallerPSCmdlet $PSCmdlet `
                -ErrorCategory InvalidArgument `
                -ExceptionObject $IconUri
        }

        if ($ProjectUri -and -not (Test-WebUri -uri $ProjectUri)) {
            $message = $LocalizedData.InvalidWebUri -f ($ProjectUri, "ProjectUri")
            ThrowError -ExceptionName "System.ArgumentException" `
                -ExceptionMessage $message `
                -ErrorId "InvalidWebUri" `
                -CallerPSCmdlet $PSCmdlet `
                -ErrorCategory InvalidArgument `
                -ExceptionObject $ProjectUri
        }

        Install-NuGetClientBinaries -CallerPSCmdlet $PSCmdlet -BootstrapNuGetExe -Force:$Force
    }

    Process {
        if ($Repository -eq $Script:PSGalleryModuleSource) {
            $moduleSource = Get-PSRepository -Name $Repository -ErrorAction SilentlyContinue -WarningAction SilentlyContinue
            if (-not $moduleSource) {
                $message = $LocalizedData.PSGalleryNotFound -f ($Repository)
                ThrowError -ExceptionName "System.ArgumentException" `
                    -ExceptionMessage $message `
                    -ErrorId 'PSGalleryNotFound' `
                    -CallerPSCmdlet $PSCmdlet `
                    -ErrorCategory InvalidArgument `
                    -ExceptionObject $Repository
                return
            }
        }
        else {
            $ev = $null
            $moduleSource = Get-PSRepository -Name $Repository -ErrorVariable ev
            if ($ev) { return }
        }

        $DestinationLocation = $moduleSource.PublishLocation

        if (-not $DestinationLocation -or
            (-not (Microsoft.PowerShell.Management\Test-Path $DestinationLocation) -and
                -not (Test-WebUri -uri $DestinationLocation))) {
            $message = $LocalizedData.PSGalleryPublishLocationIsMissing -f ($Repository, $Repository)
            ThrowError -ExceptionName "System.ArgumentException" `
                -ExceptionMessage $message `
                -ErrorId "PSGalleryPublishLocationIsMissing" `
                -CallerPSCmdlet $PSCmdlet `
                -ErrorCategory InvalidArgument `
                -ExceptionObject $Repository
        }

        $message = $LocalizedData.PublishLocation -f ($DestinationLocation)
        Write-Verbose -Message $message

        if (-not $NuGetApiKey.Trim()) {
            if (Microsoft.PowerShell.Management\Test-Path -Path $DestinationLocation) {
                $NuGetApiKey = "$(Get-Random)"
            }
            else {
                $message = $LocalizedData.NuGetApiKeyIsRequiredForNuGetBasedGalleryService -f ($Repository, $DestinationLocation)
                ThrowError -ExceptionName "System.ArgumentException" `
                    -ExceptionMessage $message `
                    -ErrorId "NuGetApiKeyIsRequiredForNuGetBasedGalleryService" `
                    -CallerPSCmdlet $PSCmdlet `
                    -ErrorCategory InvalidArgument
            }
        }

        $providerName = Get-ProviderName -PSCustomObject $moduleSource
        if ($providerName -ne $script:NuGetProviderName) {
            $message = $LocalizedData.PublishModuleSupportsOnlyNuGetBasedPublishLocations -f ($moduleSource.PublishLocation, $Repository, $Repository)
            ThrowError -ExceptionName "System.ArgumentException" `
                -ExceptionMessage $message `
                -ErrorId "PublishModuleSupportsOnlyNuGetBasedPublishLocations" `
                -CallerPSCmdlet $PSCmdlet `
                -ErrorCategory InvalidArgument `
                -ExceptionObject $Repository
        }

        $moduleName = $null

        if ($Name) {
            if ($RequiredVersion) {
                $ValidationResult = Validate-VersionParameters -CallerPSCmdlet $PSCmdlet `
                    -Name $Name `
                    -RequiredVersion $RequiredVersion `
                    -AllowPrerelease:$AllowPrerelease
                if (-not $ValidationResult) {
                    # Validate-VersionParameters throws the error.
                    # returning to avoid further execution when different values are specified for -ErrorAction parameter
                    return
                }

                $reqResult = ValidateAndGet-VersionPrereleaseStrings -Version $RequiredVersion -CallerPSCmdlet $PSCmdlet
                if (-not $reqResult) {
                    # ValidateAndGet-VersionPrereleaseStrings throws the error.
                    # returning to avoid further execution when different values are specified for -ErrorAction parameter
                    return
                }
                $reqVersion = $reqResult["Version"]
                $reqPrerelease = $reqResult["Prerelease"]
            }
            else {
                $reqVersion = $null
                $reqPrerelease = $null
            }

            # Find the module to be published locally, search by name and RequiredVersion
            $module = Microsoft.PowerShell.Core\Get-Module -ListAvailable -Name $Name -Verbose:$false |
            Microsoft.PowerShell.Core\Where-Object {
                $modInfoPrerelease = $null
                if ($_.PrivateData -and
                    $_.PrivateData.GetType().ToString() -eq "System.Collections.Hashtable" -and
                    $_.PrivateData["PSData"] -and
                    $_.PrivateData.PSData.GetType().ToString() -eq "System.Collections.Hashtable" -and
                    $_.PrivateData.PSData["Prerelease"]) {
                    $modInfoPrerelease = $_.PrivateData.PSData.Prerelease
                }
                (-not $RequiredVersion) -or ( ($reqVersion -eq $_.Version) -and ($reqPrerelease -match $modInfoPrerelease) )
            }

            if (-not $module) {
                if ($RequiredVersion) {
                    $message = $LocalizedData.ModuleWithRequiredVersionNotAvailableLocally -f ($Name, $RequiredVersion)
                }
                else {
                    $message = $LocalizedData.ModuleNotAvailableLocally -f ($Name)
                }

                ThrowError -ExceptionName "System.ArgumentException" `
                    -ExceptionMessage $message `
                    -ErrorId "ModuleNotAvailableLocallyToPublish" `
                    -CallerPSCmdlet $PSCmdlet `
                    -ErrorCategory InvalidArgument `
                    -ExceptionObject $Name

            }
            elseif ($module.GetType().ToString() -ne "System.Management.Automation.PSModuleInfo") {
                $message = $LocalizedData.AmbiguousModuleName -f ($Name)
                ThrowError -ExceptionName "System.ArgumentException" `
                    -ExceptionMessage $message `
                    -ErrorId "AmbiguousModuleNameToPublish" `
                    -CallerPSCmdlet $PSCmdlet `
                    -ErrorCategory InvalidArgument `
                    -ExceptionObject $Name
            }

            $moduleName = $module.Name
            $Path = $module.ModuleBase
        }
        else {
            $resolvedPath = Resolve-PathHelper -Path $Path -CallerPSCmdlet $PSCmdlet | Microsoft.PowerShell.Utility\Select-Object -First 1 -ErrorAction Ignore

            if (-not $resolvedPath -or
                -not (Microsoft.PowerShell.Management\Test-Path -Path $resolvedPath -PathType Container)) {
                ThrowError -ExceptionName "System.ArgumentException" `
                    -ExceptionMessage ($LocalizedData.PathIsNotADirectory -f ($Path)) `
                    -ErrorId "PathIsNotADirectory" `
                    -CallerPSCmdlet $PSCmdlet `
                    -ErrorCategory InvalidArgument `
                    -ExceptionObject $Path
                return
            }

            $moduleName = Microsoft.PowerShell.Management\Split-Path -Path $resolvedPath -Leaf
            $modulePathWithVersion = $false

            # if the Leaf of the $resolvedPath is a version, use its parent folder name as the module name
            [Version]$ModuleVersion = $null
            if ([System.Version]::TryParse($moduleName, ([ref]$ModuleVersion))) {
                $moduleName = Microsoft.PowerShell.Management\Split-Path -Path (Microsoft.PowerShell.Management\Split-Path $resolvedPath -Parent) -Leaf
                $modulePathWithVersion = $true
            }

            $manifestPath = Join-PathUtility -Path $resolvedPath -ChildPath "$moduleName.psd1" -PathType File
            $module = $null

            if (Microsoft.PowerShell.Management\Test-Path -Path $manifestPath -PathType Leaf) {
                $ev = $null
                $module = Microsoft.PowerShell.Core\Test-ModuleManifest -Path $manifestPath `
                    -ErrorVariable ev `
                    -Verbose:$VerbosePreference
                if ($ev) {
                    # Above Test-ModuleManifest cmdlet should write an errors to the Errors stream and Console.
                    return
                }
            }
            elseif (-not $modulePathWithVersion -and ($PSVersionTable.PSVersion -ge '5.0.0')) {
                $module = Microsoft.PowerShell.Core\Get-Module -Name $resolvedPath -ListAvailable -ErrorAction SilentlyContinue -Verbose:$false
            }

            if (-not $module) {
                $message = $LocalizedData.InvalidModulePathToPublish -f ($Path)

                ThrowError -ExceptionName "System.ArgumentException" `
                    -ExceptionMessage $message `
                    -ErrorId 'InvalidModulePathToPublish' `
                    -CallerPSCmdlet $PSCmdlet `
                    -ErrorCategory InvalidArgument `
                    -ExceptionObject $Path
            }
            elseif ($module.GetType().ToString() -ne "System.Management.Automation.PSModuleInfo") {
                $message = $LocalizedData.AmbiguousModulePath -f ($Path)
                ThrowError -ExceptionName "System.ArgumentException" `
                    -ExceptionMessage $message `
                    -ErrorId 'AmbiguousModulePathToPublish' `
                    -CallerPSCmdlet $PSCmdlet `
                    -ErrorCategory InvalidArgument `
                    -ExceptionObject $Path
            }

            if ($module -and (-not $module.Path.EndsWith('.psd1', [System.StringComparison]::OrdinalIgnoreCase))) {
                $message = $LocalizedData.InvalidModuleToPublish -f ($module.Name)
                ThrowError -ExceptionName "System.InvalidOperationException" `
                    -ExceptionMessage $message `
                    -ErrorId "InvalidModuleToPublish" `
                    -CallerPSCmdlet $PSCmdlet `
                    -ErrorCategory InvalidOperation `
                    -ExceptionObject $module.Name
            }

            $moduleName = $module.Name
            $Path = $module.ModuleBase
        }

        $message = $LocalizedData.PublishModuleLocation -f ($moduleName, $Path)
        Write-Verbose -Message $message

        #If users are providing tags using -Tags while running PS 5.0, will show warning messages
        if ($Tags) {
            $message = $LocalizedData.TagsShouldBeIncludedInManifestFile -f ($moduleName, $Path)
            Write-Warning $message
        }

        if ($ReleaseNotes) {
            $message = $LocalizedData.ReleaseNotesShouldBeIncludedInManifestFile -f ($moduleName, $Path)
            Write-Warning $message
        }

        if ($LicenseUri) {
            $message = $LocalizedData.LicenseUriShouldBeIncludedInManifestFile -f ($moduleName, $Path)
            Write-Warning $message
        }

        if ($IconUri) {
            $message = $LocalizedData.IconUriShouldBeIncludedInManifestFile -f ($moduleName, $Path)
            Write-Warning $message
        }

        if ($ProjectUri) {
            $message = $LocalizedData.ProjectUriShouldBeIncludedInManifestFile -f ($moduleName, $Path)
            Write-Warning $message
        }


        # Copy the source module to temp location to publish
        $tempModulePath = Microsoft.PowerShell.Management\Join-Path -Path $script:TempPath `
            -ChildPath "$(Microsoft.PowerShell.Utility\Get-Random)\$moduleName"


        if ($FormatVersion -eq "1.0") {
            $tempModulePathForFormatVersion = Microsoft.PowerShell.Management\Join-Path $tempModulePath "Content\Deployment\$script:ModuleReferences\$moduleName"
        }
        else {
            $tempModulePathForFormatVersion = $tempModulePath
        }

        $null = Microsoft.PowerShell.Management\New-Item -Path $tempModulePathForFormatVersion -ItemType Directory -Force -ErrorAction SilentlyContinue -WarningAction SilentlyContinue -Confirm:$false -WhatIf:$false

        # Copy-Item -Recurse -Force includes hidden items like .git directories, which we don't want
        # This finds all the items without force (leaving out hidden files and dirs) then copies them
        Microsoft.PowerShell.Management\Get-ChildItem $Path -recurse |
        Microsoft.PowerShell.Management\Copy-Item -Force -Confirm:$false -WhatIf:$false -Destination {
            if ($_.PSIsContainer) {
                Join-Path $tempModulePathForFormatVersion $_.Parent.FullName.substring($path.length)
            }
            else {
                join-path $tempModulePathForFormatVersion $_.FullName.Substring($path.Length)
            }
        }

        try {
            $manifestPath = Join-PathUtility -Path $tempModulePathForFormatVersion -ChildPath "$moduleName.psd1" -PathType File

            if (-not (Microsoft.PowerShell.Management\Test-Path $manifestPath)) {
                $message = $LocalizedData.InvalidModuleToPublish -f ($moduleName)
                ThrowError -ExceptionName "System.InvalidOperationException" `
                    -ExceptionMessage $message `
                    -ErrorId "InvalidModuleToPublish" `
                    -CallerPSCmdlet $PSCmdlet `
                    -ErrorCategory InvalidOperation `
                    -ExceptionObject $moduleName
            }

            $ev = $null
            $moduleInfo = Microsoft.PowerShell.Core\Test-ModuleManifest -Path $manifestPath `
                -ErrorVariable ev `
                -Verbose:$VerbosePreference
            if ($ev) {
                # Above Test-ModuleManifest cmdlet should write an errors to the Errors stream and Console.
                return
            }

            if (-not $moduleInfo -or
                -not $moduleInfo.Author -or
                -not $moduleInfo.Description) {
                $message = $LocalizedData.MissingRequiredManifestKeys -f ($moduleName)
                ThrowError -ExceptionName "System.InvalidOperationException" `
                    -ExceptionMessage $message `
                    -ErrorId "MissingRequiredModuleManifestKeys" `
                    -CallerPSCmdlet $PSCmdlet `
                    -ErrorCategory InvalidOperation `
                    -ExceptionObject $moduleName
            }

            # Validate Prerelease string
            $moduleInfoPrerelease = $null
            if ($moduleInfo.PrivateData -and
                $moduleInfo.PrivateData.GetType().ToString() -eq "System.Collections.Hashtable" -and
                $moduleInfo.PrivateData["PSData"] -and
                $moduleInfo.PrivateData.PSData.GetType().ToString() -eq "System.Collections.Hashtable" -and
                $moduleInfo.PrivateData.PSData["Prerelease"]) {
                $moduleInfoPrerelease = $moduleInfo.PrivateData.PSData.Prerelease
            }

            $result = ValidateAndGet-VersionPrereleaseStrings -Version $moduleInfo.Version -Prerelease $moduleInfoPrerelease -CallerPSCmdlet $PSCmdlet
            if (-not $result) {
                # ValidateAndGet-VersionPrereleaseStrings throws the error.
                # returning to avoid further execution when different values are specified for -ErrorAction parameter
                return
            }
            $moduleInfoVersion = $result["Version"]
            $moduleInfoPrerelease = $result["Prerelease"]
            $moduleInfoFullVersion = $result["FullVersion"]

            $FindParameters = @{
                Name            = $moduleName
                Repository      = $Repository
                Tag             = 'PSScript'
                AllowPrerelease = $true
                Verbose         = $VerbosePreference
                ErrorAction     = 'SilentlyContinue'
                WarningAction   = 'SilentlyContinue'
                Debug           = $DebugPreference
            }

            if ($Credential) {
                $FindParameters[$script:Credential] = $Credential
            }

            # Check if the specified module name is already used for a script on the specified repository
            # Use Find-Script to check if that name is already used as scriptname
            $scriptPSGetItemInfo = Find-Script @FindParameters |
            Microsoft.PowerShell.Core\Where-Object { $_.Name -eq $moduleName } |
            Microsoft.PowerShell.Utility\Select-Object -Last 1 -ErrorAction Ignore
            if ($scriptPSGetItemInfo) {
                $message = $LocalizedData.SpecifiedNameIsAlearyUsed -f ($moduleName, $Repository, 'Find-Script')
                ThrowError -ExceptionName "System.InvalidOperationException" `
                    -ExceptionMessage $message `
                    -ErrorId "SpecifiedNameIsAlearyUsed" `
                    -CallerPSCmdlet $PSCmdlet `
                    -ErrorCategory InvalidOperation `
                    -ExceptionObject $moduleName
            }

            $null = $FindParameters.Remove('Tag')
            $currentPSGetItemInfo = Find-Module @FindParameters |
            Microsoft.PowerShell.Core\Where-Object { $_.Name -eq $moduleInfo.Name } |
            Microsoft.PowerShell.Utility\Select-Object -Last 1 -ErrorAction Ignore

            if ($currentPSGetItemInfo) {
                $result = ValidateAndGet-VersionPrereleaseStrings -Version $currentPSGetItemInfo.Version -CallerPSCmdlet $PSCmdlet
                if (-not $result) {
                    # ValidateAndGet-VersionPrereleaseStrings throws the error.
                    # returning to avoid further execution when different values are specified for -ErrorAction parameter
                    return
                }
                $currentPSGetItemVersion = $result["Version"]
                $currentPSGetItemPrereleaseString = $result["Prerelease"]
                $currentPSGetItemFullVersion = $result["FullVersion"]

                if ($currentPSGetItemVersion -eq $moduleInfoVersion) {
                    # Compare Prerelease strings
                    if (-not $currentPSGetItemPrereleaseString -and -not $moduleInfoPrerelease) {
                        $message = $LocalizedData.ModuleVersionIsAlreadyAvailableInTheGallery -f ($moduleInfo.Name, $moduleInfoFullVersion, $currentPSGetItemFullVersion, $currentPSGetItemInfo.RepositorySourceLocation)
                        ThrowError -ExceptionName 'System.InvalidOperationException' `
                            -ExceptionMessage $message `
                            -ErrorId 'ModuleVersionIsAlreadyAvailableInTheGallery' `
                            -CallerPSCmdlet $PSCmdlet `
                            -ErrorCategory InvalidOperation
                    }
                    elseif (-not $Force -and (-not $currentPSGetItemPrereleaseString -and $moduleInfoPrerelease)) {
                        # User is trying to publish a new Prerelease version AFTER publishing the stable version.
                        $message = $LocalizedData.ModuleVersionShouldBeGreaterThanGalleryVersion -f ($moduleInfo.Name, $moduleInfoFullVersion, $currentPSGetItemFullVersion, $currentPSGetItemInfo.RepositorySourceLocation)
                        ThrowError -ExceptionName "System.InvalidOperationException" `
                            -ExceptionMessage $message `
                            -ErrorId "ModuleVersionShouldBeGreaterThanGalleryVersion" `
                            -CallerPSCmdlet $PSCmdlet `
                            -ErrorCategory InvalidOperation
                    }

                    # elseif ($currentPSGetItemPrereleaseString -and -not $moduleInfoPrerelease) --> allow publish
                    # User is attempting to publish a stable version after publishing a Prerelease version (allowed).

                    elseif ($currentPSGetItemPrereleaseString -and $moduleInfoPrerelease) {
                        if ($currentPSGetItemPrereleaseString -eq $moduleInfoPrerelease) {
                            $message = $LocalizedData.ModuleVersionIsAlreadyAvailableInTheGallery -f ($moduleInfo.Name, $moduleInfoFullVersion, $currentPSGetItemFullVersion, $currentPSGetItemInfo.RepositorySourceLocation)
                            ThrowError -ExceptionName 'System.InvalidOperationException' `
                                -ExceptionMessage $message `
                                -ErrorId 'ModuleVersionIsAlreadyAvailableInTheGallery' `
                                -CallerPSCmdlet $PSCmdlet `
                                -ErrorCategory InvalidOperation
                        }

                        elseif (-not $Force -and ($currentPSGetItemPrereleaseString -gt $moduleInfoPrerelease)) {
                            $message = $LocalizedData.ModuleVersionShouldBeGreaterThanGalleryVersion -f ($moduleInfo.Name, $moduleInfoFullVersion, $currentPSGetItemFullVersion, $currentPSGetItemInfo.RepositorySourceLocation)
                            ThrowError -ExceptionName "System.InvalidOperationException" `
                                -ExceptionMessage $message `
                                -ErrorId "ModuleVersionShouldBeGreaterThanGalleryVersion" `
                                -CallerPSCmdlet $PSCmdlet `
                                -ErrorCategory InvalidOperation
                        }

                        # elseif ($currentPSGetItemPrereleaseString -lt $moduleInfoPrerelease) --> allow publish
                    }
                }
                elseif (-not $Force -and (Compare-PrereleaseVersions -FirstItemVersion $moduleInfoVersion `
                            -FirstItemPrerelease $moduleInfoPrerelease `
                            -SecondItemVersion $currentPSGetItemVersion `
                            -SecondItemPrerelease $currentPSGetItemPrereleaseString)) {
                    $message = $LocalizedData.ModuleVersionShouldBeGreaterThanGalleryVersion -f ($moduleInfo.Name, $moduleInfoVersion, $currentPSGetItemFullVersion, $currentPSGetItemInfo.RepositorySourceLocation)
                    ThrowError -ExceptionName "System.InvalidOperationException" `
                        -ExceptionMessage $message `
                        -ErrorId "ModuleVersionShouldBeGreaterThanGalleryVersion" `
                        -CallerPSCmdlet $PSCmdlet `
                        -ErrorCategory InvalidOperation
                }

                # else ($currentPSGetItemVersion -lt $moduleInfoVersion) --> allow publish
            }

            $shouldProcessMessage = $LocalizedData.PublishModulewhatIfMessage -f ($moduleInfo.Version, $moduleInfo.Name)
            if ($Force -or $PSCmdlet.ShouldProcess($shouldProcessMessage, "Publish-Module")) {
                $PublishPSArtifactUtility_Params = @{
                    PSModuleInfo      = $moduleInfo
                    ManifestPath      = $manifestPath
                    NugetApiKey       = $NuGetApiKey
                    Destination       = $DestinationLocation
                    Repository        = $Repository
                    NugetPackageRoot  = $tempModulePath
                    FormatVersion     = $FormatVersion
                    ReleaseNotes      = $($ReleaseNotes -join "`r`n")
                    Tags              = $Tags
                    SkipAutomaticTags = $SkipAutomaticTags
                    LicenseUri        = $LicenseUri
                    IconUri           = $IconUri
                    ProjectUri        = $ProjectUri
                    Verbose           = $VerbosePreference
                    WarningAction     = $WarningPreference
                    ErrorAction       = $ErrorActionPreference
                    Debug             = $DebugPreference
                }
                if ($PSBoundParameters.Containskey('Credential')) {
                    $PublishPSArtifactUtility_Params.Add('Credential', $Credential)
                }
                if ($Exclude) {
                    $PublishPSArtifactUtility_Params.Add('Exclude', $Exclude)
                }
                Publish-PSArtifactUtility @PublishPSArtifactUtility_Params
            }
        }
        finally {
            Microsoft.PowerShell.Management\Remove-Item $tempModulePath -Force -Recurse -ErrorAction Ignore -WarningAction SilentlyContinue -Confirm:$false -WhatIf:$false
        }
    }

    End {
        # Change back to user specified security protocol
        [Net.ServicePointManager]::SecurityProtocol = $script:securityProtocol
    }
}
function Publish-Script {
    <#
    .ExternalHelp PSModule-help.xml
    #>
    [CmdletBinding(SupportsShouldProcess = $true,
        PositionalBinding = $false,
        DefaultParameterSetName = 'PathParameterSet',
        HelpUri = 'https://go.microsoft.com/fwlink/?LinkId=619788')]
    Param
    (
        [Parameter(Mandatory = $true,
            ValueFromPipelineByPropertyName = $true,
            ParameterSetName = 'PathParameterSet')]
        [ValidateNotNullOrEmpty()]
        [string]
        $Path,

        [Parameter(Mandatory = $true,
            ValueFromPipelineByPropertyName = $true,
            ParameterSetName = 'LiteralPathParameterSet')]
        [Alias('PSPath')]
        [ValidateNotNullOrEmpty()]
        [string]
        $LiteralPath,

        [Parameter()]
        [ValidateNotNullOrEmpty()]
        [string]
        $NuGetApiKey,

        [Parameter()]
        [ValidateNotNullOrEmpty()]
        [string]
        $Repository = $Script:PSGalleryModuleSource,

        [Parameter(ValueFromPipelineByPropertyName = $true)]
        [PSCredential]
        $Credential,

        [Parameter()]
        [switch]
        $Force
    )

    Begin {
        # Change security protocol to TLS 1.2
        $script:securityProtocol = [Net.ServicePointManager]::SecurityProtocol
        [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12

        Install-NuGetClientBinaries -CallerPSCmdlet $PSCmdlet -BootstrapNuGetExe -Force:$Force
    }

    Process {
        $scriptFilePath = $null
        if ($Path) {
            $scriptFilePath = Resolve-PathHelper -Path $Path -CallerPSCmdlet $PSCmdlet |
            Microsoft.PowerShell.Utility\Select-Object -First 1 -ErrorAction Ignore

            if (-not $scriptFilePath -or
                -not (Microsoft.PowerShell.Management\Test-Path -Path $scriptFilePath -PathType Leaf)) {
                $errorMessage = ($LocalizedData.PathNotFound -f $Path)
                ThrowError  -ExceptionName "System.ArgumentException" `
                    -ExceptionMessage $errorMessage `
                    -ErrorId "PathNotFound" `
                    -CallerPSCmdlet $PSCmdlet `
                    -ExceptionObject $Path `
                    -ErrorCategory InvalidArgument
            }
        }
        else {
            $scriptFilePath = Resolve-PathHelper -Path $LiteralPath -IsLiteralPath -CallerPSCmdlet $PSCmdlet |
            Microsoft.PowerShell.Utility\Select-Object -First 1 -ErrorAction Ignore

            if (-not $scriptFilePath -or
                -not (Microsoft.PowerShell.Management\Test-Path -LiteralPath $scriptFilePath -PathType Leaf)) {
                $errorMessage = ($LocalizedData.PathNotFound -f $LiteralPath)
                ThrowError  -ExceptionName "System.ArgumentException" `
                    -ExceptionMessage $errorMessage `
                    -ErrorId "PathNotFound" `
                    -CallerPSCmdlet $PSCmdlet `
                    -ExceptionObject $LiteralPath `
                    -ErrorCategory InvalidArgument
            }
        }

        if (-not $scriptFilePath.EndsWith('.ps1', [System.StringComparison]::OrdinalIgnoreCase)) {
            $errorMessage = ($LocalizedData.InvalidScriptFilePath -f $scriptFilePath)
            ThrowError  -ExceptionName "System.ArgumentException" `
                -ExceptionMessage $errorMessage `
                -ErrorId "InvalidScriptFilePath" `
                -CallerPSCmdlet $PSCmdlet `
                -ExceptionObject $scriptFilePath `
                -ErrorCategory InvalidArgument
            return
        }

        if ($Repository -eq $Script:PSGalleryModuleSource) {
            $repo = Get-PSRepository -Name $Repository -ErrorAction SilentlyContinue -WarningAction SilentlyContinue
            if (-not $repo) {
                $message = $LocalizedData.PSGalleryNotFound -f ($Repository)
                ThrowError -ExceptionName "System.ArgumentException" `
                    -ExceptionMessage $message `
                    -ErrorId 'PSGalleryNotFound' `
                    -CallerPSCmdlet $PSCmdlet `
                    -ErrorCategory InvalidArgument `
                    -ExceptionObject $Repository
                return
            }
        }
        else {
            $ev = $null
            $repo = Get-PSRepository -Name $Repository -ErrorVariable ev
            # Checking for the $repo object as well as terminating errors are not captured into ev on downlevel PowerShell versions.
            if ($ev -or (-not $repo)) { return }
        }

        $DestinationLocation = $null

        if (Get-Member -InputObject $repo -Name $script:ScriptPublishLocation) {
            $DestinationLocation = $repo.ScriptPublishLocation
        }

        if (-not $DestinationLocation -or
            (-not (Microsoft.PowerShell.Management\Test-Path -Path $DestinationLocation) -and
                -not (Test-WebUri -uri $DestinationLocation))) {
            $message = $LocalizedData.PSRepositoryScriptPublishLocationIsMissing -f ($Repository, $Repository)
            ThrowError -ExceptionName "System.ArgumentException" `
                -ExceptionMessage $message `
                -ErrorId "PSRepositoryScriptPublishLocationIsMissing" `
                -CallerPSCmdlet $PSCmdlet `
                -ErrorCategory InvalidArgument `
                -ExceptionObject $Repository
        }

        $message = $LocalizedData.PublishLocation -f ($DestinationLocation)
        Write-Verbose -Message $message

        if (-not $NuGetApiKey.Trim()) {
            if (Microsoft.PowerShell.Management\Test-Path -Path $DestinationLocation) {
                $NuGetApiKey = "$(Get-Random)"
            }
            else {
                $message = $LocalizedData.NuGetApiKeyIsRequiredForNuGetBasedGalleryService -f ($Repository, $DestinationLocation)
                ThrowError -ExceptionName "System.ArgumentException" `
                    -ExceptionMessage $message `
                    -ErrorId "NuGetApiKeyIsRequiredForNuGetBasedGalleryService" `
                    -CallerPSCmdlet $PSCmdlet `
                    -ErrorCategory InvalidArgument
            }
        }

        $providerName = Get-ProviderName -PSCustomObject $repo
        if ($providerName -ne $script:NuGetProviderName) {
            $message = $LocalizedData.PublishScriptSupportsOnlyNuGetBasedPublishLocations -f ($DestinationLocation, $Repository, $Repository)
            ThrowError -ExceptionName "System.ArgumentException" `
                -ExceptionMessage $message `
                -ErrorId "PublishScriptSupportsOnlyNuGetBasedPublishLocations" `
                -CallerPSCmdlet $PSCmdlet `
                -ErrorCategory InvalidArgument `
                -ExceptionObject $Repository
        }

        if ($Path) {
            $PSScriptInfo = Test-ScriptFileInfo -Path $scriptFilePath
        }
        else {
            $PSScriptInfo = Test-ScriptFileInfo -LiteralPath $scriptFilePath
        }

        if (-not $PSScriptInfo) {
            # Test-ScriptFileInfo throws the actual error
            return
        }

        $scriptName = $PSScriptInfo.Name

        $result = ValidateAndGet-VersionPrereleaseStrings -Version $PSScriptInfo.Version -CallerPSCmdlet $PSCmdlet
        if (-not $result) {
            # ValidateAndGet-VersionPrereleaseStrings throws the error.
            # returning to avoid further execution when different values are specified for -ErrorAction parameter
            return
        }
        $scriptVersion = $result["Version"]
        $scriptPrerelease = $result["Prerelease"]
        $scriptFullVersion = $result["FullVersion"]

        # Copy the source script file to temp location to publish
        $tempScriptPath = Microsoft.PowerShell.Management\Join-Path -Path $script:TempPath -ChildPath "$(Get-Random)" |
        Microsoft.PowerShell.Management\Join-Path -ChildPath $scriptName

        $null = Microsoft.PowerShell.Management\New-Item -Path $tempScriptPath -ItemType Directory -Force -ErrorAction SilentlyContinue -WarningAction SilentlyContinue -Confirm:$false -WhatIf:$false
        if ($Path) {
            Microsoft.PowerShell.Management\Copy-Item -Path $scriptFilePath -Destination $tempScriptPath -Force -Recurse -Confirm:$false -WhatIf:$false
        }
        else {
            Microsoft.PowerShell.Management\Copy-Item -LiteralPath $scriptFilePath -Destination $tempScriptPath -Force -Recurse -Confirm:$false -WhatIf:$false
        }

        try {
            $FindParameters = @{
                Name            = $scriptName
                Repository      = $Repository
                Tag             = 'PSModule'
                AllowPrerelease = $true
                Verbose         = $VerbosePreference
                ErrorAction     = 'SilentlyContinue'
                WarningAction   = 'SilentlyContinue'
                Debug           = $DebugPreference
            }

            if ($Credential) {
                $FindParameters[$script:Credential] = $Credential
            }

            # Check if the specified script name is already used for a module on the specified repository
            # Use Find-Module to check if that name is already used as module name
            $modulePSGetItemInfo = Find-Module @FindParameters |
            Microsoft.PowerShell.Core\Where-Object { $_.Name -eq $scriptName } |
            Microsoft.PowerShell.Utility\Select-Object -Last 1 -ErrorAction Ignore
            if ($modulePSGetItemInfo) {
                $message = $LocalizedData.SpecifiedNameIsAlearyUsed -f ($scriptName, $Repository, 'Find-Module')
                ThrowError -ExceptionName "System.InvalidOperationException" `
                    -ExceptionMessage $message `
                    -ErrorId "SpecifiedNameIsAlearyUsed" `
                    -CallerPSCmdlet $PSCmdlet `
                    -ErrorCategory InvalidOperation `
                    -ExceptionObject $scriptName
            }

            $null = $FindParameters.Remove('Tag')

            $currentPSGetItemInfo = $null
            $currentPSGetItemInfo = Find-Script @FindParameters |
            Microsoft.PowerShell.Core\Where-Object { $_.Name -eq $scriptName } |
            Microsoft.PowerShell.Utility\Select-Object -Last 1 -ErrorAction Ignore

            if ($currentPSGetItemInfo) {
                $result = ValidateAndGet-VersionPrereleaseStrings -Version $currentPSGetItemInfo.Version -CallerPSCmdlet $PSCmdlet
                if (-not $result) {
                    # ValidateAndGet-VersionPrereleaseStrings throws the error.
                    # returning to avoid further execution when different values are specified for -ErrorAction parameter
                    return
                }
                $galleryScriptVersion = $result["Version"]
                $galleryScriptPrerelease = $result["Prerelease"]
                $galleryScriptFullVersion = $result["FullVersion"]

                if ($galleryScriptFullVersion -eq $scriptFullVersion) {
                    $message = $LocalizedData.ScriptVersionIsAlreadyAvailableInTheGallery -f ($scriptName,
                        $scriptFullVersion,
                        $galleryScriptFullVersion,
                        $currentPSGetItemInfo.RepositorySourceLocation)
                    ThrowError -ExceptionName "System.InvalidOperationException" `
                        -ExceptionMessage $message `
                        -ErrorId 'ScriptVersionIsAlreadyAvailableInTheGallery' `
                        -CallerPSCmdlet $PSCmdlet `
                        -ErrorCategory InvalidOperation
                }

                if ($galleryScriptVersion -eq $scriptVersion -and -not $Force) {
                    # Prerelease strings will not both be null, otherwise would have terminated already above

                    if (-not $Force -and (-not $galleryScriptPrerelease -and $scriptPrerelease)) {
                        # User is trying to publish a new Prerelease version AFTER publishing the stable version.
                        $message = $LocalizedData.ScriptPrereleaseStringShouldBeGreaterThanGalleryPrereleaseString -f ($scriptName,
                            $scriptVersion,
                            $scriptPrerelease,
                            $galleryScriptPrerelease,
                            $currentPSGetItemInfo.RepositorySourceLocation)
                        ThrowError -ExceptionName "System.InvalidOperationException" `
                            -ExceptionMessage $message `
                            -ErrorId "ScriptPrereleaseStringShouldBeGreaterThanGalleryPrereleaseString" `
                            -CallerPSCmdlet $PSCmdlet `
                            -ErrorCategory InvalidOperation
                    }

                    # elseif ($galleryScriptPrerelease -and -not $scriptPrerelease) --> allow publish
                    # User is attempting to publish a stable version after publishing a prerelease version (allowed).

                    elseif ($galleryScriptPrerelease -and $scriptPrerelease) {
                        # if ($galleryScriptPrerelease -eq $scriptPrerelease) --> not reachable, would have terminated already above.

                        if (-not $Force -and ($galleryScriptPrerelease -gt $scriptPrerelease)) {
                            # User is trying to publish a lower prerelease version.
                            $message = $LocalizedData.ScriptPrereleaseStringShouldBeGreaterThanGalleryPrereleaseString -f ($scriptName,
                                $scriptVersion,
                                $scriptPrerelease,
                                $galleryScriptPrerelease,
                                $currentPSGetItemInfo.RepositorySourceLocation)
                            ThrowError -ExceptionName "System.InvalidOperationException" `
                                -ExceptionMessage $message `
                                -ErrorId "ScriptPrereleaseStringShouldBeGreaterThanGalleryPrereleaseString" `
                                -CallerPSCmdlet $PSCmdlet `
                                -ErrorCategory InvalidOperation
                        }

                        # elseif ($galleryScriptPrerelease -lt $scriptPrerelease) --> allow publish
                        # User is trying to publish a newer prerelease version (allowed)
                    }
                }
                elseif (-not $Force -and (Compare-PrereleaseVersions -FirstItemVersion $scriptVersion `
                            -FirstItemPrerelease $scriptPrerelease `
                            -SecondItemVersion $galleryScriptVersion `
                            -SecondItemPrerelease $galleryScriptPrerelease)) {
                    $message = $LocalizedData.ScriptVersionShouldBeGreaterThanGalleryVersion -f ($scriptName,
                        $scriptVersion,
                        $galleryScriptVersion,
                        $currentPSGetItemInfo.RepositorySourceLocation)
                    ThrowError -ExceptionName "System.InvalidOperationException" `
                        -ExceptionMessage $message `
                        -ErrorId "ScriptVersionShouldBeGreaterThanGalleryVersion" `
                        -CallerPSCmdlet $PSCmdlet `
                        -ErrorCategory InvalidOperation
                }

                # else ($galleryScriptVersion -lt $scriptVersion) --> allow publish
                # User is trying to publish a newer stable version (allowed)
            }

            $shouldProcessMessage = $LocalizedData.PublishScriptwhatIfMessage -f ($PSScriptInfo.Version, $scriptName)
            if ($Force -or $PSCmdlet.ShouldProcess($shouldProcessMessage, "Publish-Script")) {
                $PublishPSArtifactUtility_Params = @{
                    PSScriptInfo     = $PSScriptInfo
                    NugetApiKey      = $NuGetApiKey
                    Destination      = $DestinationLocation
                    Repository       = $Repository
                    NugetPackageRoot = $tempScriptPath
                    Verbose          = $VerbosePreference
                    WarningAction    = $WarningPreference
                    ErrorAction      = $ErrorActionPreference
                    Debug            = $DebugPreference
                }
                if ($PSBoundParameters.ContainsKey('Credential')) {
                    $PublishPSArtifactUtility_Params.Add('Credential', $Credential)
                }
                Publish-PSArtifactUtility @PublishPSArtifactUtility_Params
            }
        }
        finally {
            Microsoft.PowerShell.Management\Remove-Item $tempScriptPath -Force -Recurse -ErrorAction Ignore -WarningAction SilentlyContinue -Confirm:$false -WhatIf:$false
        }
    }

    End {
        # Change back to user specified security protocol
        [Net.ServicePointManager]::SecurityProtocol = $script:securityProtocol
    }
}
function Register-PSRepository {
    <#
    .ExternalHelp PSModule-help.xml
    #>
    [CmdletBinding(DefaultParameterSetName = 'NameParameterSet',
        HelpUri = 'https://go.microsoft.com/fwlink/?LinkID=517129')]
    Param
    (
        [Parameter(Mandatory = $true,
            Position = 0,
            ParameterSetName = 'NameParameterSet')]
        [ValidateNotNullOrEmpty()]
        [string]
        $Name,

        [Parameter(Mandatory = $true,
            Position = 1,
            ParameterSetName = 'NameParameterSet')]
        [ValidateNotNullOrEmpty()]
        [Uri]
        $SourceLocation,

        [Parameter(ParameterSetName = 'NameParameterSet')]
        [ValidateNotNullOrEmpty()]
        [Uri]
        $PublishLocation,

        [Parameter(ParameterSetName = 'NameParameterSet')]
        [ValidateNotNullOrEmpty()]
        [Uri]
        $ScriptSourceLocation,

        [Parameter(ParameterSetName = 'NameParameterSet')]
        [ValidateNotNullOrEmpty()]
        [Uri]
        $ScriptPublishLocation,

        [Parameter(ValueFromPipelineByPropertyName = $true,
            ParameterSetName = 'NameParameterSet')]
        [PSCredential]
        $Credential,

        [Parameter(Mandatory = $true,
            ParameterSetName = 'PSGalleryParameterSet')]
        [Switch]
        $Default,

        [Parameter()]
        [ValidateSet('Trusted', 'Untrusted')]
        [string]
        $InstallationPolicy = 'Untrusted',

        [Parameter(ValueFromPipelineByPropertyName = $true)]
        [ValidateNotNullOrEmpty()]
        [Uri]
        $Proxy,

        [Parameter(ValueFromPipelineByPropertyName = $true)]
        [PSCredential]
        $ProxyCredential,

        [Parameter(ParameterSetName = 'NameParameterSet')]
        [ValidateNotNullOrEmpty()]
        [string]
        $PackageManagementProvider
    )

    DynamicParam {
        if (Get-Variable -Name SourceLocation -ErrorAction SilentlyContinue) {
            Set-Variable -Name selectedProviderName -value $null -Scope 1

            if (Get-Variable -Name PackageManagementProvider -ErrorAction SilentlyContinue) {
                $selectedProviderName = $PackageManagementProvider
                $null = Get-DynamicParameters -Location $SourceLocation -PackageManagementProvider ([REF]$selectedProviderName)
            }
            else {
                $dynamicParameters = Get-DynamicParameters -Location $SourceLocation -PackageManagementProvider ([REF]$selectedProviderName)
                Set-Variable -Name PackageManagementProvider -Value $selectedProviderName -Scope 1
                $null = $dynamicParameters
            }
        }
    }

    Begin {
        Install-NuGetClientBinaries -CallerPSCmdlet $PSCmdlet -Proxy $Proxy -ProxyCredential $ProxyCredential

        if ($PackageManagementProvider) {
            $providers = PackageManagement\Get-PackageProvider | Where-Object { $_.Name -ne $script:PSModuleProviderName -and $_.Features.ContainsKey($script:SupportsPSModulesFeatureName) }

            if (-not $providers -or $providers.Name -notcontains $PackageManagementProvider) {
                $possibleProviderNames = $script:NuGetProviderName

                if ($providers) {
                    $possibleProviderNames = ($providers.Name -join ',')
                }

                $message = $LocalizedData.InvalidPackageManagementProviderValue -f ($PackageManagementProvider, $possibleProviderNames, $script:NuGetProviderName)
                ThrowError -ExceptionName "System.ArgumentException" `
                    -ExceptionMessage $message `
                    -ErrorId "InvalidPackageManagementProviderValue" `
                    -CallerPSCmdlet $PSCmdlet `
                    -ErrorCategory InvalidArgument `
                    -ExceptionObject $PackageManagementProvider
                return
            }
        }
    }

    Process {
        if ($PSCmdlet.ParameterSetName -eq 'PSGalleryParameterSet') {
            if (-not $Default) {
                return
            }

            $PSBoundParameters['Name'] = $Script:PSGalleryModuleSource
            $null = $PSBoundParameters.Remove('Default')
        }
        else {
            if ($Name -eq $Script:PSGalleryModuleSource) {
                $message = $LocalizedData.UseDefaultParameterSetOnRegisterPSRepository
                ThrowError -ExceptionName "System.ArgumentException" `
                    -ExceptionMessage $message `
                    -ErrorId 'UseDefaultParameterSetOnRegisterPSRepository' `
                    -CallerPSCmdlet $PSCmdlet `
                    -ErrorCategory InvalidArgument `
                    -ExceptionObject $Name
                return
            }

            # Ping and resolve the specified location
            $SourceLocation = Resolve-Location -Location (Get-LocationString -LocationUri $SourceLocation) `
                -LocationParameterName 'SourceLocation' `
                -Credential $Credential `
                -Proxy $Proxy `
                -ProxyCredential $ProxyCredential `
                -CallerPSCmdlet $PSCmdlet
            if (-not $SourceLocation) {
                # Above Resolve-Location function throws an error when it is not able to resolve a location
                return
            }

            $pingResult = Ping-Endpoint -Endpoint (Get-LocationString -LocationUri $SourceLocation) -Credential $Credential -Proxy $Proxy -ProxyCredential $ProxyCredential

            $retrievedCredential = $null
            if (!$Credential -and $pingResult -and $pingResult.ContainsKey($Script:StatusCode) `
                    -and ($pingResult[$Script:StatusCode] -eq 401)) {

                # Try pulling credentials from credential provider
                $retrievedCredential = Get-CredsFromCredentialProvider -SourceLocation $SourceLocation

                # Ping and resolve the specified location
                $SourceLocation = Resolve-Location -Location (Get-LocationString -LocationUri $SourceLocation) `
                    -LocationParameterName 'SourceLocation' `
                    -Credential $retrievedCredential `
                    -Proxy $Proxy `
                    -ProxyCredential $ProxyCredential `
                    -CallerPSCmdlet $PSCmdlet
                if (-not $SourceLocation) {
                    # Above Resolve-Location function throws an error when it is not able to resolve a location
                    return
                }

                $pingResult = Ping-Endpoint -Endpoint (Get-LocationString -LocationUri $SourceLocation) -Credential $retrievedCredential -Proxy $Proxy -ProxyCredential $ProxyCredential

                if (!$retrievedCredential -or ($pingResult -and $pingResult.ContainsKey($Script:StatusCode) `
                            -and ($pingResult[$Script:StatusCode] -eq 401))) {

                    # Try again
                    $retriedRetrievedCredential = Get-CredsFromCredentialProvider -SourceLocation $SourceLocation -IsRetry $true

                    # Ping and resolve the specified location
                    $SourceLocation = Resolve-Location -Location (Get-LocationString -LocationUri $SourceLocation) `
                        -LocationParameterName 'SourceLocation' `
                        -Credential $retriedRetrievedCredential `
                        -Proxy $Proxy `
                        -ProxyCredential $ProxyCredential `
                        -CallerPSCmdlet $PSCmdlet

                    if (-not $SourceLocation) {
                        # Above Resolve-Location function throws an error when it is not able to resolve a location
                        return
                    }

                    $pingResult = Ping-Endpoint -Endpoint (Get-LocationString -LocationUri $SourceLocation) -Credential $retrievedCredential -Proxy $Proxy -ProxyCredential $ProxyCredential

                    if (!$retriedRetrievedCredential -or ($pingResult -and $pingResult.ContainsKey($Script:StatusCode) `
                                -and ($pingResult[$Script:StatusCode] -eq 401))) {

                        $message = $LocalizedData.RepositoryCannotBeRegistered -f ($Name)
                        Write-Error -Message $message -ErrorId "RepositoryCannotBeRegistered" -Category InvalidOperation

                        return
                    }
                }
            }

            $providerName = $null

            if ($PackageManagementProvider) {
                $providerName = $PackageManagementProvider
            }
            elseif ($selectedProviderName) {
                $providerName = $selectedProviderName
            }
            else {
                $providerName = Get-PackageManagementProviderName -Location $SourceLocation
            }

            if ($providerName) {
                $PSBoundParameters[$script:PackageManagementProviderParam] = $providerName
            }

            if ($PublishLocation) {
                $PSBoundParameters[$script:PublishLocation] = Get-LocationString -LocationUri $PublishLocation
            }

            if ($ScriptPublishLocation) {
                $PSBoundParameters[$script:ScriptPublishLocation] = Get-LocationString -LocationUri $ScriptPublishLocation
            }

            if ($ScriptSourceLocation) {
                $PSBoundParameters[$script:ScriptSourceLocation] = Get-LocationString -LocationUri $ScriptSourceLocation
            }

            $PSBoundParameters["Location"] = Get-LocationString -LocationUri $SourceLocation
            $null = $PSBoundParameters.Remove("SourceLocation")
        }

        if ($InstallationPolicy -eq "Trusted") {
            $PSBoundParameters['Trusted'] = $true
        }
        $null = $PSBoundParameters.Remove("InstallationPolicy")

        $PSBoundParameters["Provider"] = $script:PSModuleProviderName
        $PSBoundParameters["MessageResolver"] = $script:PackageManagementMessageResolverScriptBlock

        $null = PackageManagement\Register-PackageSource @PSBoundParameters

        # add nuget based repo as a nuget source
        $nugetCmd = Microsoft.PowerShell.Core\Get-Command -Name $script:NuGetExeName `
            -ErrorAction SilentlyContinue -WarningAction SilentlyContinue

        if ($nugetCmd) {
            $nugetSourceExists = nuget sources list | where-object { $_.Trim() -in $SourceLocation }
            if (!$nugetSourceExists) {
                nuget sources add -name $Name -source $SourceLocation
            }
        }
    }
}
function Save-Module {
    <#
    .ExternalHelp PSModule-help.xml
    #>
    [CmdletBinding(DefaultParameterSetName = 'NameAndPathParameterSet',
        HelpUri = 'https://go.microsoft.com/fwlink/?LinkId=531351',
        SupportsShouldProcess = $true)]
    Param
    (
        [Parameter(Mandatory = $true,
            ValueFromPipelineByPropertyName = $true,
            Position = 0,
            ParameterSetName = 'NameAndPathParameterSet')]
        [Parameter(Mandatory = $true,
            ValueFromPipelineByPropertyName = $true,
            Position = 0,
            ParameterSetName = 'NameAndLiteralPathParameterSet')]
        [ValidateNotNullOrEmpty()]
        [string[]]
        $Name,

        [Parameter(Mandatory = $true,
            ValueFromPipeline = $true,
            ValueFromPipelineByPropertyName = $true,
            Position = 0,
            ParameterSetName = 'InputObjectAndPathParameterSet')]
        [Parameter(Mandatory = $true,
            ValueFromPipeline = $true,
            ValueFromPipelineByPropertyName = $true,
            Position = 0,
            ParameterSetName = 'InputObjectAndLiteralPathParameterSet')]
        [ValidateNotNull()]
        [PSCustomObject[]]
        $InputObject,

        [Parameter(ValueFromPipelineByPropertyName = $true,
            ParameterSetName = 'NameAndPathParameterSet')]
        [Parameter(ValueFromPipelineByPropertyName = $true,
            ParameterSetName = 'NameAndLiteralPathParameterSet')]
        [ValidateNotNull()]
        [string]
        $MinimumVersion,

        [Parameter(ValueFromPipelineByPropertyName = $true,
            ParameterSetName = 'NameAndPathParameterSet')]
        [Parameter(ValueFromPipelineByPropertyName = $true,
            ParameterSetName = 'NameAndLiteralPathParameterSet')]
        [ValidateNotNull()]
        [string]
        $MaximumVersion,

        [Parameter(ValueFromPipelineByPropertyName = $true,
            ParameterSetName = 'NameAndPathParameterSet')]
        [Parameter(ValueFromPipelineByPropertyName = $true,
            ParameterSetName = 'NameAndLiteralPathParameterSet')]
        [ValidateNotNull()]
        [string]
        $RequiredVersion,

        [Parameter(ValueFromPipelineByPropertyName = $true,
            ParameterSetName = 'NameAndPathParameterSet')]
        [Parameter(ValueFromPipelineByPropertyName = $true,
            ParameterSetName = 'NameAndLiteralPathParameterSet')]
        [ValidateNotNullOrEmpty()]
        [string[]]
        $Repository,

        [Parameter(Mandatory = $true,
            Position = 1,
            ValueFromPipelineByPropertyName = $true,
            ParameterSetName = 'NameAndPathParameterSet')]
        [Parameter(Mandatory = $true,
            Position = 1,
            ValueFromPipelineByPropertyName = $true,
            ParameterSetName = 'InputObjectAndPathParameterSet')]
        [string]
        $Path,

        [Parameter(Mandatory = $true,
            ValueFromPipelineByPropertyName = $true,
            ParameterSetName = 'NameAndLiteralPathParameterSet')]
        [Parameter(Mandatory = $true,
            ValueFromPipelineByPropertyName = $true,
            ParameterSetName = 'InputObjectAndLiteralPathParameterSet')]
        [Alias('PSPath')]
        [string]
        $LiteralPath,

        [Parameter(ValueFromPipelineByPropertyName = $true)]
        [ValidateNotNullOrEmpty()]
        [Uri]
        $Proxy,

        [Parameter(ValueFromPipelineByPropertyName = $true)]
        [PSCredential]
        $ProxyCredential,

        [Parameter(ValueFromPipelineByPropertyName = $true)]
        [PSCredential]
        $Credential,

        [Parameter()]
        [switch]
        $Force,

        [Parameter(ParameterSetName = 'NameAndPathParameterSet')]
        [Parameter(ParameterSetName = 'NameAndLiteralPathParameterSet')]
        [switch]
        $AllowPrerelease,

        [Parameter()]
        [switch]
        $AcceptLicense
    )

    Begin {
        # Change security protocol to TLS 1.2
        $script:securityProtocol = [Net.ServicePointManager]::SecurityProtocol
        [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12

        Install-NuGetClientBinaries -CallerPSCmdlet $PSCmdlet -Proxy $Proxy -ProxyCredential $ProxyCredential

        # Module names already tried in the current pipeline for InputObject parameterset
        $moduleNamesInPipeline = @()
    }

    Process {
        $PSBoundParameters["Provider"] = $script:PSModuleProviderName
        $PSBoundParameters["MessageResolver"] = $script:PackageManagementSaveModuleMessageResolverScriptBlock
        $PSBoundParameters[$script:PSArtifactType] = $script:PSArtifactTypeModule
        if ($AllowPrerelease) {
            $PSBoundParameters[$script:AllowPrereleaseVersions] = $true
        }
        $null = $PSBoundParameters.Remove("AllowPrerelease")

        # When -Force is specified, Path will be created if not available.
        if (-not $Force) {
            if ($Path) {
                $destinationPath = Resolve-PathHelper -Path $Path -CallerPSCmdlet $PSCmdlet | Microsoft.PowerShell.Utility\Select-Object -First 1 -ErrorAction Ignore

                if (-not $destinationPath -or -not (Microsoft.PowerShell.Management\Test-path $destinationPath)) {
                    $errorMessage = ($LocalizedData.PathNotFound -f $Path)
                    ThrowError  -ExceptionName "System.ArgumentException" `
                        -ExceptionMessage $errorMessage `
                        -ErrorId "PathNotFound" `
                        -CallerPSCmdlet $PSCmdlet `
                        -ExceptionObject $Path `
                        -ErrorCategory InvalidArgument
                }

                $PSBoundParameters['Path'] = $destinationPath
            }
            else {
                $destinationPath = Resolve-PathHelper -Path $LiteralPath -IsLiteralPath -CallerPSCmdlet $PSCmdlet | Microsoft.PowerShell.Utility\Select-Object -First 1 -ErrorAction Ignore

                if (-not $destinationPath -or -not (Microsoft.PowerShell.Management\Test-Path -LiteralPath $destinationPath)) {
                    $errorMessage = ($LocalizedData.PathNotFound -f $LiteralPath)
                    ThrowError  -ExceptionName "System.ArgumentException" `
                        -ExceptionMessage $errorMessage `
                        -ErrorId "PathNotFound" `
                        -CallerPSCmdlet $PSCmdlet `
                        -ExceptionObject $LiteralPath `
                        -ErrorCategory InvalidArgument
                }

                $PSBoundParameters['LiteralPath'] = $destinationPath
            }
        }

        if ($Name) {
            $ValidationResult = Validate-VersionParameters -CallerPSCmdlet $PSCmdlet `
                -Name $Name `
                -TestWildcardsInName `
                -MinimumVersion $MinimumVersion `
                -MaximumVersion $MaximumVersion `
                -RequiredVersion $RequiredVersion `
                -AllowPrerelease:$AllowPrerelease

            if (-not $ValidationResult) {
                # Validate-VersionParameters throws the error.
                # returning to avoid further execution when different values are specified for -ErrorAction parameter
                return
            }

            if ($PSBoundParameters.ContainsKey("Repository")) {
                $PSBoundParameters["Source"] = $Repository
                $null = $PSBoundParameters.Remove("Repository")

                $ev = $null
                $null = Get-PSRepository -Name $Repository -ErrorVariable ev -verbose:$false
                if ($ev) { return }
            }

            $null = PackageManagement\Save-Package @PSBoundParameters
        }
        elseif ($InputObject) {
            $null = $PSBoundParameters.Remove("InputObject")

            foreach ($inputValue in $InputObject) {
                if (($inputValue.PSTypeNames -notcontains "Microsoft.PowerShell.Commands.PSRepositoryItemInfo") -and
                    ($inputValue.PSTypeNames -notcontains "Deserialized.Microsoft.PowerShell.Commands.PSRepositoryItemInfo") -and
                    ($inputValue.PSTypeNames -notcontains "Microsoft.PowerShell.Commands.PSGetCommandInfo") -and
                    ($inputValue.PSTypeNames -notcontains "Deserialized.Microsoft.PowerShell.Commands.PSGetCommandInfo") -and
                    ($inputValue.PSTypeNames -notcontains "Microsoft.PowerShell.Commands.PSGetDscResourceInfo") -and
                    ($inputValue.PSTypeNames -notcontains "Deserialized.Microsoft.PowerShell.Commands.PSGetDscResourceInfo") -and
                    ($inputValue.PSTypeNames -notcontains "Microsoft.PowerShell.Commands.PSGetRoleCapabilityInfo") -and
                    ($inputValue.PSTypeNames -notcontains "Deserialized.Microsoft.PowerShell.Commands.PSGetRoleCapabilityInfo")) {
                    ThrowError -ExceptionName "System.ArgumentException" `
                        -ExceptionMessage $LocalizedData.InvalidInputObjectValue `
                        -ErrorId "InvalidInputObjectValue" `
                        -CallerPSCmdlet $PSCmdlet `
                        -ErrorCategory InvalidArgument `
                        -ExceptionObject $inputValue
                }

                if ( ($inputValue.PSTypeNames -contains "Microsoft.PowerShell.Commands.PSGetDscResourceInfo") -or
                    ($inputValue.PSTypeNames -contains "Deserialized.Microsoft.PowerShell.Commands.PSGetDscResourceInfo") -or
                    ($inputValue.PSTypeNames -contains "Microsoft.PowerShell.Commands.PSGetCommandInfo") -or
                    ($inputValue.PSTypeNames -contains "Deserialized.Microsoft.PowerShell.Commands.PSGetCommandInfo") -or
                    ($inputValue.PSTypeNames -contains "Microsoft.PowerShell.Commands.PSGetRoleCapabilityInfo") -or
                    ($inputValue.PSTypeNames -contains "Deserialized.Microsoft.PowerShell.Commands.PSGetRoleCapabilityInfo")) {
                    $psgetModuleInfo = $inputValue.PSGetModuleInfo
                }
                else {
                    $psgetModuleInfo = $inputValue
                }

                # Skip the module name if it is already tried in the current pipeline
                if ($moduleNamesInPipeline -contains $psgetModuleInfo.Name) {
                    continue
                }

                $moduleNamesInPipeline += $psgetModuleInfo.Name

                if ($psgetModuleInfo.PowerShellGetFormatVersion -and
                    ($script:SupportedPSGetFormatVersionMajors -notcontains $psgetModuleInfo.PowerShellGetFormatVersion.Major)) {
                    $message = $LocalizedData.NotSupportedPowerShellGetFormatVersion -f ($psgetModuleInfo.Name, $psgetModuleInfo.PowerShellGetFormatVersion, $psgetModuleInfo.Name)
                    Write-Error -Message $message -ErrorId "NotSupportedPowerShellGetFormatVersion" -Category InvalidOperation
                    continue
                }

                $PSBoundParameters["Name"] = $psgetModuleInfo.Name
                $PSBoundParameters["RequiredVersion"] = $psgetModuleInfo.Version
                if (($psgetModuleInfo.AdditionalMetadata) -and
                    (Get-Member -InputObject $psgetModuleInfo.AdditionalMetadata -Name "IsPrerelease") -and
                    ($psgetModuleInfo.AdditionalMetadata.IsPrerelease -eq "true")) {
                    $PSBoundParameters[$script:AllowPrereleaseVersions] = $true
                }
                elseif ($PSBoundParameters.ContainsKey($script:AllowPrereleaseVersions)) {
                    $null = $PSBoundParameters.Remove($script:AllowPrereleaseVersions)
                }
                $PSBoundParameters['Source'] = $psgetModuleInfo.Repository
                $PSBoundParameters["PackageManagementProvider"] = (Get-ProviderName -PSCustomObject $psgetModuleInfo)

                $null = PackageManagement\Save-Package @PSBoundParameters
            }
        }
    }

    End {
        # Change back to user specified security protocol
        [Net.ServicePointManager]::SecurityProtocol = $script:securityProtocol
    }
}
function Save-Script {
    <#
    .ExternalHelp PSModule-help.xml
    #>
    [CmdletBinding(DefaultParameterSetName = 'NameAndPathParameterSet',
        HelpUri = 'https://go.microsoft.com/fwlink/?LinkId=619786',
        SupportsShouldProcess = $true)]
    Param
    (
        [Parameter(Mandatory = $true,
            ValueFromPipelineByPropertyName = $true,
            Position = 0,
            ParameterSetName = 'NameAndPathParameterSet')]
        [Parameter(Mandatory = $true,
            ValueFromPipelineByPropertyName = $true,
            Position = 0,
            ParameterSetName = 'NameAndLiteralPathParameterSet')]
        [ValidateNotNullOrEmpty()]
        [string[]]
        $Name,

        [Parameter(Mandatory = $true,
            ValueFromPipeline = $true,
            ValueFromPipelineByPropertyName = $true,
            Position = 0,
            ParameterSetName = 'InputObjectAndPathParameterSet')]
        [Parameter(Mandatory = $true,
            ValueFromPipeline = $true,
            ValueFromPipelineByPropertyName = $true,
            Position = 0,
            ParameterSetName = 'InputObjectAndLiteralPathParameterSet')]
        [ValidateNotNull()]
        [PSCustomObject[]]
        $InputObject,

        [Parameter(ValueFromPipelineByPropertyName = $true,
            ParameterSetName = 'NameAndPathParameterSet')]
        [Parameter(ValueFromPipelineByPropertyName = $true,
            ParameterSetName = 'NameAndLiteralPathParameterSet')]
        [ValidateNotNull()]
        [string]
        $MinimumVersion,

        [Parameter(ValueFromPipelineByPropertyName = $true,
            ParameterSetName = 'NameAndPathParameterSet')]
        [Parameter(ValueFromPipelineByPropertyName = $true,
            ParameterSetName = 'NameAndLiteralPathParameterSet')]
        [ValidateNotNull()]
        [string]
        $MaximumVersion,

        [Parameter(ValueFromPipelineByPropertyName = $true,
            ParameterSetName = 'NameAndPathParameterSet')]
        [Parameter(ValueFromPipelineByPropertyName = $true,
            ParameterSetName = 'NameAndLiteralPathParameterSet')]
        [ValidateNotNull()]
        [string]
        $RequiredVersion,

        [Parameter(ValueFromPipelineByPropertyName = $true,
            ParameterSetName = 'NameAndPathParameterSet')]
        [Parameter(ValueFromPipelineByPropertyName = $true,
            ParameterSetName = 'NameAndLiteralPathParameterSet')]
        [ValidateNotNullOrEmpty()]
        [string[]]
        $Repository,

        [Parameter(Mandatory = $true,
            ValueFromPipelineByPropertyName = $true,
            Position = 1,
            ParameterSetName = 'NameAndPathParameterSet')]

        [Parameter(Mandatory = $true,
            ValueFromPipelineByPropertyName = $true,
            Position = 1,
            ParameterSetName = 'InputObjectAndPathParameterSet')]
        [string]
        $Path,

        [Parameter(Mandatory = $true,
            ValueFromPipelineByPropertyName = $true,
            ParameterSetName = 'NameAndLiteralPathParameterSet')]

        [Parameter(Mandatory = $true,
            ValueFromPipelineByPropertyName = $true,
            ParameterSetName = 'InputObjectAndLiteralPathParameterSet')]
        [Alias('PSPath')]
        [string]
        $LiteralPath,

        [Parameter(ValueFromPipelineByPropertyName = $true)]
        [ValidateNotNullOrEmpty()]
        [Uri]
        $Proxy,

        [Parameter(ValueFromPipelineByPropertyName = $true)]
        [PSCredential]
        $ProxyCredential,

        [Parameter(ValueFromPipelineByPropertyName = $true)]
        [PSCredential]
        $Credential,

        [Parameter()]
        [switch]
        $Force,

        [Parameter(ParameterSetName = 'NameAndPathParameterSet')]
        [Parameter(ParameterSetName = 'NameAndLiteralPathParameterSet')]
        [switch]
        $AllowPrerelease,

        [Parameter()]
        [switch]
        $AcceptLicense
    )

    Begin {
        # Change security protocol to TLS 1.2
        $script:securityProtocol = [Net.ServicePointManager]::SecurityProtocol
        [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12

        Install-NuGetClientBinaries -CallerPSCmdlet $PSCmdlet -Proxy $Proxy -ProxyCredential $ProxyCredential

        # Script names already tried in the current pipeline for InputObject parameterset
        $scriptNamesInPipeline = @()
    }

    Process {
        $PSBoundParameters["Provider"] = $script:PSModuleProviderName
        $PSBoundParameters["MessageResolver"] = $script:PackageManagementSaveScriptMessageResolverScriptBlock
        $PSBoundParameters[$script:PSArtifactType] = $script:PSArtifactTypeScript
        if ($AllowPrerelease) {
            $PSBoundParameters[$script:AllowPrereleaseVersions] = $true
        }
        $null = $PSBoundParameters.Remove("AllowPrerelease")

        # When -Force is specified, Path will be created if not available.
        if (-not $Force) {
            if ($Path) {
                $destinationPath = Resolve-PathHelper -Path $Path -CallerPSCmdlet $PSCmdlet |
                Microsoft.PowerShell.Utility\Select-Object -First 1 -ErrorAction Ignore

                if (-not $destinationPath -or -not (Microsoft.PowerShell.Management\Test-path $destinationPath)) {
                    $errorMessage = ($LocalizedData.PathNotFound -f $Path)
                    ThrowError  -ExceptionName "System.ArgumentException" `
                        -ExceptionMessage $errorMessage `
                        -ErrorId "PathNotFound" `
                        -CallerPSCmdlet $PSCmdlet `
                        -ExceptionObject $Path `
                        -ErrorCategory InvalidArgument
                }

                $PSBoundParameters['Path'] = $destinationPath
            }
            else {
                $destinationPath = Resolve-PathHelper -Path $LiteralPath -IsLiteralPath -CallerPSCmdlet $PSCmdlet |
                Microsoft.PowerShell.Utility\Select-Object -First 1 -ErrorAction Ignore

                if (-not $destinationPath -or -not (Microsoft.PowerShell.Management\Test-Path -LiteralPath $destinationPath)) {
                    $errorMessage = ($LocalizedData.PathNotFound -f $LiteralPath)
                    ThrowError  -ExceptionName "System.ArgumentException" `
                        -ExceptionMessage $errorMessage `
                        -ErrorId "PathNotFound" `
                        -CallerPSCmdlet $PSCmdlet `
                        -ExceptionObject $LiteralPath `
                        -ErrorCategory InvalidArgument
                }

                $PSBoundParameters['LiteralPath'] = $destinationPath
            }
        }

        if ($Name) {
            $ValidationResult = Validate-VersionParameters -CallerPSCmdlet $PSCmdlet `
                -Name $Name `
                -TestWildcardsInName `
                -MinimumVersion $MinimumVersion `
                -MaximumVersion $MaximumVersion `
                -RequiredVersion $RequiredVersion `
                -AllowPrerelease:$AllowPrerelease

            if (-not $ValidationResult) {
                # Validate-VersionParameters throws the error.
                # returning to avoid further execution when different values are specified for -ErrorAction parameter
                return
            }

            if ($PSBoundParameters.ContainsKey("Repository")) {
                $PSBoundParameters["Source"] = $Repository
                $null = $PSBoundParameters.Remove("Repository")

                $ev = $null
                $repositories = Get-PSRepository -Name $Repository -ErrorVariable ev -verbose:$false
                if ($ev) { return }

                $RepositoriesWithoutScriptSourceLocation = $false
                foreach ($repo in $repositories) {
                    if (-not $repo.ScriptSourceLocation) {
                        $message = $LocalizedData.ScriptSourceLocationIsMissing -f ($repo.Name)
                        Write-Error -Message $message `
                            -ErrorId 'ScriptSourceLocationIsMissing' `
                            -Category InvalidArgument `
                            -TargetObject $repo.Name `
                            -Exception 'System.ArgumentException'

                        $RepositoriesWithoutScriptSourceLocation = $true
                    }
                }

                if ($RepositoriesWithoutScriptSourceLocation) {
                    return
                }
            }

            $null = PackageManagement\Save-Package @PSBoundParameters
        }
        elseif ($InputObject) {
            $null = $PSBoundParameters.Remove("InputObject")

            foreach ($inputValue in $InputObject) {
                if (($inputValue.PSTypeNames -notcontains "Microsoft.PowerShell.Commands.PSRepositoryItemInfo") -and
                    ($inputValue.PSTypeNames -notcontains "Deserialized.Microsoft.PowerShell.Commands.PSRepositoryItemInfo")) {
                    ThrowError -ExceptionName "System.ArgumentException" `
                        -ExceptionMessage $LocalizedData.InvalidInputObjectValue `
                        -ErrorId "InvalidInputObjectValue" `
                        -CallerPSCmdlet $PSCmdlet `
                        -ErrorCategory InvalidArgument `
                        -ExceptionObject $inputValue
                }

                $psRepositoryItemInfo = $inputValue

                # Skip the script name if it is already tried in the current pipeline
                if ($scriptNamesInPipeline -contains $psRepositoryItemInfo.Name) {
                    continue
                }

                $scriptNamesInPipeline += $psRepositoryItemInfo.Name

                if ($psRepositoryItemInfo.PowerShellGetFormatVersion -and
                    ($script:SupportedPSGetFormatVersionMajors -notcontains $psRepositoryItemInfo.PowerShellGetFormatVersion.Major)) {
                    $message = $LocalizedData.NotSupportedPowerShellGetFormatVersionScripts -f ($psRepositoryItemInfo.Name, $psRepositoryItemInfo.PowerShellGetFormatVersion, $psRepositoryItemInfo.Name)
                    Write-Error -Message $message -ErrorId "NotSupportedPowerShellGetFormatVersion" -Category InvalidOperation
                    continue
                }

                $PSBoundParameters["Name"] = $psRepositoryItemInfo.Name
                $PSBoundParameters["RequiredVersion"] = $psRepositoryItemInfo.Version
                if (($psRepositoryItemInfo.AdditionalMetadata) -and
                    (Get-Member -InputObject $psRepositoryItemInfo.AdditionalMetadata -Name "IsPrerelease") -and
                    ($psRepositoryItemInfo.AdditionalMetadata.IsPrerelease -eq "true")) {
                    $PSBoundParameters[$script:AllowPrereleaseVersions] = $true
                }
                elseif ($PSBoundParameters.ContainsKey($script:AllowPrereleaseVersions)) {
                    $null = $PSBoundParameters.Remove($script:AllowPrereleaseVersions)
                }
                $PSBoundParameters['Source'] = $psRepositoryItemInfo.Repository
                $PSBoundParameters["PackageManagementProvider"] = (Get-ProviderName -PSCustomObject $psRepositoryItemInfo)

                $null = PackageManagement\Save-Package @PSBoundParameters
            }
        }
    }

    End {
        # Change back to user specified security protocol
        [Net.ServicePointManager]::SecurityProtocol = $script:securityProtocol
    }
}
function Set-PSRepository {
    <#
    .ExternalHelp PSModule-help.xml
    #>
    [CmdletBinding(PositionalBinding = $false,
        HelpUri = 'https://go.microsoft.com/fwlink/?LinkID=517128')]
    Param
    (
        [Parameter(Mandatory = $true, Position = 0, ValueFromPipelineByPropertyName = $true)]
        [ValidateNotNullOrEmpty()]
        [string]
        $Name,

        [Parameter(Position = 1)]
        [ValidateNotNullOrEmpty()]
        [Uri]
        $SourceLocation,

        [Parameter()]
        [ValidateNotNullOrEmpty()]
        [Uri]
        $PublishLocation,

        [Parameter()]
        [ValidateNotNullOrEmpty()]
        [Uri]
        $ScriptSourceLocation,

        [Parameter()]
        [ValidateNotNullOrEmpty()]
        [Uri]
        $ScriptPublishLocation,

        [Parameter(ValueFromPipelineByPropertyName = $true)]
        [PSCredential]
        $Credential,

        [Parameter()]
        [ValidateSet('Trusted', 'Untrusted')]
        [string]
        $InstallationPolicy,

        [Parameter(ValueFromPipelineByPropertyName = $true)]
        [ValidateNotNullOrEmpty()]
        [Uri]
        $Proxy,

        [Parameter(ValueFromPipelineByPropertyName = $true)]
        [PSCredential]
        $ProxyCredential,

        [Parameter()]
        [ValidateNotNullOrEmpty()]
        [string]
        $PackageManagementProvider
    )

    DynamicParam {
        if (Get-Variable -Name Name -ErrorAction SilentlyContinue) {
            $moduleSource = Get-PSRepository -Name $Name -ErrorAction SilentlyContinue -WarningAction SilentlyContinue

            if ($moduleSource) {
                $providerName = (Get-ProviderName -PSCustomObject $moduleSource)

                $loc = $moduleSource.SourceLocation

                if (Get-Variable -Name SourceLocation -ErrorAction SilentlyContinue) {
                    $loc = $SourceLocation
                }

                if (Get-Variable -Name PackageManagementProvider -ErrorAction SilentlyContinue) {
                    $providerName = $PackageManagementProvider
                }

                $null = Get-DynamicParameters -Location $loc -PackageManagementProvider ([REF]$providerName)
            }
        }
    }

    Begin {
        Install-NuGetClientBinaries -CallerPSCmdlet $PSCmdlet -Proxy $Proxy -ProxyCredential $ProxyCredential

        if ($PackageManagementProvider) {
            $providers = PackageManagement\Get-PackageProvider | Where-Object { $_.Name -ne $script:PSModuleProviderName -and $_.Features.ContainsKey($script:SupportsPSModulesFeatureName) }

            if (-not $providers -or $providers.Name -notcontains $PackageManagementProvider) {
                $possibleProviderNames = $script:NuGetProviderName

                if ($providers) {
                    $possibleProviderNames = ($providers.Name -join ',')
                }

                $message = $LocalizedData.InvalidPackageManagementProviderValue -f ($PackageManagementProvider, $possibleProviderNames, $script:NuGetProviderName)
                ThrowError -ExceptionName "System.ArgumentException" `
                    -ExceptionMessage $message `
                    -ErrorId "InvalidPackageManagementProviderValue" `
                    -CallerPSCmdlet $PSCmdlet `
                    -ErrorCategory InvalidArgument `
                    -ExceptionObject $PackageManagementProvider
                return
            }
        }
    }

    Process {
        # Ping and resolve the specified location
        if ($SourceLocation) {
            # Ping and resolve the specified location
            $SourceLocation = Resolve-Location -Location (Get-LocationString -LocationUri $SourceLocation) `
                -LocationParameterName 'SourceLocation' `
                -Credential $Credential `
                -Proxy $Proxy `
                -ProxyCredential $ProxyCredential `
                -CallerPSCmdlet $PSCmdlet
            if (-not $SourceLocation) {
                # Above Resolve-Location function throws an error when it is not able to resolve a location
                return
            }
        }

        $ModuleSource = Get-PSRepository -Name $Name -ErrorAction SilentlyContinue -WarningAction SilentlyContinue

        if (-not $ModuleSource) {
            $message = $LocalizedData.RepositoryNotFound -f ($Name)

            ThrowError -ExceptionName "System.InvalidOperationException" `
                -ExceptionMessage $message `
                -ErrorId "RepositoryNotFound" `
                -CallerPSCmdlet $PSCmdlet `
                -ErrorCategory InvalidOperation `
                -ExceptionObject $Name
        }

        if (-not $PackageManagementProvider) {
            $PackageManagementProvider = (Get-ProviderName -PSCustomObject $ModuleSource)
        }

        $Trusted = $ModuleSource.Trusted
        if ($InstallationPolicy) {
            if ($InstallationPolicy -eq "Trusted") {
                $Trusted = $true
            }
            else {
                $Trusted = $false
            }

            $null = $PSBoundParameters.Remove("InstallationPolicy")
        }

        if ($PublishLocation) {
            $PSBoundParameters[$script:PublishLocation] = Get-LocationString -LocationUri $PublishLocation
        }

        if ($ScriptPublishLocation) {
            $PSBoundParameters[$script:ScriptPublishLocation] = Get-LocationString -LocationUri $ScriptPublishLocation
        }

        if ($ScriptSourceLocation) {
            $PSBoundParameters[$script:ScriptSourceLocation] = Get-LocationString -LocationUri $ScriptSourceLocation
        }

        if ($SourceLocation) {
            $PSBoundParameters["NewLocation"] = Get-LocationString -LocationUri $SourceLocation

            $null = $PSBoundParameters.Remove("SourceLocation")
        }

        $PSBoundParameters[$script:PackageManagementProviderParam] = $PackageManagementProvider
        $PSBoundParameters["Trusted"] = $Trusted
        $PSBoundParameters["Provider"] = $script:PSModuleProviderName
        $PSBoundParameters["MessageResolver"] = $script:PackageManagementMessageResolverScriptBlock

        $null = PackageManagement\Set-PackageSource @PSBoundParameters
    }
}
function Test-ScriptFileInfo {
    <#
    .ExternalHelp PSModule-help.xml
    #>
    [CmdletBinding(PositionalBinding = $false,
        DefaultParameterSetName = 'PathParameterSet',
        HelpUri = 'https://go.microsoft.com/fwlink/?LinkId=619791')]
    Param
    (
        [Parameter(Mandatory = $true,
            Position = 0,
            ValueFromPipelineByPropertyName = $true,
            ParameterSetName = 'PathParameterSet')]
        [ValidateNotNullOrEmpty()]
        [string]
        $Path,

        [Parameter(Mandatory = $true,
            ValueFromPipelineByPropertyName = $true,
            ParameterSetName = 'LiteralPathParameterSet')]
        [Alias('PSPath')]
        [ValidateNotNullOrEmpty()]
        [string]
        $LiteralPath
    )

    Process {
        $scriptFilePath = $null
        if ($Path) {
            $scriptFilePath = Resolve-PathHelper -Path $Path -CallerPSCmdlet $PSCmdlet | Microsoft.PowerShell.Utility\Select-Object -First 1 -ErrorAction Ignore

            if (-not $scriptFilePath -or -not (Microsoft.PowerShell.Management\Test-Path -Path $scriptFilePath -PathType Leaf)) {
                $errorMessage = ($LocalizedData.PathNotFound -f $Path)
                ThrowError  -ExceptionName "System.ArgumentException" `
                    -ExceptionMessage $errorMessage `
                    -ErrorId "PathNotFound" `
                    -CallerPSCmdlet $PSCmdlet `
                    -ExceptionObject $Path `
                    -ErrorCategory InvalidArgument
                return
            }
        }
        else {
            $scriptFilePath = Resolve-PathHelper -Path $LiteralPath -IsLiteralPath -CallerPSCmdlet $PSCmdlet | Microsoft.PowerShell.Utility\Select-Object -First 1 -ErrorAction Ignore

            if (-not $scriptFilePath -or -not (Microsoft.PowerShell.Management\Test-Path -LiteralPath $scriptFilePath -PathType Leaf)) {
                $errorMessage = ($LocalizedData.PathNotFound -f $LiteralPath)
                ThrowError  -ExceptionName "System.ArgumentException" `
                    -ExceptionMessage $errorMessage `
                    -ErrorId "PathNotFound" `
                    -CallerPSCmdlet $PSCmdlet `
                    -ExceptionObject $LiteralPath `
                    -ErrorCategory InvalidArgument
                return
            }
        }

        if (-not $scriptFilePath.EndsWith('.ps1', [System.StringComparison]::OrdinalIgnoreCase)) {
            $errorMessage = ($LocalizedData.InvalidScriptFilePath -f $scriptFilePath)
            ThrowError  -ExceptionName "System.ArgumentException" `
                -ExceptionMessage $errorMessage `
                -ErrorId "InvalidScriptFilePath" `
                -CallerPSCmdlet $PSCmdlet `
                -ExceptionObject $scriptFilePath `
                -ErrorCategory InvalidArgument
            return
        }

        $PSScriptInfo = New-PSScriptInfoObject -Path $scriptFilePath

        [System.Management.Automation.Language.Token[]]$tokens = $null;
        [System.Management.Automation.Language.ParseError[]]$errors = $null;
        $ast = [System.Management.Automation.Language.Parser]::ParseFile($scriptFilePath, ([ref]$tokens), ([ref]$errors))


        $notSupportedOnNanoErrorIds = @('WorkflowNotSupportedInPowerShellCore',
            'ConfigurationNotSupportedInPowerShellCore')
        $errorsAfterSkippingOneCoreErrors = $errors | Microsoft.PowerShell.Core\Where-Object { $notSupportedOnNanoErrorIds -notcontains $_.ErrorId }

        if ($errorsAfterSkippingOneCoreErrors) {
            $errorMessage = ($LocalizedData.ScriptParseError -f $scriptFilePath)
            ThrowError  -ExceptionName "System.ArgumentException" `
                -ExceptionMessage $errorMessage `
                -ErrorId "ScriptParseError" `
                -CallerPSCmdlet $PSCmdlet `
                -ExceptionObject $errorsAfterSkippingOneCoreErrors `
                -ErrorCategory InvalidArgument
            return
        }

        if ($ast) {
            # Get the block/group comment beginning with <#PSScriptInfo
            $CommentTokens = $tokens | Microsoft.PowerShell.Core\Where-Object { $_.Kind -eq 'Comment' }

            $psscriptInfoComments = $CommentTokens |
            Microsoft.PowerShell.Core\Where-Object { $_.Extent.Text -match "<#PSScriptInfo" } |
            Microsoft.PowerShell.Utility\Select-Object -First 1 -ErrorAction Ignore

            if (-not $psscriptInfoComments) {
                $errorMessage = ($LocalizedData.MissingPSScriptInfo -f $scriptFilePath)
                ThrowError  -ExceptionName "System.ArgumentException" `
                    -ExceptionMessage $errorMessage `
                    -ErrorId "MissingPSScriptInfo" `
                    -CallerPSCmdlet $PSCmdlet `
                    -ExceptionObject $scriptFilePath `
                    -ErrorCategory InvalidArgument
                return
            }

            # $psscriptInfoComments.Text will have the multiline PSScriptInfo comment,
            # split them into multiple lines to parse for the PSScriptInfo metadata properties.
            $commentLines = [System.Text.RegularExpressions.Regex]::Split($psscriptInfoComments.Text, "[\r\n]")

            $KeyName = $null
            $Value = ""

            # PSScriptInfo comment will be in following format:
            <#PSScriptInfo

                .VERSION 1.0

                .GUID 544238e3-1751-4065-9227-be105ff11636

                .AUTHOR manikb

                .COMPANYNAME Microsoft Corporation

                .COPYRIGHT (c) 2015 Microsoft Corporation. All rights reserved.

                .TAGS Tag1 Tag2 Tag3

                .LICENSEURI https://contoso.com/License

                .PROJECTURI https://contoso.com/

                .ICONURI https://contoso.com/Icon

                .EXTERNALMODULEDEPENDENCIES ExternalModule1

                .REQUIREDSCRIPTS Start-WFContosoServer,Stop-ContosoServerScript

                .EXTERNALSCRIPTDEPENDENCIES Stop-ContosoServerScript

                .RELEASENOTES
                contoso script now supports following features
                Feature 1
                Feature 2
                Feature 3
                Feature 4
                Feature 5

                #>
            # If comment line count is not more than two, it doesn't have the any metadata property
            # First line is <#PSScriptInfo
            # Last line #>
            #
            if ($commentLines.Count -gt 2) {
                for ($i = 1; $i -lt ($commentLines.count - 1); $i++) {
                    $line = $commentLines[$i]

                    if (-not $line) {
                        continue
                    }

                    # A line is starting with . conveys a new metadata property
                    # __NEWLINE__ is used for replacing the value lines while adding the value to $PSScriptInfo object
                    #
                    if ($line.trim().StartsWith('.')) {
                        $parts = $line.trim() -split '[.\s+]', 3 | Microsoft.PowerShell.Core\Where-Object { $_ }

                        if ($KeyName -and $Value) {
                            if ($keyName -eq $script:ReleaseNotes) {
                                $Value = $Value.Trim() -split '__NEWLINE__'
                            }
                            elseif ($keyName -eq $script:DESCRIPTION) {
                                $Value = $Value -split '__NEWLINE__'
                                $Value = ($Value -join "`r`n").Trim()
                            }
                            else {
                                $Value = $Value -split '__NEWLINE__' | Microsoft.PowerShell.Core\Where-Object { $_ }

                                if ($Value -and $Value.GetType().ToString() -eq "System.String") {
                                    $Value = $Value.Trim()
                                }
                            }

                            ValidateAndAdd-PSScriptInfoEntry -PSScriptInfo $PSScriptInfo `
                                -PropertyName $KeyName `
                                -PropertyValue $Value `
                                -CallerPSCmdlet $PSCmdlet
                        }

                        $KeyName = $null
                        $Value = ""

                        if ($parts.GetType().ToString() -eq "System.String") {
                            $KeyName = $parts
                        }
                        else {
                            $KeyName = $parts[0];
                            $Value = $parts[1]
                        }
                    }
                    else {
                        if ($Value) {
                            # __NEWLINE__ is used for replacing the value lines while adding the value to $PSScriptInfo object
                            $Value += '__NEWLINE__'
                        }

                        $Value += $line
                    }
                }

                if ($KeyName -and $Value) {
                    if ($keyName -eq $script:ReleaseNotes) {
                        $Value = $Value.Trim() -split '__NEWLINE__'
                    }
                    elseif ($keyName -eq $script:DESCRIPTION) {
                        $Value = $Value -split '__NEWLINE__'
                        $Value = ($Value -join "`r`n").Trim()
                    }
                    else {
                        $Value = $Value -split '__NEWLINE__' | Microsoft.PowerShell.Core\Where-Object { $_ }

                        if ($Value -and $Value.GetType().ToString() -eq "System.String") {
                            $Value = $Value.Trim()
                        }
                    }

                    ValidateAndAdd-PSScriptInfoEntry -PSScriptInfo $PSScriptInfo `
                        -PropertyName $KeyName `
                        -PropertyValue $Value `
                        -CallerPSCmdlet $PSCmdlet

                    $KeyName = $null
                    $Value = ""
                }
            }

            $helpContent = $ast.GetHelpContent()
            if ($helpContent -and $helpContent.Description) {
                ValidateAndAdd-PSScriptInfoEntry -PSScriptInfo $PSScriptInfo `
                    -PropertyName $script:DESCRIPTION `
                    -PropertyValue $helpContent.Description.Trim() `
                    -CallerPSCmdlet $PSCmdlet

            }

            # Handle RequiredModules
            if ((Microsoft.PowerShell.Utility\Get-Member -InputObject $ast -Name 'ScriptRequirements') -and
                $ast.ScriptRequirements -and
                (Microsoft.PowerShell.Utility\Get-Member -InputObject $ast.ScriptRequirements -Name 'RequiredModules') -and
                $ast.ScriptRequirements.RequiredModules) {
                ValidateAndAdd-PSScriptInfoEntry -PSScriptInfo $PSScriptInfo `
                    -PropertyName $script:RequiredModules `
                    -PropertyValue $ast.ScriptRequirements.RequiredModules `
                    -CallerPSCmdlet $PSCmdlet
            }

            # Get all defined functions and populate DefinedCommands, DefinedFunctions and DefinedWorkflows
            $allCommands = $ast.FindAll( { param($i) return ($i.GetType().Name -eq 'FunctionDefinitionAst') }, $true)

            if ($allCommands) {
                $allCommandNames = $allCommands | ForEach-Object { $_.Name } | Select-Object -Unique -ErrorAction Ignore
                ValidateAndAdd-PSScriptInfoEntry -PSScriptInfo $PSScriptInfo `
                    -PropertyName $script:DefinedCommands `
                    -PropertyValue $allCommandNames `
                    -CallerPSCmdlet $PSCmdlet

                $allFunctionNames = $allCommands | Where-Object { -not $_.IsWorkflow } | ForEach-Object { $_.Name } | Select-Object -Unique -ErrorAction Ignore
                ValidateAndAdd-PSScriptInfoEntry -PSScriptInfo $PSScriptInfo `
                    -PropertyName $script:DefinedFunctions `
                    -PropertyValue $allFunctionNames `
                    -CallerPSCmdlet $PSCmdlet


                $allWorkflowNames = $allCommands | Where-Object { $_.IsWorkflow } | ForEach-Object { $_.Name } | Select-Object -Unique -ErrorAction Ignore
                ValidateAndAdd-PSScriptInfoEntry -PSScriptInfo $PSScriptInfo `
                    -PropertyName $script:DefinedWorkflows `
                    -PropertyValue $allWorkflowNames `
                    -CallerPSCmdlet $PSCmdlet
            }
        }

        # Ensure that the script file has the required metadata properties.
        if (-not $PSScriptInfo.Version -or -not $PSScriptInfo.Guid -or -not $PSScriptInfo.Author -or -not $PSScriptInfo.Description) {
            $errorMessage = ($LocalizedData.MissingRequiredPSScriptInfoProperties -f $scriptFilePath)
            ThrowError  -ExceptionName "System.ArgumentException" `
                -ExceptionMessage $errorMessage `
                -ErrorId "MissingRequiredPSScriptInfoProperties" `
                -CallerPSCmdlet $PSCmdlet `
                -ExceptionObject $Path `
                -ErrorCategory InvalidArgument
            return
        }

        if ($PSScriptInfo.Version -match '-') {
            $result = ValidateAndGet-VersionPrereleaseStrings -Version $PSScriptInfo.Version  -CallerPSCmdlet $PSCmdlet
            if (-not $result) {
                # ValidateAndGet-VersionPrereleaseStrings throws the error.
                # returning to avoid further execution when different values are specified for -ErrorAction parameter
                return
            }
        }

        $PSScriptInfo = Get-OrderedPSScriptInfoObject -PSScriptInfo $PSScriptInfo

        return $PSScriptInfo
    }
}
function Uninstall-Module
{
    <#
    .ExternalHelp PSModule-help.xml
    #>
    [CmdletBinding(DefaultParameterSetName='NameParameterSet',
                   SupportsShouldProcess=$true,
                   HelpUri='https://go.microsoft.com/fwlink/?LinkId=526864')]
    Param
    (
        [Parameter(ValueFromPipelineByPropertyName=$true,
                   Mandatory=$true,
                   Position=0,
                   ParameterSetName='NameParameterSet')]
        [ValidateNotNullOrEmpty()]
        [String[]]
        $Name,

        [Parameter(Mandatory=$true,
                   ValueFromPipeline=$true,
                   ValueFromPipelineByPropertyName=$true,
                   Position=0,
                   ParameterSetName='InputObject')]
        [ValidateNotNull()]
        [PSCustomObject[]]
        $InputObject,

        [Parameter(ValueFromPipelineByPropertyName=$true,
                   ParameterSetName='NameParameterSet')]
        [ValidateNotNull()]
        [string]
        $MinimumVersion,

        [Parameter(ValueFromPipelineByPropertyName=$true,
                   ParameterSetName='NameParameterSet')]
        [ValidateNotNull()]
        [string]
        $RequiredVersion,

        [Parameter(ValueFromPipelineByPropertyName=$true,
                   ParameterSetName='NameParameterSet')]
        [ValidateNotNull()]
        [string]
        $MaximumVersion,

        [Parameter(ParameterSetName='NameParameterSet')]
        [switch]
        $AllVersions,

        [Parameter()]
        [Switch]
        $Force,

        [Parameter(ParameterSetName='NameParameterSet')]
        [switch]
        $AllowPrerelease
    )

    Process
    {
        $PSBoundParameters["Provider"] = $script:PSModuleProviderName
        $PSBoundParameters["MessageResolver"] = $script:PackageManagementUnInstallModuleMessageResolverScriptBlock
        $PSBoundParameters[$script:PSArtifactType] = $script:PSArtifactTypeModule

        if($PSCmdlet.ParameterSetName -eq "InputObject")
        {
            $null = $PSBoundParameters.Remove("InputObject")

            foreach($inputValue in $InputObject)
            {
                if (($inputValue.PSTypeNames -notcontains "Microsoft.PowerShell.Commands.PSRepositoryItemInfo") -and
                    ($inputValue.PSTypeNames -notcontains "Deserialized.Microsoft.PowerShell.Commands.PSRepositoryItemInfo"))
                {
                    ThrowError -ExceptionName "System.ArgumentException" `
                                -ExceptionMessage $LocalizedData.InvalidInputObjectValue `
                                -ErrorId "InvalidInputObjectValue" `
                                -CallerPSCmdlet $PSCmdlet `
                                -ErrorCategory InvalidArgument `
                                -ExceptionObject $inputValue
                }

                $PSBoundParameters["Name"] = $inputValue.Name
                $PSBoundParameters["RequiredVersion"] = $inputValue.Version
                if (($inputValue.AdditionalMetadata) -and
                    (Get-Member -InputObject $inputValue.AdditionalMetadata -Name "IsPrerelease") -and
                    ($inputValue.AdditionalMetadata.IsPrerelease -eq "true")) {
                    $PSBoundParameters[$script:AllowPrereleaseVersions] = $true
                }
                elseif ($PSBoundParameters.ContainsKey($script:AllowPrereleaseVersions)) {
                    $null = $PSBoundParameters.Remove($script:AllowPrereleaseVersions)
                }

                $null = PackageManagement\Uninstall-Package @PSBoundParameters
            }
        }
        else
        {
            $ValidationResult = Validate-VersionParameters -CallerPSCmdlet $PSCmdlet `
                                                           -Name $Name `
                                                           -TestWildcardsInName `
                                                           -MinimumVersion $MinimumVersion `
                                                           -MaximumVersion $MaximumVersion `
                                                           -RequiredVersion $RequiredVersion `
                                                           -AllVersions:$AllVersions `
                                                           -AllowPrerelease:$AllowPrerelease

            if(-not $ValidationResult)
            {
                # Validate-VersionParameters throws the error.
                # returning to avoid further execution when different values are specified for -ErrorAction parameter
                return
            }

            $null = PackageManagement\Uninstall-Package @PSBoundParameters
        }
    }
}
function Uninstall-Script
{
    <#
    .ExternalHelp PSModule-help.xml
    #>
    [CmdletBinding(DefaultParameterSetName='NameParameterSet',
                   SupportsShouldProcess=$true,
                   HelpUri='https://go.microsoft.com/fwlink/?LinkId=619789')]
    Param
    (
        [Parameter(ValueFromPipelineByPropertyName=$true,
                   Mandatory=$true,
                   Position=0,
                   ParameterSetName='NameParameterSet')]
        [ValidateNotNullOrEmpty()]
        [String[]]
        $Name,

        [Parameter(Mandatory=$true,
                   ValueFromPipeline=$true,
                   ValueFromPipelineByPropertyName=$true,
                   Position=0,
                   ParameterSetName='InputObject')]
        [ValidateNotNull()]
        [PSCustomObject[]]
        $InputObject,

        [Parameter(ValueFromPipelineByPropertyName=$true,
                   ParameterSetName='NameParameterSet')]
        [ValidateNotNull()]
        [string]
        $MinimumVersion,

        [Parameter(ValueFromPipelineByPropertyName=$true,
                   ParameterSetName='NameParameterSet')]
        [ValidateNotNull()]
        [string]
        $RequiredVersion,

        [Parameter(ValueFromPipelineByPropertyName=$true,
                   ParameterSetName='NameParameterSet')]
        [ValidateNotNull()]
        [string]
        $MaximumVersion,

        [Parameter()]
        [Switch]
        $Force,

        [Parameter(ParameterSetName='NameParameterSet')]
        [Switch]
        $AllowPrerelease
    )

    Process
    {
        $PSBoundParameters["Provider"] = $script:PSModuleProviderName
        $PSBoundParameters["MessageResolver"] = $script:PackageManagementUnInstallScriptMessageResolverScriptBlock
        $PSBoundParameters[$script:PSArtifactType] = $script:PSArtifactTypeScript
        if($AllowPrerelease) {
            $PSBoundParameters[$script:AllowPrereleaseVersions] = $true
        }
        $null = $PSBoundParameters.Remove("AllowPrerelease")

        if($PSCmdlet.ParameterSetName -eq "InputObject")
        {
            $null = $PSBoundParameters.Remove("InputObject")

            foreach($inputValue in $InputObject)
            {
                if (($inputValue.PSTypeNames -notcontains "Microsoft.PowerShell.Commands.PSRepositoryItemInfo") -and
                    ($inputValue.PSTypeNames -notcontains "Deserialized.Microsoft.PowerShell.Commands.PSRepositoryItemInfo"))
                {
                    ThrowError -ExceptionName "System.ArgumentException" `
                                -ExceptionMessage $LocalizedData.InvalidInputObjectValue `
                                -ErrorId "InvalidInputObjectValue" `
                                -CallerPSCmdlet $PSCmdlet `
                                -ErrorCategory InvalidArgument `
                                -ExceptionObject $inputValue
                }

                $PSBoundParameters["Name"] = $inputValue.Name
                $PSBoundParameters["RequiredVersion"] = $inputValue.Version
                if (($inputValue.AdditionalMetadata) -and
                    (Get-Member -InputObject $inputValue.AdditionalMetadata -Name "IsPrerelease") -and
                    ($inputValue.AdditionalMetadata.IsPrerelease -eq "true")) {
                    $PSBoundParameters[$script:AllowPrereleaseVersions] = $true
                }
                elseif ($PSBoundParameters.ContainsKey($script:AllowPrereleaseVersions)) {
                    $null = $PSBoundParameters.Remove($script:AllowPrereleaseVersions)
                }

                $null = PackageManagement\Uninstall-Package @PSBoundParameters
            }
        }
        else
        {
            $ValidationResult = Validate-VersionParameters -CallerPSCmdlet $PSCmdlet `
                                                           -Name $Name `
                                                           -TestWildcardsInName `
                                                           -MinimumVersion $MinimumVersion `
                                                           -MaximumVersion $MaximumVersion `
                                                           -RequiredVersion $RequiredVersion `
                                                           -AllowPrerelease:$AllowPrerelease

            if(-not $ValidationResult)
            {
                # Validate-VersionParameters throws the error.
                # returning to avoid further execution when different values are specified for -ErrorAction parameter
                return
            }

            $null = PackageManagement\Uninstall-Package @PSBoundParameters
        }
    }
}
function Unregister-PSRepository {
    <#
    .ExternalHelp PSModule-help.xml
    #>
    [CmdletBinding(HelpUri = 'https://go.microsoft.com/fwlink/?LinkID=517130')]
    Param
    (
        [Parameter(ValueFromPipelineByPropertyName = $true,
            Mandatory = $true)]
        [ValidateNotNullOrEmpty()]
        [string[]]
        $Name
    )

    Begin {
    }

    Process {
        $PSBoundParameters["Provider"] = $script:PSModuleProviderName
        $PSBoundParameters["MessageResolver"] = $script:PackageManagementMessageResolverScriptBlock

        $null = $PSBoundParameters.Remove("Name")

        foreach ($moduleSourceName in $Name) {
            # Check if $moduleSourceName contains any wildcards
            if (Test-WildcardPattern $moduleSourceName) {
                $message = $LocalizedData.RepositoryNameContainsWildCards -f ($moduleSourceName)
                Write-Error -Message $message -ErrorId "RepositoryNameContainsWildCards" -Category InvalidOperation
                continue
            }

            $PSBoundParameters["Source"] = $moduleSourceName

            $null = PackageManagement\Unregister-PackageSource @PSBoundParameters

            $nugetCmd = Microsoft.PowerShell.Core\Get-Command -Name $script:NuGetExeName `
                -ErrorAction SilentlyContinue -WarningAction SilentlyContinue

            if ($nugetCmd){
                # remove nuget based repo as a nuget source
                $nugetSourceExists = nuget source list | where-object { $_.Contains($Name) }
                if ($nugetSourceExists) {
                    nuget sources remove -name $Name
                }
            }
        }
    }
}
function Update-Module {
    <#
    .ExternalHelp PSModule-help.xml
    #>
    [CmdletBinding(SupportsShouldProcess = $true,
        HelpUri = 'https://go.microsoft.com/fwlink/?LinkID=398576')]
    Param
    (
        [Parameter(ValueFromPipelineByPropertyName = $true,
            Position = 0)]
        [ValidateNotNullOrEmpty()]
        [String[]]
        $Name,

        [Parameter(ValueFromPipelineByPropertyName = $true)]
        [ValidateNotNull()]
        [string]
        $RequiredVersion,

        [Parameter(ValueFromPipelineByPropertyName = $true)]
        [ValidateNotNull()]
        [string]
        $MaximumVersion,

        [Parameter(ValueFromPipelineByPropertyName = $true)]
        [PSCredential]
        $Credential,

        [Parameter()]
        [ValidateSet("CurrentUser", "AllUsers")]
        [string]
        $Scope,

        [Parameter(ValueFromPipelineByPropertyName = $true)]
        [ValidateNotNullOrEmpty()]
        [Uri]
        $Proxy,

        [Parameter(ValueFromPipelineByPropertyName = $true)]
        [PSCredential]
        $ProxyCredential,

        [Parameter()]
        [Switch]
        $Force,

        [Parameter()]
        [Switch]
        $AllowPrerelease,

        [Parameter()]
        [switch]
        $AcceptLicense,

        [Parameter()]
        [switch]
        $PassThru
    )

    Begin {
        # Change security protocol to TLS 1.2
        $script:securityProtocol = [Net.ServicePointManager]::SecurityProtocol
        [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12

        Install-NuGetClientBinaries -CallerPSCmdlet $PSCmdlet -Proxy $Proxy -ProxyCredential $ProxyCredential

        if ($Scope -eq "AllUsers" -and -not (Test-RunningAsElevated)) {
            # Throw an error when Update-Module is used as a non-admin user and '-Scope AllUsers'
            $message = $LocalizedData.UpdateModuleAdminPrivilegeRequiredForAllUsersScope -f @($script:programFilesModulesPath, $script:MyDocumentsModulesPath)

            ThrowError -ExceptionName "System.ArgumentException" `
                -ExceptionMessage $message `
                -ErrorId "UpdateModuleAdminPrivilegeRequiredForAllUsersScope" `
                -CallerPSCmdlet $PSCmdlet `
                -ErrorCategory InvalidArgument
        }

        # Module names already tried in the current pipeline
        $moduleNamesInPipeline = @()
    }

    Process {
        $ValidationResult = Validate-VersionParameters -CallerPSCmdlet $PSCmdlet `
            -Name $Name `
            -MaximumVersion $MaximumVersion `
            -RequiredVersion $RequiredVersion `
            -AllowPrerelease:$AllowPrerelease

        if (-not $ValidationResult) {
            # Validate-VersionParameters throws the error.
            # returning to avoid further execution when different values are specified for -ErrorAction parameter
            return
        }

        $GetPackageParameters = @{ }
        $GetPackageParameters[$script:PSArtifactType] = $script:PSArtifactTypeModule
        $GetPackageParameters["Provider"] = $script:PSModuleProviderName
        $GetPackageParameters["MessageResolver"] = $script:PackageManagementMessageResolverScriptBlock
        $GetPackageParameters['ErrorAction'] = 'SilentlyContinue'
        $GetPackageParameters['WarningAction'] = 'SilentlyContinue'
        if ($AllowPrerelease) {
            $PSBoundParameters[$script:AllowPrereleaseVersions] = $true
        }
        $null = $PSBoundParameters.Remove("AllowPrerelease")
        $null = $PSBoundParameters.Remove("PassThru")

        $PSGetItemInfos = @()

        if (-not $Name) {
            $Name = @('*')
        }

        foreach ($moduleName in $Name) {
            $GetPackageParameters['Name'] = $moduleName
            $installedPackages = PackageManagement\Get-Package @GetPackageParameters

            if (-not $installedPackages -and -not (Test-WildcardPattern -Name $moduleName)) {
                $availableModules = Get-Module -ListAvailable $moduleName -Verbose:$false | Microsoft.PowerShell.Utility\Select-Object -Unique -ErrorAction Ignore

                if (-not $availableModules) {
                    $message = $LocalizedData.ModuleNotInstalledOnThisMachine -f ($moduleName)
                    Write-Error -Message $message -ErrorId 'ModuleNotInstalledOnThisMachine' -Category InvalidOperation -TargetObject $moduleName
                }
                else {
                    $message = $LocalizedData.ModuleNotInstalledUsingPowerShellGet -f ($moduleName)
                    Write-Error -Message $message -ErrorId 'ModuleNotInstalledUsingInstallModuleCmdlet' -Category InvalidOperation -TargetObject $moduleName
                }

                continue
            }

            $installedPackages |
            Microsoft.PowerShell.Core\ForEach-Object { New-PSGetItemInfo -SoftwareIdentity $_ -Type $script:PSArtifactTypeModule } |
            Microsoft.PowerShell.Core\ForEach-Object { $PSGetItemInfos += $_ }
        }

        $PSBoundParameters["Provider"] = $script:PSModuleProviderName
        $PSBoundParameters[$script:PSArtifactType] = $script:PSArtifactTypeModule

        foreach ($psgetItemInfo in $PSGetItemInfos) {
            # Skip the module name if it is already tried in the current pipeline
            if ($moduleNamesInPipeline -contains $psgetItemInfo.Name) {
                continue
            }

            $moduleNamesInPipeline += $psgetItemInfo.Name

            $message = $LocalizedData.CheckingForModuleUpdate -f ($psgetItemInfo.Name)
            Write-Verbose -Message $message

            $providerName = Get-ProviderName -PSCustomObject $psgetItemInfo
            if (-not $providerName) {
                $providerName = $script:NuGetProviderName
            }

            $PSBoundParameters["MessageResolver"] = $script:PackageManagementUpdateModuleMessageResolverScriptBlock
            $PSBoundParameters["Name"] = $psgetItemInfo.Name
            $PSBoundParameters['Source'] = $psgetItemInfo.Repository

            $PSBoundParameters["PackageManagementProvider"] = $providerName
            $PSBoundParameters["InstallUpdate"] = $true

            if (-not $Scope) {
                $Scope = Get-InstallationScope -PreviousInstallLocation $psgetItemInfo.InstalledLocation -CurrentUserPath $script:MyDocumentsModulesPath
            }

            $PSBoundParameters["Scope"] = $Scope

            $sid = PackageManagement\Install-Package @PSBoundParameters

            if ($PassThru) {
                $sid | Microsoft.PowerShell.Core\ForEach-Object { New-PSGetItemInfo -SoftwareIdentity $_ -Type $script:PSArtifactTypeModule }
            }
        }
    }

    End {
        # Change back to user specified security protocol
        [Net.ServicePointManager]::SecurityProtocol = $script:securityProtocol
    }
}
function Update-ModuleManifest
{
    <#
    .ExternalHelp PSModule-help.xml
    #>
    [CmdletBinding(SupportsShouldProcess=$true,
                   PositionalBinding=$false,
                   HelpUri='https://go.microsoft.com/fwlink/?LinkId=619311')]
    Param
    (
        [Parameter(Mandatory=$true,
                   Position=0,
                   ValueFromPipelineByPropertyName=$true)]
        [ValidateNotNullOrEmpty()]
        [string]
        $Path,

        [ValidateNotNullOrEmpty()]
        [Object[]]
        $NestedModules,

        [ValidateNotNullOrEmpty()]
        [Guid]
        $Guid,

        [Parameter()]
        [ValidateNotNullOrEmpty()]
        [string]
        $Author,

        [Parameter()]
        [ValidateNotNullOrEmpty()]
        [String]
        $CompanyName,

        [Parameter()]
        [ValidateNotNullOrEmpty()]
        [string]
        $Copyright,

        [Parameter()]
        [ValidateNotNullOrEmpty()]
        [string]
        $RootModule,

        [Parameter()]
        [ValidateNotNullOrEmpty()]
        [Version]
        $ModuleVersion,

        [Parameter()]
        [ValidateNotNullOrEmpty()]
        [string]
        $Description,

        [Parameter()]
        [ValidateNotNullOrEmpty()]
        [System.Reflection.ProcessorArchitecture]
        $ProcessorArchitecture,

        [Parameter()]
        [ValidateSet('Desktop','Core')]
        [string[]]
        $CompatiblePSEditions,

        [Parameter()]
        [ValidateNotNullOrEmpty()]
        [Version]
        $PowerShellVersion,

        [Parameter()]
        [ValidateNotNullOrEmpty()]
        [Version]
        $ClrVersion,

        [Parameter()]
        [ValidateNotNullOrEmpty()]
        [Version]
        $DotNetFrameworkVersion,

        [Parameter()]
        [ValidateNotNullOrEmpty()]
        [String]
        $PowerShellHostName,

        [Parameter()]
        [ValidateNotNullOrEmpty()]
        [Version]
        $PowerShellHostVersion,

        [Parameter()]
        [ValidateNotNullOrEmpty()]
        [Object[]]
        $RequiredModules,

        [Parameter()]
        [ValidateNotNullOrEmpty()]
        [string[]]
        $TypesToProcess,

        [Parameter()]
        [ValidateNotNullOrEmpty()]
        [string[]]
        $FormatsToProcess,

        [Parameter()]
        [ValidateNotNullOrEmpty()]
        [string[]]
        $ScriptsToProcess,

        [Parameter()]
        [ValidateNotNullOrEmpty()]
        [string[]]
        $RequiredAssemblies,

        [Parameter()]
        [ValidateNotNullOrEmpty()]
        [string[]]
        $FileList,

        [Parameter()]
        [ValidateNotNullOrEmpty()]
        [object[]]
        $ModuleList,

        [Parameter()]
        [string[]]
        $FunctionsToExport,

        [Parameter()]
        [string[]]
        $AliasesToExport,

        [Parameter()]
        [ValidateNotNullOrEmpty()]
        [string[]]
        $VariablesToExport,

        [Parameter()]
        [string[]]
        $CmdletsToExport,

        [Parameter()]
        [ValidateNotNullOrEmpty()]
        [string[]]
        $DscResourcesToExport,

        [Parameter()]
        [ValidateNotNullOrEmpty()]
        [System.Collections.Hashtable]
        $PrivateData,

        [Parameter()]
        [ValidateNotNullOrEmpty()]
        [string[]]
        $Tags,

        [Parameter()]
        [ValidateNotNullOrEmpty()]
        [Uri]
        $ProjectUri,

        [Parameter()]
        [ValidateNotNullOrEmpty()]
        [Uri]
        $LicenseUri,

        [Parameter()]
        [ValidateNotNullOrEmpty()]
        [Uri]
        $IconUri,

        [Parameter()]
        [string[]]
        $ReleaseNotes,

        [Parameter()]
        [string]
        $Prerelease,

        [Parameter()]
        [ValidateNotNullOrEmpty()]
        [Uri]
        $HelpInfoUri,

        [Parameter()]
        [switch]
        $PassThru,

        [Parameter()]
        [ValidateNotNullOrEmpty()]
        [String]
        $DefaultCommandPrefix,

        [Parameter()]
        [ValidateNotNullOrEmpty()]
        [String[]]
        $ExternalModuleDependencies,

        [Parameter()]
        [ValidateNotNullOrEmpty()]
        [String[]]
        $PackageManagementProviders,

        [Parameter()]
        [switch]
        $RequireLicenseAcceptance


    )

    if(-not (Microsoft.PowerShell.Management\Test-Path -Path $Path -PathType Leaf))
    {
        $message = $LocalizedData.UpdateModuleManifestPathCannotFound -f ($Path)
        ThrowError -ExceptionName "System.ArgumentException" `
                   -ExceptionMessage $message `
                   -ErrorId "InvalidModuleManifestFilePath" `
                   -ExceptionObject $Path `
                   -CallerPSCmdlet $PSCmdlet `
                   -ErrorCategory InvalidArgument
    }

    $ModuleManifestHashTable = $null

    try
    {
        $ModuleManifestHashTable = Get-ManifestHashTable -Path $Path -CallerPSCmdlet $PSCmdlet
    }
    catch
    {
        $message = $LocalizedData.TestModuleManifestFail -f ($_.Exception.Message)
        ThrowError -ExceptionName "System.ArgumentException" `
                    -ExceptionMessage $message `
                    -ErrorId "InvalidModuleManifestFile" `
                    -ExceptionObject $Path `
                    -CallerPSCmdlet $PSCmdlet `
                    -ErrorCategory InvalidArgument
        return
    }

    #Get the original module manifest and migrate all the fields to the new module manifest, including the specified parameter values
    $moduleInfo = $null

    try
    {
        $moduleInfo = Microsoft.PowerShell.Core\Test-ModuleManifest -Path $Path -ErrorAction Stop
    }
    catch
    {
        # Throw an error only if Test-ModuleManifest did not return the PSModuleInfo object.
        # This enables the users to use Update-ModuleManifest cmdlet to update the metadata.
        if(-not $moduleInfo)
        {
            $message = $LocalizedData.TestModuleManifestFail -f ($_.Exception.Message)
            ThrowError -ExceptionName "System.ArgumentException" `
                       -ExceptionMessage $message `
                       -ErrorId "InvalidModuleManifestFile" `
                       -ExceptionObject $Path `
                       -CallerPSCmdlet $PSCmdlet `
                       -ErrorCategory InvalidArgument
            return
        }
    }

    #Params to pass to New-ModuleManifest module
    $params = @{}

    #NestedModules is read-only property
    if($NestedModules)
    {
        $params.Add("NestedModules",$NestedModules)
    }
    elseif($ModuleManifestHashTable -and $ModuleManifestHashTable.ContainsKey("NestedModules"))
    {
        $params.Add("NestedModules",$ModuleManifestHashtable.NestedModules)
    }

    #Guid is read-only property
    if($Guid)
    {
        $params.Add("Guid",$Guid)
    }
    elseif($moduleInfo.Guid)
    {
        $params.Add("Guid",$moduleInfo.Guid)
    }

    if($Author)
    {
        $params.Add("Author",$Author)
    }
    elseif($moduleInfo.Author)
    {
        $params.Add("Author",$moduleInfo.Author)
    }

    if($CompanyName)
    {
        $params.Add("CompanyName",$CompanyName)
    }
    elseif($moduleInfo.CompanyName)
    {
        $params.Add("CompanyName",$moduleInfo.CompanyName)
    } 
    else  
    {
        #Creating a unique disposable company name to later be replaced by ''
        #Work-around to deal with New-ModuleManifest changing '' to 'Unknown'
        $params.Add("CompanyName", '__UPDATEDCOMPANYNAMETOBEREPLACEDINFUNCTION__')
    }

    if($Copyright)
    {
        $params.Add("CopyRight",$Copyright)
    }
    elseif($moduleInfo.Copyright)
    {
        $params.Add("Copyright",$moduleInfo.Copyright)
    }

    if($RootModule)
    {
        $params.Add("RootModule",$RootModule)
    }
    elseif($ModuleManifestHashTable -and $ModuleManifestHashTable.ContainsKey("RootModule") -and $moduleInfo.RootModule)
    {
        $params.Add("RootModule",$ModuleManifestHashTable.RootModule)
    }

    if($ModuleVersion)
    {
        $params.Add("ModuleVersion",$ModuleVersion)
    }
    elseif($moduleInfo.Version)
    {
        $params.Add("ModuleVersion",$moduleInfo.Version)
    }

    if($Description)
    {
        $params.Add("Description",$Description)
    }
    elseif($moduleInfo.Description)
    {
        $params.Add("Description",$moduleInfo.Description)
    }

    if($ProcessorArchitecture)
    {
        $params.Add("ProcessorArchitecture",$ProcessorArchitecture)
    }
    #Check if ProcessorArchitecture has a value and is not 'None' on lower version PS
    elseif($moduleInfo.ProcessorArchitecture -and $moduleInfo.ProcessorArchitecture -ne 'None')
    {
        $params.Add("ProcessorArchitecture",$moduleInfo.ProcessorArchitecture)
    }

    if($PowerShellVersion)
    {
        $params.Add("PowerShellVersion",$PowerShellVersion)
    }
    elseif($moduleinfo.PowerShellVersion)
    {
        $params.Add("PowerShellVersion",$moduleinfo.PowerShellVersion)
    }

    if($ClrVersion)
    {
        $params.Add("ClrVersion",$ClrVersion)
    }
    elseif($moduleInfo.ClrVersion)
    {
        $params.Add("ClrVersion",$moduleInfo.ClrVersion)
    }

    if($DotNetFrameworkVersion)
    {
        $params.Add("DotNetFrameworkVersion",$DotNetFrameworkVersion)
    }
    elseif($moduleInfo.DotNetFrameworkVersion)
    {
        $params.Add("DotNetFrameworkVersion",$moduleInfo.DotNetFrameworkVersion)
    }

    if($PowerShellHostName)
    {
        $params.Add("PowerShellHostName",$PowerShellHostName)
    }
    elseif($moduleInfo.PowerShellHostName)
    {
        $params.Add("PowerShellHostName",$moduleInfo.PowerShellHostName)
    }

    if($PowerShellHostVersion)
    {
        $params.Add("PowerShellHostVersion",$PowerShellHostVersion)
    }
    elseif($moduleInfo.PowerShellHostVersion)
    {
        $params.Add("PowerShellHostVersion",$moduleInfo.PowerShellHostVersion)
    }

    if($RequiredModules)
    {
        $params.Add("RequiredModules",$RequiredModules)
    }
    elseif($ModuleManifestHashTable -and $ModuleManifestHashTable.ContainsKey("RequiredModules") -and $moduleInfo.RequiredModules)
    {
        $params.Add("RequiredModules",$ModuleManifestHashtable.RequiredModules)
    }

    if($TypesToProcess)
    {
        $params.Add("TypesToProcess",$TypesToProcess)
    }
    elseif($ModuleManifestHashTable -and $ModuleManifestHashTable.ContainsKey("TypesToProcess") -and $moduleInfo.ExportedTypeFiles)
    {
        $params.Add("TypesToProcess",$ModuleManifestHashTable.TypesToProcess)
    }

    if($FormatsToProcess)
    {
        $params.Add("FormatsToProcess",$FormatsToProcess)
    }
    elseif($ModuleManifestHashTable -and $ModuleManifestHashTable.ContainsKey("FormatsToProcess") -and $moduleInfo.ExportedFormatFiles)
    {
        $params.Add("FormatsToProcess",$ModuleManifestHashTable.FormatsToProcess)
    }

    if($ScriptsToProcess)
    {
        $params.Add("ScriptsToProcess",$ScriptstoProcess)
    }
    elseif($ModuleManifestHashTable -and $ModuleManifestHashTable.ContainsKey("ScriptsToProcess") -and $moduleInfo.Scripts)
    {
        $params.Add("ScriptsToProcess",$ModuleManifestHashTable.ScriptsToProcess)
    }

    if($RequiredAssemblies)
    {
        $params.Add("RequiredAssemblies",$RequiredAssemblies)
    }
    elseif($ModuleManifestHashTable -and $ModuleManifestHashTable.ContainsKey("RequiredAssemblies") -and $moduleInfo.RequiredAssemblies)
    {
        $params.Add("RequiredAssemblies",$moduleInfo.RequiredAssemblies)
    }

    if($FileList)
    {
        $params.Add("FileList",$FileList)
    }
    elseif($ModuleManifestHashTable -and $ModuleManifestHashTable.ContainsKey("FileList") -and $moduleInfo.FileList)
    {
        $params.Add("FileList",$ModuleManifestHashTable.FileList)
    }

    #Make sure every path defined under FileList is within module base
    $moduleBase = $moduleInfo.ModuleBase
    foreach($file in $params["FileList"])
    {
        #If path is not root path, append the module base to it and check if the file exists
        if(-not [System.IO.Path]::IsPathRooted($file))
        {
            $combinedPath = Join-Path $moduleBase -ChildPath $file
        }
        else
        {
            $combinedPath = $file
        }
        if(-not (Microsoft.PowerShell.Management\Test-Path -Type Leaf -LiteralPath $combinedPath))
        {
            $message = $LocalizedData.FilePathInFileListNotWithinModuleBase -f ($file,$moduleBase)
            ThrowError -ExceptionName "System.ArgumentException" `
               -ExceptionMessage $message `
               -ErrorId "FilePathInFileListNotWithinModuleBase" `
               -ExceptionObject $file `
               -CallerPSCmdlet $PSCmdlet `
               -ErrorCategory InvalidArgument

            return
        }
    }

    if($ModuleList)
    {
        $params.Add("ModuleList",$ModuleList)
    }
    elseif($ModuleManifestHashTable -and $ModuleManifestHashTable.ContainsKey("ModuleList") -and $moduleInfo.ModuleList)
    {
        $params.Add("ModuleList",$ModuleManifestHashtable.ModuleList)
    }

    if($FunctionsToExport -or $FunctionsToExport -is [array])
    {
        $params.Add("FunctionsToExport",$FunctionsToExport)
    }
    elseif($moduleInfo.ExportedFunctions)
    {
        #Get the original module info from ManifestHashTable
        if($ModuleManifestHashTable -and $ModuleManifestHashTable.ContainsKey("FunctionsToExport") -and $ModuleManifestHashTable['FunctionsToExport'] -eq '*' `
            -and $moduleInfo.ExportedFunctions.Keys.Count -eq 0)
        {
            $params.Add("FunctionsToExport", $ModuleManifestHashTable['FunctionsToExport'])
        }
        elseif($moduleInfo.Prefix)
        {
            #Earlier call to Test-ModuleManifest adds prefix to functions, now those prefixes need to be remove
            #Prefixes are affixed to the beginning of function, or after '-'
            $originalFunctions = $moduleInfo.ExportedFunctions.Keys | 
                foreach-object { $parts = $_ -split '-', 2; $parts[-1] = $parts[-1] -replace "^$($moduleInfo.Prefix)"; $parts -join '-' }
            $params.Add("FunctionsToExport", $originalFunctions)
        }
        else 
        {
            $params.Add("FunctionsToExport",($moduleInfo.ExportedFunctions.Keys -split ' '))
        }
    }
    elseif ($ModuleManifestHashTable -and $ModuleManifestHashTable.ContainsKey("FunctionsToExport"))
    {
        $params.Add("FunctionsToExport", $ModuleManifestHashTable['FunctionsToExport'])
    }

    if($AliasesToExport -or $AliasesToExport -is [array])
    {
        $params.Add("AliasesToExport",$AliasesToExport)
    }
    elseif($moduleInfo.ExportedAliases)
    {
        #Get the original module info from ManifestHashTable
        if($ModuleManifestHashTable -and $ModuleManifestHashTable.ContainsKey("AliasesToExport") -and $ModuleManifestHashTable['AliasesToExport'] -eq '*' `
            -and $moduleInfo.ExportedAliases.Keys.Count -eq 0)
        {
            $params.Add("AliasesToExport", $ModuleManifestHashTable['AliasesToExport'])
        }
        elseif($moduleInfo.Prefix)
        {
            #Earlier call to Test-ModuleManifest adds prefix to aliases, now those prefixes need to be removed
            #Prefixes are affixed to the beginning of function, or after '-'
            $originalAliases = $moduleInfo.ExportedAliases.Keys | 
                ForEach-Object { $parts = $_ -split '-', 2; $parts[-1] = $parts[-1] -replace "^$($moduleInfo.Prefix)"; $parts -join '-' }
            $params.Add("AliasesToExport", $originalAliases)   
        }
        else 
        {
            $params.Add("AliasesToExport",($moduleInfo.ExportedAliases.Keys -split ' '))
        }
    }
    elseif ($ModuleManifestHashTable -and $ModuleManifestHashTable.ContainsKey("AliasesToExport"))
    {
        $params.Add("AliasesToExport", $ModuleManifestHashTable['AliasesToExport'])
    }

    if($VariablesToExport)
    {
        $params.Add("VariablesToExport",$VariablesToExport)
    }
    elseif($moduleInfo.ExportedVariables)
    {
         #Get the original module info from ManifestHashTable
        if($ModuleManifestHashTable -and $ModuleManifestHashTable.ContainsKey("VariablesToExport") -and $ModuleManifestHashTable['VariablesToExport'] -eq '*' `
            -and $moduleInfo.ExportedVariables.Keys.Count -eq 0)
        {
            $params.Add("VariablesToExport", $ModuleManifestHashTable['VariablesToExport'])
        }
        else {
            #Since $moduleInfo.ExportedAliases is a hashtable, we need to take the name of the
            #variables and make them into a list
            $params.Add("VariablesToExport",($moduleInfo.ExportedVariables.Keys -split ' '))
        }
    }

    if($CmdletsToExport -or $CmdletsToExport -is [array])
    {
        $params.Add("CmdletsToExport", $CmdletsToExport)
    }
    elseif($moduleInfo.ExportedCmdlets)
    {
        #Get the original module info from ManifestHashTable
        if($ModuleManifestHashTable -and $ModuleManifestHashTable.ContainsKey("CmdletsToExport") -and $ModuleManifestHashTable['CmdletsToExport'] -eq '*' `
          -and $moduleInfo.ExportedCmdlets.Count -eq 0)
        {
            $params.Add("CmdletsToExport", $ModuleManifestHashTable['CmdletsToExport'])
        }
        elseif($moduleInfo.Prefix)
        {
            #Earlier call to Test-ModuleManifest adds prefix to cmdlets, now those prefixes need to be removed
            #Prefixes are affixed to the beginning of function, or after '-'
            $originalCmdlets = $moduleInfo.ExportedCmdlets.Keys | 
                ForEach-Object { $parts = $_ -split '-', 2; $parts[-1] = $parts[-1] -replace "^$($moduleInfo.Prefix)"; $parts -join '-' }
            $params.Add("CmdletsToExport", $originalCmdlets)
        }
        else
        {
            $params.Add("CmdletsToExport",($moduleInfo.ExportedCmdlets.Keys -split ' '))
        }
    }
    elseif ($ModuleManifestHashTable -and $ModuleManifestHashTable.ContainsKey("CmdletsToExport"))
    {
        $params.Add("CmdletsToExport", $ModuleManifestHashTable['CmdletsToExport'])
    }

    if($DscResourcesToExport)
    {
        #DscResourcesToExport field is not available in PowerShell version lower than 5.0

        if  (($PSVersionTable.PSVersion -lt '5.0.0') -or ($PowerShellVersion -and $PowerShellVersion -lt '5.0') `
             -or (-not $PowerShellVersion -and $moduleInfo.PowerShellVersion -and $moduleInfo.PowerShellVersion -lt '5.0') `
             -or (-not $PowerShellVersion -and -not $moduleInfo.PowerShellVersion))
        {
                ThrowError -ExceptionName "System.ArgumentException" `
                   -ExceptionMessage $LocalizedData.ExportedDscResourcesNotSupportedOnLowerPowerShellVersion `
                   -ErrorId "ExportedDscResourcesNotSupported" `
                   -ExceptionObject $DscResourcesToExport `
                   -CallerPSCmdlet $PSCmdlet `
                   -ErrorCategory InvalidArgument
                return
        }

        $params.Add("DscResourcesToExport",$DscResourcesToExport)
    }
    elseif(Microsoft.PowerShell.Utility\Get-Member -InputObject $moduleInfo -name "ExportedDscResources")
    {
        if($ModuleManifestHashTable -and $ModuleManifestHashTable.ContainsKey("DscResourcesToExport") -and $ModuleManifestHashTable['DscResourcesToExport'] -eq '*' `
                -and $moduleInfo.ExportedDscResources.Count -eq 0)
        {
            $params.Add("DscResourcesToExport", $ModuleManifestHashTable['DscResourcesToExport']) 
        }
        else 
        {
            $params.Add("DscResourcesToExport", $moduleInfo.ExportedDscResources)
        }
    }

    if($CompatiblePSEditions)
    {
        # CompatiblePSEditions field is not available in PowerShell version lower than 5.1
        #
        if  (($PSVersionTable.PSVersion -lt '5.1.0') -or ($PowerShellVersion -and $PowerShellVersion -lt '5.1') `
             -or (-not $PowerShellVersion -and $moduleInfo.PowerShellVersion -and $moduleInfo.PowerShellVersion -lt '5.1') `
             -or (-not $PowerShellVersion -and -not $moduleInfo.PowerShellVersion))
        {
                ThrowError -ExceptionName 'System.ArgumentException' `
                           -ExceptionMessage $LocalizedData.CompatiblePSEditionsNotSupportedOnLowerPowerShellVersion `
                           -ErrorId 'CompatiblePSEditionsNotSupported' `
                           -ExceptionObject $CompatiblePSEditions `
                           -CallerPSCmdlet $PSCmdlet `
                           -ErrorCategory InvalidArgument
                return
        }

        $params.Add('CompatiblePSEditions', $CompatiblePSEditions)
    }
    elseif( (Microsoft.PowerShell.Utility\Get-Member -InputObject $moduleInfo -name 'CompatiblePSEditions') -and
            $moduleInfo.CompatiblePSEditions)
    {
        $params.Add('CompatiblePSEditions', $moduleInfo.CompatiblePSEditions)
    }

    if($HelpInfoUri)
    {
        $params.Add("HelpInfoUri",$HelpInfoUri)
    }
    elseif($moduleInfo.HelpInfoUri)
    {
        $params.Add("HelpInfoUri",$moduleInfo.HelpInfoUri)
    }

    if($DefaultCommandPrefix)
    {
        $params.Add("DefaultCommandPrefix",$DefaultCommandPrefix)
    }
    elseif($ModuleManifestHashTable -and $ModuleManifestHashTable.ContainsKey("DefaultCommandPrefix") -and $ModuleManifestHashTable.DefaultCommandPrefix)
    {
        $params.Add("DefaultCommandPrefix",$ModuleManifestHashTable.DefaultCommandPrefix)
    }

    #Create a temp file within the directory and generate a new temporary manifest with the input
    $tempPath = Microsoft.PowerShell.Management\Join-Path -Path $moduleInfo.ModuleBase -ChildPath "PSGet_$($moduleInfo.Name).psd1"
    $params.Add("Path",$tempPath)

    try
    {
        #Terminates if there is error creating new module manifest
        try{
            Microsoft.PowerShell.Core\New-ModuleManifest @params -Confirm:$false -WhatIf:$false
            #If company name is the disposable name created for the new module manifest, it will be changed back to ''
            (Get-Content -Path $tempPath) | ForEach-Object {$_ -Replace '__UPDATEDCOMPANYNAMETOBEREPLACEDINFUNCTION__', ''} | Set-Content -Path $tempPath -Confirm:$false -WhatIf:$false
        }
        catch
        {
            $ErrorMessage = $LocalizedData.UpdatedModuleManifestNotValid -f ($Path, $_.Exception.Message)
            ThrowError -ExceptionName "System.ArgumentException" `
                       -ExceptionMessage $ErrorMessage `
                       -ErrorId "NewModuleManifestFailure" `
                       -ExceptionObject $params `
                       -CallerPSCmdlet $PSCmdlet `
                       -ErrorCategory InvalidArgument
            return
        }

        #Manually update the section in PrivateData since New-ModuleManifest works differently on different PS version
        $PrivateDataInput = ""
        $ExistingData = $moduleInfo.PrivateData
        $Data = @{}
        if($ExistingData)
        {
            foreach($key in $ExistingData.Keys)
            {
                if($key -ne "PSData"){
                    $Data.Add($key,$ExistingData[$key])
                }
                else
                {
                    $PSData = $ExistingData["PSData"]
                    foreach($entry in $PSData.Keys)
                    {
                        $Data.Add($entry,$PSData[$Entry])
                    }
                }
            }
        }

        if($PrivateData)
        {
            foreach($key in $PrivateData.Keys)
            {
                #if user provides PSData within PrivateData, we will parse through the PSData
                if($key -ne "PSData")
                {
                    $Data[$key] = $PrivateData[$Key]
                }

                else
                {
                    $PSData = $ExistingData["PSData"]
                    foreach($entry in $PSData.Keys)
                    {
                        $Data[$entry] = $PSData[$entry]
                    }
                }
            }
        }

        #Tags is a read-only property
        if($Tags)
        {
           $Data["Tags"] = $Tags
        }

        #The following Uris and ReleaseNotes cannot be empty
        if($ProjectUri)
        {
            $Data["ProjectUri"] = $ProjectUri
        }

        if($LicenseUri)
        {
            $Data["LicenseUri"] = $LicenseUri
        }

        if($IconUri)
        {
            $Data["IconUri"] = $IconUri
        }
        if($RequireLicenseAcceptance)
        {
            $Data["RequireLicenseAcceptance"] = $RequireLicenseAcceptance
        }

        if($ReleaseNotes)
        {
            #If value is provided as an array, we append the string.
            $Data["ReleaseNotes"] = $($ReleaseNotes -join "`r`n")
        }

        if ($Prerelease)
        {
            $result = ValidateAndGet-VersionPrereleaseStrings -Version $params["ModuleVersion"] -Prerelease $Prerelease -CallerPSCmdlet $PSCmdlet
            if (-not $result)
            {
                # ValidateAndGet-VersionPrereleaseStrings throws the error.
                # returning to avoid further execution when different values are specified for -ErrorAction parameter
                return
            }
            $validatedPrerelease = $result["Prerelease"]
            $Data[$script:Prerelease] = $validatedPrerelease
        }

        if($ExternalModuleDependencies)
        {
            #ExternalModuleDependencies have to be specified either under $RequiredModules or $NestedModules
            #Extract all the module names specified in the moduleInfo of NestedModules and RequiredModules
            $DependentModuleNames = @()
            foreach($moduleInfo in $params["NestedModules"])
            {
                if($moduleInfo.GetType() -eq [System.Collections.Hashtable])
                {
                    $DependentModuleNames += $moduleInfo.ModuleName
                }
            }

            foreach($moduleInfo in $params["RequiredModules"])
            {
                if($moduleInfo.GetType() -eq [System.Collections.Hashtable])
                {
                    $DependentModuleNames += $moduleInfo.ModuleName
                }
            }

            foreach($dependency in $ExternalModuleDependencies)
            {
                if($params["NestedModules"] -notcontains $dependency -and
                $params["RequiredModules"] -notContains $dependency -and
                $DependentModuleNames -notcontains $dependency)
                {
                    $message = $LocalizedData.ExternalModuleDependenciesNotSpecifiedInRequiredOrNestedModules -f ($dependency)
                    ThrowError -ExceptionName "System.ArgumentException" `
                        -ExceptionMessage $message `
                        -ErrorId "InvalidExternalModuleDependencies" `
                        -ExceptionObject $Exception `
                        -CallerPSCmdlet $PSCmdlet `
                        -ErrorCategory InvalidArgument
                        return
                    }
            }
            if($Data.ContainsKey("ExternalModuleDependencies"))
            {
                $Data["ExternalModuleDependencies"] = $ExternalModuleDependencies
            }
            else
            {
                $Data.Add("ExternalModuleDependencies", $ExternalModuleDependencies)
            }
        }
        if($PackageManagementProviders)
        {
            #Check if the provided value is within the relative path
            $ModuleBase = Microsoft.PowerShell.Management\Split-Path $Path -Parent
            $Files = Microsoft.PowerShell.Management\Get-ChildItem -Path $ModuleBase
            foreach($provider in $PackageManagementProviders)
            {
                if ($Files.Name -notcontains $provider)
                {
                    $message = $LocalizedData.PackageManagementProvidersNotInModuleBaseFolder -f ($provider,$ModuleBase)
                    ThrowError -ExceptionName "System.ArgumentException" `
                               -ExceptionMessage $message `
                               -ErrorId "InvalidPackageManagementProviders" `
                               -ExceptionObject $PackageManagementProviders `
                               -CallerPSCmdlet $PSCmdlet `
                               -ErrorCategory InvalidArgument
                    return
                }
            }

            $Data["PackageManagementProviders"] = $PackageManagementProviders
        }
        $PrivateDataInput = Get-PrivateData -PrivateData $Data

        #Replace the PrivateData section by first locating the linenumbers of start line and endline.
        $PrivateDataBegin = Select-String -Path $tempPath -Pattern "PrivateData ="
        $PrivateDataBeginLine = $PrivateDataBegin.LineNumber

        $newManifest = Microsoft.PowerShell.Management\Get-Content -Path $tempPath
        #Look up the endline of PrivateData section by finding the matching brackets since private data could
        #consist of multiple pairs of brackets.
        $PrivateDataEndLine=0
        if($PrivateDataBegin -match "@{")
        {
            $leftBrace = 0
            $EndLineOfFile = $newManifest.Length-1

            For($i = $PrivateDataBeginLine;$i -lt $EndLineOfFile; $i++)
            {
                if($newManifest[$i] -match "{")
                {
                    $leftBrace ++
                }
                elseif($newManifest[$i] -match "}")
                {
                    if($leftBrace -gt 0)
                    {
                        $leftBrace --
                    }
                    else
                    {
                       $PrivateDataEndLine = $i
                       break
                    }
                }
            }
        }


        try
        {
            if($PrivateDataEndLine -ne 0)
            {
                #If PrivateData section has more than one line, we will remove the old content and insert the new PrivataData
                $newManifest  | where {$_.readcount -le $PrivateDataBeginLine -or $_.readcount -gt $PrivateDataEndLine+1} `
                | ForEach-Object {
                    $_
                    if($_ -match "PrivateData = ")
                    {
                        $PrivateDataInput
                    }
                  } | Set-Content -Path $tempPath -Confirm:$false -WhatIf:$false
            }

            #In lower version, PrivateData is just a single line
            else
            {
                $PrivateDataForDownlevelPS = "PrivateData = @{ `n"+$PrivateDataInput

                $newManifest  | where {$_.readcount -le $PrivateDataBeginLine -or $_.readcount -gt $PrivateDataBeginLine } `
                | ForEach-Object {
                    $_
                    if($_ -match "PrivateData = ")
                    {
                       $PrivateDataForDownlevelPS
                    }
                } | Set-Content -Path $tempPath -Confirm:$false -WhatIf:$false
            }

            #Verify the new module manifest is valid
            $testModuleInfo = Microsoft.PowerShell.Core\Test-ModuleManifest -Path $tempPath `
                                                                        -Verbose:$VerbosePreference ` -ErrorAction Stop
        }
        #Catch the exceptions from Test-ModuleManifest
        catch
        {
            $message = $LocalizedData.UpdatedModuleManifestNotValid -f ($Path, $_.Exception.Message)

            ThrowError -ExceptionName "System.ArgumentException" `
                       -ExceptionMessage $message `
                       -ErrorId "UpdateManifestFileFail" `
                       -ExceptionObject $_.Exception `
                       -CallerPSCmdlet $PSCmdlet `
                       -ErrorCategory InvalidArgument
            return
        }


        $newContent = Microsoft.PowerShell.Management\Get-Content -Path $tempPath

        #Remove the PSGet_ prepended to the original manifest name due to the temp file name
        $newContent[1] = $newContent[1] -replace "'PSGet_", "'"

        try
        {
            #Ask for confirmation of the new manifest before replacing the original one
            if($PSCmdlet.ShouldProcess($Path,$LocalizedData.UpdateManifestContentMessage+$newContent))
            {
                Microsoft.PowerShell.Management\Set-Content -Path $Path -Value $newContent -Confirm:$false -WhatIf:$false
            }

            #Return the new content if -PassThru is specified
            if($PassThru)
            {
                return $newContent
            }
        }
        catch
        {
            $message = $LocalizedData.ManifestFileReadWritePermissionDenied -f ($Path)
            ThrowError -ExceptionName "System.ArgumentException" `
                        -ExceptionMessage $message `
                        -ErrorId "ManifestFileReadWritePermissionDenied" `
                        -ExceptionObject $Path `
                        -CallerPSCmdlet $PSCmdlet `
                        -ErrorCategory InvalidArgument
        }
    }
    finally
    {
        Microsoft.PowerShell.Management\Remove-Item -LiteralPath $tempPath -Force -ErrorAction SilentlyContinue -WarningAction SilentlyContinue -Confirm:$false -WhatIf:$false
    }
}
function Update-Script {
    <#
    .ExternalHelp PSModule-help.xml
    #>
    [CmdletBinding(SupportsShouldProcess = $true,
        HelpUri = 'https://go.microsoft.com/fwlink/?LinkId=619787')]
    Param
    (
        [Parameter(ValueFromPipelineByPropertyName = $true,
            Position = 0)]
        [ValidateNotNullOrEmpty()]
        [String[]]
        $Name,

        [Parameter(ValueFromPipelineByPropertyName = $true)]
        [ValidateNotNull()]
        [string]
        $RequiredVersion,

        [Parameter(ValueFromPipelineByPropertyName = $true)]
        [ValidateNotNull()]
        [string]
        $MaximumVersion,

        [Parameter(ValueFromPipelineByPropertyName = $true)]
        [ValidateNotNullOrEmpty()]
        [Uri]
        $Proxy,

        [Parameter(ValueFromPipelineByPropertyName = $true)]
        [PSCredential]
        $ProxyCredential,

        [Parameter(ValueFromPipelineByPropertyName = $true)]
        [PSCredential]
        $Credential,

        [Parameter()]
        [Switch]
        $Force,

        [Parameter()]
        [Switch]
        $AllowPrerelease,

        [Parameter()]
        [switch]
        $AcceptLicense,

        [Parameter()]
        [switch]
        $PassThru
    )

    Begin {
        # Change security protocol to TLS 1.2
        $script:securityProtocol = [Net.ServicePointManager]::SecurityProtocol
        [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12

        Install-NuGetClientBinaries -CallerPSCmdlet $PSCmdlet -Proxy $Proxy -ProxyCredential $ProxyCredential

        # Script names already tried in the current pipeline
        $scriptNamesInPipeline = @()
    }

    Process {
        $scriptFilePathsToUpdate = @()

        $ValidationResult = Validate-VersionParameters -CallerPSCmdlet $PSCmdlet `
            -Name $Name `
            -MaximumVersion $MaximumVersion `
            -RequiredVersion $RequiredVersion `
            -AllowPrerelease:$AllowPrerelease

        if (-not $ValidationResult) {
            # Validate-VersionParameters throws the error.
            # returning to avoid further execution when different values are specified for -ErrorAction parameter
            return
        }

        if (-not $Name) {
            $Name = @('*')
        }

        if ($Name) {
            foreach ($scriptName in $Name) {
                $availableScriptPaths = Get-AvailableScriptFilePath -Name $scriptName -Verbose:$false

                if (-not $availableScriptPaths -and -not (Test-WildcardPattern -Name $scriptName)) {
                    $message = $LocalizedData.ScriptNotInstalledOnThisMachine -f ($scriptName, $script:MyDocumentsScriptsPath, $script:ProgramFilesScriptsPath)
                    Write-Error -Message $message -ErrorId "ScriptNotInstalledOnThisMachine" -Category InvalidOperation -TargetObject $scriptName
                    continue
                }

                foreach ($scriptFilePath in $availableScriptPaths) {
                    # Check if this script got installed with PowerShellGet
                    $installedScriptFilePath = Get-InstalledScriptFilePath -Name ([System.IO.Path]::GetFileNameWithoutExtension($scriptFilePath)) |
                    Microsoft.PowerShell.Core\Where-Object { $_ -eq $scriptFilePath }

                    if ($installedScriptFilePath) {
                        $scriptFilePathsToUpdate += $installedScriptFilePath
                    }
                    else {
                        if (-not (Test-WildcardPattern -Name $scriptName)) {
                            $message = $LocalizedData.ScriptNotInstalledUsingPowerShellGet -f ($scriptName)
                            Write-Error -Message $message -ErrorId "ScriptNotInstalledUsingPowerShellGet" -Category InvalidOperation -TargetObject $scriptName
                        }
                        continue
                    }
                }
            }
        }

        $PSBoundParameters["Provider"] = $script:PSModuleProviderName
        $PSBoundParameters[$script:PSArtifactType] = $script:PSArtifactTypeScript
        $PSBoundParameters["InstallUpdate"] = $true

        foreach ($scriptFilePath in $scriptFilePathsToUpdate) {
            $scriptName = [System.IO.Path]::GetFileNameWithoutExtension($scriptFilePath)

            $installedScriptInfoFilePath = $null
            $installedScriptInfoFileName = "$($scriptName)_$script:InstalledScriptInfoFileName"

            if ($scriptFilePath.ToString().StartsWith($script:MyDocumentsScriptsPath, [System.StringComparison]::OrdinalIgnoreCase)) {
                $installedScriptInfoFilePath = Microsoft.PowerShell.Management\Join-Path -Path $script:MyDocumentsInstalledScriptInfosPath `
                    -ChildPath $installedScriptInfoFileName
            }
            elseif ($scriptFilePath.ToString().StartsWith($script:ProgramFilesScriptsPath, [System.StringComparison]::OrdinalIgnoreCase)) {
                $installedScriptInfoFilePath = Microsoft.PowerShell.Management\Join-Path -Path $script:ProgramFilesInstalledScriptInfosPath `
                    -ChildPath $installedScriptInfoFileName

            }

            $psgetItemInfo = $null
            if ($installedScriptInfoFilePath -and (Microsoft.PowerShell.Management\Test-Path -Path $installedScriptInfoFilePath -PathType Leaf)) {
                $psgetItemInfo = DeSerialize-PSObject -Path $installedScriptInfoFilePath
            }

            # Skip the script name if it is already tried in the current pipeline
            if (-not $psgetItemInfo -or ($scriptNamesInPipeline -contains $psgetItemInfo.Name)) {
                continue
            }


            $scriptFilePath = Microsoft.PowerShell.Management\Join-Path -Path $psgetItemInfo.InstalledLocation `
                -ChildPath "$($psgetItemInfo.Name).ps1"

            # Remove the InstalledScriptInfo.xml file if the actual script file was manually uninstalled by the user
            if (-not (Microsoft.PowerShell.Management\Test-Path -Path $scriptFilePath -PathType Leaf)) {
                Microsoft.PowerShell.Management\Remove-Item -Path $installedScriptInfoFilePath -Force -ErrorAction SilentlyContinue

                continue
            }

            $scriptNamesInPipeline += $psgetItemInfo.Name

            $message = $LocalizedData.CheckingForScriptUpdate -f ($psgetItemInfo.Name)
            Write-Verbose -Message $message

            $providerName = Get-ProviderName -PSCustomObject $psgetItemInfo
            if (-not $providerName) {
                $providerName = $script:NuGetProviderName
            }

            $PSBoundParameters["MessageResolver"] = $script:PackageManagementUpdateScriptMessageResolverScriptBlock
            $PSBoundParameters["PackageManagementProvider"] = $providerName
            $PSBoundParameters["Name"] = $psgetItemInfo.Name
            $PSBoundParameters['Source'] = $psgetItemInfo.Repository
            if ($AllowPrerelease) {
                $PSBoundParameters[$script:AllowPrereleaseVersions] = $true
            }
            $null = $PSBoundParameters.Remove("AllowPrerelease")
            $null = $PSBoundParameters.Remove("PassThru")

            $PSBoundParameters["Scope"] = Get-InstallationScope -PreviousInstallLocation $scriptFilePath -CurrentUserPath $script:MyDocumentsScriptsPath
            $sid = PackageManagement\Install-Package @PSBoundParameters

            if ($PassThru) {
                $sid | Microsoft.PowerShell.Core\ForEach-Object { New-PSGetItemInfo -SoftwareIdentity $_ -Type $script:PSArtifactTypeScript }
            }
        }
    }

    End {
        # Change back to user specified security protocol
        [Net.ServicePointManager]::SecurityProtocol = $script:securityProtocol
    }
}
function Update-ScriptFileInfo {
    <#
    .ExternalHelp PSModule-help.xml
    #>
    [CmdletBinding(PositionalBinding = $false,
        DefaultParameterSetName = 'PathParameterSet',
        SupportsShouldProcess = $true,
        HelpUri = 'https://go.microsoft.com/fwlink/?LinkId=619793')]
    Param
    (
        [Parameter(Mandatory = $true,
            Position = 0,
            ParameterSetName = 'PathParameterSet',
            ValueFromPipelineByPropertyName = $true)]
        [ValidateNotNullOrEmpty()]
        [string]
        $Path,

        [Parameter(Mandatory = $true,
            Position = 0,
            ParameterSetName = 'LiteralPathParameterSet',
            ValueFromPipelineByPropertyName = $true)]
        [Alias('PSPath')]
        [ValidateNotNullOrEmpty()]
        [string]
        $LiteralPath,

        [Parameter()]
        [ValidateNotNullOrEmpty()]
        [string]
        $Version,

        [Parameter()]
        [ValidateNotNullOrEmpty()]
        [string]
        $Author,

        [Parameter()]
        [ValidateNotNullOrEmpty()]
        [Guid]
        $Guid,

        [Parameter()]
        [ValidateNotNullOrEmpty()]
        [string]
        $Description,

        [Parameter()]
        [ValidateNotNullOrEmpty()]
        [string]
        $CompanyName,

        [Parameter()]
        [ValidateNotNullOrEmpty()]
        [string]
        $Copyright,

        [Parameter()]
        [ValidateNotNullOrEmpty()]
        [Object[]]
        $RequiredModules,

        [Parameter()]
        [ValidateNotNullOrEmpty()]
        [String[]]
        $ExternalModuleDependencies,

        [Parameter()]
        [ValidateNotNullOrEmpty()]
        [string[]]
        $RequiredScripts,

        [Parameter()]
        [ValidateNotNullOrEmpty()]
        [String[]]
        $ExternalScriptDependencies,

        [Parameter()]
        [ValidateNotNullOrEmpty()]
        [string[]]
        $Tags,

        [Parameter()]
        [ValidateNotNullOrEmpty()]
        [Uri]
        $ProjectUri,

        [Parameter()]
        [ValidateNotNullOrEmpty()]
        [Uri]
        $LicenseUri,

        [Parameter()]
        [ValidateNotNullOrEmpty()]
        [Uri]
        $IconUri,

        [Parameter()]
        [string[]]
        $ReleaseNotes,

        [Parameter()]
        [ValidateNotNullOrEmpty()]
        [string]
        $PrivateData,

        [Parameter()]
        [switch]
        $PassThru,

        [Parameter()]
        [switch]
        $Force
    )

    Process {
        # Resolve the script path
        $scriptFilePath = $null
        if ($Path) {
            $scriptFilePath = Resolve-PathHelper -Path $Path -CallerPSCmdlet $PSCmdlet |
            Microsoft.PowerShell.Utility\Select-Object -First 1 -ErrorAction Ignore

            if (-not $scriptFilePath -or
                -not (Microsoft.PowerShell.Management\Test-Path -Path $scriptFilePath -PathType Leaf)) {
                $errorMessage = ($LocalizedData.PathNotFound -f $Path)
                ThrowError  -ExceptionName "System.ArgumentException" `
                    -ExceptionMessage $errorMessage `
                    -ErrorId "PathNotFound" `
                    -CallerPSCmdlet $PSCmdlet `
                    -ExceptionObject $Path `
                    -ErrorCategory InvalidArgument
            }
        }
        else {
            $scriptFilePath = Resolve-PathHelper -Path $LiteralPath -IsLiteralPath -CallerPSCmdlet $PSCmdlet |
            Microsoft.PowerShell.Utility\Select-Object -First 1 -ErrorAction Ignore

            if (-not $scriptFilePath -or
                -not (Microsoft.PowerShell.Management\Test-Path -LiteralPath $scriptFilePath -PathType Leaf)) {
                $errorMessage = ($LocalizedData.PathNotFound -f $LiteralPath)
                ThrowError  -ExceptionName "System.ArgumentException" `
                    -ExceptionMessage $errorMessage `
                    -ErrorId "PathNotFound" `
                    -CallerPSCmdlet $PSCmdlet `
                    -ExceptionObject $LiteralPath `
                    -ErrorCategory InvalidArgument
            }
        }

        if (-not $scriptFilePath.EndsWith('.ps1', [System.StringComparison]::OrdinalIgnoreCase)) {
            $errorMessage = ($LocalizedData.InvalidScriptFilePath -f $scriptFilePath)
            ThrowError  -ExceptionName "System.ArgumentException" `
                -ExceptionMessage $errorMessage `
                -ErrorId "InvalidScriptFilePath" `
                -CallerPSCmdlet $PSCmdlet `
                -ExceptionObject $scriptFilePath `
                -ErrorCategory InvalidArgument
            return
        }

        # Obtain script info
        $psscriptInfo = $null
        try {
            $psscriptInfo = Test-ScriptFileInfo -LiteralPath $scriptFilePath
        }
        catch {
            if (-not $Force) {
                throw $_
                return
            }
        }

        if (-not $psscriptInfo) {
            if (-not $Description) {
                ThrowError  -ExceptionName "System.ArgumentException" `
                    -ExceptionMessage $LocalizedData.DescriptionParameterIsMissingForAddingTheScriptFileInfo `
                    -ErrorId 'DescriptionParameterIsMissingForAddingTheScriptFileInfo' `
                    -CallerPSCmdlet $PSCmdlet `
                    -ErrorCategory InvalidArgument
                return
            }

            if (-not $Version) {
                $Version = '1.0'
            }
            else {
                $result = ValidateAndGet-VersionPrereleaseStrings -Version $Version -CallerPSCmdlet $PSCmdlet
                if (-not $result) {
                    # ValidateAndGet-VersionPrereleaseStrings throws the error.
                    # returning to avoid further execution when different values are specified for -ErrorAction parameter
                    return
                }
            }

            if (-not $Author) {
                if ($script:IsWindows) {
                    $Author = (Get-EnvironmentVariable -Name 'USERNAME' -Target $script:EnvironmentVariableTarget.Process -ErrorAction SilentlyContinue)
                }
                else {
                    $Author = $env:USER
                }
            }

            if (-not $Guid) {
                $Guid = [System.Guid]::NewGuid()
            }
        }
        else {
            # Use existing values if any of the parameters are not specified during Update-ScriptFileInfo
            if (-not $Version -and $psscriptInfo.Version) {
                $Version = $psscriptInfo.Version
            }

            if (-not $Guid -and $psscriptInfo.Guid) {
                $Guid = $psscriptInfo.Guid
            }

            if (-not $Author -and $psscriptInfo.Author) {
                $Author = $psscriptInfo.Author
            }

            if (-not $CompanyName -and $psscriptInfo.CompanyName) {
                $CompanyName = $psscriptInfo.CompanyName
            }

            if (-not $Copyright -and $psscriptInfo.Copyright) {
                $Copyright = $psscriptInfo.Copyright
            }

            if (-not $RequiredModules -and $psscriptInfo.RequiredModules) {
                $RequiredModules = $psscriptInfo.RequiredModules
            }

            if (-not $ExternalModuleDependencies -and $psscriptInfo.ExternalModuleDependencies) {
                $ExternalModuleDependencies = $psscriptInfo.ExternalModuleDependencies
            }

            if (-not $RequiredScripts -and $psscriptInfo.RequiredScripts) {
                $RequiredScripts = $psscriptInfo.RequiredScripts
            }

            if (-not $ExternalScriptDependencies -and $psscriptInfo.ExternalScriptDependencies) {
                $ExternalScriptDependencies = $psscriptInfo.ExternalScriptDependencies
            }

            if (-not $Tags -and $psscriptInfo.Tags) {
                $Tags = $psscriptInfo.Tags
            }

            if (-not $ProjectUri -and $psscriptInfo.ProjectUri) {
                $ProjectUri = $psscriptInfo.ProjectUri
            }

            if (-not $LicenseUri -and $psscriptInfo.LicenseUri) {
                $LicenseUri = $psscriptInfo.LicenseUri
            }

            if (-not $IconUri -and $psscriptInfo.IconUri) {
                $IconUri = $psscriptInfo.IconUri
            }

            if (-not $ReleaseNotes -and $psscriptInfo.ReleaseNotes) {
                $ReleaseNotes = $psscriptInfo.ReleaseNotes
            }

            if (-not $PrivateData -and $psscriptInfo.PrivateData) {
                $PrivateData = $psscriptInfo.PrivateData
            }
        }

        $params = @{
            Version                    = $Version
            Author                     = $Author
            Guid                       = $Guid
            CompanyName                = $CompanyName
            Copyright                  = $Copyright
            ExternalModuleDependencies = $ExternalModuleDependencies
            RequiredScripts            = $RequiredScripts
            ExternalScriptDependencies = $ExternalScriptDependencies
            Tags                       = $Tags
            ProjectUri                 = $ProjectUri
            LicenseUri                 = $LicenseUri
            IconUri                    = $IconUri
            ReleaseNotes               = $ReleaseNotes
            PrivateData                = $PrivateData
        }

        # Ensure no fields contain '<#' or '#>' (would break comment section)
        if (-not (Validate-ScriptFileInfoParameters -parameters $params)) {
            return
        }

        if ("$Description" -match '<#' -or "$Description" -match '#>') {
            $message = $LocalizedData.InvalidParameterValue -f ($Description, 'Description')
            Write-Error -Message $message -ErrorId 'InvalidParameterValue' -Category InvalidArgument

            return
        }

        $PSScriptInfoString = Get-PSScriptInfoString @params

        $requiresStrings = Get-RequiresString -RequiredModules $RequiredModules

        $DescriptionValue = if ($Description) { $Description } else { $psscriptInfo.Description }
        $ScriptCommentHelpInfoString = Get-ScriptCommentHelpInfoString -Description $DescriptionValue

        $ScriptMetadataString = $PSScriptInfoString
        $ScriptMetadataString += "`r`n"

        if ("$requiresStrings".Trim()) {
            $ScriptMetadataString += "`r`n"
            $ScriptMetadataString += $requiresStrings -join "`r`n"
            $ScriptMetadataString += "`r`n"
        }

        $ScriptMetadataString += "`r`n"
        $ScriptMetadataString += $ScriptCommentHelpInfoString
        $ScriptMetadataString += "`r`nParam()`r`n`r`n"

        $tempScriptFilePath = Microsoft.PowerShell.Management\Join-Path -Path $script:TempPath -ChildPath "$(Get-Random).ps1"

        try {
            # First create a new script file with new script metadata to ensure that updated values are valid.
            Microsoft.PowerShell.Management\Set-Content -Value $ScriptMetadataString -Path $tempScriptFilePath -Force -WhatIf:$false -Confirm:$false

            $scriptInfo = Test-ScriptFileInfo -Path $tempScriptFilePath

            if (-not $scriptInfo) {
                # Above Test-ScriptFileInfo cmdlet writes the error
                return
            }

            $scriptFileContents = Microsoft.PowerShell.Management\Get-Content -LiteralPath $scriptFilePath

            # If -Force is specified and script file doesnt have a valid PSScriptInfo
            # Prepend the PSScriptInfo and Check if the Test-ScriptFileInfo returns a valid script info without any errors
            if ($Force -and -not $psscriptInfo) {
                # Add the script file contents to the temp file with script metadata
                Microsoft.PowerShell.Management\Set-Content -LiteralPath $tempScriptFilePath `
                    -Value $ScriptMetadataString, $scriptFileContents `
                    -Force `
                    -WhatIf:$false `
                    -Confirm:$false

                $tempScriptInfo = $null
                try {
                    $tempScriptInfo = Test-ScriptFileInfo -LiteralPath $tempScriptFilePath
                }
                catch {
                    $errorMessage = ($LocalizedData.UnableToAddPSScriptInfo -f $scriptFilePath)
                    ThrowError  -ExceptionName 'System.InvalidOperationException' `
                        -ExceptionMessage $errorMessage `
                        -ErrorId 'UnableToAddPSScriptInfo' `
                        -CallerPSCmdlet $PSCmdlet `
                        -ExceptionObject $scriptFilePath `
                        -ErrorCategory InvalidOperation
                    return
                }
            }
            else {
                [System.Management.Automation.Language.Token[]]$tokens = $null;
                [System.Management.Automation.Language.ParseError[]]$errors = $null;
                $ast = [System.Management.Automation.Language.Parser]::ParseFile($scriptFilePath, ([ref]$tokens), ([ref]$errors))

                # Update PSScriptInfo and #Requires
                $CommentTokens = $tokens | Microsoft.PowerShell.Core\Where-Object { $_.Kind -eq 'Comment' }

                $psscriptInfoComments = $CommentTokens |
                Microsoft.PowerShell.Core\Where-Object { $_.Extent.Text -match "<#PSScriptInfo" } |
                Microsoft.PowerShell.Utility\Select-Object -First 1 -ErrorAction Ignore

                if (-not $psscriptInfoComments) {
                    $errorMessage = ($LocalizedData.MissingPSScriptInfo -f $scriptFilePath)
                    ThrowError  -ExceptionName "System.ArgumentException" `
                        -ExceptionMessage $errorMessage `
                        -ErrorId "MissingPSScriptInfo" `
                        -CallerPSCmdlet $PSCmdlet `
                        -ExceptionObject $scriptFilePath `
                        -ErrorCategory InvalidArgument
                    return
                }

                # Ensure that metadata is replaced at the correct location and should not corrupt the existing script file.

                # Remove the lines between below lines and add the new PSScriptInfo and new #Requires statements
                # ($psscriptInfoComments.Extent.StartLineNumber - 1)
                # ($psscriptInfoComments.Extent.EndLineNumber - 1)
                $tempContents = @()
                $IsNewPScriptInfoAdded = $false

                for ($i = 0; $i -lt $scriptFileContents.Count; $i++) {
                    $line = $scriptFileContents[$i]
                    if (($i -ge ($psscriptInfoComments.Extent.StartLineNumber - 1)) -and
                        ($i -le ($psscriptInfoComments.Extent.EndLineNumber - 1))) {
                        if (-not $IsNewPScriptInfoAdded) {
                            $PSScriptInfoString = $PSScriptInfoString.TrimStart()
                            $requiresStrings = $requiresStrings.TrimEnd()

                            $tempContents += "$PSScriptInfoString `r`n`r`n$($requiresStrings -join "`r`n")"
                            $IsNewPScriptInfoAdded = $true
                        }
                    }
                    elseif ($line -notmatch "\s*#Requires\s+-Module") {
                        # Add the existing lines if they are not part of PSScriptInfo comment or not containing #Requires -Module statements.
                        $tempContents += $line
                    }
                }

                Microsoft.PowerShell.Management\Set-Content -Value $tempContents -Path $tempScriptFilePath -Force -WhatIf:$false -Confirm:$false

                $scriptInfo = Test-ScriptFileInfo -Path $tempScriptFilePath

                if (-not $scriptInfo) {
                    # Above Test-ScriptFileInfo cmdlet writes the error
                    return
                }

                # Now update the Description value if a new is specified.
                if ($Description) {
                    $tempContents = @()
                    $IsDescriptionAdded = $false

                    $IsDescriptionBeginFound = $false
                    $scriptFileContents = Microsoft.PowerShell.Management\Get-Content -Path $tempScriptFilePath

                    for ($i = 0; $i -lt $scriptFileContents.Count; $i++) {
                        $line = $scriptFileContents[$i]

                        if (-not $IsDescriptionAdded) {
                            if (-not $IsDescriptionBeginFound) {
                                if ($line.Trim().StartsWith(".DESCRIPTION", [System.StringComparison]::OrdinalIgnoreCase)) {
                                    $IsDescriptionBeginFound = $true
                                }
                                else {
                                    $tempContents += $line
                                }
                            }
                            else {
                                # Description begin has found
                                # Skip the old description lines until description end is found

                                if ($line.Trim().StartsWith("#>", [System.StringComparison]::OrdinalIgnoreCase) -or
                                    $line.Trim().StartsWith(".", [System.StringComparison]::OrdinalIgnoreCase)) {
                                    $tempContents += ".DESCRIPTION `r`n$($Description -join "`r`n")`r`n"
                                    $IsDescriptionAdded = $true
                                    $tempContents += $line
                                }
                            }
                        }
                        else {
                            $tempContents += $line
                        }
                    }

                    Microsoft.PowerShell.Management\Set-Content -Value $tempContents -Path $tempScriptFilePath -Force -WhatIf:$false -Confirm:$false

                    $scriptInfo = Test-ScriptFileInfo -Path $tempScriptFilePath

                    if (-not $scriptInfo) {
                        # Above Test-ScriptFileInfo cmdlet writes the error
                        return
                    }
                }
            }

            if ($Force -or $PSCmdlet.ShouldProcess($scriptFilePath, ($LocalizedData.UpdateScriptFileInfowhatIfMessage -f $Path) )) {
                Microsoft.PowerShell.Management\Copy-Item -Path $tempScriptFilePath -Destination $scriptFilePath -Force -WhatIf:$false -Confirm:$false

                if ($PassThru) {
                    $ScriptMetadataString
                }
            }
        }
        finally {
            Microsoft.PowerShell.Management\Remove-Item -Path $tempScriptFilePath -Force -WhatIf:$false -Confirm:$false -ErrorAction SilentlyContinue -WarningAction SilentlyContinue
        }
    }
}

function Add-PackageSource
{
    [CmdletBinding()]
    param
    (
        [string]
        $Name,

        [string]
        $Location,

        [bool]
        $Trusted
    )

    Write-Debug ($LocalizedData.ProviderApiDebugMessage -f ('Add-PackageSource'))

    if(-not $Name)
    {
        return
    }

    $Credential = $request.Credential

    $IsNewModuleSource = $false
    $Options = $request.Options

    foreach( $o in $Options.Keys )
    {
        Write-Debug ( "OPTION: {0} => {1}" -f ($o, $Options[$o]) )
    }

    $Proxy = $null
    if($Options.ContainsKey($script:Proxy))
    {
        $Proxy = $Options[$script:Proxy]

        if(-not (Test-WebUri -Uri $Proxy))
        {
            $message = $LocalizedData.InvalidWebUri -f ($Proxy, $script:Proxy)
            ThrowError -ExceptionName 'System.ArgumentException' `
                        -ExceptionMessage $message `
                        -ErrorId 'InvalidWebUri' `
                        -CallerPSCmdlet $PSCmdlet `
                        -ErrorCategory InvalidArgument `
                        -ExceptionObject $Proxy
        }
    }

    $ProxyCredential = $null
    if($Options.ContainsKey($script:ProxyCredential))
    {
        $ProxyCredential = $Options[$script:ProxyCredential]
    }

    Set-ModuleSourcesVariable -Force -Proxy $Proxy -ProxyCredential $ProxyCredential

    if($Options.ContainsKey('IsNewModuleSource'))
    {
        $IsNewModuleSource = $Options['IsNewModuleSource']

        if($IsNewModuleSource.GetType().ToString() -eq 'System.String')
        {
            if($IsNewModuleSource -eq 'false')
            {
                $IsNewModuleSource = $false
            }
            elseif($IsNewModuleSource -eq 'true')
            {
                $IsNewModuleSource = $true
            }
        }
    }

    $IsUpdatePackageSource = $false
    if($Options.ContainsKey('IsUpdatePackageSource'))
    {
        $IsUpdatePackageSource = $Options['IsUpdatePackageSource']

        if($IsUpdatePackageSource.GetType().ToString() -eq 'System.String')
        {
            if($IsUpdatePackageSource -eq 'false')
            {
                $IsUpdatePackageSource = $false
            }
            elseif($IsUpdatePackageSource -eq 'true')
            {
                $IsUpdatePackageSource = $true
            }
        }
    }

    $PublishLocation = $null
    if($Options.ContainsKey($script:PublishLocation))
    {
        if($Name -eq $Script:PSGalleryModuleSource)
        {
            $message = $LocalizedData.ParameterIsNotAllowedWithPSGallery -f ('PublishLocation')
            ThrowError -ExceptionName "System.ArgumentException" `
                       -ExceptionMessage $message `
                       -ErrorId 'ParameterIsNotAllowedWithPSGallery' `
                       -CallerPSCmdlet $PSCmdlet `
                       -ErrorCategory InvalidArgument `
                       -ExceptionObject $PublishLocation
        }

        $PublishLocation = $Options[$script:PublishLocation]

        if(-not (Microsoft.PowerShell.Management\Test-Path -LiteralPath $PublishLocation) -and
           -not (Test-WebUri -uri $PublishLocation))
        {
            $PublishLocationUri = [Uri]$PublishLocation
            if($PublishLocationUri.Scheme -eq 'file')
            {
                $message = $LocalizedData.PathNotFound -f ($PublishLocation)
                ThrowError -ExceptionName "System.ArgumentException" `
                           -ExceptionMessage $message `
                           -ErrorId "PathNotFound" `
                           -CallerPSCmdlet $PSCmdlet `
                           -ErrorCategory InvalidArgument `
                           -ExceptionObject $PublishLocation
            }
            else
            {
                $message = $LocalizedData.InvalidWebUri -f ($PublishLocation, "PublishLocation")
                ThrowError -ExceptionName "System.ArgumentException" `
                           -ExceptionMessage $message `
                           -ErrorId "InvalidWebUri" `
                           -CallerPSCmdlet $PSCmdlet `
                           -ErrorCategory InvalidArgument `
                           -ExceptionObject $PublishLocation
            }
        }
    }

    $ScriptSourceLocation = $null
    if($Options.ContainsKey($script:ScriptSourceLocation))
    {
        if($Name -eq $Script:PSGalleryModuleSource)
        {
            $message = $LocalizedData.ParameterIsNotAllowedWithPSGallery -f ('ScriptSourceLocation')
            ThrowError -ExceptionName "System.ArgumentException" `
                       -ExceptionMessage $message `
                       -ErrorId 'ParameterIsNotAllowedWithPSGallery' `
                       -CallerPSCmdlet $PSCmdlet `
                       -ErrorCategory InvalidArgument `
                       -ExceptionObject $ScriptSourceLocation
        }

        $ScriptSourceLocation = $Options[$script:ScriptSourceLocation]

        if(-not (Microsoft.PowerShell.Management\Test-Path -LiteralPath $ScriptSourceLocation) -and
           -not (Test-WebUri -uri $ScriptSourceLocation))
        {
            $ScriptSourceLocationUri = [Uri]$ScriptSourceLocation
            if($ScriptSourceLocationUri.Scheme -eq 'file')
            {
                $message = $LocalizedData.PathNotFound -f ($ScriptSourceLocation)
                ThrowError -ExceptionName "System.ArgumentException" `
                           -ExceptionMessage $message `
                           -ErrorId "PathNotFound" `
                           -CallerPSCmdlet $PSCmdlet `
                           -ErrorCategory InvalidArgument `
                           -ExceptionObject $ScriptSourceLocation
            }
            else
            {
                $message = $LocalizedData.InvalidWebUri -f ($ScriptSourceLocation, "ScriptSourceLocation")
                ThrowError -ExceptionName "System.ArgumentException" `
                           -ExceptionMessage $message `
                           -ErrorId "InvalidWebUri" `
                           -CallerPSCmdlet $PSCmdlet `
                           -ErrorCategory InvalidArgument `
                           -ExceptionObject $ScriptSourceLocation
            }
        }
    }

    $ScriptPublishLocation = $null
    if($Options.ContainsKey($script:ScriptPublishLocation))
    {
        if($Name -eq $Script:PSGalleryModuleSource)
        {
            $message = $LocalizedData.ParameterIsNotAllowedWithPSGallery -f ('ScriptPublishLocation')
            ThrowError -ExceptionName "System.ArgumentException" `
                       -ExceptionMessage $message `
                       -ErrorId 'ParameterIsNotAllowedWithPSGallery' `
                       -CallerPSCmdlet $PSCmdlet `
                       -ErrorCategory InvalidArgument `
                       -ExceptionObject $ScriptPublishLocation
        }

        $ScriptPublishLocation = $Options[$script:ScriptPublishLocation]

        if(-not (Microsoft.PowerShell.Management\Test-Path -LiteralPath $ScriptPublishLocation) -and
           -not (Test-WebUri -uri $ScriptPublishLocation))
        {
            $ScriptPublishLocationUri = [Uri]$ScriptPublishLocation
            if($ScriptPublishLocationUri.Scheme -eq 'file')
            {
                $message = $LocalizedData.PathNotFound -f ($ScriptPublishLocation)
                ThrowError -ExceptionName "System.ArgumentException" `
                           -ExceptionMessage $message `
                           -ErrorId "PathNotFound" `
                           -CallerPSCmdlet $PSCmdlet `
                           -ErrorCategory InvalidArgument `
                           -ExceptionObject $ScriptPublishLocation
            }
            else
            {
                $message = $LocalizedData.InvalidWebUri -f ($ScriptPublishLocation, "ScriptPublishLocation")
                ThrowError -ExceptionName "System.ArgumentException" `
                           -ExceptionMessage $message `
                           -ErrorId "InvalidWebUri" `
                           -CallerPSCmdlet $PSCmdlet `
                           -ErrorCategory InvalidArgument `
                           -ExceptionObject $ScriptPublishLocation
            }
        }
    }

    $currentSourceObject = $null

    # Check if Name is already registered
    if($script:PSGetModuleSources.Contains($Name))
    {
        $currentSourceObject = $script:PSGetModuleSources[$Name]
    }

    # Location is not allowed for PSGallery source
    # However OneGet passes Location value during Set-PackageSource cmdlet,
    # that's why ensuring that Location value is same as the current SourceLocation
    #
    if(($Name -eq $Script:PSGalleryModuleSource) -and
       $Location -and
       ((-not $IsUpdatePackageSource) -or ($currentSourceObject -and $currentSourceObject.SourceLocation -ne $Location)))
    {
        $message = $LocalizedData.ParameterIsNotAllowedWithPSGallery -f ('Location, NewLocation or SourceLocation')
        ThrowError -ExceptionName "System.ArgumentException" `
                   -ExceptionMessage $message `
                   -ErrorId 'ParameterIsNotAllowedWithPSGallery' `
                   -CallerPSCmdlet $PSCmdlet `
                   -ErrorCategory InvalidArgument `
                   -ExceptionObject $Location
    }

    if($Name -eq $Script:PSGalleryModuleSource)
    {
        # Add or update the PSGallery repository
        $repository = Set-PSGalleryRepository -Trusted:$Trusted

        if($repository)
        {
            # return the package source object.
            Write-Output -InputObject (New-PackageSourceFromModuleSource -ModuleSource $repository)
        }

        return
    }

    if($Location)
    {
        # Ping and resolve the specified location
        $Location = Resolve-Location -Location $Location `
                                     -LocationParameterName 'Location' `
                                     -Credential $Credential `
                                     -Proxy $Proxy `
                                     -ProxyCredential $ProxyCredential `
                                     -CallerPSCmdlet $PSCmdlet
    }

    if(-not $Location)
    {
        # Above Resolve-Location function throws an error when it is not able to resolve a location
        return
    }

    if(-not (Microsoft.PowerShell.Management\Test-Path -LiteralPath $Location) -and
       -not (Test-WebUri -uri $Location) )
    {
        $LocationUri = [Uri]$Location
        if($LocationUri.Scheme -eq 'file')
        {
            $message = $LocalizedData.PathNotFound -f ($Location)
            ThrowError -ExceptionName "System.ArgumentException" `
                       -ExceptionMessage $message `
                       -ErrorId "PathNotFound" `
                       -CallerPSCmdlet $PSCmdlet `
                       -ErrorCategory InvalidArgument `
                       -ExceptionObject $Location
        }
        else
        {
            $message = $LocalizedData.InvalidWebUri -f ($Location, "Location")
            ThrowError -ExceptionName "System.ArgumentException" `
                       -ExceptionMessage $message `
                       -ErrorId "InvalidWebUri" `
                       -CallerPSCmdlet $PSCmdlet `
                       -ErrorCategory InvalidArgument `
                       -ExceptionObject $Location
        }
    }

    if(Test-WildcardPattern $Name)
    {
        $message = $LocalizedData.RepositoryNameContainsWildCards -f ($Name)
        ThrowError -ExceptionName "System.ArgumentException" `
                    -ExceptionMessage $message `
                    -ErrorId "RepositoryNameContainsWildCards" `
                    -CallerPSCmdlet $PSCmdlet `
                    -ErrorCategory InvalidArgument `
                    -ExceptionObject $Name
    }

    $LocationString = Get-ValidModuleLocation -LocationString $Location -ParameterName "Location" -Proxy $Proxy -ProxyCredential $ProxyCredential -Credential $Credential

    # Check if Location is already registered with another Name
    $existingSourceName = Get-SourceName -Location $LocationString

    if($existingSourceName -and
       ($Name -ne $existingSourceName) -and
       -not $IsNewModuleSource)
    {
        $message = $LocalizedData.RepositoryAlreadyRegistered -f ($existingSourceName, $Location, $Name)
        ThrowError -ExceptionName "System.ArgumentException" `
                   -ExceptionMessage $message `
                   -ErrorId "RepositoryAlreadyRegistered" `
                   -CallerPSCmdlet $PSCmdlet `
                   -ErrorCategory InvalidArgument
    }

    if(-not $PublishLocation -and $currentSourceObject -and $currentSourceObject.PublishLocation)
    {
        $PublishLocation = $currentSourceObject.PublishLocation
    }

    if((-not $ScriptPublishLocation) -and
       $currentSourceObject -and
       (Get-Member -InputObject $currentSourceObject -Name $script:ScriptPublishLocation) -and
       $currentSourceObject.ScriptPublishLocation)
    {
        $ScriptPublishLocation = $currentSourceObject.ScriptPublishLocation
    }

    if((-not $ScriptSourceLocation) -and
       $currentSourceObject -and
       (Get-Member -InputObject $currentSourceObject -Name $script:ScriptSourceLocation) -and
       $currentSourceObject.ScriptSourceLocation)
    {
        $ScriptSourceLocation = $currentSourceObject.ScriptSourceLocation
    }

    $IsProviderSpecified = $false;
    if ($Options.ContainsKey($script:PackageManagementProviderParam))
    {
        $SpecifiedProviderName = $Options[$script:PackageManagementProviderParam]

        $IsProviderSpecified = $true

        Write-Verbose ($LocalizedData.SpecifiedProviderName -f $SpecifiedProviderName)
        if ($SpecifiedProviderName -eq $script:PSModuleProviderName)
        {
            $message = $LocalizedData.InvalidPackageManagementProviderValue -f ($SpecifiedProviderName, $script:NuGetProviderName, $script:NuGetProviderName)
            ThrowError -ExceptionName "System.ArgumentException" `
                        -ExceptionMessage $message `
                        -ErrorId "InvalidPackageManagementProviderValue" `
                        -CallerPSCmdlet $PSCmdlet `
                        -ErrorCategory InvalidArgument `
                        -ExceptionObject $SpecifiedProviderName
            return
        }
    }
    else
    {
        $SpecifiedProviderName = $script:NuGetProviderName
        Write-Verbose ($LocalizedData.ProviderNameNotSpecified -f $SpecifiedProviderName)
    }

    $packageSource = $null

    $selProviders = $request.SelectProvider($SpecifiedProviderName)

    if(-not $selProviders -and $IsProviderSpecified)
    {
        $message = $LocalizedData.SpecifiedProviderNotAvailable -f $SpecifiedProviderName
        ThrowError -ExceptionName "System.InvalidOperationException" `
                    -ExceptionMessage $message `
                    -ErrorId "SpecifiedProviderNotAvailable" `
                    -CallerPSCmdlet $PSCmdlet `
                    -ErrorCategory InvalidOperation `
                    -ExceptionObject $SpecifiedProviderName
    }

    # Try with user specified provider or NuGet provider
    foreach($SelectedProvider in $selProviders)
    {
        if($request.IsCanceled)
        {
            return
        }

        if($SelectedProvider -and $SelectedProvider.Features.ContainsKey($script:SupportsPSModulesFeatureName))
        {
            $NewRequest = $request.CloneRequest( $null, @($LocationString), $request.Credential )
            $packageSource = $SelectedProvider.ResolvePackageSources( $NewRequest )
        }
        else
        {
            $message = $LocalizedData.SpecifiedProviderDoesnotSupportPSModules -f $SelectedProvider.ProviderName
            ThrowError -ExceptionName "System.InvalidOperationException" `
                        -ExceptionMessage $message `
                        -ErrorId "SpecifiedProviderDoesnotSupportPSModules" `
                        -CallerPSCmdlet $PSCmdlet `
                        -ErrorCategory InvalidOperation `
                        -ExceptionObject $SelectedProvider.ProviderName
        }

        if($packageSource)
        {
            break
        }
    }

    # Poll other package provider when NuGet provider doesn't resolves the specified location
    if(-not $packageSource -and -not $IsProviderSpecified)
    {
        Write-Verbose ($LocalizedData.PollingPackageManagementProvidersForLocation -f $LocationString)

        $moduleProviders = $request.SelectProvidersWithFeature($script:SupportsPSModulesFeatureName)

        foreach($provider in $moduleProviders)
        {
            if($request.IsCanceled)
            {
                return
            }

            # Skip already tried $SpecifiedProviderName and PowerShellGet provider
            if($provider.ProviderName -eq $SpecifiedProviderName -or
               $provider.ProviderName -eq $script:PSModuleProviderName)
            {
                continue
            }

            Write-Verbose ($LocalizedData.PollingSingleProviderForLocation -f ($LocationString, $provider.ProviderName))
            $NewRequest = $request.CloneRequest( @{}, @($LocationString), $request.Credential )
            $packageSource = $provider.ResolvePackageSources($NewRequest)

            if($packageSource)
            {
                Write-Verbose ($LocalizedData.FoundProviderForLocation -f ($provider.ProviderName, $Location))
                $SelectedProvider = $provider
                break
            }
        }
    }

    if(-not $packageSource)
    {
        $message = $LocalizedData.SpecifiedLocationCannotBeRegistered -f $Location
        ThrowError -ExceptionName "System.InvalidOperationException" `
                    -ExceptionMessage $message `
                    -ErrorId "SpecifiedLocationCannotBeRegistered" `
                    -CallerPSCmdlet $PSCmdlet `
                    -ErrorCategory InvalidOperation `
                    -ExceptionObject $Location
    }

    $ProviderOptions = @{}

    $SelectedProvider.DynamicOptions | Microsoft.PowerShell.Core\ForEach-Object {
                                            if($options.ContainsKey($_.Name) )
                                            {
                                                $ProviderOptions[$_.Name] = $options[$_.Name]
                                            }
                                       }

    # Keep the existing provider options if not specified in Set-PSRepository
    if($currentSourceObject)
    {
        $currentSourceObject.ProviderOptions.GetEnumerator() | Microsoft.PowerShell.Core\ForEach-Object {
                                                                   if (-not $ProviderOptions.ContainsKey($_.Key) )
                                                                   {
                                                                       $ProviderOptions[$_.Key] = $_.Value
                                                                   }
                                                               }
    }

    if(-not $PublishLocation)
    {
        $PublishLocation = Get-PublishLocation -Location $LocationString
    }

    # Use the PublishLocation for the scripts when ScriptPublishLocation is not specified by the user
    if(-not $ScriptPublishLocation)
    {
        $ScriptPublishLocation = $PublishLocation

        # ScriptPublishLocation and PublishLocation should be equal in case of SMB Share or Local directory paths
        if($Options.ContainsKey($script:ScriptPublishLocation) -and
           (Microsoft.PowerShell.Management\Test-Path -LiteralPath $ScriptPublishLocation))
        {
            if($ScriptPublishLocation -ne $PublishLocation)
            {
                $message = $LocalizedData.PublishLocationPathsForModulesAndScriptsShouldBeEqual -f ($LocationString, $ScriptSourceLocation)
                ThrowError -ExceptionName "System.InvalidOperationException" `
                            -ExceptionMessage $message `
                            -ErrorId "PublishLocationPathsForModulesAndScriptsShouldBeEqual" `
                            -CallerPSCmdlet $PSCmdlet `
                            -ErrorCategory InvalidOperation `
                            -ExceptionObject $Location
            }
        }
    }

    if(-not $ScriptSourceLocation)
    {
        $ScriptSourceLocation = Get-ScriptSourceLocation -Location $LocationString -Proxy $Proxy -ProxyCredential $ProxyCredential -Credential $Credential
    }
    elseif($Options.ContainsKey($script:ScriptSourceLocation))
    {
        # ScriptSourceLocation and SourceLocation should be equal for SMB Share or Local directory paths
        if(Microsoft.PowerShell.Management\Test-Path -LiteralPath $ScriptSourceLocation)
        {
            if($ScriptSourceLocation -ne $LocationString)
            {
                $message = $LocalizedData.SourceLocationPathsForModulesAndScriptsShouldBeEqual -f ($LocationString, $ScriptSourceLocation)
                ThrowError -ExceptionName "System.InvalidOperationException" `
                            -ExceptionMessage $message `
                            -ErrorId "SourceLocationPathsForModulesAndScriptsShouldBeEqual" `
                            -CallerPSCmdlet $PSCmdlet `
                            -ErrorCategory InvalidOperation `
                            -ExceptionObject $Location
            }
        }
    }

    # no error so we can safely remove the source
    if($script:PSGetModuleSources.Contains($Name))
    {
        $null = $script:PSGetModuleSources.Remove($Name)
    }

    # Add new module source
    $moduleSource = Microsoft.PowerShell.Utility\New-Object PSCustomObject -Property ([ordered]@{
            Name = $Name
            SourceLocation = $LocationString
            PublishLocation = $PublishLocation
            ScriptSourceLocation = $ScriptSourceLocation
            ScriptPublishLocation = $ScriptPublishLocation
            Trusted=$Trusted
            Registered= (-not $IsNewModuleSource)
            InstallationPolicy = if($Trusted) {'Trusted'} else {'Untrusted'}
            PackageManagementProvider = $SelectedProvider.ProviderName
            ProviderOptions = $ProviderOptions
        })

    #region telemetry - Capture non-PSGallery registrations as telemetry events
    if ($script:TelemetryEnabled)
    {

        Log-NonPSGalleryRegistration -sourceLocation $moduleSource.SourceLocation `
                                     -installationPolicy $moduleSource.InstallationPolicy `
                                     -packageManagementProvider $moduleSource.PackageManagementProvider `
                                     -publishLocation $moduleSource.PublishLocation `
                                     -scriptSourceLocation $moduleSource.ScriptSourceLocation `
                                     -scriptPublishLocation $moduleSource.ScriptPublishLocation `
                                     -operationName PSGET_NONPSGALLERY_REGISTRATION `
                                     -ErrorAction SilentlyContinue `
                                     -WarningAction SilentlyContinue

    }
    #endregion

    $moduleSource.PSTypeNames.Insert(0, "Microsoft.PowerShell.Commands.PSRepository")

    # Persist the repositories only when Register-PSRepository cmdlet is used
    if(-not $IsNewModuleSource)
    {
        $script:PSGetModuleSources.Add($Name, $moduleSource)

        $message = $LocalizedData.RepositoryRegistered -f ($Name, $LocationString)
        Write-Verbose $message

        # Persist the module sources
        Save-ModuleSources
    }

    # return the package source object.
    Write-Output -InputObject (New-PackageSourceFromModuleSource -ModuleSource $moduleSource)
}
function Download-Package
{
    [CmdletBinding()]
    param
    (
        [Parameter(Mandatory=$true)]
        [ValidateNotNullOrEmpty()]
        [string]
        $FastPackageReference,

        [Parameter(Mandatory=$true)]
        [ValidateNotNullOrEmpty()]
        [string]
        $Location
    )

    Write-Debug ($LocalizedData.ProviderApiDebugMessage -f ('Download-Package'))

    Install-PackageUtility -FastPackageReference $FastPackageReference -Request $Request -Location $Location
}
function Find-Package
{
    [CmdletBinding()]
    param
    (
        [string[]]
        $names,

        [string]
        $requiredVersion,

        [string]
        $minimumVersion,

        [string]
        $maximumVersion
    )

    Write-Debug ($LocalizedData.ProviderApiDebugMessage -f ('Find-Package'))

    Set-ModuleSourcesVariable

    if($RequiredVersion -and $MinimumVersion)
    {
        ThrowError -ExceptionName "System.ArgumentException" `
                   -ExceptionMessage $LocalizedData.VersionRangeAndRequiredVersionCannotBeSpecifiedTogether `
                   -ErrorId "VersionRangeAndRequiredVersionCannotBeSpecifiedTogether" `
                   -CallerPSCmdlet $PSCmdlet `
                   -ErrorCategory InvalidArgument
    }

    if($RequiredVersion -or $MinimumVersion)
    {
        if(-not $names -or $names.Count -ne 1 -or (Test-WildcardPattern -Name $names[0]))
        {
            ThrowError -ExceptionName "System.ArgumentException" `
                       -ExceptionMessage $LocalizedData.VersionParametersAreAllowedOnlyWithSingleName `
                       -ErrorId "VersionParametersAreAllowedOnlyWithSingleName" `
                       -CallerPSCmdlet $PSCmdlet `
                       -ErrorCategory InvalidArgument
        }
    }

    $options = $request.Options

    foreach( $o in $options.Keys )
    {
        Write-Debug ( "OPTION: {0} => {1}" -f ($o, $options[$o]) )
    }

	# When using -Name, we don't send PSGet-specific properties to the server - we will filter it ourselves
	$postFilter = New-Object -TypeName  System.Collections.Hashtable
	if($options.ContainsKey("Name"))
	{
		if($options.ContainsKey("Includes"))
		{
			$postFilter["Includes"] = $options["Includes"]
			$null = $options.Remove("Includes")
		}

		if($options.ContainsKey("DscResource"))
		{
			$postFilter["DscResource"] = $options["DscResource"]
			$null = $options.Remove("DscResource")
		}

		if($options.ContainsKey('RoleCapability'))
		{
			$postFilter['RoleCapability'] = $options['RoleCapability']
			$null = $options.Remove('RoleCapability')
		}

		if($options.ContainsKey("Command"))
		{
			$postFilter["Command"] = $options["Command"]
			$null = $options.Remove("Command")
		}
	}

    $LocationOGPHashtable = [ordered]@{}
    if($options -and $options.ContainsKey('Source'))
    {
        $SourceNames = $($options['Source'])

        Write-Verbose ($LocalizedData.SpecifiedSourceName -f ($SourceNames))

        foreach($sourceName in $SourceNames)
        {
            if($script:PSGetModuleSources.Contains($sourceName))
            {
                $ModuleSource = $script:PSGetModuleSources[$sourceName]
                $LocationOGPHashtable[$ModuleSource.SourceLocation] = (Get-ProviderName -PSCustomObject $ModuleSource)
            }
            else
            {
                $sourceByLocation = Get-SourceName -Location $sourceName

                if ($sourceByLocation)
                {
                    $ModuleSource = $script:PSGetModuleSources[$sourceByLocation]
                    $LocationOGPHashtable[$ModuleSource.SourceLocation] = (Get-ProviderName -PSCustomObject $ModuleSource)
                }
                else
                {
                    $message = $LocalizedData.RepositoryNotFound -f ($sourceName)
                    Write-Error -Message $message `
                                -ErrorId 'RepositoryNotFound' `
                                -Category InvalidArgument `
                                -TargetObject $sourceName
                }
            }
        }
    }
    elseif($options -and
           $options.ContainsKey($script:PackageManagementProviderParam) -and
           $options.ContainsKey('Location'))
    {
        $Location = $options['Location']
        $PackageManagementProvider = $options['PackageManagementProvider']

        Write-Verbose ($LocalizedData.SpecifiedLocationAndOGP -f ($Location, $PackageManagementProvider))

        $LocationOGPHashtable[$Location] = $PackageManagementProvider
    }
    else
    {
        Write-Verbose $LocalizedData.NoSourceNameIsSpecified

        $script:PSGetModuleSources.Values | Microsoft.PowerShell.Core\ForEach-Object { $LocationOGPHashtable[$_.SourceLocation] = (Get-ProviderName -PSCustomObject $_) }
    }

    $artifactTypes = $script:PSArtifactTypeModule
    if($options.ContainsKey($script:PSArtifactType))
    {
        $artifactTypes = $options[$script:PSArtifactType]
    }

    if($artifactTypes -eq $script:All)
    {
        $artifactTypes = @($script:PSArtifactTypeModule,$script:PSArtifactTypeScript)
    }

    $providerOptions = @{}

    if($options.ContainsKey($script:AllVersions))
    {
        $providerOptions[$script:AllVersions] = $options[$script:AllVersions]
    }

    if ($options.Contains($script:AllowPrereleaseVersions))
    {
        $providerOptions[$script:AllowPrereleaseVersions] = $options[$script:AllowPrereleaseVersions]
    }

    if($options.ContainsKey($script:Filter))
    {
        $Filter = $options[$script:Filter]
        $providerOptions['Contains'] = $Filter
    }

    if($options.ContainsKey($script:Tag))
    {
        $userSpecifiedTags = $options[$script:Tag] | Microsoft.PowerShell.Utility\Select-Object -Unique -ErrorAction Ignore
    }
    else
    {
        $userSpecifiedTags = @($script:NotSpecified)
    }

    $specifiedDscResources = @()
    if($options.ContainsKey('DscResource'))
    {
        $specifiedDscResources = $options['DscResource'] |
                                    Microsoft.PowerShell.Utility\Select-Object -Unique -ErrorAction Ignore |
                                        Microsoft.PowerShell.Core\ForEach-Object {"$($script:DscResource)_$_"}
    }

    $specifiedRoleCapabilities = @()
    if($options.ContainsKey('RoleCapability'))
    {
        $specifiedRoleCapabilities = $options['RoleCapability'] |
                                        Microsoft.PowerShell.Utility\Select-Object -Unique -ErrorAction Ignore |
                                            Microsoft.PowerShell.Core\ForEach-Object {"$($script:RoleCapability)_$_"}
    }

    $specifiedCommands = @()
    if($options.ContainsKey('Command'))
    {
        $specifiedCommands = $options['Command'] |
                                Microsoft.PowerShell.Utility\Select-Object -Unique -ErrorAction Ignore |
                                    Microsoft.PowerShell.Core\ForEach-Object {"$($script:Command)_$_"}
    }

    $specifiedIncludes = @()
    if($options.ContainsKey('Includes'))
    {
        $includes = $options['Includes'] |
                        Microsoft.PowerShell.Utility\Select-Object -Unique -ErrorAction Ignore |
                            Microsoft.PowerShell.Core\ForEach-Object {"$($script:Includes)_$_"}

        # Add PSIncludes_DscResource to $specifiedIncludes iff -DscResource names are not specified
        # Add PSIncludes_RoleCapability to $specifiedIncludes iff -RoleCapability names are not specified
        # Add PSIncludes_Cmdlet or PSIncludes_Function to $specifiedIncludes iff -Command names are not specified
        # otherwise $script:NotSpecified will be added to $specifiedIncludes
        if($includes)
        {
            if(-not $specifiedDscResources -and ($includes -contains "$($script:Includes)_DscResource") )
            {
               $specifiedIncludes += "$($script:Includes)_DscResource"
            }

            if(-not $specifiedRoleCapabilities -and ($includes -contains "$($script:Includes)_RoleCapability") )
            {
               $specifiedIncludes += "$($script:Includes)_RoleCapability"
            }

            if(-not $specifiedCommands)
            {
               if($includes -contains "$($script:Includes)_Cmdlet")
               {
                   $specifiedIncludes += "$($script:Includes)_Cmdlet"
               }

               if($includes -contains "$($script:Includes)_Function")
               {
                   $specifiedIncludes += "$($script:Includes)_Function"
               }

               if($includes -contains "$($script:Includes)_Workflow")
               {
                   $specifiedIncludes += "$($script:Includes)_Workflow"
               }
            }
        }
    }

    if(-not $specifiedDscResources)
    {
        $specifiedDscResources += $script:NotSpecified
    }

    if(-not $specifiedRoleCapabilities)
    {
        $specifiedRoleCapabilities += $script:NotSpecified
    }

    if(-not $specifiedCommands)
    {
        $specifiedCommands += $script:NotSpecified
    }

    if(-not $specifiedIncludes)
    {
        $specifiedIncludes += $script:NotSpecified
    }

    $providerSearchTags = @{}

    foreach($tag in $userSpecifiedTags)
    {
        foreach($include in $specifiedIncludes)
        {
            foreach($command in $specifiedCommands)
            {
                foreach($resource in $specifiedDscResources)
                {
                    foreach($roleCapability in $specifiedRoleCapabilities)
                    {
                        $providerTags = @()
                        if($resource -ne $script:NotSpecified)
                        {
                            $providerTags += $resource
                        }

                        if($roleCapability -ne $script:NotSpecified)
                        {
                            $providerTags += $roleCapability
                        }

                        if($command -ne $script:NotSpecified)
                        {
                            $providerTags += $command
                        }

                        if($include -ne $script:NotSpecified)
                        {
                            $providerTags += $include
                        }

                        if($tag -ne $script:NotSpecified)
                        {
                            $providerTags += $tag
                        }

                        if($providerTags)
                        {
                            $providerSearchTags["$tag $resource $roleCapability $command $include"] = $providerTags
                        }
                    }
                }
            }
        }
    }

    $InstallationPolicy = "Untrusted"
    if($options.ContainsKey('InstallationPolicy'))
    {
        $InstallationPolicy = $options['InstallationPolicy']
    }

    $streamedResults = @()

    foreach($artifactType in $artifactTypes)
    {
        foreach($kvPair in $LocationOGPHashtable.GetEnumerator())
        {
            if($request.IsCanceled)
            {
                return
            }

            $Location = $kvPair.Key
            if($artifactType -eq $script:PSArtifactTypeScript)
            {
                $sourceName = Get-SourceName -Location $Location

                if($SourceName)
                {
                    $ModuleSource = $script:PSGetModuleSources[$SourceName]

                    # Skip source if no ScriptSourceLocation is available.
                    if(-not $ModuleSource.ScriptSourceLocation)
                    {
                        if($options.ContainsKey('Source'))
                        {
                            $message = $LocalizedData.ScriptSourceLocationIsMissing -f ($ModuleSource.Name)
                            Write-Error -Message $message `
                                        -ErrorId 'ScriptSourceLocationIsMissing' `
                                        -Category InvalidArgument `
                                        -TargetObject $ModuleSource.Name
                        }

                        continue
                    }

                    $Location = $ModuleSource.ScriptSourceLocation
                }
            }

            $ProviderName = $kvPair.Value

            Write-Verbose ($LocalizedData.GettingPackageManagementProviderObject -f ($ProviderName))

	        $provider = $request.SelectProvider($ProviderName)

            if(-not $provider)
            {
                Write-Error -Message ($LocalizedData.PackageManagementProviderIsNotAvailable -f $ProviderName)

                Continue
            }

            Write-Verbose ($LocalizedData.SpecifiedLocationAndOGP -f ($Location, $provider.ProviderName))

            if($providerSearchTags.Values.Count)
            {
                $tagList = $providerSearchTags.Values
            }
            else
            {
                $tagList = @($script:NotSpecified)
            }

            $namesParameterEmpty = ($names.Count -eq 1) -and ($names[0] -eq '')

            foreach($providerTag in $tagList)
            {
                if($request.IsCanceled)
                {
                    return
                }

                $FilterOnTag = @()

                if($providerTag -ne $script:NotSpecified)
                {
                    $FilterOnTag = $providerTag
                }

                if(Microsoft.PowerShell.Management\Test-Path -Path $Location)
                {
                    if($artifactType -eq $script:PSArtifactTypeScript)
                    {
                        $FilterOnTag += 'PSScript'
                    }
                    elseif($artifactType -eq $script:PSArtifactTypeModule)
                    {
                        $FilterOnTag += 'PSModule'
                    }
                }

                if($FilterOnTag)
                {
                    $providerOptions["FilterOnTag"] = $FilterOnTag
                }
                elseif($providerOptions.ContainsKey('FilterOnTag'))
                {
                    $null = $providerOptions.Remove('FilterOnTag')
                }

                if($request.Options.ContainsKey($script:FindByCanonicalId))
                {
                    $providerOptions[$script:FindByCanonicalId] = $request.Options[$script:FindByCanonicalId]
                }

                $providerOptions["Headers"] = 'PSGalleryClientVersion=1.1'

                $NewRequest = $request.CloneRequest( $providerOptions, @($Location), $request.Credential )

                $pkgs = $provider.FindPackages($names,
                                               $requiredVersion,
                                               $minimumVersion,
                                               $maximumVersion,
                                               $NewRequest )

                foreach($pkg in  $pkgs)
                {
                    if($request.IsCanceled)
                    {
                        return
                    }

                    # $pkg.Name has to match any of the supplied names, using PowerShell wildcards
                    if ($namesParameterEmpty -or ($names | Foreach-Object { if ($pkg.Name -like $_){return $true; break} } -End {return $false}))
                    {
						$includePackage = $true

						# If -Name was provided, we need to post-filter
						# Filtering has AND semantics between different parameters and OR within a parameter (each parameter is potentially an array)
						if($options.ContainsKey("Name") -and $postFilter.Count -gt 0)
						{
							if ($pkg.Metadata["DscResources"].Count -gt 0)
							{
								$pkgDscResources = $pkg.Metadata["DscResources"] -Split " " | Microsoft.PowerShell.Core\Where-Object { $_.Trim() }
							}
							else
							{
								$pkgDscResources = $pkg.Metadata["tags"] -Split " " `
									| Microsoft.PowerShell.Core\Where-Object { $_.Trim() } `
									| Microsoft.PowerShell.Core\Where-Object { $_.StartsWith($script:DscResource, [System.StringComparison]::OrdinalIgnoreCase) } `
									| Microsoft.PowerShell.Core\ForEach-Object { $_.Substring($script:DscResource.Length + 1) }
							}

							if ($pkg.Metadata['RoleCapabilities'].Count -gt 0)
							{
								$pkgRoleCapabilities = $pkg.Metadata['RoleCapabilities'] -Split ' ' | Microsoft.PowerShell.Core\Where-Object { $_.Trim() }
							}
							else
							{
								$pkgRoleCapabilities = $pkg.Metadata["tags"] -Split ' ' `
									| Microsoft.PowerShell.Core\Where-Object { $_.Trim() } `
									| Microsoft.PowerShell.Core\Where-Object { $_.StartsWith($script:RoleCapability, [System.StringComparison]::OrdinalIgnoreCase) } `
									| Microsoft.PowerShell.Core\ForEach-Object { $_.Substring($script:RoleCapability.Length + 1) }
							}

							if ($pkg.Metadata["Functions"].Count -gt 0)
							{
								$pkgFunctions = $pkg.Metadata["Functions"] -Split " " | Microsoft.PowerShell.Core\Where-Object { $_.Trim() }
							}
							else
							{
								$pkgFunctions = $pkg.Metadata["tags"] -Split " " `
									| Microsoft.PowerShell.Core\Where-Object { $_.Trim() } `
									| Microsoft.PowerShell.Core\Where-Object { $_.StartsWith($script:Function, [System.StringComparison]::OrdinalIgnoreCase) } `
									| Microsoft.PowerShell.Core\ForEach-Object { $_.Substring($script:Function.Length + 1) }
							}

							if ($pkg.Metadata["Cmdlets"].Count -gt 0)
							{
								$pkgCmdlets = $pkg.Metadata["Cmdlets"] -Split " " | Microsoft.PowerShell.Core\Where-Object { $_.Trim() }
							}
							else
							{
								$pkgCmdlets = $pkg.Metadata["tags"] -Split " " `
									| Microsoft.PowerShell.Core\Where-Object { $_.Trim() } `
									| Microsoft.PowerShell.Core\Where-Object { $_.StartsWith($script:Cmdlet, [System.StringComparison]::OrdinalIgnoreCase) } `
									| Microsoft.PowerShell.Core\ForEach-Object { $_.Substring($script:Cmdlet.Length + 1) }
							}

							if ($pkg.Metadata["Workflows"].Count -gt 0)
							{
								$pkgWorkflows = $pkg.Metadata["Workflows"] -Split " " | Microsoft.PowerShell.Core\Where-Object { $_.Trim() }
							}
							else
							{
								$pkgWorkflows = $pkg.Metadata["tags"] -Split " " `
									| Microsoft.PowerShell.Core\Where-Object { $_.Trim() } `
									| Microsoft.PowerShell.Core\Where-Object { $_.StartsWith($script:Workflow, [System.StringComparison]::OrdinalIgnoreCase) } `
									| Microsoft.PowerShell.Core\ForEach-Object { $_.Substring($script:Workflow.Length + 1) }
							}

							foreach ($key in $postFilter.Keys)
							{
								switch ($key)
								{
									"DscResource" {
										$values = $postFilter[$key]

										$includePackage = $false

										foreach ($value in $values)
										{
											$wildcardPattern = New-Object System.Management.Automation.WildcardPattern $value,$script:wildcardOptions

											$pkgDscResources | Microsoft.PowerShell.Core\ForEach-Object {
												if ($wildcardPattern.IsMatch($_))
												{
													$includePackage = $true
													break
												}
											}
										}

										if (-not $includePackage)
										{
											break
										}
									}

									'RoleCapability' {
										$values = $postFilter[$key]

										$includePackage = $false

										foreach ($value in $values)
										{
											$wildcardPattern = New-Object System.Management.Automation.WildcardPattern $value,$script:wildcardOptions

											$pkgRoleCapabilities | Microsoft.PowerShell.Core\ForEach-Object {
												if ($wildcardPattern.IsMatch($_))
												{
													$includePackage = $true
													break
												}
											}
										}

										if (-not $includePackage)
										{
											break
										}
									}

									"Command" {
										$values = $postFilter[$key]

										$includePackage = $false

										foreach ($value in $values)
										{
											$wildcardPattern = New-Object System.Management.Automation.WildcardPattern $value,$script:wildcardOptions

											$pkgFunctions | Microsoft.PowerShell.Core\ForEach-Object {
												if ($wildcardPattern.IsMatch($_))
												{
													$includePackage = $true
													break
												}
											}

											$pkgCmdlets | Microsoft.PowerShell.Core\ForEach-Object {
												if ($wildcardPattern.IsMatch($_))
												{
													$includePackage = $true
													break
												}
											}

											$pkgWorkflows | Microsoft.PowerShell.Core\ForEach-Object {
												if ($wildcardPattern.IsMatch($_))
												{
													$includePackage = $true
													break
												}
											}
										}

										if (-not $includePackage)
										{
											break
										}
									}

									"Includes" {
										$values = $postFilter[$key]

										$includePackage = $false

										foreach ($value in $values)
										{
											switch ($value)
											{
												"Cmdlet" { if ($pkgCmdlets ) { $includePackage = $true } }
												"Function" { if ($pkgFunctions ) { $includePackage = $true } }
												"DscResource" { if ($pkgDscResources ) { $includePackage = $true } }
												"RoleCapability" { if ($pkgRoleCapabilities ) { $includePackage = $true } }
												"Workflow" { if ($pkgWorkflows ) { $includePackage = $true } }
											}
										}

										if (-not $includePackage)
										{
											break
										}
									}
								}
							}
						}

						if ($includePackage)
						{
							$fastPackageReference = New-FastPackageReference -ProviderName $provider.ProviderName `
																			-PackageName $pkg.Name `
																			-Version $pkg.Version `
																			-Source $Location `
																			-ArtifactType $artifactType

							if($streamedResults -notcontains $fastPackageReference)
							{
								$streamedResults += $fastPackageReference

								$FromTrustedSource = $false

								$ModuleSourceName = Get-SourceName -Location $Location

								if($ModuleSourceName)
								{
									$FromTrustedSource = $script:PSGetModuleSources[$ModuleSourceName].Trusted
								}
								elseif($InstallationPolicy -eq "Trusted")
								{
									$FromTrustedSource = $true
								}

								$sid = New-SoftwareIdentityFromPackage -Package $pkg `
																	-PackageManagementProviderName $provider.ProviderName `
																	-SourceLocation $Location `
																	-IsFromTrustedSource:$FromTrustedSource `
																	-Type $artifactType `
																	-request $request

								$script:FastPackRefHashtable[$fastPackageReference] = $pkg

								Write-Output -InputObject $sid
							}
						}
                    }
                }
            }
        }
    }
}
function Get-DynamicOptions
{
    param
    (
        [Microsoft.PackageManagement.MetaProvider.PowerShell.OptionCategory]
        $category
    )

    Write-Debug ($LocalizedData.ProviderApiDebugMessage -f ('Get-DynamicOptions'))

    Write-Output -InputObject (New-DynamicOption -Category $category -Name $script:PackageManagementProviderParam -ExpectedType String -IsRequired $false)

    switch($category)
    {
        Package {
                    Write-Output -InputObject (New-DynamicOption -Category $category `
                                                                 -Name $script:PSArtifactType `
                                                                 -ExpectedType String `
                                                                 -IsRequired $false `
                                                                 -PermittedValues @($script:PSArtifactTypeModule,$script:PSArtifactTypeScript, $script:All))
                    Write-Output -InputObject (New-DynamicOption -Category $category -Name $script:Filter -ExpectedType String -IsRequired $false)
                    Write-Output -InputObject (New-DynamicOption -Category $category -Name $script:Tag -ExpectedType StringArray -IsRequired $false)
                    Write-Output -InputObject (New-DynamicOption -Category $category -Name Includes -ExpectedType StringArray -IsRequired $false -PermittedValues $script:IncludeValidSet)
                    Write-Output -InputObject (New-DynamicOption -Category $category -Name DscResource -ExpectedType StringArray -IsRequired $false)
                    Write-Output -InputObject (New-DynamicOption -Category $category -Name RoleCapability -ExpectedType StringArray -IsRequired $false)
                    Write-Output -InputObject (New-DynamicOption -Category $category -Name 'AllowPrereleaseVersions' -ExpectedType Switch -IsRequired $false)
                    Write-Output -InputObject (New-DynamicOption -Category $category -Name Command -ExpectedType StringArray -IsRequired $false)
                    Write-Output -InputObject (New-DynamicOption -Category $category -Name 'AcceptLicense' -ExpectedType Switch -IsRequired $false)
                }

        Source  {
                    Write-Output -InputObject (New-DynamicOption -Category $category -Name $script:PublishLocation -ExpectedType String -IsRequired $false)
                    Write-Output -InputObject (New-DynamicOption -Category $category -Name $script:ScriptSourceLocation -ExpectedType String -IsRequired $false)
                    Write-Output -InputObject (New-DynamicOption -Category $category -Name $script:ScriptPublishLocation -ExpectedType String -IsRequired $false)
                }

        Install
                {
                    Write-Output -InputObject (New-DynamicOption -Category $category `
                                                                 -Name $script:PSArtifactType `
                                                                 -ExpectedType String `
                                                                 -IsRequired $false `
                                                                 -PermittedValues @($script:PSArtifactTypeModule,$script:PSArtifactTypeScript, $script:All))
                    Write-Output -InputObject (New-DynamicOption -Category $category -Name "Scope" -ExpectedType String -IsRequired $false -PermittedValues @("CurrentUser","AllUsers"))
                    Write-Output -InputObject (New-DynamicOption -Category $category -Name 'AllowClobber' -ExpectedType Switch -IsRequired $false)
                    Write-Output -InputObject (New-DynamicOption -Category $category -Name 'SkipPublisherCheck' -ExpectedType Switch -IsRequired $false)
                    Write-Output -InputObject (New-DynamicOption -Category $category -Name "InstallUpdate" -ExpectedType Switch -IsRequired $false)
                    Write-Output -InputObject (New-DynamicOption -Category $category -Name 'NoPathUpdate' -ExpectedType Switch -IsRequired $false)
                    Write-Output -InputObject (New-DynamicOption -Category $category -Name 'AllowPrereleaseVersions' -ExpectedType Switch -IsRequired $false)
                }
    }
}
function Get-Feature
{
    Write-Debug ($LocalizedData.ProviderApiDebugMessage -f ('Get-Feature'))
    Write-Output -InputObject (New-Feature $script:SupportsPSModulesFeatureName )
}
function Get-InstalledPackage
{
    [CmdletBinding()]
    param
    (
        [Parameter()]
        [string]
        $Name,

        [Parameter()]
        [string]
        $RequiredVersion,

        [Parameter()]
        [string]
        $MinimumVersion,

        [Parameter()]
        [string]
        $MaximumVersion
    )

    Write-Debug -Message ($LocalizedData.ProviderApiDebugMessage -f ('Get-InstalledPackage'))

    $options = $request.Options

    foreach( $o in $options.Keys )
    {
        Write-Debug ( "OPTION: {0} => {1}" -f ($o, $options[$o]) )
    }

    $artifactTypes = $script:PSArtifactTypeModule
    if($options.ContainsKey($script:PSArtifactType))
    {
        $artifactTypes = $options[$script:PSArtifactType]
    }

    if($artifactTypes -eq $script:All)
    {
        $artifactTypes = @($script:PSArtifactTypeModule,$script:PSArtifactTypeScript)
    }

    if($artifactTypes -contains $script:PSArtifactTypeModule)
    {
        Get-InstalledModuleDetails -Name $Name `
                                   -RequiredVersion $RequiredVersion `
                                   -MinimumVersion $MinimumVersion `
                                   -MaximumVersion $MaximumVersion | Microsoft.PowerShell.Core\ForEach-Object {$_.SoftwareIdentity}
    }

    if($artifactTypes -contains $script:PSArtifactTypeScript)
    {
        Get-InstalledScriptDetails -Name $Name `
                                   -RequiredVersion $RequiredVersion `
                                   -MinimumVersion $MinimumVersion `
                                   -MaximumVersion $MaximumVersion | Microsoft.PowerShell.Core\ForEach-Object {$_.SoftwareIdentity}
    }
}
function Get-PackageProviderName
{
    return $script:PSModuleProviderName
}
function Initialize-Provider
{
    Write-Debug ($LocalizedData.ProviderApiDebugMessage -f ('Initialize-Provider'))
}
function Install-Package
{
    [CmdletBinding()]
    param
    (
        [Parameter(Mandatory=$true)]
        [ValidateNotNullOrEmpty()]
        [string]
        $FastPackageReference
    )

    Write-Debug ($LocalizedData.ProviderApiDebugMessage -f ('Install-Package'))

    Install-PackageUtility -FastPackageReference $FastPackageReference -Request $Request
}
function Remove-PackageSource
{
    param
    (
        [string]
        $Name
    )

    Write-Debug ($LocalizedData.ProviderApiDebugMessage -f ('Remove-PackageSource'))

    Set-ModuleSourcesVariable -Force

    $ModuleSourcesToBeRemoved = @()

    foreach ($moduleSourceName in $Name)
    {
        if($request.IsCanceled)
        {
            return
        }

        # Check if $Name contains any wildcards
        if(Test-WildcardPattern $moduleSourceName)
        {
            $message = $LocalizedData.RepositoryNameContainsWildCards -f ($moduleSourceName)
            Write-Error -Message $message -ErrorId "RepositoryNameContainsWildCards" -Category InvalidOperation -TargetObject $moduleSourceName
            continue
        }

        # Check if the specified module source name is in the registered module sources
        if(-not $script:PSGetModuleSources.Contains($moduleSourceName))
        {
            $message = $LocalizedData.RepositoryNotFound -f ($moduleSourceName)
            Write-Error -Message $message -ErrorId "RepositoryNotFound" -Category InvalidOperation -TargetObject $moduleSourceName
            continue
        }

        $ModuleSourcesToBeRemoved += $moduleSourceName
        $message = $LocalizedData.RepositoryUnregistered -f ($moduleSourceName)
        Write-Verbose $message
    }

    # Remove the module source
    $ModuleSourcesToBeRemoved | Microsoft.PowerShell.Core\ForEach-Object { $null = $script:PSGetModuleSources.Remove($_) }

    # Persist the module sources
    Save-ModuleSources
}
function Resolve-PackageSource
{
    Write-Debug ($LocalizedData.ProviderApiDebugMessage -f ('Resolve-PackageSource'))

    Set-ModuleSourcesVariable

    $SourceName = $request.PackageSources

    if(-not $SourceName)
    {
        $SourceName = "*"
    }

    foreach($moduleSourceName in $SourceName)
    {
        if($request.IsCanceled)
        {
            return
        }

        $wildcardPattern = New-Object System.Management.Automation.WildcardPattern $moduleSourceName,$script:wildcardOptions
        $moduleSourceFound = $false

        $script:PSGetModuleSources.GetEnumerator() |
            Microsoft.PowerShell.Core\Where-Object {$wildcardPattern.IsMatch($_.Key)} |
                Microsoft.PowerShell.Core\ForEach-Object {

                    $moduleSource = $script:PSGetModuleSources[$_.Key]

                    $packageSource = New-PackageSourceFromModuleSource -ModuleSource $moduleSource

                    Write-Output -InputObject $packageSource

                    $moduleSourceFound = $true
                }

        if(-not $moduleSourceFound)
        {
            $sourceName  = Get-SourceName -Location $moduleSourceName

            if($sourceName)
            {
                $moduleSource = $script:PSGetModuleSources[$sourceName]

                $packageSource = New-PackageSourceFromModuleSource -ModuleSource $moduleSource

                Write-Output -InputObject $packageSource
            }
            elseif( -not (Test-WildcardPattern $moduleSourceName))
            {
                $message = $LocalizedData.RepositoryNotFound -f ($moduleSourceName)

                Write-Error -Message $message -ErrorId "RepositoryNotFound" -Category InvalidOperation -TargetObject $moduleSourceName
            }
        }
    }
}
function Uninstall-Package
{
    [CmdletBinding()]
    param
    (
        [Parameter(Mandatory=$true)]
        [ValidateNotNullOrEmpty()]
        [string]
        $fastPackageReference
    )

    Write-Debug -Message ($LocalizedData.ProviderApiDebugMessage -f ('Uninstall-Package'))

    Write-Debug -Message ($LocalizedData.FastPackageReference -f $fastPackageReference)

    # take the fastPackageReference and get the package object again.
    $parts = $fastPackageReference -Split '[|]'
    $Force = $false

    $options = $request.Options
    if($options)
    {
        foreach( $o in $options.Keys )
        {
            Write-Debug -Message ("OPTION: {0} => {1}" -f ($o, $request.Options[$o]) )
        }
    }

    if($parts.Length -eq 5)
    {
        $providerName = $parts[0]
        $packageName = $parts[1]
        $version = $parts[2]
        $sourceLocation= $parts[3]
        $artifactType = $parts[4]

        if($request.IsCanceled)
        {
            return
        }

        if($options.ContainsKey('Force'))
        {
            $Force = $options['Force']

            if($Force.GetType().ToString() -eq 'System.String')
            {
                if($Force -eq 'false')
                {
                    $Force = $false
                }
                elseif($Force -eq 'true')
                {
                    $Force = $true
                }
            }
        }

        if($artifactType -eq $script:PSArtifactTypeModule)
        {
            $moduleName = $packageName
            $InstalledModuleInfo = $script:PSGetInstalledModules["$($moduleName)$($version)"]

            if(-not $InstalledModuleInfo)
            {
                $message = $LocalizedData.ModuleUninstallationNotPossibleAsItIsNotInstalledUsingPowerShellGet -f $moduleName

                ThrowError -ExceptionName "System.ArgumentException" `
                           -ExceptionMessage $message `
                           -ErrorId "ModuleUninstallationNotPossibleAsItIsNotInstalledUsingPowerShellGet" `
                           -CallerPSCmdlet $PSCmdlet `
                           -ErrorCategory InvalidArgument

                return
            }

            $moduleBase = $InstalledModuleInfo.PSGetItemInfo.InstalledLocation

            if(-not (Test-RunningAsElevated) -and $moduleBase.StartsWith($script:programFilesModulesPath, [System.StringComparison]::OrdinalIgnoreCase))
            {
                $message = $LocalizedData.AdminPrivilegesRequiredForUninstall -f ($moduleName, $moduleBase)

                ThrowError -ExceptionName "System.InvalidOperationException" `
                           -ExceptionMessage $message `
                           -ErrorId "AdminPrivilegesRequiredForUninstall" `
                           -CallerPSCmdlet $PSCmdlet `
                           -ErrorCategory InvalidOperation

                return
            }

            $dependentModuleScript = {
                                param ([string] $moduleName)
                                Microsoft.PowerShell.Core\Get-Module -ListAvailable |
                                Microsoft.PowerShell.Core\Where-Object {
                                    ($moduleName -ne $_.Name) -and (
                                    ($_.RequiredModules -and $_.RequiredModules.Name -contains $moduleName) -or
                                    ($_.NestedModules -and $_.NestedModules.Name -contains $moduleName))
                                }
                            }
            $dependentModulesJob =  Microsoft.PowerShell.Core\Start-Job -ScriptBlock $dependentModuleScript -ArgumentList $moduleName
            Microsoft.PowerShell.Core\Wait-Job -job $dependentModulesJob
            $dependentModules = Microsoft.PowerShell.Core\Receive-Job -job $dependentModulesJob -ErrorAction Ignore

            if(-not $Force -and $dependentModules)
            {
                $message = $LocalizedData.UnableToUninstallAsOtherModulesNeedThisModule -f ($moduleName, $version, $moduleBase, $(($dependentModules.Name | Select-Object -Unique -ErrorAction Ignore) -join ','), $moduleName)

                ThrowError -ExceptionName "System.InvalidOperationException" `
                           -ExceptionMessage $message `
                           -ErrorId "UnableToUninstallAsOtherModulesNeedThisModule" `
                           -CallerPSCmdlet $PSCmdlet `
                           -ErrorCategory InvalidOperation

                return
            }

            $moduleInUse = Test-ModuleInUse -ModuleBasePath $moduleBase `
                                            -ModuleName $InstalledModuleInfo.PSGetItemInfo.Name`
                                            -ModuleVersion $InstalledModuleInfo.PSGetItemInfo.Version `
                                            -Verbose:$VerbosePreference `
                                            -WarningAction $WarningPreference `
                                            -ErrorAction $ErrorActionPreference `
                                            -Debug:$DebugPreference

            if($moduleInUse)
            {
                $message = $LocalizedData.ModuleIsInUse -f ($moduleName)

                ThrowError -ExceptionName "System.InvalidOperationException" `
                           -ExceptionMessage $message `
                           -ErrorId "ModuleIsInUse" `
                           -CallerPSCmdlet $PSCmdlet `
                           -ErrorCategory InvalidOperation

                return
            }

            $ModuleBaseFolderToBeRemoved = $moduleBase

            # With SxS version support, more than one version of the module can be installed.
            # - Remove the parent directory of the module version base when only one version is installed
            # - Don't remove the modulebase when it was installed before SxS version support and
            #   other versions are installed under the module base folder
            #
            if(Test-ModuleSxSVersionSupport)
            {
                $ModuleBaseWithoutVersion = $moduleBase
                $IsModuleInstalledAsSxSVersion = $false

                if($moduleBase.EndsWith("$version", [System.StringComparison]::OrdinalIgnoreCase))
                {
                    $IsModuleInstalledAsSxSVersion = $true
                    $ModuleBaseWithoutVersion = Microsoft.PowerShell.Management\Split-Path -Path $moduleBase -Parent
                }

                $InstalledVersionsWithSameModuleBase = @()
                Get-Module -Name $moduleName -ListAvailable |
                    Microsoft.PowerShell.Core\ForEach-Object {
                        if($_.ModuleBase.StartsWith($ModuleBaseWithoutVersion, [System.StringComparison]::OrdinalIgnoreCase))
                        {
                            $InstalledVersionsWithSameModuleBase += $_.ModuleBase
                        }
                    }

                # Remove ..\ModuleName directory when only one module is installed with the same ..\ModuleName path
                # like ..\ModuleName\1.0 or ..\ModuleName
                if($InstalledVersionsWithSameModuleBase.Count -eq 1)
                {
                    $ModuleBaseFolderToBeRemoved = $ModuleBaseWithoutVersion
                }
                elseif($ModuleBaseWithoutVersion -eq $moduleBase)
                {
                    # There are version specific folders under the same module base dir
                    # Throw an error saying uninstall other versions then uninstall this current version
                    $message = $LocalizedData.UnableToUninstallModuleVersion -f ($moduleName, $version, $moduleBase)

                    ThrowError -ExceptionName "System.InvalidOperationException" `
                               -ExceptionMessage $message `
                               -ErrorId "UnableToUninstallModuleVersion" `
                               -CallerPSCmdlet $PSCmdlet `
                               -ErrorCategory InvalidOperation

                    return
                }
                # Otherwise specified version folder will be removed as current module base is assigned to $ModuleBaseFolderToBeRemoved
            }

            Microsoft.PowerShell.Management\Remove-Item -Path $ModuleBaseFolderToBeRemoved `
                                                        -Force -Recurse `
                                                        -ErrorAction SilentlyContinue `
                                                        -WarningAction SilentlyContinue `
                                                        -Confirm:$false -WhatIf:$false

            $message = $LocalizedData.ModuleUninstallationSucceeded -f $moduleName, $moduleBase
            Write-Verbose  $message

            Write-Output -InputObject $InstalledModuleInfo.SoftwareIdentity
        }
        elseif($artifactType -eq $script:PSArtifactTypeScript)
        {
            $scriptName = $packageName
            $InstalledScriptInfo = $script:PSGetInstalledScripts["$($scriptName)$($version)"]

            if(-not $InstalledScriptInfo)
            {
                $message = $LocalizedData.ScriptUninstallationNotPossibleAsItIsNotInstalledUsingPowerShellGet -f $scriptName
                ThrowError -ExceptionName "System.ArgumentException" `
                           -ExceptionMessage $message `
                           -ErrorId "ScriptUninstallationNotPossibleAsItIsNotInstalledUsingPowerShellGet" `
                           -CallerPSCmdlet $PSCmdlet `
                           -ErrorCategory InvalidArgument

                return
            }

            $scriptBase = $InstalledScriptInfo.PSGetItemInfo.InstalledLocation
            $installedScriptInfoPath = $script:MyDocumentsInstalledScriptInfosPath

            if($scriptBase.StartsWith($script:ProgramFilesScriptsPath, [System.StringComparison]::OrdinalIgnoreCase))
            {
                if(-not (Test-RunningAsElevated))
                {
                    $message = $LocalizedData.AdminPrivilegesRequiredForScriptUninstall -f ($scriptName, $scriptBase)

                    ThrowError -ExceptionName "System.InvalidOperationException" `
                               -ExceptionMessage $message `
                               -ErrorId "AdminPrivilegesRequiredForUninstall" `
                               -CallerPSCmdlet $PSCmdlet `
                               -ErrorCategory InvalidOperation

                    return
                }

                $installedScriptInfoPath = $script:ProgramFilesInstalledScriptInfosPath
            }

            # Check if there are any dependent scripts
            $dependentScriptDetails = $script:PSGetInstalledScripts.Values |
                                          Microsoft.PowerShell.Core\Where-Object {
                                              $_.PSGetItemInfo.Dependencies -contains $scriptName
                                          }

            $dependentScriptNames = $dependentScriptDetails |
                                        Microsoft.PowerShell.Core\ForEach-Object { $_.PSGetItemInfo.Name }

            if(-not $Force -and $dependentScriptNames)
            {
                $message = $LocalizedData.UnableToUninstallAsOtherScriptsNeedThisScript -f
                               ($scriptName,
                                $version,
                                $scriptBase,
                                $(($dependentScriptNames | Select-Object -Unique -ErrorAction Ignore) -join ','),
                                $scriptName)

                ThrowError -ExceptionName 'System.InvalidOperationException' `
                           -ExceptionMessage $message `
                           -ErrorId 'UnableToUninstallAsOtherScriptsNeedThisScript' `
                           -CallerPSCmdlet $PSCmdlet `
                           -ErrorCategory InvalidOperation
                return
            }

            $scriptFilePath = Microsoft.PowerShell.Management\Join-Path -Path $scriptBase `
                                                                        -ChildPath "$($scriptName).ps1"

            $installedScriptInfoFilePath = Microsoft.PowerShell.Management\Join-Path -Path $installedScriptInfoPath `
                                                                                      -ChildPath "$($scriptName)_$($script:InstalledScriptInfoFileName)"

            # Remove the script file and it's corresponding InstalledScriptInfo.xml
            if(Microsoft.PowerShell.Management\Test-Path -Path $scriptFilePath -PathType Leaf)
            {
                Microsoft.PowerShell.Management\Remove-Item -Path $scriptFilePath `
                                                            -Force `
                                                            -ErrorAction SilentlyContinue `
                                                            -WarningAction SilentlyContinue `
                                                            -Confirm:$false -WhatIf:$false
            }

            if(Microsoft.PowerShell.Management\Test-Path -Path $installedScriptInfoFilePath -PathType Leaf)
            {
                Microsoft.PowerShell.Management\Remove-Item -Path $installedScriptInfoFilePath `
                                                            -Force `
                                                            -ErrorAction SilentlyContinue `
                                                            -WarningAction SilentlyContinue `
                                                            -Confirm:$false -WhatIf:$false
            }

            $message = $LocalizedData.ScriptUninstallationSucceeded -f $scriptName, $scriptBase
            Write-Verbose $message

            Write-Output -InputObject $InstalledScriptInfo.SoftwareIdentity
        }
    }
}

#endregion

Export-ModuleMember -Function Add-PackageSource,Download-Package,Find-Package,Get-DynamicOptions,Get-Feature,Get-InstalledPackage,Get-PackageProviderName,Initialize-Provider,Install-Package,Remove-PackageSource,Resolve-PackageSource,Uninstall-Package,Find-Command,Find-DSCResource,Find-Module,Find-RoleCapability,Find-Script,Get-CredsFromCredentialProvider,Get-InstalledModule,Get-InstalledScript,Get-PSRepository,Install-Module,Install-Script,New-ScriptFileInfo,Publish-Module,Publish-Script,Register-PSRepository,Save-Module,Save-Script,Set-PSRepository,Test-ScriptFileInfo,Uninstall-Module,Uninstall-Script,Unregister-PSRepository,Update-Module,Update-ModuleManifest,Update-Script,Update-ScriptFileInfo

# Create install locations for scripts if they are not already created
if (-not (Microsoft.PowerShell.Management\Test-Path -Path $script:ProgramFilesInstalledScriptInfosPath) -and (Test-RunningAsElevated)) {
    $ev = $null
    $null = Microsoft.PowerShell.Management\New-Item -Path $script:ProgramFilesInstalledScriptInfosPath `
        -ItemType Directory `
        -Force `
        -ErrorVariable ev `
        -ErrorAction SilentlyContinue `
        -WarningAction SilentlyContinue `
        -Confirm:$false `
        -WhatIf:$false

    if ($ev) {
        $script:IsRunningAsElevated = $false
    }
}

if (-not (Microsoft.PowerShell.Management\Test-Path -Path $script:MyDocumentsInstalledScriptInfosPath)) {
    $null = Microsoft.PowerShell.Management\New-Item -Path $script:MyDocumentsInstalledScriptInfosPath `
        -ItemType Directory `
        -Force `
        -Confirm:$false `
        -WhatIf:$false
}

# allow -repository params to be tab-completed
$commandsWithRepositoryParameter = @(
    "Find-Command"
    "Find-DscResource"
    "Find-Module"
    "Find-RoleCapability"
    "Find-Script"
    "Install-Module"
    "Install-Script"
    "Publish-Module"
    "Publish-Script"
    "Save-Module"
    "Save-Script")

$commandsWithRepositoryAsName = @(
    "Get-PSRepository",
    "Register-PSRepository"
    "Unregister-PSRepository"
)

Add-ArgumentCompleter -Cmdlets $commandsWithRepositoryParameter -ParameterName "Repository"
Add-ArgumentCompleter -Cmdlets $commandsWithRepositoryAsName -ParameterName "Name"

try {
    if (Get-Command -Name Register-ArgumentCompleter -ErrorAction SilentlyContinue) {
        Register-ArgumentCompleter -CommandName Publish-Module -ParameterName Name -ScriptBlock {
            param ($commandName, $parameterName, $wordToComplete)

            Get-Module -Name $wordToComplete* -ListAvailable -ErrorAction SilentlyContinue -WarningAction SilentlyContinue | Foreach-Object {
                [System.Management.Automation.CompletionResult]::new($_.Name, $_.Name, 'ParameterValue', $_.Name)
            }
        }
    }
}
catch {
    # All this functionality is optional, so suppress errors
    Write-Debug -Message "Error registering argument completer: $_"
}

Set-Alias -Name fimo -Value Find-Module
Set-Alias -Name inmo -Value Install-Module
Set-Alias -Name upmo -Value Update-Module
Set-Alias -Name pumo -Value Publish-Module
Set-Alias -Name uimo -Value Uninstall-Module

Export-ModuleMember -Alias fimo, inmo, upmo, pumo, uimo -Variable PSGetPath

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Private\AADSync\Invoke-RemoteADSyncCycle.ps1

function Invoke-RemoteADSyncCycle {
    <#
    .SYNOPSIS
        Triggers Start-ADSyncSyncCycle (Delta/Initial) on the remote host.
    .OUTPUTS
        [pscustomobject] result with ComputerName, PolicyType, Status, Errors
    #>
    [CmdletBinding(SupportsShouldProcess = $true)]
    param(
        [Parameter(Mandatory)][System.Management.Automation.Runspaces.PSSession]$Session,
        [Parameter(Mandatory)][ValidateSet('Delta', 'Initial')][string]$PolicyType
    )

    if ($PSCmdlet.ShouldProcess(("ADSync on $($Session.ComputerName)"), "Start-ADSyncSyncCycle ($PolicyType)")) {
        return Invoke-Command -Session $Session -ScriptBlock {
            try {
                Start-ADSyncSyncCycle -PolicyType $using:PolicyType | Out-Null
                [PSCustomObject]@{
                    ComputerName = $env:COMPUTERNAME
                    PolicyType   = $using:PolicyType
                    Status       = 'SyncTriggered'
                    Errors       = ''
                }
            }
            catch {
                [PSCustomObject]@{
                    ComputerName = $env:COMPUTERNAME
                    PolicyType   = $using:PolicyType
                    Status       = 'SyncFailed'
                    Errors       = $_.Exception.Message
                }
            }
        }
    }
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Private\AADSync\Test-AADSyncRemote.ps1

function Test-AADSyncRemote {
    <#
    .SYNOPSIS
        Validates ADSync module import and service state on the remote host.
    .OUTPUTS
        [pscustomobject] with ComputerName, Status, Errors
    #>
    [CmdletBinding()]
    param([Parameter(Mandatory)][System.Management.Automation.Runspaces.PSSession]$Session)

    return Invoke-Command -Session $Session -ScriptBlock {
        $errors = @()
        try { Import-Module ADSync -ErrorAction Stop } catch {
            $errors += "ADSync module not found or failed to import: $($_.Exception.Message)"
        }
        $svc = Get-Service -Name 'ADSync' -ErrorAction SilentlyContinue
        if (-not $svc) {
            $errors += "ADSync service not found."
        }
        elseif ($svc.Status -ne 'Running') {
            $errors += "ADSync service state is '$($svc.Status)'; expected 'Running'."
        }
        if ($errors.Count -gt 0) {
            [PSCustomObject]@{
                ComputerName = $env:COMPUTERNAME
                Status       = 'PreCheckFailed'
                Errors       = ($errors -join '; ')
            }
        }
        else {
            [PSCustomObject]@{
                ComputerName = $env:COMPUTERNAME
                Status       = 'PreCheckPassed'
                Errors       = ''
            }
        }
    }
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Private\ActiveDirectory\Disable-ADUserAccount.ps1
function Disable-ADUserAccount {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$SamAccountName,

        [Parameter()]
        [string]$DisabledOU
    )

    Write-Log -Level Info -Message ("Disabling AD account: {0}" -f $SamAccountName)

    try {
        # Disable the account
        Disable-ADAccount -Identity $SamAccountName -ErrorAction Stop

        Write-Log -Level Ok -Message ("AD account disabled: {0}" -f $SamAccountName)

        # Move to Disabled OU if provided
        if ($DisabledOU) {
            try {
                Move-ADObject -Identity (Get-ADUser -Identity $SamAccountName).DistinguishedName `
                    -TargetPath $DisabledOU -ErrorAction Stop

                Write-Log -Level Ok -Message ("Moved to Disabled OU: {0}" -f $DisabledOU)
                $moved = $true
            }
            catch {
                Write-Log -Level Warn -Message ("Failed to move user to Disabled OU: {0}" -f $_.Exception.Message)
                $moved = $false
            }
        }
        else {
            $moved = $false
        }

        # Optional: stamp description
        try {
            Set-ADUser -Identity $SamAccountName `
                -Description ("Disabled by TechToolbox on {0}" -f (Get-Date)) `
                -ErrorAction Stop

            Write-Log -Level Info -Message "Stamped AD description with offboarding note."
        }
        catch {
            Write-Log -Level Warn -Message ("Failed to update AD description: {0}" -f $_.Exception.Message)
        }

        return [pscustomobject]@{
            Action         = "Disable-ADUserAccount"
            SamAccountName = $SamAccountName
            Disabled       = $true
            MovedToOU      = $moved
            OU             = $DisabledOU
            Success        = $true
        }
    }
    catch {
        Write-Log -Level Error -Message ("Failed to disable AD account {0}: {1}" -f $SamAccountName, $_.Exception.Message)

        return [pscustomobject]@{
            Action         = "Disable-ADUserAccount"
            SamAccountName = $SamAccountName
            Disabled       = $false
            MovedToOU      = $false
            OU             = $DisabledOU
            Success        = $false
            Error          = $_.Exception.Message
        }
    }
}
[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Private\ActiveDirectory\Format-UserRecord.ps1
function Format-UserRecord {
    <#
    .SYNOPSIS
        Normalizes user data from local Active Directory (AD-only) to a single
        record.
    .DESCRIPTION
        Accepts a raw AD user object (Get-ADUser -Properties * recommended) and
        outputs a unified PSCustomObject, including:
          - Identity: Sam, UPN, DisplayName, ObjectGuid, DN
          - Mailbox: Primary SMTP (from proxyAddresses), all SMTP aliases
          - Useful attributes: Enabled, WhenCreated, LastLogon, Department,
            Title
          - Manager resolution: name, UPN, sAM, mail (from manager DN)
          - MemberOf resolution: group Name, sAM, Scope/Category (from DNs)
            Caches manager and group lookups within the session to avoid
            repeated queries.
    .PARAMETER AD
        Raw AD user object (Get-ADUser -Properties * result).
    .PARAMETER Server
        Optional domain controller to target (e.g., dc01.domain.local).
    .PARAMETER Credential
        Optional PSCredential for AD lookups (manager/group resolution).
    .PARAMETER ResolveManager
        Resolve Manager DN to user details (default: On).
    .PARAMETER ResolveGroups
        Resolve MemberOf DNs to group details (default: On).
    .OUTPUTS
        PSCustomObject
    #>
    [CmdletBinding()]
    param(
        [Parameter(ValueFromPipelineByPropertyName, Mandatory = $true)]
        $AD,

        [string]$Server,
        [pscredential]$Credential,

        [switch]$ResolveManager,
        [switch]$ResolveGroups
    )

    begin {
        # Prepare caches (module/script-scoped, session-lifetime)
        if (-not (Get-Variable -Name __TT_ManagerCache -Scope Script -ErrorAction SilentlyContinue)) {
            Set-Variable -Name __TT_ManagerCache -Scope Script -Value (@{}) -Force
        }
        if (-not (Get-Variable -Name __TT_GroupCache -Scope Script -ErrorAction SilentlyContinue)) {
            Set-Variable -Name __TT_GroupCache -Scope Script -Value (@{}) -Force
        }

        # Prepare caches (session-scoped)
        if (-not $script:__TT_ManagerCache) { $script:__TT_ManagerCache = @{} }
        if (-not $script:__TT_GroupCache) { $script:__TT_GroupCache = @{} }

        function Convert-FileTimeSafe {
            param([Nullable[long]]$FileTime)
            if (-not $FileTime) { return $null }
            try { [DateTime]::FromFileTimeUtc([Int64]$FileTime) } catch { $null }
        }

        function Get-CachedADUserByDn {
            param([string]$Dn, [string]$Server, [pscredential]$Credential)
            if (-not $Dn) { return $null }
            $key = $Dn.ToLowerInvariant()
            if ($script:__TT_ManagerCache.ContainsKey($key)) { return $script:__TT_ManagerCache[$key] }

            if (-not (Get-Module -ListAvailable -Name ActiveDirectory)) {
                throw "ActiveDirectory module is not available. Install RSAT or run on a domain-joined admin workstation."
            }
            Import-Module ActiveDirectory -ErrorAction Stop

            try {
                $p = @{
                    Identity    = $Dn
                    Properties  = @('DisplayName', 'UserPrincipalName', 'SamAccountName', 'mail')
                    ErrorAction = 'Stop'
                }
                if ($Server) { $p['Server'] = $Server }
                if ($Credential) { $p['Credential'] = $Credential }
                $u = Get-ADUser @p
                $script:__TT_ManagerCache[$key] = $u
                return $u
            }
            catch {
                $script:__TT_ManagerCache[$key] = $null
                return $null
            }
        }

        function Get-CachedADGroupByDn {
            param([string]$Dn, [string]$Server, [pscredential]$Credential)
            if (-not $Dn) { return $null }
            $key = $Dn.ToLowerInvariant()
            if ($script:__TT_GroupCache.ContainsKey($key)) { return $script:__TT_GroupCache[$key] }

            if (-not (Get-Module -ListAvailable -Name ActiveDirectory)) {
                throw "ActiveDirectory module is not available. Install RSAT or run on a domain-joined admin workstation."
            }
            Import-Module ActiveDirectory -ErrorAction Stop

            try {
                $p = @{
                    Identity    = $Dn
                    Properties  = @('Name', 'SamAccountName', 'GroupCategory', 'GroupScope')
                    ErrorAction = 'Stop'
                }
                if ($Server) { $p['Server'] = $Server }
                if ($Credential) { $p['Credential'] = $Credential }
                $g = Get-ADGroup @p
                $script:__TT_GroupCache[$key] = $g
                return $g
            }
            catch {
                $script:__TT_GroupCache[$key] = $null
                return $null
            }
        }

        function Edit-ProxyAddresses {
            param([object]$AdUser)
            $raw = @()
            if ($AdUser -and $AdUser.PSObject.Properties['proxyAddresses'] -and $AdUser.proxyAddresses) {
                $raw = @($AdUser.proxyAddresses)
            }
            $primary = ($raw | Where-Object { $_ -is [string] -and $_.StartsWith('SMTP:') } | Select-Object -First 1)
            $primaryEmail = if ($primary) { $primary.Substring(5) } else { $null }

            # All SMTP (primary + aliases), normalized to bare addresses
            $allSmtp = $raw |
            Where-Object { $_ -is [string] -and $_ -match '^(?i)smtp:' } |
            ForEach-Object { $_ -replace '^(?i)smtp:', '' }

            [pscustomobject]@{
                PrimarySmtp = $primaryEmail
                AllSmtp     = $allSmtp
                Raw         = $raw
            }
        }
    }

    process {
        $oldEAP = $ErrorActionPreference
        $ErrorActionPreference = 'Stop'
        try {
            if (-not $AD) { return $null }

            # Core identity fields
            $sam = $AD.PSObject.Properties['SamAccountName']    ? $AD.SamAccountName    : $null
            $upn = $AD.PSObject.Properties['UserPrincipalName'] ? $AD.UserPrincipalName : $null
            $dn = $AD.PSObject.Properties['DistinguishedName'] ? $AD.DistinguishedName : $null
            $mail = $AD.PSObject.Properties['Mail']              ? $AD.Mail              : $null
            $name = if ($AD.PSObject.Properties['DisplayName'] -and $AD.DisplayName) { $AD.DisplayName } elseif ($AD.PSObject.Properties['Name']) { $AD.Name } else { $null }

            # ProxyAddresses -> mailbox (primary + aliases)
            $px = Edit-ProxyAddresses -AdUser $AD
            $primarySmtp = $px.PrimarySmtp
            $allSmtp = $px.AllSmtp
            $proxyRaw = $px.Raw

            # Fill Mail using primary SMTP, then UPN if still blank
            if (-not $mail -and $primarySmtp) { $mail = $primarySmtp }
            if (-not $mail -and $upn) { $mail = $upn }

            # Manager resolution (DN -> user)
            $mgrDn = $AD.PSObject.Properties['Manager'] ? $AD.Manager : $null
            $mgrUpn = $null; $mgrName = $null; $mgrSam = $null; $mgrMail = $null
            if ($ResolveManager -and $mgrDn) {
                $mgr = Get-CachedADUserByDn -Dn $mgrDn -Server $Server -Credential $Credential
                if ($mgr) {
                    $mgrUpn = $mgr.UserPrincipalName
                    $mgrName = $mgr.DisplayName
                    $mgrSam = $mgr.SamAccountName
                    $mgrMail = $mgr.mail
                }
            }

            # Group resolution
            $memberOfDn = @()
            if ($AD.PSObject.Properties['MemberOf'] -and $AD.MemberOf) { $memberOfDn = @($AD.MemberOf) }

            $memberOfResolved = @()
            $memberOfNames = @()
            $memberOfSams = @()

            if ($ResolveGroups -and $memberOfDn.Count -gt 0) {
                foreach ($gDn in $memberOfDn) {
                    $g = Get-CachedADGroupByDn -Dn $gDn -Server $Server -Credential $Credential
                    if ($g) {
                        $memberOfResolved += [pscustomobject]@{
                            Name              = $g.Name
                            SamAccountName    = $g.SamAccountName
                            GroupScope        = $g.GroupScope
                            GroupCategory     = $g.GroupCategory
                            DistinguishedName = $g.DistinguishedName
                            ObjectGuid        = $g.ObjectGuid
                        }
                        $memberOfNames += $g.Name
                        $memberOfSams += $g.SamAccountName
                    }
                    else {
                        $memberOfResolved += [pscustomobject]@{
                            Name              = $null
                            SamAccountName    = $null
                            GroupScope        = $null
                            GroupCategory     = $null
                            DistinguishedName = $gDn
                            ObjectGuid        = $null
                        }
                    }
                }
            }

            # LastLogonTimestamp -> DateTime (UTC)
            $lastLogon = $null
            if ($AD.PSObject.Properties['lastLogonTimestamp'] -and $AD.lastLogonTimestamp) {
                $lastLogon = Convert-FileTimeSafe $AD.lastLogonTimestamp
            }

            # --- Password/Expiry calculations (AD-only) ---
            # "Password never expires" flag (redundancy-safe: uses both the friendly prop and the UAC bit)
            $PasswordNeverExpires = $false
            if ($AD.PSObject.Properties['PasswordNeverExpires']) {
                $PasswordNeverExpires = [bool]$AD.PasswordNeverExpires
            }
            if ($AD.PSObject.Properties['userAccountControl']) {
                # UAC bit 0x10000 = DON'T_EXPIRE_PASSWORD
                $PasswordNeverExpires = $PasswordNeverExpires -or ( ($AD.userAccountControl -band 0x10000) -ne 0 )
            }

            # Must change at next logon => pwdLastSet = 0
            $MustChangePasswordAtNextLogon = $false
            if ($AD.PSObject.Properties['pwdLastSet']) {
                $MustChangePasswordAtNextLogon = ($AD.pwdLastSet -eq 0)
            }

            # Try to get the computed expiry time (works with FGPP)
            $PasswordExpiryTime = $null
            if ($AD.PSObject.Properties['msDS-UserPasswordExpiryTimeComputed'] -and $AD.'msDS-UserPasswordExpiryTimeComputed') {
                try {
                    $PasswordExpiryTime = [datetime]::FromFileTimeUtc([int64]$AD.'msDS-UserPasswordExpiryTimeComputed').ToLocalTime()
                }
                catch {
                    $PasswordExpiryTime = $null
                }
            }

            # Fall back to constructed PasswordExpired if present (some DCs expose it)
            $PasswordExpired = $null
            if ($MustChangePasswordAtNextLogon) {
                $PasswordExpired = $true
            }
            elseif ($PasswordNeverExpires) {
                $PasswordExpired = $false
            }
            elseif ($PasswordExpiryTime) {
                $PasswordExpired = ($PasswordExpiryTime -le (Get-Date))
            }
            elseif ($AD.PSObject.Properties['PasswordExpired']) {
                # Last resort (constructed attribute, not always populated).
                $PasswordExpired = [bool]$AD.PasswordExpired
            }

            # Convenience: how many days remain until expiry
            $DaysUntilPasswordExpiry = $null
            if ($PasswordExpiryTime) {
                $DaysUntilPasswordExpiry = [int]([math]::Floor(($PasswordExpiryTime - (Get-Date)).TotalDays))
            }

            # Emit normalized AD-only record
            [pscustomobject]@{
                # Identity
                SamAccountName                = $sam
                UserPrincipalName             = $upn
                DisplayName                   = $name
                ObjectSid                     = $AD.ObjectSid
                DistinguishedName             = $dn

                # Mailbox / addresses
                Mail                          = $mail
                PrimarySmtpAddress            = $primarySmtp
                SmtpAddresses                 = $allSmtp
                ProxyAddressesRaw             = $proxyRaw

                # AD attributes
                Enabled                       = ($AD.PSObject.Properties['Enabled']      ? [bool]$AD.Enabled : $null)
                WhenCreated                   = ($AD.PSObject.Properties['whenCreated']  ? $AD.whenCreated   : $null)
                LastLogon                     = $lastLogon
                Department                    = ($AD.PSObject.Properties['Department']   ? $AD.Department    : $null)
                Title                         = ($AD.PSObject.Properties['Title']        ? $AD.Title         : $null)

                # Manager (resolved)
                ManagerDn                     = $mgrDn
                ManagerUpn                    = $mgrUpn
                ManagerName                   = $mgrName
                ManagerSamAccountName         = $mgrSam
                ManagerMail                   = $mgrMail

                # Group membership (resolved)
                MemberOfDn                    = $memberOfDn
                MemberOfNames                 = $memberOfNames
                MemberOfSamAccountNames       = $memberOfSams
                MemberOfResolved              = $memberOfResolved

                # Password / expiry (AD-only)
                PasswordExpired               = $PasswordExpired
                PasswordExpiryTime            = $PasswordExpiryTime
                DaysUntilPasswordExpiry       = $DaysUntilPasswordExpiry
                MustChangePasswordAtNextLogon = $MustChangePasswordAtNextLogon
                PasswordNeverExpires          = $PasswordNeverExpires

                # Provenance
                Source                        = 'AD'
                FoundInAD                     = $true

                # Raw for troubleshooting
                RawAD                         = $AD
            }

        }
        catch {
            if (Get-Command -Name Write-Log -ErrorAction SilentlyContinue) {
                Write-Log -Level Error -Message ("[Format-UserRecord] Failed: {0}" -f $_.Exception.Message)
            }
            else {
                Write-Error ("[Format-UserRecord] Failed: {0}" -f $_.Exception.Message)
            }
            throw
        }
        finally {
            $ErrorActionPreference = $oldEAP
        }
    }
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Private\ActiveDirectory\Move-UserToDisabledOU.ps1
function Move-UserToDisabledOU {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$SamAccountName,

        [Parameter(Mandatory)]
        [string]$TargetOU
    )

    Write-Log -Level Info -Message ("Moving AD user '{0}' to Disabled OU..." -f $SamAccountName)

    try {
        $user = Get-ADUser -Identity $SamAccountName -ErrorAction Stop

        Move-ADObject -Identity $user.DistinguishedName `
            -TargetPath $TargetOU `
            -ErrorAction Stop

        Write-Log -Level Ok -Message ("Moved '{0}' to {1}" -f $SamAccountName, $TargetOU)

        return [pscustomobject]@{
            Action         = "Move-UserToDisabledOU"
            SamAccountName = $SamAccountName
            TargetOU       = $TargetOU
            Success        = $true
        }
    }
    catch {
        Write-Log -Level Error -Message ("Failed to move user '{0}' to Disabled OU: {1}" -f $SamAccountName, $_.Exception.Message)

        return [pscustomobject]@{
            Action         = "Move-UserToDisabledOU"
            SamAccountName = $SamAccountName
            TargetOU       = $TargetOU
            Success        = $false
            Error          = $_.Exception.Message
        }
    }
}
[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Private\ActiveDirectory\New-ADUserNormalize.ps1
function New-ADUserNormalize([string]$s) { ($s -replace '\s+', '').ToLower() }
[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Private\ActiveDirectory\Remove-ADUserGroups.ps1
function Remove-ADUserGroups {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$SamAccountName
    )

    Write-Log -Level Info -Message ("Cleaning up AD group memberships for: {0}" -f $SamAccountName)

    $protectedGroups = @(
        "Domain Users",
        "Authenticated Users",
        "Everyone",
        "Users"
    )

    try {
        $user = Get-ADUser -Identity $SamAccountName -Properties MemberOf -ErrorAction Stop
    }
    catch {
        Write-Log -Level Error -Message ("Failed to retrieve AD user {0}: {1}" -f $SamAccountName, $_.Exception.Message)
        return [pscustomobject]@{
            Action         = "Cleanup-ADUserGroups"
            SamAccountName = $SamAccountName
            Success        = $false
            Error          = $_.Exception.Message
        }
    }

    $removed = @()
    $failed = @()

    foreach ($dn in $user.MemberOf) {
        try {
            $group = Get-ADGroup -Identity $dn -ErrorAction Stop

            # Skip protected groups
            if ($protectedGroups -contains $group.Name) {
                Write-Log -Level Info -Message ("Skipping protected group: {0}" -f $group.Name)
                continue
            }

            # Remove membership
            Remove-ADGroupMember -Identity $group.DistinguishedName `
                -Members $user.DistinguishedName `
                -Confirm:$false `
                -ErrorAction Stop

            Write-Log -Level Ok -Message ("Removed from group: {0}" -f $group.Name)
            $removed += $group.Name
        }
        catch {
            Write-Log -Level Warn -Message ("Failed to remove from group {0}: {1}" -f $dn, $_.Exception.Message)
            $failed += $dn
        }
    }

    return [pscustomobject]@{
        Action         = "Cleanup-ADUserGroups"
        SamAccountName = $SamAccountName
        Removed        = $removed
        Failed         = $failed
        Success        = $true
    }
}
[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Private\ActiveDirectory\Resolve-Naming.ps1
function Resolve-Naming {
    param(
        [hashtable]$Naming,
        [string]$GivenName,
        [string]$Surname
    )
    $f = New-ADUserNormalize $GivenName
    $l = New-ADUserNormalize $Surname

    # UPN prefix
    switch ($Naming.upnPattern) {
        'first.last' { $upnPrefix = "$f.$l" }
        'flast' { $upnPrefix = '{0}{1}' -f $f.Substring(0, 1), $l }
        default { $upnPrefix = "$f.$l" }
    }

    # SAM
    switch ($Naming.samPattern) {
        'first.last' { $sam = "$f.$l" }
        'flast' { $sam = '{0}{1}' -f $f.Substring(0, 1), $l }
        default { $sam = '{0}{1}' -f $f.Substring(0, 1), $l }
    }

    [pscustomobject]@{
        UpnPrefix = $upnPrefix
        Sam       = $sam
    }
}
[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Private\ActiveDirectory\Write-OffboardingSummary.ps1
function Write-OffboardingSummary {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        $User,

        [Parameter(Mandatory)]
        $Results
    )

    Write-Log -Level Info -Message ("Writing offboarding summary for: {0}" -f $User.UserPrincipalName)

    try {
        # Load config
        $off = $script:cfg.settings.offboarding

        # Determine output directory from config
        $root = $off.log.dir
        if (-not $root) {
            # Fallback for safety
            $root = Join-Path $env:TEMP "TechToolbox-Offboarding"
            Write-Log -Level Warn -Message "offboarding.logDir not found in config. Using TEMP fallback."
        }

        # Ensure directory exists
        if (-not (Test-Path $root)) {
            New-Item -Path $root -ItemType Directory | Out-Null
        }

        # Filename
        $file = Join-Path $root ("OffboardingSummary_{0}_{1}.txt" -f `
                $User.SamAccountName, (Get-Date -Format "yyyyMMdd_HHmmss"))

        # Build summary content
        $lines = @()
        $lines += "==============================================="
        $lines += " TechToolbox Offboarding Summary"
        $lines += "==============================================="
        $lines += ""
        $lines += "User:              {0}" -f $User.UserPrincipalName
        $lines += "Display Name:      {0}" -f $User.DisplayName
        $lines += "SamAccountName:    {0}" -f $User.SamAccountName
        $lines += "Timestamp:         {0}" -f (Get-Date)
        $lines += ""
        $lines += "-----------------------------------------------"
        $lines += " Actions Performed"
        $lines += "-----------------------------------------------"

        foreach ($key in $Results.Keys) {
            $step = $Results[$key]

            $lines += ""
            $lines += "[$key]"

            # Normalize Action
            $action = $null
            if ($step -and $step.PSObject.Properties['Action']) {
                $action = $step.Action
            }
            else {
                $action = $key
            }
            $lines += "  Action: $action"

            # Normalize Success
            $success = $null
            if ($step -and $step.PSObject.Properties['Success']) {
                $success = $step.Success
            }
            else {
                # If no Success property, assume unknown
                $success = "Unknown"
            }
            $lines += "  Success: $success"

            # Dump all other properties
            if ($step) {
                foreach ($p in $step.PSObject.Properties.Name) {
                    if ($p -in @("Action", "Success")) { continue }
                    $value = $step.$p
                    if ($null -eq $value) { $value = "" }
                    $lines += "  ${p}: $value"
                }
            }
            else {
                $lines += "  (no data)"
            }
        }

        $lines += ""
        $lines += "==============================================="
        $lines += " End of Summary"
        $lines += "==============================================="

        # Write file
        $lines | Out-File -FilePath $file -Encoding UTF8

        Write-Log -Level Ok -Message ("Offboarding summary written to: {0}" -f $file)

        return [pscustomobject]@{
            Action   = "Write-OffboardingSummary"
            FilePath = $file
            Success  = $true
        }
    }
    catch {
        Write-Log -Level Error -Message ("Failed to write offboarding summary: {0}" -f $_.Exception.Message)

        return [pscustomobject]@{
            Action  = "Write-OffboardingSummary"
            Success = $false
            Error   = $_.Exception.Message
        }
    }
}
[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Private\AI\Format-FileName.ps1
function Format-FileName {
    param([string]$Name)
    return ($Name -replace '[\\/:*?"<>|]', '-')
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Private\AI\Get-ModuleSource.ps1
function Get-ModuleSource {
    param([string]$ModuleRoot)

    Get-ChildItem -Path $ModuleRoot -Recurse -Include *.ps1, *.psm1 |
    Sort-Object FullName |
    ForEach-Object {
        "### FILE: $($_.FullName)`n" +
        (Get-Content $_.FullName -Raw) +
        "`n`n"
    } |
    Out-String
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Private\AI\Invoke-LocalLLM.ps1
function Invoke-LocalLLM {
    <#
    .SYNOPSIS
        Sends a prompt to a local LLM HTTP API and returns the full text
        response.

    .DESCRIPTION
        This function posts a JSON payload containing a model name and prompt to
        a local HTTP endpoint (Ollama-style /api/generate), reads the streaming
        JSONL response, and concatenates the `response` tokens into a single
        string.

        It uses HttpClient with ResponseHeadersRead to support streaming, parses
        each non-empty line as JSON, and safely skips malformed lines.

    .PARAMETER Prompt
        The text prompt to send to the local LLM.

    .PARAMETER Model
        The model name to use on the local LLM endpoint. Defaults to
        'qwen2.5-coder:14b'.

    .OUTPUTS
        System.String The concatenated response text from the local LLM.

    .NOTES
        Requires a local HTTP endpoint compatible with: POST /api/generate {
        "model": "<model>", "prompt": "<prompt>" }
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$Prompt,

        [string]$Model = 'qwen2.5-coder:14b'
    )

    # Base URL and request URI kept in variables for reuse and clarity
    $baseUrl = 'http://localhost:11434/api'
    $requestUri = "$baseUrl/generate"

    # Build JSON body
    $body = @{
        model = $Model
        prompt = $Prompt
    } | ConvertTo-Json

    # Prepare HTTP objects
    $handler = $null
    $client = $null
    $request = $null
    $response = $null
    $stream = $null
    $reader = $null

    # Accumulate full text from streaming tokens
    $fullText = ''

    try {
        Write-Log -Level Warn -Message ("`nInvoking local LLM at '{0}' with model '{1}'..." -f $requestUri, $Model)
        # HttpClient handler and client
        $handler = [System.Net.Http.HttpClientHandler]::new()
        $client = [System.Net.Http.HttpClient]::new($handler)

        # Request message
        $request = [System.Net.Http.HttpRequestMessage]::new()
        $request.Method = [System.Net.Http.HttpMethod]::Post
        $request.RequestUri = $requestUri
        $request.Content = [System.Net.Http.StringContent]::new(
            $body,
            [System.Text.Encoding]::UTF8,
            'application/json'
        )

        # Send request with streaming semantics
        $response = $client.SendAsync(
            $request,
            [System.Net.Http.HttpCompletionOption]::ResponseHeadersRead
        ).Result

        if (-not $response.IsSuccessStatusCode) {
            throw "Local LLM endpoint returned HTTP $($response.StatusCode) ($($response.ReasonPhrase))."
        }

        # Get response stream and reader
        $stream = $response.Content.ReadAsStreamAsync().Result
        $reader = [System.IO.StreamReader]::new($stream)

        # Read line-by-line (JSONL)
        while (-not $reader.EndOfStream) {
            $line = $reader.ReadLine()

            if ([string]::IsNullOrWhiteSpace($line)) {
                continue
            }

            try {
                $obj = $line | ConvertFrom-Json
            }
            catch {
                # Malformed JSON line; log and continue
                Write-Log -Level Warn -Message ("Malformed JSON from LLM stream: {0}" -f $line)
                continue
            }

            if ($null -ne $obj -and $obj.PSObject.Properties.Name -contains 'response' -and $obj.response) {
                # Append token to full text
                $fullText += $obj.response
            }
        }
    }
    catch {
        # Surface a clear error and rethrow for callers if needed
        Write-Log -Level Error -Message ("Error invoking local LLM: {0}" -f $_.Exception.Message)
        throw
    }
    finally {
        # Dispose IDisposable resources safely
        if ($null -ne $reader) { $reader.Dispose() }
        if ($null -ne $stream) { $stream.Dispose() }
        if ($null -ne $response) { $response.Dispose() }
        if ($null -ne $request) { $request.Dispose() }
        if ($null -ne $client) { $client.Dispose() }
        if ($null -ne $handler) { $handler.Dispose() }
    }

    # Optional: log a blank line or summary if you like
    Write-Log -Level OK -Message ("Local LLM call completed for model '{0}'." -f $Model)

    return $fullText
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Private\Browser\Clear-CacheForProfile.ps1

function Clear-CacheForProfile {
    [CmdletBinding(SupportsShouldProcess = $true)]
    param([Parameter(Mandatory)][string]$ProfilePath)

    $cacheTargets = @(
        (Join-Path $ProfilePath 'Cache'),
        (Join-Path $ProfilePath 'Code Cache'),
        (Join-Path $ProfilePath 'GPUCache'),
        (Join-Path $ProfilePath 'Service Worker'),
        (Join-Path $ProfilePath 'Application Cache'),
        (Join-Path $ProfilePath 'Network\Cache')
    )

    $removedCount = 0
    foreach ($cachePath in $cacheTargets) {
        try {
            if (Test-Path -LiteralPath $cachePath) {
                if ($PSCmdlet.ShouldProcess($cachePath, 'Clear cache contents')) {
                    Remove-Item -LiteralPath (Join-Path $cachePath '*') -Recurse -Force -ErrorAction SilentlyContinue
                    $removedCount++
                    Write-Log -Level Ok -Message "Cleared cache content: $cachePath"
                }
            }
            else {
                Write-Log -Level Info -Message "Cache path not present: $cachePath"
            }
        }
        catch {
            Write-Log -Level Warn -Message ("Error clearing cache at '{0}': {1}" -f $cachePath, $_.Exception.Message)
        }
    }

    [PSCustomObject]@{
        CacheTargetsProcessed = $cacheTargets.Count
        CacheTargetsCleared   = $removedCount
    }
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Private\Browser\Clear-CookiesForProfile.ps1

function Clear-CookiesForProfile {
    [CmdletBinding(SupportsShouldProcess = $true)]
    param(
        [Parameter(Mandatory)]
        [string]$ProfilePath,

        [Parameter()]
        [bool]$SkipLocalStorage = $false
    )

    # Common cookie DB targets (SQLite + journal)
    $cookieTargets = @(
        (Join-Path $ProfilePath 'Network\Cookies'),
        (Join-Path $ProfilePath 'Network\Cookies-journal'),
        (Join-Path $ProfilePath 'Cookies'),
        (Join-Path $ProfilePath 'Cookies-journal')
    )

    $cookiesRemoved = $false
    foreach ($cookiesPath in $cookieTargets) {
        try {
            if (Test-Path -LiteralPath $cookiesPath) {
                if ($PSCmdlet.ShouldProcess($cookiesPath, 'Delete cookie DB')) {
                    # Attempt a rename first to get around file locks
                    $tmp = "$cookiesPath.bak.$([guid]::NewGuid().ToString('N'))"
                    $renamed = $false
                    try {
                        Rename-Item -LiteralPath $cookiesPath -NewName (Split-Path -Path $tmp -Leaf) -ErrorAction Stop
                        $renamed = $true
                        $cookiesPath = $tmp
                    }
                    catch {
                        # If rename fails (e.g., path not a file or locked), continue with direct delete
                    }

                    Remove-Item -LiteralPath $cookiesPath -Force -ErrorAction SilentlyContinue
                    $cookiesRemoved = $true
                    Write-Log -Level Ok -Message ("Removed cookie DB: {0}" -f $cookiesPath)
                }
            }
            else {
                Write-Log -Level Info -Message ("Cookie DB not present: {0}" -f $cookiesPath)
            }
        }
        catch {
            Write-Log -Level Warn -Message ("Error removing cookies DB '{0}': {1}" -f $cookiesPath, $_.Exception.Message)
        }
    }

    $localStorageCleared = $false
    $localTargets = @()
    if (-not $SkipLocalStorage) {
        # Core local storage path
        $localStoragePath = Join-Path $ProfilePath 'Local Storage'
        $localTargets += $localStoragePath

        # Optional modern/related site data (uncomment any you want)
        $localTargets += @(
            (Join-Path $ProfilePath 'Local Storage\leveldb'),
            (Join-Path $ProfilePath 'IndexedDB'),
            (Join-Path $ProfilePath 'Session Storage')
            # (Join-Path $ProfilePath 'Web Storage')    # rare / variant
            # (Join-Path $ProfilePath 'Storage')         # umbrella in some builds
        )

        foreach ($lt in $localTargets | Select-Object -Unique) {
            if (Test-Path -LiteralPath $lt) {
                try {
                    if ($PSCmdlet.ShouldProcess($lt, 'Clear Local Storage/Site Data')) {
                        Remove-Item -LiteralPath (Join-Path $lt '*') -Recurse -Force -ErrorAction SilentlyContinue
                        $localStorageCleared = $true
                        Write-Log -Level Ok -Message ("Cleared local storage/site data: {0}" -f $lt)
                    }
                }
                catch {
                    Write-Log -Level Warn -Message ("Error clearing local storage at '{0}': {1}" -f $lt, $_.Exception.Message)
                }
            }
            else {
                Write-Log -Level Info -Message ("Local storage path not present: {0}" -f $lt)
            }
        }
    }
    else {
        Write-Log -Level Info -Message "Local storage cleanup skipped by configuration."
    }

    # Return practical status for the driver
    [PSCustomObject]@{
        CookiesRemoved       = $cookiesRemoved
        LocalStorageCleared  = $localStorageCleared
        CookieTargetsChecked = $cookieTargets.Count
        LocalTargetsChecked  = $localTargets.Count
    }
}
[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Private\Browser\Get-BrowserProfileFolders.ps1

function Get-BrowserProfileFolders {
    <#
    .SYNOPSIS
    Returns Chromium profile directories (Default, Profile N, Guest Profile).
    Excludes System Profile by default.
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$UserDataPath,

        [Parameter()]
        [switch]$IncludeAllNames  # when set, return all directories except 'System Profile'
    )

    if (-not (Test-Path -LiteralPath $UserDataPath)) {
        Write-Log -Level Error -Message "User Data path not found: $UserDataPath"
        return @()
    }

    $dirs = Get-ChildItem -Path $UserDataPath -Directory -ErrorAction SilentlyContinue

    if ($IncludeAllNames) {
        # Return everything except System Profile
        return $dirs | Where-Object { $_.Name -ne 'System Profile' }
    }

    # Default filter: typical Chromium profiles
    $profiles = $dirs | Where-Object {
        $_.Name -eq 'Default' -or
        $_.Name -match '^Profile \d+$' -or
        $_.Name -eq 'Guest Profile'
    }

    # Exclude internal/system profile explicitly
    $profiles = $profiles | Where-Object { $_.Name -ne 'System Profile' }

    return $profiles
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Private\Browser\Get-BrowserUserDataPath.ps1

function Get-BrowserUserDataPath {
    <#
    .SYNOPSIS
    Returns the Chromium 'User Data' path for Chrome/Edge on Windows.
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [ValidateSet('Chrome', 'Edge')]
        [string]$Browser
    )

    $base = $env:LOCALAPPDATA
    if ([string]::IsNullOrWhiteSpace($base)) {
        Write-Log -Level Error -Message "LOCALAPPDATA is not set; cannot resolve User Data path."
        return $null
    }

    $path = switch ($Browser) {
        'Chrome' { Join-Path $base 'Google\Chrome\User Data' }
        'Edge' { Join-Path $base 'Microsoft\Edge\User Data' }
    }

    if (-not (Test-Path -LiteralPath $path)) {
        Write-Log -Level Warn -Message "User Data path not found for ${Browser}: $path"
        # still return it; the caller will handle empty profile enumeration gracefully
    }

    return $path
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Private\Exchange\EXOHelpers\Connect-ExchangeOnlineIfNeeded.ps1

function Connect-ExchangeOnlineIfNeeded {
    <#
    .SYNOPSIS
        Connects to Exchange Online only if no active connection exists.
    .PARAMETER ShowProgress
        Whether to show progress per config (ExchangeOnline.ShowProgress).
    #>
    [CmdletBinding()]
    param([Parameter()][bool]$ShowProgress = $false)

    try {
        $active = $null
        try { $active = Get-ConnectionInformation } catch { }
        if (-not $active) {
            Write-Log -Level Info -Message "Connecting to Exchange Online..."
            Connect-ExchangeOnline -ShowProgress:$ShowProgress
        }
    }
    catch {
        Write-Log -Level Error -Message ("Failed to connect to Exchange Online: {0}" -f $_.Exception.Message)
        throw
    }
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Private\Exchange\EXOHelpers\Export-MessageTraceResults.ps1

function Export-MessageTraceResults {
    <#
    .SYNOPSIS
        Exports message trace summary and details to CSV.
    .DESCRIPTION
        Creates the export folder if needed and writes Summary/Details CSVs.
        Honours -WhatIf/-Confirm via SupportsShouldProcess.
    .PARAMETER Summary
        Summary objects (Received, SenderAddress, RecipientAddress, Subject,
        Status, MessageTraceId).
    .PARAMETER Details
        Detail objects (Recipient, MessageTraceId, Date, Event, Detail).
    .PARAMETER ExportFolder
        Target folder for CSVs.
    #>
    [CmdletBinding(SupportsShouldProcess = $true)]
    param(
        [Parameter(Mandatory)][object[]]$Summary,
        [Parameter()][object[]]$Details,
        [Parameter(Mandatory)][string]$ExportFolder
    )

    $ExportFolder = $script:cfg.settings.messageTrace.defaultExportFolder
    $summaryPattern = $script:cfg.settings.messageTrace.summaryFileNamePattern
    $detailsPattern = $script:cfg.settings.messageTrace.detailsFileNamePattern
    $tsFormat = $script:cfg.settings.messageTrace.timestampFormat

    try {
        if ($PSCmdlet.ShouldProcess($ExportFolder, 'Ensure export folder')) {
            if (-not (Test-Path -LiteralPath $ExportFolder)) {
                New-Item -Path $ExportFolder -ItemType Directory -Force | Out-Null
            }
        }

        $ts = (Get-Date).ToString($tsFormat)
        $sumPath = Join-Path -Path $ExportFolder -ChildPath ($summaryPattern -f $ts)
        $detPath = Join-Path -Path $ExportFolder -ChildPath ($detailsPattern -f $ts)

        if ($PSCmdlet.ShouldProcess($sumPath, 'Export summary CSV')) {
            $Summary | Export-Csv -Path $sumPath -NoTypeInformation -Encoding UTF8 -UseQuotes AsNeeded
        }

        if (($Details ?? @()).Count -gt 0) {
            if ($PSCmdlet.ShouldProcess($detPath, 'Export details CSV')) {
                $Details | Export-Csv -Path $detPath -NoTypeInformation -Encoding UTF8 -UseQuotes AsNeeded
            }
        }

        Write-Log -Level Ok  -Message "Export complete."
        Write-Log -Level Info -Message (" Summary: {0}" -f $sumPath)

        if (Test-Path -LiteralPath $detPath) {
            Write-Log -Level Info -Message (" Details: {0}" -f $detPath)
        }
    }
    catch {
        Write-Log -Level Error -Message ("Export failed: {0}" -f $_.Exception.Message)
        throw
    }
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Private\Exchange\EXOHelpers\Import-ExchangeOnlineModule.ps1
function Import-ExchangeOnlineModule {
    [CmdletBinding()]
    param()

    # Ensure runtime/config is initialized before accessing $script:cfg, but do NOT assume it will succeed.
    if (-not $script:cfg) {
        try {
            Initialize-TechToolboxRuntime -ErrorAction Stop
        }
        catch {
            # Don't fail hard herestill allow fallbacks to work
            Write-Verbose "Initialize-TechToolboxRuntime failed or not available; proceeding with defaults. Error: $($_.Exception.Message)"
        }
    }

    # ---- Resolve dependency root & version safely from $script:cfg ----
    # Note: Use null-safe access and fallbacks; DO NOT dereference in param defaults.
    $DependencyRoot = $null
    $RequiredVersion = $null

    # Prefer existing schema: cfg.dependencies + cfg.dependencies.requiredVersion
    if ($script:cfg) {
        if ($script:cfg.PSObject.Properties.Match('dependencies').Count) {
            $DependencyRoot = $script:cfg.dependencies
            if ($script:cfg.dependencies -is [hashtable] -or $script:cfg.dependencies -is [pscustomobject]) {
                if ($script:cfg.dependencies.PSObject.Properties.Match('requiredVersion').Count) {
                    $RequiredVersion = $script:cfg.dependencies.requiredVersion
                }
            }
        }
    }

    # Fallbacks if config didnt provide values
    if (-not $DependencyRoot -or [string]::IsNullOrWhiteSpace([string]$DependencyRoot)) {
        $DependencyRoot = 'C:\TechToolbox\Dependencies'
    }
    if (-not $RequiredVersion -or [string]::IsNullOrWhiteSpace([string]$RequiredVersion)) {
        $RequiredVersion = '3.9.2'
    }

    $exoRoot = Join-Path $DependencyRoot 'ExchangeOnlineManagement'
    $manifest = Join-Path (Join-Path $exoRoot $RequiredVersion) 'ExchangeOnlineManagement.psd1'

    # 1) Prefer the in-house exact version
    if (Test-Path -LiteralPath $manifest) {
        Import-Module $manifest -Force -ErrorAction Stop
        $mod = Get-Module ExchangeOnlineManagement -ListAvailable |
        Where-Object { $_.Version -eq [version]$RequiredVersion } |
        Select-Object -First 1
        if ($mod) {
            Write-Information "Imported ExchangeOnlineManagement v$RequiredVersion from: $($mod.Path)" -InformationAction Continue
            return
        }
        else {
            throw "Unexpected: Could not verify ExchangeOnlineManagement v$RequiredVersion after import. Manifest used: $manifest"
        }
    }

    # 2) If the in-house exact version is missing, try discovering the exact version via PSModulePath
    $available = Get-Module ExchangeOnlineManagement -ListAvailable | Sort-Object Version -Descending
    $exact = $available | Where-Object { $_.Version -eq [version]$RequiredVersion } | Select-Object -First 1
    if ($exact) {
        Import-Module $exact.Path -Force -ErrorAction Stop
        Write-Information "Imported ExchangeOnlineManagement v$RequiredVersion from PSModulePath: $($exact.Path)" -InformationAction Continue
        return
    }

    # 3) Fail with actionable guidance
    $paths = ($env:PSModulePath -split ';') -join [Environment]::NewLine
    $msg = @"
TechToolbox: ExchangeOnlineManagement v$RequiredVersion not found.
Searched:
  - In-house path: $manifest
  - PSModulePath:
$paths

Fix options:
  - Place the module here: $exoRoot\$RequiredVersion\ExchangeOnlineManagement.psd1
  - Or add the dependencies root to PSModulePath (User scope):
      [Environment]::SetEnvironmentVariable(
        'PSModulePath',
        [Environment]::GetEnvironmentVariable('PSModulePath','User') + ';$DependencyRoot', 'User')
  - Or adjust config: `dependencies.requiredVersion` or `settings.exchange.online.requiredVersion`
"@
    throw $msg
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Private\Exchange\EXOHelpers\Invoke-DisconnectExchangeOnline.ps1
function Invoke-DisconnectExchangeOnline {
    [CmdletBinding(SupportsShouldProcess)]
    [OutputType([bool])]
    param(
        # Either pass the full config or omit and it will try $global:cfg
        [pscustomobject]$Config,

        # Or pass just the exchangeOnline section explicitly
        [pscustomobject]$ExchangeOnline,

        # Skip prompting and disconnect.
        [switch]$Force,

        # Suppress prompting (opposite of Force: dont disconnect unless forced).
        [switch]$NoPrompt
    )

    # --- Resolve configuration ---
    $exoCfg = $null

    if ($PSBoundParameters.ContainsKey('ExchangeOnline') -and $ExchangeOnline) {
        $exoCfg = $ExchangeOnline
    }
    elseif ($PSBoundParameters.ContainsKey('Config') -and $Config) {
        # If full config was provided (has settings.exchangeOnline), use that
        if ($Config.PSObject.Properties.Name -contains 'settings' -and
            $Config.settings -and
            $Config.settings.PSObject.Properties.Name -contains 'exchangeOnline') {
            $exoCfg = $Config.settings.exchangeOnline
        }
        # Or if we were given the exchangeOnline section directly (has autoDisconnectPrompt), use it
        elseif ($Config.PSObject.Properties.Name -contains 'autoDisconnectPrompt') {
            $exoCfg = $Config
        }
    }
    elseif ($script:cfg) {
        $exoCfg = $script:cfg.settings.exchangeOnline
    }

    # Default: prompt unless config says otherwise
    $autoPrompt = $true
    if ($exoCfg -and $null -ne $exoCfg.autoDisconnectPrompt) {
        $autoPrompt = [bool]$exoCfg.autoDisconnectPrompt
    }

    $shouldPrompt = $autoPrompt -and -not $Force -and -not $NoPrompt

    # --- Connection check ---
    $isConnected = $false
    try {
        if (Get-Command Get-ConnectionInformation -ErrorAction SilentlyContinue) {
            $conn = Get-ConnectionInformation -ErrorAction SilentlyContinue
            $isConnected = $conn -and $conn.State -eq 'Connected'
        }
        else {
            # Older module: we can't reliably check; assume connected and let disconnect handle it
            $isConnected = $true
        }
    }
    catch {
        # If uncertain, err on the side of attempting a disconnect
        $isConnected = $true
    }

    if (-not $isConnected) {
        Write-Log -Level Info -Message "No active Exchange Online session detected."
        return $true
    }

    # --- Decide whether to proceed ---
    $proceed = $false
    if ($Force) {
        $proceed = $true
    }
    elseif ($shouldPrompt) {
        $resp = Read-Host -Prompt "Disconnect from Exchange Online? (y/N)"
        $proceed = ($resp.Trim() -match '^(y|yes)$')
    }

    if (-not $proceed) {
        Write-Log -Level Info -Message "Keeping Exchange Online session connected."
        return $false
    }

    # --- Disconnect ---
    if ($PSCmdlet.ShouldProcess('Exchange Online session', 'Disconnect')) {
        try {
            Disconnect-ExchangeOnline -Confirm:$false
            Write-Log -Level Info -Message "Disconnected from Exchange Online."
            return $true
        }
        catch {
            Write-Log -Level Warn -Message ("Failed to disconnect cleanly: {0}" -f $_.Exception.Message)
            Write-Log -Level Info -Message "Session may remain connected."
            return $false
        }
    }

    return $false
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Private\Exchange\MailHeaderAuthHelpers\Format-AuthResults.ps1
function Format-AuthResults {
    param(
        [Parameter(Mandatory)][string[]]$Lines,
        [string]$Label = 'edge'  # 'edge' (Authentication-Results) or 'origin' (Authentication-Results-Original/X-Original-Authentication-Results)
    )
    # Aggregate signals (we may have multiple A-R lines; we try to keep best-available)
    $result = [ordered]@{
        Label        = $Label
        SPF          = $null
        SPF_MailFrom = $null
        DKIM         = $null
        DKIM_Domains = @()
        DMARC        = $null
        DMARC_From   = $null
        CompAuth     = $null
        ARC          = $null
        Raw          = @()
    }

    $re = @{
        spf    = [regex]'\bspf=(?<val>[a-z]+)\b'
        spf_mf = [regex]'smtp\.mailfrom=(?<val>[^;\s]+)'
        dkim   = [regex]'\bdkim=(?<val>[a-z]+)\b'
        dkim_d = [regex]'header\.d=(?<val>[^;\s]+)'
        dmarc  = [regex]'\bdmarc=(?<val>[a-z]+)\b'
        dmarcF = [regex]'header\.from=(?<val>[^;\s]+)'
        comp   = [regex]'\bcompauth=(?<val>[a-z]+)\b'
        arc    = [regex]'\barc=(?<val>[a-z]+)\b'
    }

    foreach ($line in $Lines) {
        $result.Raw += $line

        if ($line -match $re.spf) { $result.SPF = $Matches.val }
        if ($line -match $re.spf_mf) { $result.SPF_MailFrom = $Matches.val }
        if ($line -match $re.dkim) { $result.DKIM = $Matches.val }
        if ($line -match $re.dkim_d) { $result.DKIM_Domains += $Matches.val.ToLower() }
        if ($line -match $re.dmarc) { $result.DMARC = $Matches.val }
        if ($line -match $re.dmarcF) { $result.DMARC_From = $Matches.val.ToLower() }
        if ($line -match $re.comp) { $result.CompAuth = $Matches.val }
        if ($line -match $re.arc) { $result.ARC = $Matches.val }
    }

    # De-dup DKIM domains
    $result.DKIM_Domains = $result.DKIM_Domains | Select-Object -Unique
    return [pscustomobject]$result
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Private\Exchange\MailHeaderAuthHelpers\Get-Domain.ps1
function Get-Domain {
    param([Parameter(Mandatory)][string]$Value)
    # Extract domain from addr-spec or bare domain; strip <>, quotes.
    $clean = $Value -replace '[<>"]', '' -replace '^\s+|\s+$', ''
    if ($clean -match '[^@<\s]+@(?<dom>[A-Za-z0-9.-]+\.[A-Za-z]{2,})') {
        return $Matches.dom.ToLower()
    }
    elseif ($clean -match '(?<dom>[A-Za-z0-9.-]+\.[A-Za-z]{2,})') {
        return $Matches.dom.ToLower()
    }
    return $null
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Private\Exchange\MailHeaderAuthHelpers\Get-FirstPublicIP.ps1
function Get-FirstPublicIP {
    param([Parameter(Mandatory)][string[]]$ReceivedLines)
    # Scan Received lines from bottom (earliest) to top to find first public IP.
    # Ignore RFC1918, CGNAT, loopback, link-local.
    $privateRanges = @(
        '^10\.', '^127\.', '^169\.254\.', '^172\.(1[6-9]|2[0-9]|3[0-1])\.', '^192\.168\.',
        '^100\.(6[4-9]|[7-9][0-9]|1[0-1][0-9]|12[0-7])\.' # 100.64.0.0/10 - CGNAT
    )
    $isPrivate = {
        param($ip)
        foreach ($pat in $privateRanges) { if ($ip -match $pat) { return $true } }
        return $false
    }

    # Extract IPv4s; you can extend to IPv6 if needed.
    $ipv4Regex = [regex]'(?<!\d)(?:\d{1,3}\.){3}\d{1,3}(?!\d)'
    # Manual reverse for compatibility
    for ($i = $ReceivedLines.Count - 1; $i -ge 0; $i--) {
        $line = $ReceivedLines[$i]
        $matches = $ipv4Regex.Matches($line)
        foreach ($m in $matches) {
            $ip = $m.Value
            # crude sanity: each octet <= 255
            if ($ip -split '\.' | ForEach-Object { [int]$_ } | Where-Object { $_ -gt 255 } | Measure-Object | Select-Object -ExpandProperty Count) {
                continue
            }
            if (-not (& $isPrivate $ip)) {
                return $ip
            }
        }
    }
    return $null
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Private\Exchange\MailHeaderAuthHelpers\Get-HeaderBlock.ps1
function Get-HeaderBlock {
    param([Parameter(Mandatory)][string]$HeadersText)
    # Unfold headers: join continuation lines starting with WSP to previous line
    $unfolded = [regex]::Replace($HeadersText, "(`r?`n)[ `t]+", ' ')
    # Normalize line endings to `n
    $unfolded = $unfolded -replace "`r?`n", "`n"
    $lines = $unfolded -split "`n"
    # Return both full text and array of lines for convenience
    [pscustomobject]@{
        Text  = $unfolded
        Lines = $lines
    }
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Private\Input\Read-Int.ps1

function Read-Int {
    <#
    .SYNOPSIS
        Prompts the user to enter an integer within specified bounds.
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)][string]$Prompt,
        [Parameter()][int]$Min = 16,
        [Parameter()][int]$Max = 2097152
    )

    while ($true) {
        $value = Read-Host $Prompt
        if ([int]::TryParse($value, [ref]$parsed)) {
            if ($parsed -ge $Min -and $parsed -le $Max) {
                return $parsed
            }
            Write-Log -Level Warning -Message "Enter a value between $Min and $Max."
        }
        else {
            Write-Log -Level Warning -Message "Enter a whole number (MB)."
        }
    }
}
[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Private\Loader\Initialize-Config.ps1

function Initialize-Config {
    [CmdletBinding()] param()

    if ($script:cfg -and $script:TechToolboxConfig) { return }  # already initialized

    if (-not $script:ModuleRoot) {
        $script:ModuleRoot = $ExecutionContext.SessionState.Module.ModuleBase
    }
    $configDir = Join-Path $script:ModuleRoot 'Config'
    $script:ConfigPath = Join-Path $configDir 'config.json'
    if (-not (Test-Path -LiteralPath $configDir)) {
        New-Item -Path $configDir -ItemType Directory -Force | Out-Null
    }

    try {
        $script:cfg = Get-TechToolboxConfig -Path $script:ConfigPath
    }
    catch {
        throw "[Initialize-Config] Failed to load config.json from '$script:ConfigPath': $($_.Exception.Message)"
    }

    $script:TechToolboxConfig = $script:cfg
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Private\Loader\Initialize-Environment.ps1
function Initialize-Environment {
    [CmdletBinding(SupportsShouldProcess)]
    param(
        # Where to persist the PATH change. 'Machine' requires elevation.
        [ValidateSet('User', 'Machine')]
        [string]$Scope = 'User',

        # The dependency path you want to ensure on PATH.
        [Parameter()]
        [string]$DependencyPath = 'C:\TechToolbox\Dependencies',

        # Create the dependency directory if it doesn't exist.
        [switch]$CreateIfMissing
    )

    $infoAction = if ($PSBoundParameters.ContainsKey('InformationAction')) { $InformationPreference } else { 'Continue' }

    # 1) Normalize target path early
    try {
        $normalizedPath = [System.IO.Path]::GetFullPath($DependencyPath)
    }
    catch {
        Write-Warning "Initialize-Environment: Invalid path: [$DependencyPath]. $_"
        return
    }

    # 2) Ensure directory exists (optional)
    if (-not (Test-Path -LiteralPath $normalizedPath)) {
        if ($CreateIfMissing) {
            try {
                $null = New-Item -ItemType Directory -Path $normalizedPath -Force
                Write-Information "Created directory: [$normalizedPath]" -InformationAction $infoAction
            }
            catch {
                Write-Warning "Failed to create directory [$normalizedPath]: $($_.Exception.Message)"
                return
            }
        }
        else {
            Write-Information "Dependency path does not exist: [$normalizedPath]. Skipping PATH update." -InformationAction $infoAction
            return
        }
    }

    # 3) Read current PATH for chosen scope
    $currentPathRaw = [Environment]::GetEnvironmentVariable('Path', $Scope)

    # 4) Normalize & de-duplicate PATH parts (case-insensitive comparison)
    $sep = ';'
    $parts =
    ($currentPathRaw -split $sep) |
    Where-Object { $_ -and $_.Trim() } |
    ForEach-Object { $_.Trim() } |
    Select-Object -Unique

    # Use case-insensitive membership check
    $contains = $false
    foreach ($p in $parts) {
        if ($p.TrimEnd('\') -ieq $normalizedPath.TrimEnd('\')) {
            $contains = $true
            break
        }
    }

    if (-not $contains) {
        $newPath = @($parts + $normalizedPath) -join $sep

        if ($PSCmdlet.ShouldProcess("$Scope PATH", "Add [$normalizedPath]")) {
            try {
                [Environment]::SetEnvironmentVariable('Path', $newPath, $Scope)
                Write-Information "Added [$normalizedPath] to $Scope PATH." -InformationAction $infoAction
            }
            catch {
                Write-Warning "Failed to update $Scope PATH: $($_.Exception.Message)"
                return
            }

            # 5) Ensure current session has it immediately
            $sessionHas = $false
            foreach ($p in ($env:Path -split $sep)) {
                if ($p.Trim() -and ($p.TrimEnd('\') -ieq $normalizedPath.TrimEnd('\'))) {
                    $sessionHas = $true
                    break
                }
            }
            if (-not $sessionHas) {
                $env:Path = ($env:Path.TrimEnd($sep) + $sep + $normalizedPath).Trim($sep)
            }

            # 6) Broadcast WM_SETTINGCHANGE so new processes pick up changes
            try {
                $signature = @'
using System;
using System.Runtime.InteropServices;
public static class NativeMethods {
  [DllImport("user32.dll", SetLastError=true, CharSet=CharSet.Auto)]
  public static extern IntPtr SendMessageTimeout(
    IntPtr hWnd, uint Msg, UIntPtr wParam, string lParam, uint fuFlags,
    uint uTimeout, out UIntPtr lpdwResult);
}
'@
                Add-Type -TypeDefinition $signature -ErrorAction SilentlyContinue | Out-Null
                $HWND_BROADCAST = [IntPtr]0xffff
                $WM_SETTINGCHANGE = 0x1A
                $SMTO_ABORTIFHUNG = 0x0002
                $result = [UIntPtr]::Zero
                [void][NativeMethods]::SendMessageTimeout($HWND_BROADCAST, $WM_SETTINGCHANGE, [UIntPtr]::Zero, 'Environment', $SMTO_ABORTIFHUNG, 5000, [ref]$result)
                Write-Verbose "Broadcasted WM_SETTINGCHANGE (Environment)."
            }
            catch {
                Write-Verbose "Failed to broadcast WM_SETTINGCHANGE: $($_.Exception.Message)"
            }
        }
    }
    else {
        # Ensure current session also has the normalized casing/version
        $needsSessionAppend = $true
        foreach ($p in ($env:Path -split ';')) {
            if ($p.Trim() -and ($p.TrimEnd('\') -ieq $normalizedPath.TrimEnd('\'))) {
                $needsSessionAppend = $false
                break
            }
        }
        if ($needsSessionAppend) {
            $env:Path = ($env:Path.TrimEnd(';') + ';' + $normalizedPath).Trim(';')
        }
    }
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Private\Loader\Initialize-Interop.ps1
function Initialize-Interop {
    $interopRoot = Join-Path $script:ModuleRoot 'Private\Security\Interop'
    if (-not (Test-Path $interopRoot)) { return }

    Get-ChildItem $interopRoot -Filter *.cs -Recurse | ForEach-Object {
        try { Add-Type -Path $_.FullName -ErrorAction Stop }
        catch { }
    }
}
[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Private\Loader\Initialize-Logging.ps1
function Initialize-Logging {
    [CmdletBinding()]
    param()

    # One-time guard
    if ($script:log -and $script:log.Initialized) { return $script:log }

    if (-not $script:log -or -not ($script:log -is [hashtable])) {
        $script:log = @{
            enableConsole = $true
            logFile       = $null
            encoding      = 'utf8'
            Initialized   = $false
            FileReady     = $false
        }
    }

    $cfg = $script:cfg
    if (-not $cfg) {
        $script:log.enableConsole = $true
        $script:log.logFile = $null
        $script:log.encoding = 'utf8'
        $script:log.Initialized = $true
        Write-Verbose "Initialize-Logging: No config; using console-only."
        return $script:log
    }

    function Get-CfgValue {
        param([hashtable]$Root, [string[]]$Path)
        $node = $Root
        foreach ($k in $Path) {
            if ($node -is [hashtable] -and $node.ContainsKey($k)) { $node = $node[$k] } else { return $null }
        }
        $node
    }

    $logDirRaw = Get-CfgValue -Root $cfg -Path @('paths', 'logs')
    $logFileRaw = Get-CfgValue -Root $cfg -Path @('settings', 'logging', 'logFile')
    $enableRaw = Get-CfgValue -Root $cfg -Path @('settings', 'logging', 'enableConsole')

    # enableConsole normalization
    $enableConsole = switch ($enableRaw) {
        $true { $true }; $false { $false }
        default {
            if ($null -eq $enableRaw) { $script:log.enableConsole }
            else {
                $t = "$enableRaw".ToLowerInvariant()
                if ($t -in @('true', '1', 'yes', 'y')) { $true }
                elseif ($t -in @('false', '0', 'no', 'n')) { $false }
                else { $script:log.enableConsole }
            }
        }
    }

    # Resolve log file (no write/touch yet)
    $logFile = $null
    if ($logFileRaw) {
        if ([IO.Path]::IsPathRooted($logFileRaw)) { $logFile = $logFileRaw }
        elseif ($logDirRaw) { $logFile = Join-Path $logDirRaw $logFileRaw }
        else {
            $resolved = Resolve-Path -LiteralPath $logFileRaw -ErrorAction Ignore
            $logFile = if ($resolved) { $resolved.Path } else { Join-Path (Get-Location) $logFileRaw }
        }
    }
    elseif ($logDirRaw) {
        $logFile = Join-Path $logDirRaw ("TechToolbox_{0:yyyyMMdd}.log" -f (Get-Date))
    }

    # Create directory only (defer file write until first log)
    if ($logFile) {
        try {
            $parent = Split-Path -Path $logFile -Parent
            if ($parent -and -not (Test-Path -LiteralPath $parent)) {
                [IO.Directory]::CreateDirectory($parent) | Out-Null
            }
            $script:log.FileReady = $true
        }
        catch {
            Write-Warning "Initialize-Logging: Dir create failed for '$parent'. Falling back to console-only. Error: $($_.Exception.Message)"
            $logFile = $null
            $enableConsole = $true
            $script:log.FileReady = $false
        }
    }

    # Persist resolved settings
    $script:log['enableConsole'] = $enableConsole
    $script:log['logFile'] = $logFile
    $script:log['encoding'] = 'utf8'
    $script:log['Initialized'] = $true

    return $script:log
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Private\Loader\Initialize-ModulePath.ps1
function Initialize-ModulePath {
    [CmdletBinding()]
    param(
        [ValidateSet('User', 'Machine')]
        [string]$Scope = 'User',

        [Parameter()]
        [string]$ModuleRoot = 'C:\TechToolbox\'
    )

    # Ensure directory exists
    if (-not (Test-Path -LiteralPath $ModuleRoot)) {
        New-Item -ItemType Directory -Path $ModuleRoot -Force | Out-Null
        Write-Information "Created module root: [$ModuleRoot]" -InformationAction Continue
    }

    # Load persisted PSModulePath for the chosen scope (seed from process if empty)
    $current = [Environment]::GetEnvironmentVariable('PSModulePath', $Scope)
    if ([string]::IsNullOrWhiteSpace($current)) { $current = $env:PSModulePath }

    $sep = ';'
    $parts = $current -split $sep | Where-Object { $_ -and $_.Trim() } | Select-Object -Unique
    $needsAdd = -not ($parts | Where-Object { $_.TrimEnd('\') -ieq $ModuleRoot.TrimEnd('\') })

    if ($needsAdd) {
        $new = @($parts + $ModuleRoot) -join $sep
        [Environment]::SetEnvironmentVariable('PSModulePath', $new, $Scope)
    }
    else {
    }

    # Ensure the current session sees it immediately
    $sessionHas = ($env:PSModulePath -split $sep) | Where-Object { $_.TrimEnd('\') -ieq $ModuleRoot.TrimEnd('\') }
    if (-not $sessionHas) {
        $env:PSModulePath = ($env:PSModulePath.TrimEnd($sep) + $sep + $ModuleRoot).Trim($sep)
    }
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Private\Loader\Initialize-TechToolboxHome.ps1
function Initialize-TechToolboxHome {
    [CmdletBinding(SupportsShouldProcess)]
    param(
        [Parameter()][string]$HomePath = 'C:\TechToolbox',
        [Parameter()][string]$SourcePath,       # <-- optional override
        [switch]$Force,
        [switch]$Quiet
    )

    $ErrorActionPreference = 'Stop'

    # Resolve Source (module files location)
    if (-not $SourcePath -or [string]::IsNullOrWhiteSpace($SourcePath)) {
        if ($script:ModuleRoot) {
            $SourcePath = $script:ModuleRoot
        }
        elseif ($MyInvocation.PSScriptRoot) {
            $SourcePath = $MyInvocation.PSScriptRoot
        }
        elseif ($ExecutionContext.SessionState.Module.ModuleBase) {
            $SourcePath = $ExecutionContext.SessionState.Module.ModuleBase
        }
    }

    if (-not $SourcePath) {
        Write-Error "Initialize-TechToolboxHome: Unable to determine source path (ModuleRoot/PSScriptRoot not set)."
        return
    }

    $src = [System.IO.Path]::GetFullPath($SourcePath)
    $home = [System.IO.Path]::GetFullPath($HomePath)

    Write-Verbose ("[Init] Source: {0}" -f $src)
    Write-Verbose ("[Init] Home:   {0}" -f $home)

    if (-not (Test-Path -LiteralPath $src)) {
        Write-Error "Initialize-TechToolboxHome: Source path not found: $src"
        return
    }

    # Short-circuit if already running from home
    if ($src.TrimEnd('\') -ieq $home.TrimEnd('\')) {
        Write-Verbose "Already running from $home  skipping copy."
        return
    }

    # Read module version (optional)
    $manifest = Join-Path $src 'TechToolbox.psd1'
    $version = '0.0.0-dev'
    if (Test-Path $manifest) {
        try {
            $data = Import-PowerShellDataFile -Path $manifest
            if ($data.ModuleVersion) { $version = $data.ModuleVersion }
        }
        catch { Write-Warning "Unable to read module version from psd1." }
    }

    # Check install stamp
    $stampDir = Join-Path $home '.ttb'
    $stampFile = Join-Path $stampDir 'install.json'
    if (-not $Force -and (Test-Path $stampFile)) {
        try {
            $stamp = Get-Content $stampFile -Raw | ConvertFrom-Json
            if ($stamp.version -eq $version) {
                Write-Information "TechToolbox v$version already installed at $home." -InformationAction Continue
                return
            }
        }
        catch { Write-Warning "Unable to parse existing install.json." }
    }

    # Ensure destination exists
    if (-not (Test-Path $home)) {
        if ($PSCmdlet.ShouldProcess($home, "Create destination folder")) {
            New-Item -ItemType Directory -Path $home -Force | Out-Null
            Write-Verbose "Created: $home"
        }
    }

    # Manual confirmation unless -Quiet
    if (-not $Quiet) {
        $resp = Read-Host "Copy TechToolbox $version to $home? (Y/N)"
        if ($resp -notmatch '^(?i)y(es)?$') {
            Write-Information "Copy aborted." -InformationAction Continue
            return
        }
    }

    # Perform copy via robocopy
    $robocopy = "$env:SystemRoot\System32\robocopy.exe"
    if (-not (Test-Path $robocopy)) { throw "robocopy.exe not found." }

    Write-Information "Copying TechToolbox to $home..." -InformationAction Continue

    # Exclude common dev/volatile dirs if you want; otherwise keep it simple
    $args = @("`"$src`"", "`"$home`"", '/MIR', '/COPY:DAT', '/R:2', '/W:1', '/NFL', '/NDL', '/NP', '/NJH', '/NJS')

    $psi = New-Object System.Diagnostics.ProcessStartInfo
    $psi.FileName = $robocopy
    $psi.Arguments = $args -join ' '
    $psi.UseShellExecute = $false
    $psi.RedirectStandardOutput = $true

    $p = [System.Diagnostics.Process]::Start($psi)
    $output = $p.StandardOutput.ReadToEnd()
    $p.WaitForExit()

    if ($p.ExitCode -gt 7) {
        Write-Verbose $output
        throw "Robocopy failed with exit code $($p.ExitCode)."
    }

    # Write install stamp
    if (-not (Test-Path $stampDir)) { New-Item -ItemType Directory -Path $stampDir -Force | Out-Null }
    $stampJson = @{
        version      = "$version"
        source       = "$src"
        installedUtc = (Get-Date).ToUniversalTime().ToString('o')
    } | ConvertTo-Json -Depth 3
    Set-Content -Path $stampFile -Value $stampJson -Encoding UTF8

    Write-Information "TechToolbox v$version installed to $home." -InformationAction Continue
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Private\Logging\Write-Log.ps1

function Write-Log {
    [CmdletBinding()]
    param(
        [ValidateSet('Error', 'Warn', 'Info', 'Ok', 'Debug')]
        [string]$Level,
        [string]$Message
    )

    # ---- Resolve effective logging settings ----
    $enableConsole = $false
    $logFile = $null
    $includeTimestamps = $true

    try {
        if ($script:log -is [hashtable]) {
            $enableConsole = [bool]  $script:log['enableConsole']
            $logFile = [string]$script:log['logFile']
            if ($script:log.ContainsKey('includeTimestamps')) {
                $includeTimestamps = [bool]$script:log['includeTimestamps']
            }
        }
        elseif ($script:cfg -and $script:cfg.settings -and $script:cfg.settings.logging) {
            # Fallback to config if $script:log wasn't initialized yet (rare)
            $enableConsole = [bool]$script:cfg.settings.logging.enableConsole
            # Compose a best-effort file path
            $logPath = [string]$script:cfg.settings.logging.logPath
            $fileFmt = [string]$script:cfg.settings.logging.logFileNameFormat
            $baseFile = [string]$script:cfg.settings.logging.logFile

            # Simple template resolver
            $resolvedName = $null
            if ($fileFmt) {
                $now = Get-Date
                $resolvedName = $fileFmt.
                Replace('{yyyyMMdd}', $now.ToString('yyyyMMdd')).
                Replace('{yyyyMMdd-HHmmss}', $now.ToString('yyyyMMdd-HHmmss')).
                Replace('{computer}', $env:COMPUTERNAME)
            }
            if ([string]::IsNullOrWhiteSpace($resolvedName)) {
                if (-not [string]::IsNullOrWhiteSpace($baseFile)) {
                    $resolvedName = $baseFile
                }
                else {
                    $resolvedName = 'TechToolbox.log'
                }
            }
            if (-not [string]::IsNullOrWhiteSpace($logPath)) {
                $logPath = $logPath.TrimEnd('\', '/')
                $logFile = Join-Path $logPath $resolvedName
            }
            else {
                $logFile = $resolvedName
            }

            if ($script:cfg.settings.logging.PSObject.Properties.Name -contains 'includeTimestamps') {
                $includeTimestamps = [bool]$script:cfg.settings.logging.includeTimestamps
            }
        }
    }
    catch {
        # Dont throwfall back to safe defaults
    }

    # ---- Formatting ----
    $timestamp = if ($includeTimestamps) { (Get-Date).ToString('yyyy-MM-dd HH:mm:ss') + ' ' } else { '' }
    $formatted = "${timestamp}[$Level] $Message"

    # ---- Console output with color ----
    if ($enableConsole) {
        switch ($Level) {
            'Info' { Write-Host $Message -ForegroundColor Gray }
            'Ok' { Write-Host $Message -ForegroundColor Green }
            'Warn' { Write-Host $Message -ForegroundColor Yellow }
            'Error' { Write-Host $Message -ForegroundColor Red }
            'Debug' { Write-Host $Message -ForegroundColor DarkGray }
            default { Write-Host $Message -ForegroundColor Gray }
        }
    }
    else {
        # Surface critical issues even if console is off
        if ($Level -eq 'Error') { Write-Error $Message }
        elseif ($Level -eq 'Warn') { Write-Warning $Message }
    }

    # ---- File logging (defensive) ----
    if ($logFile) {
        try {
            # If we were handed a directory, compose a default file name
            $leaf = Split-Path -Path $logFile -Leaf
            if ([string]::IsNullOrWhiteSpace($leaf)) {
                # It's a directory, append a default file name
                $logFile = Join-Path $logFile 'TechToolbox.log'
                $leaf = Split-Path -Path $logFile -Leaf
            }

            # Ensure parent directory exists
            $dir = Split-Path -Path $logFile -Parent
            if (-not [string]::IsNullOrWhiteSpace($dir) -and -not (Test-Path $dir)) {
                New-Item -Path $dir -ItemType Directory -Force | Out-Null
            }

            # Only write if we definitely have a file name
            if (-not [string]::IsNullOrWhiteSpace($leaf)) {
                Add-Content -Path $logFile -Value $formatted
            }
            else {
                if ($enableConsole) {
                    Write-Host "Write-Log: Skipping file write; invalid logFile path (no filename): $logFile" -ForegroundColor Yellow
                }
            }
        }
        catch {
            if ($enableConsole) {
                Write-Host "Failed to write log to ${logFile}: $($_.Exception.Message)" -ForegroundColor Yellow
            }
        }
    }
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Private\M365\Convert-MailboxToShared.ps1
function Convert-MailboxToShared {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$Identity
    )

    Write-Log -Level Info -Message ("Converting mailbox to shared: {0}" -f $Identity)

    try {
        # Convert the mailbox
        Set-Mailbox -Identity $Identity -Type Shared -ErrorAction Stop

        Write-Log -Level Ok -Message ("Mailbox converted to shared: {0}" -f $Identity)

        return [pscustomobject]@{
            Action   = "Convert-MailboxToShared"
            Identity = $Identity
            Success  = $true
        }
    }
    catch {
        Write-Log -Level Error -Message ("Failed to convert mailbox for {0}: {1}" -f $Identity, $_.Exception.Message)

        return [pscustomobject]@{
            Action   = "Convert-MailboxToShared"
            Identity = $Identity
            Success  = $false
            Error    = $_.Exception.Message
        }
    }
}
[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Private\M365\Grant-ManagerMailboxAccess.ps1
function Grant-ManagerMailboxAccess {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$Identity,   # The mailbox being accessed

        [Parameter(Mandatory)]
        [string]$ManagerUPN  # The manager receiving access
    )

    Write-Log -Level Info -Message ("Granting mailbox access for '{0}' to manager '{1}'..." -f $Identity, $ManagerUPN)

    $fullAccessGranted = $false
    $sendAsGranted = $false
    $errors = @()

    # --- FullAccess ---
    try {
        Add-MailboxPermission -Identity $Identity `
            -User $ManagerUPN `
            -AccessRights FullAccess `
            -InheritanceType All `
            -AutoMapping:$true `
            -ErrorAction Stop

        Write-Log -Level Ok -Message ("Granted FullAccess to {0}" -f $ManagerUPN)
        $fullAccessGranted = $true
    }
    catch {
        Write-Log -Level Error -Message ("Failed to grant FullAccess: {0}" -f $_.Exception.Message)
        $errors += "FullAccess: $($_.Exception.Message)"
    }

    # --- SendAs ---
    try {
        Add-RecipientPermission -Identity $Identity `
            -Trustee $ManagerUPN `
            -AccessRights SendAs `
            -ErrorAction Stop

        Write-Log -Level Ok -Message ("Granted SendAs to {0}" -f $ManagerUPN)
        $sendAsGranted = $true
    }
    catch {
        Write-Log -Level Error -Message ("Failed to grant SendAs: {0}" -f $_.Exception.Message)
        $errors += "SendAs: $($_.Exception.Message)"
    }

    return [pscustomobject]@{
        Action     = "Grant-ManagerMailboxAccess"
        Identity   = $Identity
        Manager    = $ManagerUPN
        FullAccess = $fullAccessGranted
        SendAs     = $sendAsGranted
        Success    = ($fullAccessGranted -and $sendAsGranted)
        Errors     = $errors
    }
}
[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Private\M365\Remove-TeamsUser.ps1
function Remove-TeamsUser {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$Identity
    )

    Write-Log -Level Info -Message ("Signing out Teams sessions for: {0}" -f $Identity)

    try {
        # Revoke all refresh tokens (Teams, Outlook, mobile, web, etc.)
        Revoke-MgUserSignInSession -UserId $Identity -ErrorAction Stop

        Write-Log -Level Ok -Message ("Teams and M365 sessions revoked for: {0}" -f $Identity)

        return [pscustomobject]@{
            Action   = "SignOut-TeamsUser"
            Identity = $Identity
            Success  = $true
        }
    }
    catch {
        Write-Log -Level Error -Message ("Failed to revoke Teams sessions for {0}: {1}" -f $Identity, $_.Exception.Message)

        return [pscustomobject]@{
            Action   = "SignOut-TeamsUser"
            Identity = $Identity
            Success  = $false
            Error    = $_.Exception.Message
        }
    }
}
[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Private\Network\Core\Start-NewPSRemoteSession.ps1
function Start-NewPSRemoteSession {
    <#
    .SYNOPSIS
        Create a remote PSSession, preferring PowerShell 7 endpoint (WSMan) with
        fallback to Windows PowerShell. Also supports SSH transport.

    .DESCRIPTION
        - For WSMan: tries -ConfigurationName PowerShell.7 first, then falls
          back to Microsoft.PowerShell.
        - For SSH: uses New-PSSession -HostName (PowerShell 7+ locally).
          Supports password or key.
        - Applies sensible timeouts; returns a live PSSession or throws.

    .PARAMETER ComputerName
        Target computer (DNS name or IP).

    .PARAMETER Credential
        PSCredential for WSMan or SSH (username/password). For SSH+Key, Username
        can come from the credential or -UserName.

    .PARAMETER UseSsh
        Use SSH transport instead of WSMan.

    .PARAMETER Port
        SSH port (default 22).

    .PARAMETER Ps7ConfigName
        WSMan endpoint name for PS7 (default 'PowerShell.7').

    .PARAMETER WinPsConfigName
        WSMan endpoint name for Windows PowerShell (default
        'Microsoft.PowerShell').

    .PARAMETER UserName
        SSH username when not using PSCredential.

    .PARAMETER KeyFilePath
        SSH private key path (if using key-based auth).

    .PARAMETER ConnectTimeoutSec
        Open/operation timeout (seconds) used in session options.

    .PARAMETER IdleTimeoutSec
        Idle timeout (milliseconds) for the session.

    .OUTPUTS
        System.Management.Automation.Runspaces.PSSession
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)][string]$ComputerName,
        [pscredential]$Credential,

        [switch]$UseSsh,
        [int]$Port = 22,

        [string]$Ps7ConfigName = 'PowerShell.7',
        [string]$WinPsConfigName = 'Microsoft.PowerShell',

        [string]$UserName,
        [string]$KeyFilePath,

        [int]$ConnectTimeoutSec = 20,
        [int]$IdleTimeoutSec = 1800000  # 30 minutes
    )

    Set-StrictMode -Version Latest
    $oldEAP = $ErrorActionPreference
    $ErrorActionPreference = 'Stop'
    try {
        $sessOpts = New-PSSessionOption -OpenTimeout ($ConnectTimeoutSec * 1000) `
            -OperationTimeout ($ConnectTimeoutSec * 1000) `
            -IdleTimeout $IdleTimeoutSec

        if ($UseSsh) {
            # Requires PowerShell 7+ locally for -HostName transport
            if (-not (Get-Command New-PSSession -ParameterName HostName -ErrorAction SilentlyContinue)) {
                throw "SSH transport requires PowerShell 7+ locally (New-PSSession -HostName)."
            }

            # Prefer credential if provided; else require -UserName (and either key or will prompt if using -Credential)
            $sshParams = @{
                HostName          = $ComputerName
                Port              = $Port
                ErrorAction       = 'Stop'
                ConfigurationName = 'PowerShell'  # PS7 remote default; adjust if you expose custom configs over SSH
                SessionOption     = $sessOpts
            }

            if ($KeyFilePath) {
                $sshParams['KeyFilePath'] = $KeyFilePath
                if (-not $UserName -and $Credential) { $UserName = $Credential.UserName }
                if (-not $UserName) { throw "For SSH key auth, specify -UserName or provide PSCredential (for username only)." }
                $sshParams['UserName'] = $UserName
            }
            elseif ($Credential) {
                $sshParams['UserName'] = $Credential.UserName
                $sshParams['Password'] = $Credential.GetNetworkCredential().Password
            }
            elseif ($UserName) {
                $sshParams['UserName'] = $UserName
            }
            else {
                throw "For SSH, specify -Credential or -UserName (and optionally -KeyFilePath)."
            }

            $s = New-PSSession @sshParams
            Write-Log -Level Ok -Message "Connected to $ComputerName via SSH (port $Port)."
            return $s
        }
        else {
            # WSMan: PS7 endpoint first
            try {
                $wsmanParams = @{
                    ComputerName      = $ComputerName
                    Credential        = $Credential
                    ConfigurationName = $Ps7ConfigName
                    ErrorAction       = 'Stop'
                    SessionOption     = $sessOpts
                }
                $s = New-PSSession @wsmanParams
                Write-Log -Level Ok -Message "Connected to $ComputerName via WSMan ($Ps7ConfigName)."
                return $s
            }
            catch {
                # Fallback to Windows PowerShell endpoint
                $wsmanParams = @{
                    ComputerName      = $ComputerName
                    Credential        = $Credential
                    ConfigurationName = $WinPsConfigName
                    ErrorAction       = 'Stop'
                    SessionOption     = $sessOpts
                }
                $s = New-PSSession @wsmanParams
                Write-Log -Level Ok -Message "Connected to $ComputerName via WSMan ($WinPsConfigName)."
                return $s
            }
        }
    }
    catch {
        $msg = $_.Exception.Message
        Write-Log -Level Error -Message "Failed to create PSSession to ${ComputerName}: $msg"
        throw
    }
    finally {
        $ErrorActionPreference = $oldEAP
    }
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Private\Network\DNS\Start-DnsQueryLoggerWorker.ps1

function Start-DnsQueryLoggerWorker {
    <#
    .SYNOPSIS
        Worker function to start real-time DNS query logging.
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string] $OutputPath
    )

    # Load config
    $cfg = $script:cfg
    $dnsCfg = $cfg["settings"]["dnsLogging"]
    if ($dnsCfg["autoEnableDiagnostics"]) {
        Set-DnsServerDiagnostics -QueryLogging $true
    }

    # Ensure DNS logging is enabled
    try {
        Set-DnsServerDiagnostics -QueryLogging $true -ErrorAction Stop
        Write-Log -Level Ok -Message "DNS query logging enabled."
    }
    catch {
        Write-Log -Level Error -Message "Failed to enable DNS query logging: $($_.Exception.Message)"
        return
    }

    # Get DNS debug log path
    $diag = Get-DnsServerDiagnostics
    $dnsDebugPath = $diag.LogFilePath

    if (-not (Test-Path $dnsDebugPath)) {
        Write-Log -Level Error -Message "DNS debug log not found at $dnsDebugPath"
        return
    }

    Write-Log -Level Info -Message "Watching DNS debug log: $dnsDebugPath"

    # Tail the log in real time
    Get-Content -Path $dnsDebugPath -Wait -Tail 0 |
    ForEach-Object {
        $line = $_

        # Skip empty lines
        if ([string]::IsNullOrWhiteSpace($line)) { return }

        # Parse DNS query lines (simple example)
        if ($line -match 'Query for (.+?) from (\d+\.\d+\.\d+\.\d+)') {
            $record = @{
                Timestamp = (Get-Date)
                Query     = $matches[1]
                Client    = $matches[2]
            }

            # Write to output file
            $json = $record | ConvertTo-Json -Compress
            Add-Content -Path $OutputPath -Value $json

            # Console/log output
            Write-Log -Level Info -Message "DNS Query: $($record.Query) from $($record.Client)"
        }
    }
}
[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Private\Network\SubnetScan\Get-HttpInfo.ps1

function Get-HttpInfo {
    <#
    .SYNOPSIS
        Retrieves HTTP headers from a specified IP address and port if
        available.
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$IP,

        [Parameter(Mandatory)]
        [int]$Port,

        [int]$TimeoutMs = 1000
    )

    try {
        # Build URL
        $url = "http://$IP`:$Port/"

        # Create request
        $req = [System.Net.WebRequest]::Create($url)
        $req.Timeout = $TimeoutMs
        $req.Method = "HEAD"
        $req.AllowAutoRedirect = $false

        # Execute
        $resp = $req.GetResponse()

        # Extract headers into a hashtable
        $headers = @{}
        foreach ($key in $resp.Headers.AllKeys) {
            $headers[$key] = $resp.Headers[$key]
        }

        $resp.Close()
        return $headers
    }
    catch {
        # No banner, no response, or port closed
        return $null
    }
}
[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Private\Network\SubnetScan\Get-IPsFromCIDR.ps1

function Get-IPsFromCIDR {
    <#
    .SYNOPSIS
        Generates a list of IP addresses from a given CIDR notation.
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$CIDR
    )

    try {
        # Split CIDR into base IP + prefix
        $parts = $CIDR -split '/'
        $baseIP = $parts[0]
        $prefix = [int]$parts[1]

        # Convert base IP to UInt32
        $ipBytes = [System.Net.IPAddress]::Parse($baseIP).GetAddressBytes()
        [Array]::Reverse($ipBytes)
        $ipInt = [BitConverter]::ToUInt32($ipBytes, 0)

        # Calculate host range
        $hostBits = 32 - $prefix
        $numHosts = [math]::Pow(2, $hostBits) - 2

        if ($numHosts -lt 1) {
            return @()
        }

        $startIP = $ipInt + 1

        $list = for ($i = 0; $i -lt $numHosts; $i++) {
            $cur = $startIP + $i
            $b = [BitConverter]::GetBytes($cur)
            [Array]::Reverse($b)
            [System.Net.IPAddress]::Parse(($b -join '.')).ToString()
        }

        return , $list
    }
    catch {
        Write-Log -Level Error -Message "Get-IPsFromCIDR failed for '$CIDR': $($_.Exception.Message)"
        return @()
    }
}
[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Private\Network\SubnetScan\Get-MacAddress.ps1

function Get-MacAddress {
    <#
    .SYNOPSIS
        Retrieves the MAC address for a given IP address from the ARP table.
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$IP
    )

    try {
        # Query ARP table for the IP
        $arpOutput = arp -a | Where-Object { $_ -match "^\s*$IP\s" }

        if (-not $arpOutput) {
            return $null
        }

        # Extract MAC address pattern
        if ($arpOutput -match '([0-9a-f]{2}[-:]){5}[0-9a-f]{2}') {
            return $matches[0].ToUpper()
        }

        return $null
    }
    catch {
        Write-Log -Level Error -Message "Get-MacAddress failed for $IP $($_.Exception.Message)"
        return $null
    }
}
[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Private\Network\SubnetScan\Get-MdnsName.ps1

function Get-MdnsName {
    <#
    .SYNOPSIS
        Retrieves the mDNS name for a given IP address if available.
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$IP
    )

    try {
        # First attempt: look for .local names in ARP output
        # Some devices register their mDNS name in the ARP table
        $arpOutput = arp -a | Where-Object { $_ -match "^\s*$IP\s" }

        if ($arpOutput -and $arpOutput -match '([a-zA-Z0-9\-]+\.local)') {
            return $matches[1]
        }

        # Second attempt: reverse lookup for .local PTRs
        try {
            $ptr = Resolve-DnsName -Name $IP -Type PTR -ErrorAction Stop |
            Where-Object { $_.NameHost -like '*.local' } |
            Select-Object -ExpandProperty NameHost -First 1

            if ($ptr) {
                return $ptr
            }
        }
        catch {
            # ignore PTR failures
        }

        # Third attempt: heuristic fallback
        # Some devices respond to <ip>.local even if not registered
        $synthetic = "$IP.local"
        try {
            $probe = Resolve-DnsName -Name $synthetic -ErrorAction Stop
            if ($probe) {
                return $synthetic
            }
        }
        catch {
            # ignore
        }

        return $null
    }
    catch {
        return $null
    }
}
[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Private\Network\SubnetScan\Get-NetbiosName.ps1

function Get-NetbiosName {
    <#
    .SYNOPSIS
        Retrieves the NetBIOS name for a given IP address.
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$IP
    )

    try {
        # Query NetBIOS table for the host
        $output = & nbtstat -A $IP 2>$null

        if (-not $output) {
            return $null
        }

        # Look for the <00> unique workstation service name
        # Example line:
        #   MYPC            <00>  UNIQUE      Registered
        $line = $output | Select-String "<00>" | Select-Object -First 1

        if ($line) {
            # Split on whitespace and take the first token (the hostname)
            $tokens = $line.ToString().Trim() -split '\s+'
            if ($tokens.Count -gt 0) {
                return $tokens[0]
            }
        }

        return $null
    }
    catch {
        # NetBIOS lookup failed or host not responding
        return $null
    }
}
[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Private\Network\SubnetScan\Get-ReverseDns.ps1

function Get-ReverseDns {
    <#
    .SYNOPSIS
        Retrieves the reverse DNS PTR record for a given IP address.
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$IP
    )

    try {
        $ptr = Resolve-DnsName -Name $IP -Type PTR -ErrorAction Stop

        if ($ptr -and $ptr.NameHost) {
            return $ptr.NameHost
        }

        return $null
    }
    catch {
        # PTR not found or DNS server unreachable
        return $null
    }
}
[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Private\Network\SubnetScan\Invoke-SubnetScanLocal.ps1

function Invoke-SubnetScanLocal {
    <#
.SYNOPSIS
    Scanning engine used by Invoke-SubnetScan.ps1.
.DESCRIPTION
    Pings each host in a CIDR, (optionally) resolves names, tests port,
    grabs HTTP banner; returns *only responding hosts*. Export is off by default
    so orchestrator can export consistently to settings.subnetScan.exportDir.
#>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)] [string]$CIDR,
        [int]$Port,
        [switch]$ResolveNames,
        [switch]$HttpBanner,
        [switch]$ExportCsv
    )

    Set-StrictMode -Version Latest
    $oldEAP = $ErrorActionPreference
    $ErrorActionPreference = 'Stop'

    try {
        # --- CONFIG ---
        $cfg = $script:cfg
        if (-not $cfg) { throw "TechToolbox config is null/empty. Ensure Config\config.json exists and is valid JSON." }
        $scanCfg = $cfg['settings']?['subnetScan']
        if (-not $scanCfg) { throw "Config missing 'settings.subnetScan'." }

        # Defaults (only if not passed)
        if (-not $PSBoundParameters.ContainsKey('Port')) { $Port = $scanCfg['defaultPort'] ?? 80 }
        if (-not $PSBoundParameters.ContainsKey('ResolveNames')) { $ResolveNames = [bool]($scanCfg['resolveNames'] ?? $false) }
        if (-not $PSBoundParameters.ContainsKey('HttpBanner')) { $HttpBanner = [bool]($scanCfg['httpBanner'] ?? $false) }
        if (-not $PSBoundParameters.ContainsKey('ExportCsv')) { $ExportCsv = [bool]($scanCfg['exportCsv'] ?? $false) }

        # Timeouts / smoothing
        $pingTimeoutMs = $scanCfg['pingTimeoutMs'] ?? 1000
        $tcpTimeoutMs = $scanCfg['tcpTimeoutMs'] ?? 1000
        $httpTimeoutMs = $scanCfg['httpTimeoutMs'] ?? 1500
        $ewmaAlpha = $scanCfg['ewmaAlpha'] ?? 0.30
        $displayAlpha = $scanCfg['displayAlpha'] ?? 0.50

        # Expand CIDR  IP list
        $ips = Get-IPsFromCIDR -CIDR $CIDR
        if (-not $ips -or $ips.Count -eq 0) {
            Write-Log -Level Warn -Message "No hosts found for CIDR $CIDR"
            return @()
        }

        Write-Log -Level Info -Message "Scanning $($ips.Count) hosts..."

        $results = [System.Collections.Generic.List[psobject]]::new()

        # Progress telemetry
        $avgHostMs = 0.0
        $displayPct = 0.0
        $current = 0
        $total = $ips.Count
        $online = 0

        $ping = [System.Net.NetworkInformation.Ping]::new()

        foreach ($ip in $ips) {
            $hostSw = [System.Diagnostics.Stopwatch]::StartNew()

            $result = [pscustomobject]@{
                IP         = $ip
                Responded  = $false
                RTTms      = $null
                MacAddress = $null
                PTR        = $null
                NetBIOS    = $null
                Mdns       = $null
                PortOpen   = $false
                ServerHdr  = $null
                Timestamp  = Get-Date
            }

            try {
                $reply = $ping.Send($ip, $pingTimeoutMs)

                if ($reply -and $reply.Status -eq [System.Net.NetworkInformation.IPStatus]::Success) {
                    $result.Responded = $true
                    $result.RTTms = $reply.RoundtripTime
                    $online++

                    try { $result.MacAddress = Get-MacAddress -ip $ip } catch {}

                    if ($ResolveNames) {
                        try { $result.PTR = Get-ReverseDns -ip $ip } catch {}
                        if (-not $result.PTR) { try { $result.NetBIOS = Get-NetbiosName -ip $ip } catch {} }
                        if (-not $result.PTR -and -not $result.NetBIOS) { try { $result.Mdns = Get-MdnsName -ip $ip } catch {} }
                    }

                    try { $result.PortOpen = Test-TcpPort -ip $ip -port $Port -timeoutMs $tcpTimeoutMs } catch {}

                    if ($HttpBanner -and $result.PortOpen) {
                        try {
                            $hdrs = Get-HttpInfo -ip $ip -port $Port -timeoutMs $httpTimeoutMs
                            if ($hdrs -and $hdrs['Server']) { $result.ServerHdr = $hdrs['Server'] }
                        }
                        catch {}
                    }

                    # Add only responding hosts
                    $results.Add($result)
                }
            }
            catch {
                # ignore host-level exceptions; treat as no response
            }
            finally {
                $hostSw.Stop()
                $durMs = $hostSw.Elapsed.TotalMilliseconds

                if ($avgHostMs -le 0) { $avgHostMs = $durMs }
                else { $avgHostMs = ($ewmaAlpha * $durMs) + ((1 - $ewmaAlpha) * $avgHostMs) }

                $current++
                $actualPct = ($current / $total) * 100
                $displayPct = ($displayAlpha * $actualPct) + ((1 - $displayAlpha) * $displayPct)

                $remaining = $total - $current
                $etaMs = [math]::Max(0, $avgHostMs * $remaining)
                $eta = [TimeSpan]::FromMilliseconds($etaMs)

                Show-ProgressBanner -current $current -total $total -displayPct $displayPct -eta $eta
            }
        }

        $ping.Dispose()
        Write-Log -Level Ok -Message "Local subnet scan complete. $online hosts responded."

        # Remote-side export when explicitly requested (used by ExportTarget=Remote)
        if ($ExportCsv -and $results.Count -gt 0) {
            try {
                $exportDir = $scanCfg['exportDir']
                if (-not $exportDir) { throw "Config 'settings.subnetScan.exportDir' is missing." }
                if (-not (Test-Path -LiteralPath $exportDir)) {
                    New-Item -ItemType Directory -Path $exportDir -Force | Out-Null
                }
                $cidrSafe = $CIDR -replace '[^\w\-\.]', '_'
                $csvPath = Join-Path $exportDir ("subnet-scan-{0}-{1}.csv" -f $cidrSafe, (Get-Date -Format 'yyyyMMdd-HHmmss'))
                $results | Export-Csv -Path $csvPath -NoTypeInformation -Encoding UTF8 -Force
                Write-Log -Level Ok -Message "Results exported to $csvPath"
            }
            catch {
                Write-Log -Level Error -Message "Failed to export CSV: $($_.Exception.Message)"
            }
        }
        elseif ($ExportCsv) {
            Write-Log -Level Warn -Message "Export skipped: no responding hosts."
        }

        return $results
    }
    finally {
        $ErrorActionPreference = $oldEAP
    }
}
[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Private\Network\SubnetScan\Show-ProgressBanner.ps1

function Show-ProgressBanner {
    <#
    .SYNOPSIS
        Displays a progress banner for subnet scanning operations.
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [int]$Current,

        [Parameter(Mandatory)]
        [int]$Total,

        [Parameter(Mandatory)]
        [double]$DisplayPct,

        [Parameter(Mandatory)]
        [TimeSpan]$ETA
    )

    try {
        $pct = "{0:N1}" -f $DisplayPct
        $etaStr = $ETA.ToString("hh\:mm\:ss")

        Write-Progress `
            -Activity "Subnet Scan" `
            -Status   "Progress: $pct% | ETA: $etaStr" `
            -PercentComplete $DisplayPct `
            -CurrentOperation "Host $Current of $Total"
    }
    catch {
        # UI failures should never break a scan
    }
}
[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Private\Network\SubnetScan\Test-TcpPort.ps1

function Test-TcpPort {
    <#
    .SYNOPSIS
        Tests if a TCP port is open on a specified IP address within a given timeout.
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$IP,

        [Parameter(Mandatory)]
        [int]$Port,

        [int]$TimeoutMs = 500
    )

    try {
        $client = New-Object System.Net.Sockets.TcpClient

        # Begin async connect
        $async = $client.BeginConnect($IP, $Port, $null, $null)

        # Wait for timeout
        if (-not $async.AsyncWaitHandle.WaitOne($TimeoutMs)) {
            $client.Close()
            return $false
        }

        # Complete connection
        $client.EndConnect($async)
        $client.Close()
        return $true
    }
    catch {
        return $false
    }
}
[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Private\Purview\Connect-PurviewSearchOnly.ps1

function Connect-PurviewSearchOnly {
    <#
    .SYNOPSIS
        Connects to Microsoft Purview with a SearchOnly IPPS session.
    .DESCRIPTION
        Uses Connect-IPPSSession -EnableSearchOnlySession with the provided UPN.
        Logs connection status via Write-Log.
    .PARAMETER UserPrincipalName
        UPN used to establish the Purview SearchOnly session (e.g., user@domain.com).
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [ValidateNotNullOrEmpty()]
        [string]$UserPrincipalName
    )

    try {
        Write-Log -Level Info -Message ("Connecting to Purview (SearchOnly) as {0}..." -f $UserPrincipalName)
        Connect-IPPSSession -UserPrincipalName $UserPrincipalName -EnableSearchOnlySession -ErrorAction Stop
        Write-Log -Level Ok -Message "Connected to Purview (SearchOnly)."
    }
    catch {
        Write-Log -Level Error -Message ("Failed to connect to Purview as {0}: {1}" -f $UserPrincipalName, $_.Exception.Message)
        throw
    }
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Private\Purview\Invoke-HardDelete.ps1

function Invoke-HardDelete {
    <#
    .SYNOPSIS
        Submits a Purview HardDelete purge for a Compliance Search and waits for
        completion.
    .DESCRIPTION
        Optionally requires typed confirmation per config; honors
        -WhatIf/-Confirm for the submission step. Calls Wait-PurgeCompletion to
        monitor the purge status.
    #>
    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Medium')]
    param(
        [Parameter(Mandatory)][ValidateNotNullOrEmpty()][string]$SearchName,
        [Parameter(Mandatory)][ValidateNotNullOrEmpty()][string]$CaseName
    )

    # --- Config (normalized camelCase) ---
    $purv = $script:cfg.settings.purview

    # Confirmation gate (default to true for safety)
    $requireTextConfirm = $purv.purge.requireTextConfirmation
    if ($null -eq $requireTextConfirm) { $requireTextConfirm = $true }

    $requireConfirmation = $purv.purge.requireConfirmation
    if ($null -eq $requireConfirmation) { $requireConfirmation = $true }

    Write-Log -Level Info -Message ("Preparing HardDelete purge for '{0}' in case '{1}'." -f $SearchName, $CaseName)
    Write-Log -Level Warn -Message "This will permanently delete all items found by the search."

    if ($requireTextConfirm) {
        $confirm = Read-Host "Type 'YES' to confirm HardDelete purge"
        if ($confirm -notmatch '^(?i)(YES|Y)$') { throw "HardDelete purge cancelled by user." }
    }

    if ($PSCmdlet.ShouldProcess(("Case '{0}' Search '{1}'" -f $CaseName, $SearchName), 'Submit HardDelete purge')) {
        $action = $null
        try {
            $action = New-ComplianceSearchAction -SearchName $SearchName -Purge -PurgeType HardDelete -Confirm:$requireConfirmation -ErrorAction Stop
            if ($action.Identity) {
                Write-Log -Level Ok -Message ("Purge submitted: {0}" -f $action.Identity)

                # Optional: pass config-driven timeouts/polling to Wait-PurgeCompletion
                $timeout = $purv.purge.timeoutSeconds
                $poll = $purv.purge.pollSeconds
                Wait-PurgeCompletion -ActionIdentity $action.Identity -CaseName $CaseName `
                    -TimeoutSeconds $timeout -PollSeconds $poll
            }
            else {
                Write-Log -Level Ok -Message "Purge submitted (no Identity returned). Monitoring by search name..."
                $timeout = $purv.purge.timeoutSeconds
                $poll = $purv.purge.pollSeconds
                Wait-PurgeCompletion -SearchName $SearchName -CaseName $CaseName `
                    -TimeoutSeconds $timeout -PollSeconds $poll
            }
        }
        catch {
            Write-Log -Level Error -Message ("Failed to submit purge: {0}" -f $_.Exception.Message)
            throw
        }
    }
    else {
        Write-Log -Level Info -Message "Purge submission skipped due to -WhatIf/-Confirm."
    }
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Private\Purview\Test-ContentMatchQuery.ps1

function Test-ContentMatchQuery {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)][string]$Query,
        [switch]$Normalize,
        [ref]$NormalizedQuery
    )

    # Trim and basic checks
    if ([string]::IsNullOrWhiteSpace($Query)) {
        if ($NormalizedQuery) { $NormalizedQuery.Value = $null }
        return $false
    }

    $q = $Query.Trim()

    # 1) Balanced parentheses
    $stack = 0
    foreach ($ch in $q.ToCharArray()) {
        if ($ch -eq '(') { $stack++ }
        elseif ($ch -eq ')') { $stack-- }
        if ($stack -lt 0) { return $false } # early close
    }
    if ($stack -ne 0) { return $false }     # unbalanced overall

    # 2) Balanced quotes (simple even-count check; covers most cases)
    $quoteArray = $q.ToCharArray() | Where-Object { $_ -eq '"' }
    $quoteCount = @($quoteArray).Count       # ensure array semantics
    if (($quoteCount % 2) -ne 0) { return $false }

    # 3) Allowed property names (adjust as you need)
    $allowed = @(
        'from', 'to', 'cc', 'bcc', 'participants',
        'subject', 'body', 'sent', 'received', 'attachment', 'attachments',
        'kind', 'size', 'importance'
    )

    $propMatches = [regex]::Matches($q, '(?i)\b([a-z]+)\s*:')
    # MatchCollection.Count is safe, but we don't need itjust iterate
    foreach ($m in $propMatches) {
        $prop = $m.Groups[1].Value.ToLowerInvariant()
        if ($allowed -notcontains $prop) { return $false }
    }

    # 4) Optional normalization for common wildcard mistakes
    $norm = $q
    if ($Normalize) {
        $norm = [regex]::Replace(
            $norm,
            '(?i)(from|to|cc|bcc)\s*:\s*\(\s*([^)]*)\s*\)',
            {
                param($m)
                $prop = $m.Groups[1].Value
                $inner = $m.Groups[2].Value
                # Split OR terms and quote them if they contain @ or * and aren't already quoted
                $parts = $inner -split '(?i)\s+OR\s+'
                $parts = $parts | ForEach-Object {
                    $p = $_.Trim()
                    if ($p -notmatch '^".*"$' -and ($p -match '[@\*]')) { '"' + $p + '"' } else { $p }
                }
                "${prop}:(" + ($parts -join ' OR ') + ")"
            }
        )
    }

    if ($NormalizedQuery) { $NormalizedQuery.Value = $norm }
    return $true
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Private\Purview\Wait-ComplianceSearchRegistration.ps1
function Wait-ComplianceSearchRegistration {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)][string]$SearchName,
        [int]$TimeoutSeconds = 60,
        [int]$PollSeconds = 3
    )
    $deadline = (Get-Date).AddSeconds($TimeoutSeconds)
    do {
        $cs = Get-ComplianceSearch -Identity $SearchName -ErrorAction SilentlyContinue
        if ($cs) { return $true }
        Start-Sleep -Seconds $PollSeconds
    } while ((Get-Date) -lt $deadline)
    return $false
}
[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Private\Purview\Wait-PurgeCompletion.ps1

function Wait-PurgeCompletion {
    <#
    .SYNOPSIS
        Monitors a Purge ComplianceSearchAction until completion or timeout.
    .DESCRIPTION
        Supports two parameter sets: by action identity or by search name.
        Caller provides TimeoutSeconds and PollSeconds (no direct config reads).
    #>
    [CmdletBinding(DefaultParameterSetName = 'BySearch')]
    param(
        [Parameter(ParameterSetName = 'BySearch', Mandatory)]
        [ValidateNotNullOrEmpty()]
        [string]$SearchName,

        [Parameter(ParameterSetName = 'ByAction', Mandatory)]
        [ValidateNotNullOrEmpty()]
        [string]$ActionIdentity,

        [Parameter()]
        [string]$CaseName,

        [Parameter()]
        [ValidateRange(1, 86400)]
        [int]$TimeoutSeconds = 1200,

        [Parameter()]
        [ValidateRange(1, 3600)]
        [int]$PollSeconds = 5
    )

    # --- Caller-resolved defaults only (no config lookups here) ---
    $target = if ($PSCmdlet.ParameterSetName -eq 'ByAction') { $ActionIdentity } else { $SearchName }
    Write-Log -Level Info -Message ("Monitoring purge for '{0}' (Timeout={1}s, Poll={2}s)..." -f $target, $TimeoutSeconds, $PollSeconds)

    $deadline = (Get-Date).AddSeconds($TimeoutSeconds)
    while ((Get-Date) -lt $deadline) {
        $action = if ($PSCmdlet.ParameterSetName -eq 'ByAction') {
            Get-ComplianceSearchAction -Identity $ActionIdentity -ErrorAction SilentlyContinue
        }
        else {
            # If CaseName provided, scope to case; else search across all purges and pick latest
            $scope = if ([string]::IsNullOrWhiteSpace($CaseName)) {
                Get-ComplianceSearchAction -Purge -ErrorAction SilentlyContinue
            }
            else {
                Get-ComplianceSearchAction -Purge -Case $CaseName -ErrorAction SilentlyContinue
            }

            $scope |
            Where-Object { $_.SearchName -eq $SearchName } |
            Sort-Object CreatedTime -Descending |
            Select-Object -First 1
        }

        if ($action) {
            $status = $action.Status
            Write-Log -Level Info -Message ("Purge status: {0}" -f $status)
            switch ($status) {
                'Completed' { Write-Log -Level Ok   -Message "Purge completed successfully."; return $action }
                'PartiallySucceeded' { Write-Log -Level Warn -Message ("Purge partially succeeded: {0}" -f $action.ErrorMessage); return $action }
                'Failed' { Write-Log -Level Error -Message ("Purge failed: {0}" -f $action.ErrorMessage); return $action }
            }
        }
        else {
            Write-Log -Level Info -Message "No purge action found yet..."
        }

        Start-Sleep -Seconds $PollSeconds
    }

    throw "Timed out waiting for purge completion."
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Private\Purview\Wait-SearchCompletion.ps1

function Wait-SearchCompletion {
    <#
    .SYNOPSIS
        Waits for a Compliance Search to reach a terminal state
        (Completed/Failed) or timeout.
    .DESCRIPTION
        Polls the search status by name (and optional case scope) until timeout.
        Caller supplies TimeoutSeconds/PollSeconds; no config access here.
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [ValidateNotNullOrEmpty()]
        [string]$SearchName,

        [Parameter()]
        [string]$CaseName,

        [Parameter()]
        [ValidateRange(1, 86400)]
        [int]$TimeoutSeconds = 1200,

        [Parameter()]
        [ValidateRange(1, 3600)]
        [int]$PollSeconds = 5
    )

    Write-Log -Level Info -Message ("Monitoring search '{0}' (Timeout={1}s, Poll={2}s)..." -f $SearchName, $TimeoutSeconds, $PollSeconds)

    $deadline = (Get-Date).AddSeconds($TimeoutSeconds)
    while ((Get-Date) -lt $deadline) {
        try {
            $search = if ([string]::IsNullOrWhiteSpace($CaseName)) {
                Get-ComplianceSearch -Identity $SearchName -ErrorAction SilentlyContinue
            }
            else {
                Get-ComplianceSearch -Identity $SearchName -Case $CaseName -ErrorAction SilentlyContinue
            }
        }
        catch {
            $search = $null
        }

        if ($null -ne $search) {
            $status = $search.Status
            Write-Log -Level Info -Message ("Search status: {0}" -f $status)

            switch ($status) {
                'Completed' {
                    Write-Log -Level Ok -Message "Search completed."
                    return $search
                }
                'Failed' {
                    Write-Log -Level Error -Message ("Search failed: {0}" -f $search.Errors)
                    return $search
                }
                default {
                    # In-progress statuses often include 'Starting', 'InProgress', etc.
                }
            }
        }
        else {
            Write-Log -Level Info -Message "Search not found yet..."
        }

        Start-Sleep -Seconds $PollSeconds
    }

    throw "Timed out waiting for search completion."
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Private\Security\Debug\Invoke-SanityCheck.ps1
function Invoke-SanityCheck {
    <#
    .SYNOPSIS
        Performs a basic sanity check on the current user.
    .DESCRIPTION
        This function simulates a sanity check by outputting humorous messages
        about the user's and module's sanity levels.
    .EXAMPLE
        sanity_check
        Runs the sanity check and displays the results.
    .INPUTS
        None. You cannot pipe objects to sanity_check.
    .OUTPUTS
        None. This function does not return any output.
    .LINK
        [TechToolbox](https://github.com/dan-damit/TechToolbox)
    #>
    Write-Host "Running sanity_check..." -ForegroundColor DarkCyan
    Start-Sleep -Milliseconds 3000

    Write-Host "Operator sanity: questionable" -ForegroundColor Yellow
    Start-Sleep -Milliseconds 2000
    Write-Host "Module sanity: excellent" -ForegroundColor Green
    Start-Sleep -Milliseconds 2000
    Write-Host "Proceed with caution." -ForegroundColor DarkYellow
}
[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Private\Security\Impersonation\Invoke-Impersonation.ps1

function Invoke-Impersonation {
    <#
    .SYNOPSIS
        Executes a script block under the context of specified user credentials.
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)][pscredential]$Credential,
        [Parameter(Mandatory)][scriptblock]$ScriptBlock
    )

    # Split domain\user if needed
    $parts = $Credential.UserName.Split('\', 2)
    if ($parts.Count -eq 2) {
        $domain   = $parts[0]
        $username = $parts[1]
    } else {
        $domain   = $env:USERDOMAIN
        $username = $parts[0]
    }

    $password = $Credential.GetNetworkCredential().Password

    # LOGON32_LOGON_NEW_CREDENTIALS = 9
    # LOGON32_PROVIDER_WINNT50      = 3
    $token = [IntPtr]::Zero
    $ok = [CredImpersonator]::LogonUser(
        $username, $domain, $password, 9, 3, [ref]$token
    )

    if (-not $ok) {
        return $null
    }

    $identity = [System.Security.Principal.WindowsIdentity]::new($token)
    $context  = $identity.Impersonate()

    try {
        & $ScriptBlock
    }
    finally {
        $context.Undo()
        $context.Dispose()
        [CredImpersonator]::CloseHandle($token) | Out-Null
    }
}
[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Private\System\BatteryReportHelpers\ConvertTo-mWh.ps1

function ConvertTo-mWh {
    <#
    .SYNOPSIS
        Parses capacity strings (e.g., '47,000 mWh', '47 Wh') into an integer
        mWh value.
    #>
    [CmdletBinding()]
    param([Parameter(Mandatory)][string]$Text)

    $t = ($Text -replace ',', '').Trim()
    $num = [double](($t -match '(\d+(\.\d+)?)') ? $Matches[1] : 0)
    if ($num -le 0) { return $null }

    if ($t -match '(?i)\bmwh\b') { return [int]$num }
    if ($t -match '(?i)\bwh\b') { return [int]($num * 1000) }
    # Unknown unit: assume mWh
    return [int]$num
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Private\System\BatteryReportHelpers\Get-BatteryReportHtml.ps1

function Get-BatteryReportHtml {
    <#
    .SYNOPSIS
        Parses the battery report HTML and returns battery objects + optional
        debug text.
    .OUTPUTS
        [object[]], [string]  # batteries array, debug text (headings) when
        table detection fails
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)][ValidateNotNullOrEmpty()][string]$Html
    )

    $htmlNorm = $Html -replace "`r`n", "`n" -replace "\t", " "
    $installedPattern = '(?is)<h[1-6][^>]*>.*?Installed\W+Batter(?:y|ies).*?</h[1-6]>.*?<table\b[^>]*>(.*?)</table>'
    $sectionMatch = [regex]::Match($htmlNorm, $installedPattern)

    # Fallback: detect table by typical labels if heading not found
    if (-not $sectionMatch.Success) {
        $tableMatches = [regex]::Matches($htmlNorm, '(?is)<table\b[^>]*>(.*?)</table>')
        foreach ($tm in $tableMatches) {
            if ($tm.Value -match '(?is)(Design\s+Capacity|Full\s+Charge\s+Capacity|Chemistry|Serial|Manufacturer)') {
                $sectionMatch = $tm
                break
            }
        }
    }

    if (-not $sectionMatch.Success) {
        # Gather headings for debug
        $headings = [regex]::Matches($htmlNorm, '(?is)<h[1-6][^>]*>(.*?)</h[1-6]>') | ForEach-Object {
            Format-Text $_.Groups[1].Value
        }
        return @(), ($headings -join [Environment]::NewLine)
    }

    $tableHtml = $sectionMatch.Value
    $tbodyMatch = [regex]::Match($tableHtml, '(?is)<tbody\b[^>]*>(.*?)</tbody>')
    $rowsHtml = if ($tbodyMatch.Success) { $tbodyMatch.Groups[1].Value } else { $tableHtml }
    $rowMatches = [regex]::Matches($rowsHtml, '(?is)<tr\b[^>]*>(.*?)</tr>')
    if ($rowMatches.Count -eq 0) { return @(), $null }

    $batteries = New-Object System.Collections.Generic.List[object]
    $current = [ordered]@{}
    $startKeys = @('manufacturer', 'serialNumber', 'name', 'batteryName')

    foreach ($rm in $rowMatches) {
        $rowInner = $rm.Groups[1].Value
        $cellMatches = [regex]::Matches($rowInner, '(?is)<t[dh]\b[^>]*>(.*?)</t[dh]>')
        if ($cellMatches.Count -eq 0) { continue }

        if ($cellMatches.Count -eq 2) {
            # Key-value row
            $label = Format-Text $cellMatches[0].Groups[1].Value
            $value = Format-Text $cellMatches[1].Groups[1].Value         
            if (-not [string]::IsNullOrWhiteSpace($label)) {
                $key = Move-ToCamelKey -Label $label
            }

            # Detect start of a new battery when a "start key" repeats
            if ($startKeys -contains $key -and $current.Contains($key)) {
                # finalize previous battery with parsed capacities
                $dc = if ($current.Contains('designCapacity')) { ConvertTo-mWh $current['designCapacity'] } else { $null }
                $fc = if ($current.Contains('fullChargeCapacity')) { ConvertTo-mWh $current['fullChargeCapacity'] } else { $null }
                if ($dc -and $fc -and $dc -gt 0) {
                    $current['designCapacity_mWh'] = $dc
                    $current['fullChargeCapacity_mWh'] = $fc
                    $current['healthRatio'] = [math]::Round($fc / $dc, 4)
                    $current['healthPercent'] = [math]::Round(($fc * 100.0) / $dc, 2)
                }
                $batteries.Add([PSCustomObject]$current)
                $current = [ordered]@{}
            }
            $current[$key] = $value
        }
        else {
            # Multi-column row: capture as raw values
            $vals = @()
            foreach ($cm in $cellMatches) { $vals += (Format-Text $cm.Groups[1].Value) }
            if ($vals.Count -gt 0) {
                if (-not $current.Contains('rows')) {
                    $current['rows'] = New-Object System.Collections.Generic.List[object]
                }
                $current['rows'].Add($vals)
            }
        }
    }

    # finalize last battery
    if ($current.Count -gt 0) {
        $dc = if ($current.Contains('designCapacity')) { ConvertTo-mWh $current['designCapacity'] } else { $null }
        $fc = if ($current.Contains('fullChargeCapacity')) { ConvertTo-mWh $current['fullChargeCapacity'] } else { $null }
        if ($dc -and $fc -and $dc -gt 0) {
            $current['designCapacity_mWh'] = $dc
            $current['fullChargeCapacity_mWh'] = $fc
            $current['healthRatio'] = [math]::Round($fc / $dc, 4)
            $current['healthPercent'] = [math]::Round(($fc * 100.0) / $dc, 2)
        }
        $batteries.Add([PSCustomObject]$current)
    }

    return , $batteries, $null
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Private\System\BatteryReportHelpers\Get-mWh.ps1
function Get-mWh {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$Text
    )

    $clean = Update-Text $Text

    # Capture number + optional unit
    $match = [regex]::Match($clean, '(?i)\b([0-9][0-9,\.]*)\s*(mwh|wh)?\b')
    if (-not $match.Success) { return $null }

    $num = $match.Groups[1].Value -replace ',', ''
    $unit = $match.Groups[2].Value.ToLower()

    if ($num -notmatch '^\d+(\.\d+)?$') {
        return $null
    }

    $val = [double]$num

    switch ($unit) {
        'mwh' { return [int][math]::Round($val) }
        'wh' { return [int][math]::Round($val * 1000) }
        default {
            # No unit  infer based on magnitude
            if ($val -ge 1000) {
                return [int][math]::Round($val)      # assume mWh
            }
            else {
                return [int][math]::Round($val * 1000) # assume Wh
            }
        }
    }
}
[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Private\System\BatteryReportHelpers\Invoke-BatteryReport.ps1

function Invoke-BatteryReport {
    <#
    .SYNOPSIS
        Runs 'powercfg /batteryreport' to generate the HTML report and waits
        until the file is non-empty.
    .OUTPUTS
        [bool] True when the report is present and non-zero length; otherwise
        False.
    #>
    [CmdletBinding(SupportsShouldProcess = $true)]
    param(
        [Parameter(Mandatory)][ValidateNotNullOrEmpty()][string]$ReportPath,
        [Parameter()][int]$MaxTries = 40,
        [Parameter()][int]$SleepMs = 250
    )

    $reportDir = Split-Path -Parent $ReportPath
    if ($reportDir -and $PSCmdlet.ShouldProcess($reportDir, 'Ensure report directory')) {
        if (-not (Test-Path -LiteralPath $reportDir)) {
            New-Item -ItemType Directory -Path $reportDir -Force | Out-Null
        }
    }

    # Generate report (matches original behavior)
    if ($PSCmdlet.ShouldProcess($ReportPath, 'Generate battery report')) {
        & powercfg.exe /batteryreport /output "$ReportPath" | Out-Null
    }

    # Poll for presence & non-zero size (40 tries x 250ms ~= 10s default)
    $tries = 0
    while ($tries -lt $MaxTries) {
        if (Test-Path -LiteralPath $ReportPath) {
            $size = (Get-Item -LiteralPath $ReportPath).Length
            if ($size -gt 0) { return $true }
        }
        Start-Sleep -Milliseconds $SleepMs
        $tries++
    }
    return $false
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Private\System\CopyHelpers\Start-RobocopyLocal.ps1
function Start-RobocopyLocal {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)][string]$Source,
        [Parameter(Mandatory)][string]$Destination,
        [Parameter(Mandatory)][string]$LogFile,
        [Parameter(Mandatory)][int]$RetryCount,
        [Parameter(Mandatory)][int]$WaitSeconds,
        [Parameter(Mandatory)][string[]]$CopyFlags,
        [Parameter()][pscredential]$Credential
    )

    # Optional: credential-aware UNC access (basic pattern)
    # For now, we log that credentials were supplied and rely on existing access.
    if ($Credential) {
        Write-Log -Level Info -Message " Credential supplied for local execution (ensure access to UNC paths is configured)."
    }

    if (-not (Test-Path -Path $Destination -PathType Container)) {
        New-Item -ItemType Directory -Path $Destination -Force | Out-Null
    }

    $arguments = @(
        "`"$Source`"",
        "`"$Destination`""
    ) + $CopyFlags + @(
        "/R:{0}" -f $RetryCount,
        "/W:{0}" -f $WaitSeconds,
        "/LOG:$LogFile"
    )

    Write-Log -Level Info -Message " Running Robocopy locally..."
    Write-Log -Level Info -Message (" Command: robocopy {0}" -f ($arguments -join ' '))

    $proc = Start-Process -FilePath "robocopy.exe" -ArgumentList $arguments -NoNewWindow -Wait -PassThru
    $exitCode = $proc.ExitCode

    Write-Log -Level Info -Message (" Robocopy exit code: {0}" -f $exitCode)

    # Robocopy exit codes 07 are typically non-fatal; >7 indicates serious issues.
    if ($exitCode -gt 7) {
        Write-Log -Level Warn -Message (" Robocopy reported a severe error (exit code {0})." -f $exitCode)
    }
}
[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Private\System\CopyHelpers\Start-RobocopyRemote.ps1
function Start-RobocopyRemote {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)][string]$Source,
        [Parameter(Mandatory)][string]$Destination,
        [Parameter(Mandatory)][string]$LogFile,
        [Parameter(Mandatory)][int]$RetryCount,
        [Parameter(Mandatory)][int]$WaitSeconds,
        [Parameter(Mandatory)][string[]]$CopyFlags,
        [Parameter(Mandatory)][string]$ComputerName,
        [Parameter()][pscredential]$Credential
    )

    Write-Log -Level Info -Message (" Opening remote session to {0}..." -f $ComputerName)

    if ($Credential) {
        $session = New-PSSession -ComputerName $ComputerName -Credential $Credential
    }
    else {
        $session = New-PSSession -ComputerName $ComputerName
    }

    try {
        $exitCode = Invoke-Command -Session $session -ScriptBlock {
            param(
                $Source,
                $Destination,
                $LogFile,
                $RetryCount,
                $WaitSeconds,
                $CopyFlags
            )

            if (-not (Test-Path -Path $Destination -PathType Container)) {
                New-Item -ItemType Directory -Path $Destination -Force | Out-Null
            }

            $arguments = @(
                "`"$Source`"",
                "`"$Destination`""
            ) + $CopyFlags + @(
                "/R:{0}" -f $RetryCount,
                "/W:{0}" -f $WaitSeconds,
                "/LOG:$LogFile"
            )

            Write-Host "Running Robocopy on remote host..."
            Write-Host ("Command: robocopy {0}" -f ($arguments -join ' '))

            $proc = Start-Process -FilePath "robocopy.exe" -ArgumentList $arguments -NoNewWindow -Wait -PassThru
            $proc.ExitCode
        } -ArgumentList $Source, $Destination, $LogFile, $RetryCount, $WaitSeconds, $CopyFlags

        Write-Log -Level Info -Message (" Remote Robocopy exit code: {0}" -f $exitCode)

        if ($exitCode -gt 7) {
            Write-Log -Level Warn -Message (" Remote Robocopy reported a severe error (exit code {0})." -f $exitCode)
        }
    }
    finally {
        if ($session) {
            Write-Log -Level Info -Message (" Closing remote session to {0}." -f $ComputerName)
            Remove-PSSession -Session $session
        }
    }
}
[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Private\System\RepairHelpers\Invoke-SystemRepairLocal.ps1
function Invoke-SystemRepairLocal {
    [CmdletBinding()]
    param(
        [switch]$RestoreHealth,
        [switch]$StartComponentCleanup,
        [switch]$ResetBase,
        [switch]$SfcScannow,
        [switch]$ResetUpdateComponents
    )

    $results = [ordered]@{
        ComputerName          = $env:COMPUTERNAME
        StartedAt             = (Get-Date)
        RestoreHealthResult   = $null
        StartComponentCleanup = $null
        ResetBaseResult       = $null
        SfcResult             = $null
        ResetWUResult         = $null
        CompletedAt           = $null
        DurationSeconds       = $null
    }

    function Invoke-DismCommand {
        param([string[]]$Args)

        $sw = [System.Diagnostics.Stopwatch]::StartNew()
        try {
            $output = & dism.exe @Args 2>&1
            $exit = $LASTEXITCODE
            $sw.Stop()

            return [pscustomobject]@{
                Success    = ($exit -eq 0)
                ExitCode   = $exit
                Output     = ($output -join "`n")
                Message    = $null
                DurationMs = $sw.ElapsedMilliseconds
            }
        }
        catch {
            $sw.Stop()
            return [pscustomobject]@{
                Success    = $false
                ExitCode   = 1
                Output     = $null
                Message    = $_.Exception.Message
                DurationMs = $sw.ElapsedMilliseconds
            }
        }
    }

    # --- DISM: RestoreHealth ---
    if ($RestoreHealth) {
        Write-Log -Level Info -Message "Running DISM /RestoreHealth locally..."
        $results.RestoreHealthResult = Invoke-DismCommand -Args @('/online', '/cleanup-image', '/restorehealth')
    }

    # --- DISM: StartComponentCleanup ---
    if ($StartComponentCleanup) {
        Write-Log -Level Info -Message "Running DISM /StartComponentCleanup locally..."
        $results.StartComponentCleanup = Invoke-DismCommand -Args @('/online', '/cleanup-image', '/startcomponentcleanup')
    }

    # --- DISM: ResetBase ---
    if ($ResetBase) {
        Write-Log -Level Info -Message "Running DISM /StartComponentCleanup /ResetBase locally..."
        $results.ResetBaseResult = Invoke-DismCommand -Args @('/online', '/cleanup-image', '/startcomponentcleanup', '/resetbase')
    }

    # --- SFC ---
    if ($SfcScannow) {
        Write-Log -Level Info -Message "Running SFC /scannow locally..."
        $sw = [System.Diagnostics.Stopwatch]::StartNew()
        try {
            $sfc = & sfc.exe /scannow 2>&1
            $sw.Stop()
            $results.SfcResult = [pscustomobject]@{
                Success    = $true
                Output     = ($sfc -join "`n")
                DurationMs = $sw.ElapsedMilliseconds
            }
        }
        catch {
            $sw.Stop()
            $results.SfcResult = [pscustomobject]@{
                Success    = $false
                Output     = "SFC failed: $($_.Exception.Message)"
                DurationMs = $sw.ElapsedMilliseconds
            }
        }
    }

    # --- Windows Update Reset ---
    if ($ResetUpdateComponents) {
        Write-Log -Level Info -Message "Resetting Windows Update components locally..."
        $sw = [System.Diagnostics.Stopwatch]::StartNew()
        try {
            $wu = Reset-WindowsUpdateComponents
            $sw.Stop()
            $results.ResetWUResult = [pscustomobject]@{
                Success    = $true
                Output     = $wu
                DurationMs = $sw.ElapsedMilliseconds
            }
        }
        catch {
            $sw.Stop()
            $results.ResetWUResult = [pscustomobject]@{
                Success    = $false
                Message    = "WU reset failed: $($_.Exception.Message)"
                DurationMs = $sw.ElapsedMilliseconds
            }
        }
    }

    # --- Finalize ---
    $results.CompletedAt = Get-Date
    $results.DurationSeconds = [math]::Round((New-TimeSpan -Start $results.StartedAt -End $results.CompletedAt).TotalSeconds, 2)

    return [pscustomobject]$results
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Private\System\Snapshot\Convert-CimDate.ps1

function Convert-CimDate {
    param([Parameter(ValueFromPipeline)][object]$CimDate)
    if ($null -eq $CimDate) { return $null }

    # If it's already a DateTime (CIM), just return it
    if ($CimDate -is [datetime]) { return [datetime]$CimDate }

    # If it's a non-empty string, try DMTF -> DateTime
    if ($CimDate -is [string] -and -not [string]::IsNullOrWhiteSpace($CimDate)) {
        try {
            return [Management.ManagementDateTimeConverter]::ToDateTime($CimDate)
        }
        catch {
            return $null
        }
    }

    return $null
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Private\System\Snapshot\Convert-FlatSnapshotToRows.ps1
function Convert-FlatSnapshotToRows {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [object]$FlatObject
    )

    $rows = @()

    # Determine groups by prefix before first underscore
    $groups = $FlatObject.PSObject.Properties.Name |
    Group-Object { $_.Split('_')[0] } |
    Sort-Object Name

    foreach ($group in $groups) {

        # Insert a section header row
        $rows += [pscustomobject]@{
            Label = "# $($group.Name)"
            Value = ""
        }

        # Insert each key/value in this group
        foreach ($key in $group.Group) {
            $rows += [pscustomobject]@{
                Label = $key
                Value = $FlatObject.$key
            }
        }

        # Blank line between groups
        $rows += [pscustomobject]@{
            Label = ""
            Value = ""
        }
    }

    return $rows
}
[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Private\System\Snapshot\Convert-SnapshotToFlatObject.ps1
function Convert-SnapshotToFlatObject {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory, ValueFromPipeline)]
        [object]$Snapshot
    )

    # Normalize to hashtable
    if ($Snapshot -isnot [hashtable]) {
        if ($Snapshot -is [pscustomobject]) {
            $h = @{}
            foreach ($p in $Snapshot.PSObject.Properties) {
                $h[$p.Name] = $p.Value
            }
            $Snapshot = $h
        }
        else {
            throw "Unsupported snapshot type: $($Snapshot.GetType().FullName)"
        }
    }

    $flat = @{}

    foreach ($key in $Snapshot.Keys) {
        $value = $Snapshot[$key]

        if ($null -eq $value) {
            $flat[$key] = $null
            continue
        }

        $typeName = $value.GetType().Name

        switch ($typeName) {

            # Nested hashtable  prefix keys
            'Hashtable' {
                foreach ($subKey in $value.Keys) {
                    $flat["${key}_${subKey}"] = $value[$subKey]
                }
            }

            # Arrays  index + prefix
            'Object[]' {
                $index = 0
                foreach ($item in $value) {

                    # If the array element is a hashtable, flatten it too
                    if ($item -is [hashtable]) {
                        foreach ($subKey in $item.Keys) {
                            $flat["${key}${index}_${subKey}"] = $item[$subKey]
                        }
                    }
                    else {
                        # Fallback: JSON encode the item
                        $flat["${key}${index}"] = ($item | ConvertTo-Json -Depth 10 -Compress)
                    }

                    $index++
                }
            }

            # Everything else  direct assignment
            default {
                $flat[$key] = $value
            }
        }
    }

    return [pscustomobject]$flat
}
[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Private\System\Snapshot\Get-SnapshotCPU.ps1
function Get-SnapshotCPU {
    [CmdletBinding()]
    param()

    <#
.SYNOPSIS
    Collect CPU information (to be executed locally on the target host).
.DESCRIPTION
    Designed for the Workers pattern. No remoting, no external logging. Emits a
    flat summary plus an optional CPUs array when multiple sockets exist.
#>

    Write-Verbose "Collecting CPU information..."

    function Convert-Architecture {
        param([int]$Code)
        switch ($Code) {
            0 { "x86" }
            1 { "MIPS" }
            2 { "Alpha" }
            3 { "PowerPC" }
            5 { "ARM" }
            6 { "Itanium" }
            9 { "x64" }
            default { [string]$Code }
        }
    }

    try {
        $cpu = Get-CimInstance -ClassName Win32_Processor -ErrorAction Stop

        # When multiple sockets exist, pick a representative for the flat summary
        $first = $cpu | Select-Object -First 1

        # Per-socket detail (safe, simple types only)
        $perSocket = $cpu | ForEach-Object {
            [pscustomobject]@{
                Name              = $_.Name
                Manufacturer      = $_.Manufacturer
                MaxClockSpeedMHz  = $_.MaxClockSpeed
                NumberOfCores     = $_.NumberOfCores
                LogicalProcessors = $_.NumberOfLogicalProcessors
                Architecture      = Convert-Architecture -Code $_.Architecture
                LoadPercentage    = $_.LoadPercentage
                SocketDesignation = $_.SocketDesignation
                ProcessorId       = $_.ProcessorId
            }
        }

        # Flat summary expected by existing flatteners
        $result = [pscustomobject]@{
            Name              = $first.Name
            Manufacturer      = $first.Manufacturer
            MaxClockSpeedMHz  = $first.MaxClockSpeed
            NumberOfCores     = $first.NumberOfCores
            LogicalProcessors = $first.NumberOfLogicalProcessors
            Architecture      = Convert-Architecture -Code $first.Architecture
            LoadPercentage    = $first.LoadPercentage
        }

        # Optional: include full detail when there are multiple processors/sockets
        if (($perSocket | Measure-Object).Count -gt 1) {
            # Adding an extra property is typically non-breaking for flatteners
            Add-Member -InputObject $result -NotePropertyName CPUs -NotePropertyValue $perSocket -Force
        }

        Write-Verbose "CPU information collected."
        return $result
    }
    catch {
        Write-Verbose ("Get-SnapshotCPU: {0}" -f $_.Exception.Message)
        # Return a minimal object so downstream code doesn't break
        return [pscustomobject]@{
            Name              = $null
            Manufacturer      = $null
            MaxClockSpeedMHz  = $null
            NumberOfCores     = $null
            LogicalProcessors = $null
            Architecture      = $null
            LoadPercentage    = $null
            Error             = $_.Exception.Message
        }
    }
}
[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Private\System\Snapshot\Get-SnapshotDisk.ps1
function Get-SnapshotDisk {
    [CmdletBinding()]
    param()

    <#
.SYNOPSIS
    Collect logical disk information (fixed disks only) for the snapshot.
.DESCRIPTION
    Designed for the Workers pattern. Runs locally on the target host and
    returns simple PSCustomObjects that serialize cleanly over remoting.
#>

    Write-Verbose "Collecting disk information..."

    try {
        # Fixed disks only (DriveType = 3)
        $volumes = Get-CimInstance -ClassName Win32_LogicalDisk -Filter "DriveType = 3" -ErrorAction Stop
    }
    catch {
        Write-Verbose ("Get-SnapshotDisks: {0}" -f $_.Exception.Message)
        return @()  # Return empty to keep downstream logic stable
    }

    $results = New-Object System.Collections.Generic.List[psobject]

    foreach ($v in $volumes) {
        # Safe numeric conversions
        $sizeGB = if ($null -ne $v.Size -and [double]::TryParse([string]$v.Size, [ref]([double]$null))) {
            [math]::Round([double]$v.Size / 1GB, 2)
        }
        else { $null }

        $freeGB = if ($null -ne $v.FreeSpace -and [double]::TryParse([string]$v.FreeSpace, [ref]([double]$null))) {
            [math]::Round([double]$v.FreeSpace / 1GB, 2)
        }
        else { $null }

        $pctFree = $null
        if ($sizeGB -ne $null -and $sizeGB -gt 0 -and $freeGB -ne $null) {
            $pctFree = [math]::Round(($freeGB / $sizeGB) * 100, 2)
        }

        $results.Add([pscustomobject]@{
                DriveLetter = $v.DeviceID
                VolumeLabel = $v.VolumeName
                FileSystem  = $v.FileSystem
                SizeGB      = $sizeGB
                FreeGB      = $freeGB
                PercentFree = $pctFree
            })
    }

    Write-Verbose "Disk information collected."
    return $results
}
[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Private\System\Snapshot\Get-SnapshotIdentity.ps1
function Get-SnapshotIdentity {
    [CmdletBinding()]
    param()

    <#
.SYNOPSIS
    Collect identity details (domain/workgroup, logged-on users, AD site, machine SID).
.DESCRIPTION
    Worker-friendly: runs locally on the target, no remoting, no module-specific logging.
    Emits a simple PSCustomObject safe for remoting serialization.
#>

    Write-Verbose "Collecting identity information..."

    function Get-MachineSidSafe {
        <#
    .SYNOPSIS
        Returns the machine SID (S-1-5-21-...).
    .DESCRIPTION
        Uses the local account with RID 500 (built-in Administrator) to derive AccountDomainSid,
        which equals the machine SID on workgroup or the domain SID on domain-joined machines.
        More robust than assuming the local admin is literally named 'Administrator'.
    #>
        try {
            $admin = Get-LocalUser -ErrorAction Stop | Where-Object { $_.SID -match '-500$' } | Select-Object -First 1
            if ($admin -and $admin.SID) {
                # AccountDomainSid is the machine (or domain) SID without the RID suffix
                return $admin.SID.AccountDomainSid.Value
            }
        }
        catch {
            Write-Verbose ("Get-MachineSidSafe: {0}" -f $_.Exception.Message)
        }
        return $null
    }

    function Get-AdSiteNameSafe {
        <#
    .SYNOPSIS
        Returns the AD site name if domain-joined and reachable.
    .DESCRIPTION
        Tries .NET (System.DirectoryServices.ActiveDirectory) first; falls back to 'nltest /dsgetsite'.
    #>
        try {
            Add-Type -AssemblyName System.DirectoryServices.AccountManagement -ErrorAction SilentlyContinue | Out-Null
            Add-Type -AssemblyName System.DirectoryServices -ErrorAction SilentlyContinue | Out-Null
            $site = [System.DirectoryServices.ActiveDirectory.ActiveDirectorySite]::GetComputerSite().Name
            if ($site) { return $site }
        }
        catch {
            # Fall back to nltest if present
            try {
                $nl = (Get-Command nltest -ErrorAction SilentlyContinue)
                if ($nl) {
                    $out = & nltest /dsgetsite 2>$null
                    if ($LASTEXITCODE -eq 0 -and $out) {
                        # nltest usually returns the site name on the first line
                        $line = ($out | Select-Object -First 1).ToString().Trim()
                        if ($line -and $line -notmatch 'is not a recognized') { return $line }
                    }
                }
            }
            catch {
                # ignore
            }
        }
        return $null
    }

    function Get-LoggedOnUsersSafe {
        <#
    .SYNOPSIS
        Attempts to enumerate interactive users.
    .DESCRIPTION
        Win32_ComputerSystem.UserName gives a single primary user (console). For RDS or multiple
        sessions, try 'quser' if available; otherwise fall back to CIM.
    #>
        $users = @()

        # quser (qwinsta alternate) is fast and present on most Windows
        try {
            $cmd = Get-Command quser -ErrorAction SilentlyContinue
            if ($cmd) {
                $lines = & quser 2>$null
                foreach ($l in $lines) {
                    # Skip headers, parse lines like:
                    # USERNAME              SESSIONNAME        ID  STATE   IDLE TIME  LOGON TIME
                    # jdoe                  rdp-tcp#12          2  Active      1:23   2/10/2026 9:15 AM
                    if ($l -match '^\s*(\S+)\s+(.+?)\s+(\d+)\s+(\S+)\s+') {
                        $users += [pscustomobject]@{
                            User    = $matches[1]
                            Session = $matches[2].Trim()
                            Id      = [int]$matches[3]
                            State   = $matches[4]
                        }
                    }
                }
            }
        }
        catch {
            Write-Verbose ("Get-LoggedOnUsersSafe(quser): {0}" -f $_.Exception.Message)
        }

        if (-not $users) {
            # Fallback: map Win32_LoggedOnUser to accounts (can include service accounts)
            try {
                $rels = Get-CimInstance Win32_LoggedOnUser -ErrorAction Stop
                # rels has Antecedent (account) and Dependent (logon session)
                foreach ($r in $rels) {
                    $acc = ($r.Antecedent -replace '^.*Domain="([^"]+)",Name="([^"]+)".*$', '$1\$2')
                    if ($acc -and $users.User -notcontains $acc) {
                        $users += [pscustomobject]@{
                            User    = $acc
                            Session = $null
                            Id      = $null
                            State   = $null
                        }
                    }
                }
            }
            catch {
                Write-Verbose ("Get-LoggedOnUsersSafe(CIM): {0}" -f $_.Exception.Message)
            }
        }

        return $users
    }

    try {
        $cs = Get-CimInstance -ClassName Win32_ComputerSystem -ErrorAction Stop

        $machineSid = Get-MachineSidSafe
        $adSite = $null
        if ($cs.PartOfDomain) {
            $adSite = Get-AdSiteNameSafe
        }

        $primaryUser = if ($cs.UserName) { $cs.UserName } else { $null }
        $allUsers = Get-LoggedOnUsersSafe

        $result = [pscustomobject]@{
            ComputerName  = $cs.Name
            DomainJoined  = [bool]$cs.PartOfDomain
            Domain        = if ($cs.PartOfDomain) { $cs.Domain } else { $null }
            Workgroup     = if (-not $cs.PartOfDomain) { $cs.Workgroup } else { $null }
            LoggedOnUser  = $primaryUser
            LoggedOnUsers = $allUsers          # optional richer view
            ADSite        = $adSite
            ComputerSID   = $machineSid
        }

        Write-Verbose "Identity information collected."
        return $result
    }
    catch {
        Write-Verbose ("Get-SnapshotIdentity: {0}" -f $_.Exception.Message)
        return [pscustomobject]@{
            ComputerName  = $env:COMPUTERNAME
            DomainJoined  = $null
            Domain        = $null
            Workgroup     = $null
            LoggedOnUser  = $null
            LoggedOnUsers = @()
            ADSite        = $null
            ComputerSID   = $null
            Error         = $_.Exception.Message
        }
    }
}
[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Private\System\Snapshot\Get-SnapshotMemory.ps1
function Get-SnapshotMemory {
    [CmdletBinding()]
    param()

    <#
.SYNOPSIS
    Collect memory and (optionally) page file information, worker-friendly.
.DESCRIPTION
    Runs locally on the target host (no remoting, no external logging). Returns
    simple PSCustomObject values that serialize cleanly.
#>

    Write-Verbose "Collecting memory information..."

    function Convert-KBToGB {
        param([Nullable[ulong]]$KB)
        if ($KB -eq $null) { return $null }
        # KB -> bytes -> GB
        [math]::Round(( [double]($KB * 1KB) / 1GB ), 2)
    }

    try {
        # Win32_OperatingSystem: TotalVisibleMemorySize/FreePhysicalMemory are in KB
        $os = Get-CimInstance -ClassName Win32_OperatingSystem -ErrorAction Stop

        $totalGB = Convert-KBToGB $os.TotalVisibleMemorySize
        $freeGB = Convert-KBToGB $os.FreePhysicalMemory

        $usedGB = $null
        if ($totalGB -ne $null -and $freeGB -ne $null) {
            $usedGB = [math]::Round($totalGB - $freeGB, 2)
        }

        $pctUsed = $null
        $pctFree = $null
        if ($totalGB -ne $null -and $totalGB -gt 0 -and $usedGB -ne $null) {
            $pctUsed = [math]::Round(($usedGB / $totalGB) * 100, 2)
            $pctFree = [math]::Round(100 - $pctUsed, 2)
        }

        # Optional: Page file usage summary (often handy in a snapshot)
        $page = $null
        try {
            $pf = Get-CimInstance -ClassName Win32_PageFileUsage -ErrorAction SilentlyContinue
            if ($pf) {
                # AllocatedBaseSize/CurrentUsage are in MB for PageFileUsage
                $page = [pscustomobject]@{
                    AllocatedGB  = [math]::Round( ( [double]($pf.AllocatedBaseSize | Measure-Object -Sum ).Sum ) / 1024, 2 )
                    CurrentUseGB = [math]::Round( ( [double]($pf.CurrentUsage     | Measure-Object -Sum ).Sum ) / 1024, 2 )
                    PeakUseGB    = [math]::Round( ( [double]($pf.PeakUsage        | Measure-Object -Sum ).Sum ) / 1024, 2 )
                    Files        = ($pf | Select-Object -ExpandProperty Name)
                }
            }
        }
        catch {
            Write-Verbose ("Get-SnapshotMemory(PageFile): {0}" -f $_.Exception.Message)
        }

        $result = [pscustomobject]@{
            TotalMemoryGB = $totalGB
            FreeMemoryGB  = $freeGB
            UsedMemoryGB  = $usedGB
            PercentUsed   = $pctUsed
            PercentFree   = $pctFree
            PageFile      = $page   # optional nested object; safe for serialization
        }

        Write-Verbose "Memory information collected."
        return $result
    }
    catch {
        Write-Verbose ("Get-SnapshotMemory: {0}" -f $_.Exception.Message)
        return [pscustomobject]@{
            TotalMemoryGB = $null
            FreeMemoryGB  = $null
            UsedMemoryGB  = $null
            PercentUsed   = $null
            PercentFree   = $null
            PageFile      = $null
            Error         = $_.Exception.Message
        }
    }
}
[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Private\System\Snapshot\Get-SnapshotNetwork.ps1
function Get-SnapshotNetwork {
    [CmdletBinding()]
    param(
        [switch]$IncludeVirtual,   # include vEthernet, VPN, Docker, etc.
        [switch]$IncludeDown       # include disconnected/administratively down adapters
    )

    <#
.SYNOPSIS
    Collect network adapter and IP configuration (worker-friendly).
.DESCRIPTION
    Uses modern NetAdapter/NetTCPIP cmdlets for reliable data. Returns a list of
    PSCustomObjects, one per relevant adapter, with IPv4/IPv6, DNS, gateway, and
    basics.
#>

    Write-Verbose "Collecting network information..."

    function Get-LinkSpeedMbps {
        param([nullable[UInt64]]$BitsPerSecond)
        if ($BitsPerSecond -eq $null) { return $null }
        # Convert bps to Mbps and round
        [math]::Round(($BitsPerSecond / 1mb), 0)
    }

    try {
        # Base adapter set
        $adapters = Get-NetAdapter -ErrorAction Stop

        # Filter by state unless IncludeDown
        if (-not $IncludeDown) {
            $adapters = $adapters | Where-Object { $_.Status -eq 'Up' }
        }

        # Filter out common virtuals unless IncludeVirtual
        if (-not $IncludeVirtual) {
            $adapters = $adapters | Where-Object {
                $n = $_.Name
                $d = $_.InterfaceDescription
                ($n -notmatch 'vEthernet|Hyper-V|Loopback|isatap|Teredo|Docker|VirtualBox|VMware|Bluetooth|Npcap') -and
                ($d -notmatch 'vEthernet|Hyper-V|Loopback|isatap|Teredo|Docker|VirtualBox|VMware|Bluetooth|Npcap')
            }
        }

        # Gather richer IP config objects in one shot
        $ipConfigs = Get-NetIPConfiguration -All -ErrorAction SilentlyContinue

        $results = New-Object System.Collections.Generic.List[psobject]

        foreach ($nic in $adapters) {
            $cfg = $ipConfigs | Where-Object { $_.InterfaceIndex -eq $nic.ifIndex } | Select-Object -First 1

            # IPv4 / IPv6 addresses with prefix lengths
            $ipv4 = @()
            $ipv6 = @()
            if ($cfg -and $cfg.IPv4Address) {
                $ipv4 = $cfg.IPv4Address | ForEach-Object {
                    [pscustomobject]@{
                        Address      = $_.IPAddress
                        PrefixLength = $_.PrefixLength
                    }
                }
            }
            if ($cfg -and $cfg.IPv6Address) {
                $ipv6 = $cfg.IPv6Address | ForEach-Object {
                    [pscustomobject]@{
                        Address      = $_.IPAddress
                        PrefixLength = $_.PrefixLength
                    }
                }
            }

            # Gateways (IPv4/IPv6)
            $gateways = @()
            if ($cfg -and $cfg.IPv4DefaultGateway) {
                $gateways += [pscustomobject]@{ Address = $cfg.IPv4DefaultGateway.NextHop; AddressFamily = 'IPv4' }
            }
            if ($cfg -and $cfg.IPv6DefaultGateway) {
                $gateways += [pscustomobject]@{ Address = $cfg.IPv6DefaultGateway.NextHop; AddressFamily = 'IPv6' }
            }

            # DNS servers and suffix
            $dnsServers = @()
            if ($cfg -and $cfg.DnsServer) {
                $dnsServers = $cfg.DnsServer.ServerAddresses
            }
            $dnsSuffix = if ($cfg) { $cfg.DnsSuffix } else { $null }

            # Profile (Domain/Private/Public) if available
            $netProfile = $null
            try {
                $profile = Get-NetConnectionProfile -InterfaceIndex $nic.ifIndex -ErrorAction SilentlyContinue | Select-Object -First 1
                if ($profile) { $netProfile = $profile.NetworkCategory }
            }
            catch { }

            # Compose object
            $results.Add([pscustomobject]@{
                    InterfaceAlias       = $nic.Name
                    InterfaceDescription = $nic.InterfaceDescription
                    InterfaceIndex       = $nic.ifIndex
                    MACAddress           = $nic.MacAddress
                    Status               = $nic.Status                 # Up/Down/Disabled
                    LinkSpeedMbps        = Get-LinkSpeedMbps $nic.LinkSpeed
                    MTU                  = $nic.Mtu
                    VlanID               = $nic.VlanID
                    DHCPEnabled          = if ($cfg) { [bool]$cfg.DhcpEnabled } else { $null }
                    DNSSuffix            = $dnsSuffix
                    DNSServers           = $dnsServers                 # array
                    IPv4Addresses        = $ipv4                       # array of {Address, PrefixLength}
                    IPv6Addresses        = $ipv6                       # array of {Address, PrefixLength}
                    Gateways             = $gateways                   # array of {Address, AddressFamily}
                    NetworkProfile       = $netProfile                 # Domain/Private/Public
                })
        }

        Write-Verbose ("Network information collected for {0} adapter(s)." -f $results.Count)
        return $results
    }
    catch {
        Write-Verbose ("Get-SnapshotNetwork: {0}" -f $_.Exception.Message)
        return @()
    }
}
[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Private\System\Snapshot\Get-SnapshotOS.ps1
function Get-SnapshotOS {
    [CmdletBinding()]
    param(
        [switch]$IncludeRoles  # When true and ServerManager is available, returns installed roles/features (Server OS)
    )

    <#
.SYNOPSIS
    Collect OS details (name/edition/build/version), install & boot times,
    uptime, and optional roles/features.
.DESCRIPTION
    Worker-friendly helper: runs locally on the target host (no remoting), uses
    CIM and registry, and emits a single PSCustomObject with only simple types.
    Optionally includes installed roles/features on Server OS.
#>

    Write-Verbose "Collecting OS information..."

    function Get-RegistryValue {
        param([string]$Path, [string]$Name)
        try {
            $item = Get-ItemProperty -Path $Path -ErrorAction Stop
            return $item.$Name
        }
        catch { return $null }
    }

    function Get-DomainRoleName {
        param([int]$Role)
        switch ($Role) {
            0 { 'StandaloneWorkstation' }
            1 { 'MemberWorkstation' }
            2 { 'StandaloneServer' }
            3 { 'MemberServer' }
            4 { 'BackupDomainController' }
            5 { 'PrimaryDomainController' }
            default { [string]$Role }
        }
    }

    # --- Core OS + ComputerSystem ---
    try {
        $os = Get-CimInstance -ClassName Win32_OperatingSystem -ErrorAction Stop
    }
    catch {
        Write-Verbose ("Get-SnapshotOS: failed WMI OS query: {0}" -f $_.Exception.Message)
        $os = $null
    }

    try {
        $cs = Get-CimInstance -ClassName Win32_ComputerSystem -ErrorAction SilentlyContinue
    }
    catch {
        $cs = $null
    }

    # --- Registry: CurrentVersion branch (extra build/version fields) ---
    $cvPath = 'HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion'
    $productNameReg = Get-RegistryValue -Path $cvPath -Name 'ProductName'
    $editionId = Get-RegistryValue -Path $cvPath -Name 'EditionID'
    $displayVersion = Get-RegistryValue -Path $cvPath -Name 'DisplayVersion'   # Win10/11 modern
    $releaseId = Get-RegistryValue -Path $cvPath -Name 'ReleaseId'        # older Win10
    $currentBuild = Get-RegistryValue -Path $cvPath -Name 'CurrentBuild'
    $currentBuildNum = Get-RegistryValue -Path $cvPath -Name 'CurrentBuildNumber'
    $ubr = Get-RegistryValue -Path $cvPath -Name 'UBR'              # Update Build Revision
    $currentVersion = Get-RegistryValue -Path $cvPath -Name 'CurrentVersion'
    $buildLabEx = Get-RegistryValue -Path $cvPath -Name 'BuildLabEx'
    $installType = Get-RegistryValue -Path $cvPath -Name 'InstallationType' # e.g., Client, Server, Server Core

    # --- Install / Boot / Uptime ---
    $installDate = if ($os -and $os.InstallDate) { Convert-CimDate $os.InstallDate } else { $null }
    $lastBoot = if ($os -and $os.LastBootUpTime) { Convert-CimDate $os.LastBootUpTime } else { $null }
    $uptimeSeconds = $null
    $uptime = $null
    if ($lastBoot) {
        $uptimeSpan = (Get-Date) - $lastBoot
        $uptimeSeconds = [int][math]::Round($uptimeSpan.TotalSeconds, 0)
        $uptime = $uptimeSpan.ToString()
    }

    # --- Domain role (friendly) ---
    $domainRoleName = if ($cs -and $null -ne $cs.DomainRole) { Get-DomainRoleName -Role $cs.DomainRole } else { $null }

    # --- Activation (best-effort) ---
    $activation = $null
    try {
        # SoftwareLicensingProduct can be noisy; filter to items with a product key and check LicenseStatus=1 (Licensed)
        $slp = Get-CimInstance -ClassName SoftwareLicensingProduct -ErrorAction SilentlyContinue |
        Where-Object { $_.PartialProductKey -and $_.LicenseStatus -ne $null } |
        Select-Object -First 1
        if ($slp) {
            $activation = if ($slp.LicenseStatus -eq 1) { 'Licensed' } else { 'Unlicensed' }
        }
    }
    catch { }

    # --- Optional: roles/features on Server OS ---
    $roles = $null
    $rolesCount = $null
    if ($IncludeRoles) {
        try {
            if (Get-Module -ListAvailable -Name ServerManager) {
                Import-Module ServerManager -ErrorAction SilentlyContinue | Out-Null
                $features = Get-WindowsFeature | Where-Object { $_.Installed }
                if ($features) {
                    # Keep it light: store names; callers can expand if needed
                    $roles = $features | Select-Object -ExpandProperty Name
                    $rolesCount = $roles.Count
                }
            }
        }
        catch {
            Write-Verbose ("Get-SnapshotOS(roles): {0}" -f $_.Exception.Message)
        }
    }

    # --- Compose result object (simple, flatten-friendly) ---
    $result = [pscustomobject]@{
        ComputerName     = if ($cs) { $cs.Name } else { $env:COMPUTERNAME }
        Caption          = if ($os) { $os.Caption } else { $productNameReg }
        ProductName      = $productNameReg
        EditionID        = $editionId
        InstallationType = $installType
        Version          = $currentVersion
        DisplayVersion   = $displayVersion
        ReleaseId        = $releaseId
        Build            = if ($currentBuild) { $currentBuild } else { if ($os) { $os.BuildNumber } else { $currentBuildNum } }
        UBR              = $ubr
        BuildLabEx       = $buildLabEx
        OSArchitecture   = if ($os) { $os.OSArchitecture } else { $null }
        InstallDate      = $installDate
        LastBootUpTime   = $lastBoot
        UptimeSeconds    = $uptimeSeconds
        Uptime           = $uptime
        DomainRole       = $domainRoleName
        Activation       = $activation
        Roles            = $roles       # array of role/feature names (Server OS only when IncludeRoles)
        RolesCount       = $rolesCount
    }

    Write-Verbose "OS information collected."
    return $result
}
[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Private\System\Snapshot\Get-SnapshotServices.ps1
function Get-SnapshotServices {
    [CmdletBinding()]
    param(
        [ValidateSet('Running', 'Stopped', 'All')]
        [string]$State = 'Running',

        [string[]]$NameLike,

        # Include only services whose StartMode is Automatic (includes Delayed start)
        [switch]$OnlyAuto,

        # Convenience filter: Automatic (incl. Delayed) but NOT currently Running
        [switch]$OnlyAutoStopped
    )

    <#
.SYNOPSIS
    Collect Windows services with optional filters; worker-friendly.
.DESCRIPTION
    Runs locally on the target host after being dot-sourced by the worker. Emits
    simple PSCustomObjects that serialize cleanly over remoting. Uses
    Win32_Service for rich details and augments with DelayedAutoStart via
    HKLM:\SYSTEM\CurrentControlSet\Services.
#>

    Write-Verbose "Collecting services..."

    # Preload DelayedAutoStart values once (faster than per-service lookups)
    $delayedMap = @{}
    try {
        $svcRoot = 'HKLM:\SYSTEM\CurrentControlSet\Services'
        if (Test-Path -LiteralPath $svcRoot) {
            Get-ChildItem -LiteralPath $svcRoot -ErrorAction SilentlyContinue | ForEach-Object {
                $n = $_.PSChildName
                try {
                    $v = (Get-ItemProperty -LiteralPath $_.PSPath -Name DelayedAutoStart -ErrorAction SilentlyContinue).DelayedAutoStart
                    if ($null -ne $v) {
                        # 1 = delayed auto start
                        $delayedMap[$n] = ([int]$v -eq 1)
                    }
                }
                catch { }
            }
        }
    }
    catch {
        Write-Verbose ("Failed to enumerate DelayedAutoStart values: {0}" -f $_.Exception.Message)
    }

    # Gather services
    $services = @()
    try {
        $services = Get-CimInstance -ClassName Win32_Service -ErrorAction Stop
    }
    catch {
        Write-Verbose ("Get-SnapshotServices: {0}" -f $_.Exception.Message)
        return @()
    }

    # Project to simple objects
    $items = foreach ($s in $services) {
        [pscustomobject]@{
            Name             = $s.Name
            DisplayName      = $s.DisplayName
            State            = $s.State                 # Running | Stopped | Paused | ...
            Status           = $s.Status                # OK | Error | ...
            StartMode        = $s.StartMode             # Auto | Manual | Disabled
            DelayedAutoStart = $( if ($delayedMap.ContainsKey($s.Name)) { $delayedMap[$s.Name] } else { $null } )
            StartName        = $s.StartName             # Log On As
            ProcessId        = $s.ProcessId
            PathName         = $s.PathName
            Description      = $s.Description
            ServiceType      = $s.ServiceType
        }
    }

    # Apply filters
    if ($State -ne 'All') {
        $items = $items | Where-Object { $_.State -eq $State }
    }

    if ($OnlyAuto) {
        $items = $items | Where-Object {
            $_.StartMode -eq 'Auto'  # includes Automatic (Delayed) which still reports StartMode='Auto'
        }
    }

    if ($OnlyAutoStopped) {
        $items = $items | Where-Object {
            $_.StartMode -eq 'Auto' -and $_.State -ne 'Running'
        }
    }

    if ($NameLike) {
        # Accept plain strings or regex fragments; OR them together
        $pattern = ($NameLike | ForEach-Object { [regex]::Escape($_) }) -join '|'
        $items = $items | Where-Object { $_.Name -match $pattern -or $_.DisplayName -match $pattern }
    }

    Write-Verbose ("Services collected: {0}" -f ($items | Measure-Object).Count)
    return $items
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Private\System\Snapshot\Show-SystemSnapshotReport.ps1
function Show-SystemSnapshotReport {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [pscustomobject]$Snapshot
    )

    Write-Host ""
    Write-Host "=== SYSTEM SNAPSHOT: $($Snapshot.ComputerName) ===" -ForegroundColor Cyan
    Write-Host "Timestamp: $($Snapshot.Timestamp)"
    Write-Host ""

    # --- OS ---
    $os = $Snapshot.OS
    Write-Host "OS" -ForegroundColor Yellow
    Write-Host "  $($os.Caption) ($($os.Build))"
    Write-Host "  Edition: $($os.EditionID)"
    Write-Host "  Architecture: $($os.OSArchitecture)"
    if ($os.Uptime) { Write-Host "  Uptime: $($os.Uptime)" }
    Write-Host ""

    # --- CPU ---
    $cpu = $Snapshot.CPU
    Write-Host "CPU" -ForegroundColor Yellow
    Write-Host "  $($cpu.Name)"
    Write-Host "  Cores: $($cpu.NumberOfCores)   Logical: $($cpu.LogicalProcessors)"
    Write-Host "  Load: $($cpu.LoadPercentage)%"
    Write-Host ""

    # --- Memory ---
    $mem = $Snapshot.Memory
    Write-Host "Memory" -ForegroundColor Yellow
    Write-Host "  Total: $([math]::Round($mem.TotalMemoryGB,2)) GB"
    Write-Host "  Used : $([math]::Round($mem.UsedMemoryGB,2)) GB ($([math]::Round($mem.PercentUsed,1))%)"
    Write-Host "  Free : $([math]::Round($mem.FreeMemoryGB,2)) GB ($([math]::Round($mem.PercentFree,1))%)"
    Write-Host ""

    # --- Disks ---
    Write-Host "Disks" -ForegroundColor Yellow
    foreach ($disk in $Snapshot.Disks) {
        Write-Host "  $($disk.DriveLetter)  $($disk.VolumeLabel)"
        Write-Host "    Size: $($disk.SizeGB) GB   Free: $($disk.FreeGB) GB ($($disk.PercentFree)% free)"
    }
    Write-Host ""

    # --- Network ---
    $net = $Snapshot.Network
    Write-Host "Network" -ForegroundColor Yellow
    Write-Host "  Logged-on user: $($net.LoggedOnUser)"
    Write-Host "  Workgroup     : $($net.Workgroup)"
    Write-Host "  Domain joined : $($net.DomainJoined)"
    Write-Host ""

    # --- Identity ---
    $id = $Snapshot.Identity
    Write-Host "Identity" -ForegroundColor Yellow
    Write-Host "  SID: $($id.ComputerSID)"
    Write-Host ""

    # --- Services (optional) ---
    if ($Snapshot.Services) {
        Write-Host "Services (Running)" -ForegroundColor Yellow
        foreach ($svc in $Snapshot.Services) {
            Write-Host "  $($svc.Name)  $($svc.DisplayName)"
        }
        Write-Host ""
    }

    Write-Host "=== END OF REPORT ===" -ForegroundColor Cyan
    Write-Host ""
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Private\System\Uptime\Export-UptimeCsv.ps1
function Export-UptimeCsv {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)][string]$OutDir,
        [Parameter(Mandatory)][string]$ComputerName,
        [Parameter(Mandatory)][pscustomobject]$Data
    )

    if (-not (Test-Path -LiteralPath $OutDir)) {
        New-Item -ItemType Directory -Path $OutDir -Force | Out-Null
    }

    $stamp = Get-Date -Format 'yyyy-MM-dd_HH-mm-ss'
    $csv = Join-Path $OutDir ("SystemUptime_{0}_{1}.csv" -f $ComputerName, $stamp)

    $Data | Export-Csv -Path $csv -NoTypeInformation -Encoding UTF8
    Write-Log -Level Ok -Message "Uptime exported for $ComputerName to $csv"
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Private\System\Uptime\Resolve-UptimeExportPath.ps1
function Resolve-UptimeExportPath {
    [CmdletBinding()]
    param(
        [string]$OutDir
    )

    if ($OutDir) { return $OutDir }

    if ($script:cfg -and $script:cfg.settings -and $script:cfg.settings.systemUptime) {
        $cfgPath = $script:cfg.settings.systemUptime.exportPath
        if ($cfgPath) { return [string]$cfgPath }
    }

    $fallback = Join-Path $script:ModuleRoot 'Exports\SystemUptime'
    if (-not (Test-Path -LiteralPath $fallback)) {
        New-Item -ItemType Directory -Path $fallback -Force | Out-Null
    }
    return $fallback
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Private\System\Utilities\LocalWorkHelpers\Invoke-WUResetLocal.ps1
function Invoke-WUResetLocal {
    [CmdletBinding()]
    param()

    $result = [ordered]@{
        StoppedServices = @()
        RenamedFolders  = @()
        Errors          = @()
    }

    $services = 'wuauserv', 'cryptsvc', 'bits', 'msiserver'

    foreach ($svc in $services) {
        try {
            Stop-Service -Name $svc -Force -ErrorAction Stop
            $result.StoppedServices += $svc
        }
        catch {
            $result.Errors += "Failed to stop ${svc}: $($_.Exception.Message)"
        }
    }

    try {
        Remove-Item -Path "$env:ALLUSERSPROFILE\Application Data\Microsoft\Network\Downloader\qmgr*.dat" -Force -ErrorAction Stop
    }
    catch {
        $result.Errors += "Failed to delete qmgr files: $($_.Exception.Message)"
    }

    try {
        $sd = Join-Path $env:SystemRoot "SoftwareDistribution"
        $sd2 = Join-Path $env:SystemRoot "SoftwareDistribution.old"
        if (Test-Path $sd2) { Remove-Item -Path $sd2 -Recurse -Force }
        if (Test-Path $sd) {
            Rename-Item -Path $sd -NewName "SoftwareDistribution.old" -Force
            $result.RenamedFolders += "SoftwareDistribution  SoftwareDistribution.old"
        }
    }
    catch {
        $result.Errors += "Failed to rename SoftwareDistribution: $($_.Exception.Message)"
    }

    try {
        $cr = Join-Path $env:SystemRoot "System32\catroot2"
        $cr2 = Join-Path $env:SystemRoot "System32\catroot2.old"
        if (Test-Path $cr2) { Remove-Item -Path $cr2 -Recurse -Force }
        if (Test-Path $cr) {
            Rename-Item -Path $cr -NewName "catroot2.old" -Force
            $result.RenamedFolders += "catroot2  catroot2.old"
        }
    }
    catch {
        $result.Errors += "Failed to rename catroot2: $($_.Exception.Message)"
    }

    foreach ($svc in $services) {
        try {
            Start-Service -Name $svc -ErrorAction Stop
        }
        catch {
            $result.Errors += "Failed to start ${svc}: $($_.Exception.Message)"
        }
    }

    return [pscustomobject]$result
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Private\System\Utilities\LocalWorkHelpers\Start-PDQDiagLocalSystem.ps1
function Start-PDQDiagLocalSystem {
    <#
.SYNOPSIS
  Collect PDQ diagnostics on THIS machine under SYSTEM and drop the ZIP to LocalDropPath.

.DESCRIPTION
  - Creates a one-shot scheduled task as SYSTEM that runs the PDQ worker.
  - Worker writes to C:\Windows\Temp\PDQDiag_<Host>_<Timestamp>.zip
  - This function then copies that ZIP to -LocalDropPath.

.PARAMETER LocalDropPath
  Destination folder for the final ZIP. Default: C:\PDQDiagLogs

.PARAMETER ExtraPaths
  Additional files/folders to include.

.PARAMETER ConnectDataPath
  Root for PDQ Connect agent data. Default: "$env:ProgramData\PDQ\PDQConnectAgent"

.PARAMETER Timestamp
  Optional fixed timestamp (yyyyMMdd-HHmmss). If not provided, generated automatically.

.OUTPUTS
  [pscustomobject] with ComputerName, Status, ZipPath, Notes
#>
    [CmdletBinding()]
    param(
        [string]  $LocalDropPath = 'C:\PDQDiagLogs',
        [string[]]$ExtraPaths,
        [string]  $ConnectDataPath = (Join-Path $env:ProgramData 'PDQ\PDQConnectAgent'),
        [string]  $Timestamp
    )

    if (-not (Get-Command -Name Get-SystemWorkerScriptContent -ErrorAction SilentlyContinue)) {
        throw "Get-SystemWorkerScriptContent is not available. Make sure it's dot-sourced in the module (Private\Get-SystemWorkerScriptContent.ps1)."
    }

    if (-not $Timestamp) { $Timestamp = Get-Date -Format 'yyyyMMdd-HHmmss' }
    if (-not (Test-Path -LiteralPath $LocalDropPath)) {
        New-Item -ItemType Directory -Path $LocalDropPath -Force | Out-Null
    }

    $tempRoot = Join-Path $env:windir 'Temp'
    $argsPath = Join-Path $tempRoot ("PDQDiag_args_{0}.json" -f $Timestamp)
    $scrPath = Join-Path $tempRoot ("PDQDiag_worker_{0}.ps1" -f $Timestamp)
    $staging = Join-Path $tempRoot ("PDQDiag_{0}_{1}" -f $env:COMPUTERNAME, $Timestamp)
    $doneFlag = Join-Path $staging  'system_done.flag'
    $zipPath = Join-Path $tempRoot ("PDQDiag_{0}_{1}.zip" -f $env:COMPUTERNAME, $Timestamp)
    $finalZip = Join-Path $LocalDropPath ("PDQDiag_{0}_{1}.zip" -f $env:COMPUTERNAME, $Timestamp)

    # Write worker + args for SYSTEM
    [pscustomobject]@{
        Timestamp       = $Timestamp
        ConnectDataPath = $ConnectDataPath
        ExtraPaths      = @($ExtraPaths)
    } | ConvertTo-Json -Depth 5 | Set-Content -Path $argsPath -Encoding UTF8

    (Get-SystemWorkerScriptContent) | Set-Content -Path $scrPath -Encoding UTF8

    Write-Host ("[{0}] Scheduling SYSTEM worker..." -f $env:COMPUTERNAME) -ForegroundColor Cyan
    $taskName = "PDQDiag-Local-$Timestamp"
    $actionArg = "-NoProfile -ExecutionPolicy Bypass -File `"$scrPath`" -ArgsPath `"$argsPath`""

    $usedSchtasks = $false
    try {
        $act = New-ScheduledTaskAction -Execute 'powershell.exe' -Argument $actionArg
        $task = Register-ScheduledTask -TaskName $taskName -Action $act -RunLevel Highest -User 'SYSTEM' -Force
        Start-ScheduledTask -TaskName $taskName
    }
    catch {
        $usedSchtasks = $true
        & schtasks.exe /Create /TN $taskName /SC ONCE /ST 00:00 /RL HIGHEST /RU SYSTEM /TR ("powershell.exe {0}" -f $actionArg) /F | Out-Null
        & schtasks.exe /Run /TN $taskName | Out-Null
    }

    # Wait up to 3 minutes for done flag
    Write-Host ("[{0}] Waiting for completion..." -f $env:COMPUTERNAME) -ForegroundColor DarkCyan
    $deadline = (Get-Date).AddSeconds(180)
    while ((Get-Date) -lt $deadline -and -not (Test-Path -LiteralPath $doneFlag -ErrorAction SilentlyContinue)) {
        Start-Sleep -Seconds 2
    }

    # Cleanup task registration
    try {
        if ($usedSchtasks) { & schtasks.exe /Delete /TN $taskName /F | Out-Null }
        else { Unregister-ScheduledTask -TaskName $taskName -Confirm:$false -ErrorAction SilentlyContinue | Out-Null }
    }
    catch {}

    if (-not (Test-Path -LiteralPath $zipPath -ErrorAction SilentlyContinue)) {
        throw "SYSTEM worker did not produce ZIP at $zipPath"
    }

    Copy-Item -LiteralPath $zipPath -Destination $finalZip -Force
    Write-Host ("[{0}] ZIP ready: {1}" -f $env:COMPUTERNAME, $finalZip) -ForegroundColor Green

    # Best-effort cleanup of temp artifacts
    try {
        if (Test-Path $staging) { Remove-Item -LiteralPath $staging -Recurse -Force -ErrorAction SilentlyContinue }
        if (Test-Path $zipPath) { Remove-Item -LiteralPath $zipPath -Force -ErrorAction SilentlyContinue }
        if (Test-Path $scrPath) { Remove-Item -LiteralPath $scrPath -Force -ErrorAction SilentlyContinue }
        if (Test-Path $argsPath) { Remove-Item -LiteralPath $argsPath -Force -ErrorAction SilentlyContinue }
    }
    catch {}

    [pscustomobject]@{
        ComputerName = $env:COMPUTERNAME
        Status       = 'Success'
        ZipPath      = $finalZip
        Notes        = 'Local SYSTEM collection (scheduled task)'
    }
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Private\System\Utilities\PasswordRelated\Get-NewPassword.ps1

function Get-NewPassword {
    [CmdletBinding()]
    param(
        [ValidateSet('Random', 'Readable', 'Passphrase')]
        [string]$Style,

        [int]$Length,

        [int]$Digits,

        [string]$Separator,

        [switch]$IncludeSymbol,

        [switch]$NoAmbiguous,

        [int]$NonAlpha,

        [string[]]$DisallowTokens = @()
    )

    $wlPath = $script:cfg.settings.passwords.wordListPath
    $def = $script:cfg.settings.passwords.default

    # Apply defaults only if not explicitly passed
    if (-not $PSBoundParameters.ContainsKey('Style') -and $def.style) { $Style = $def.style }
    if (-not $PSBoundParameters.ContainsKey('Length') -and $def.length) { $Length = [int]$def.length }
    if (-not $PSBoundParameters.ContainsKey('Digits') -and $def.digits) { $Digits = [int]$def.digits }
    if (-not $PSBoundParameters.ContainsKey('Separator') -and $def.separator -ne $null) { $Separator = [string]$def.separator }

    # Random style-only param default
    if ($Style -eq 'Random' -and -not $PSBoundParameters.ContainsKey('NonAlpha')) {
        $NonAlpha = 0
    }

    # Call the generator
    New-RandomPassword `
        -Style ($Style ? $Style : 'Readable') `
        -Length ($Length ? $Length : 12) `
        -Digits ($Digits ? $Digits : 2) `
        -Separator ($Separator ? $Separator : '') `
        -IncludeSymbol:$IncludeSymbol `
        -NoAmbiguous:$NoAmbiguous `
        -NonAlpha ($NonAlpha ? $NonAlpha : 0) `
        -WordListPath $wlPath `
        -DisallowTokens $DisallowTokens
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Private\System\Utilities\PasswordRelated\New-RandomPassword.ps1

function New-RandomPassword {
    <#
    .SYNOPSIS
        Generates passwords that meet AD "complexity" (3/4 categories) using
        Random, Readable, or Passphrase styles.

    .DESCRIPTION
        - Random: cryptographically-random with optional symbols; exact length.
        - Readable: Two (or more) capitalized words + digits (+ optional
          symbol); length is a minimum.
        - Passphrase: 34 lower/Title words with separators + digits; length is
          a minimum. All styles avoid ambiguous characters when -NoAmbiguous is
          set. You can provide -DisallowTokens to prevent generating passwords
          that include user-related tokens (e.g., given/surname fragments).

    .PARAMETER Length
        For Random: exact length. For Readable/Passphrase: *minimum* length;
        will be padded if shorter.

    .PARAMETER NonAlpha
        Number of required symbols (Random style only). Set to 0 to omit symbols
        entirely.

    .PARAMETER NoAmbiguous
        Excludes look-alike chars and, for Readable/Passphrase, filters out
        words containing ambiguous letters.

    .PARAMETER Style
        Random | Readable | Passphrase

    .PARAMETER Words
        Number of words for Readable/Passphrase (Readable defaults 2; Passphrase
        defaults 3).

    .PARAMETER Digits
        Number of digits to include (ensures numeric category).

    .PARAMETER Separator
        Character(s) used between words for Readable/Passphrase (e.g., '-', '.',
        '').

    .PARAMETER IncludeSymbol
        Adds exactly one symbol in Readable/Passphrase styles (not required for
        AD).

    .PARAMETER WordListPath
        Optional path to a newline-delimited word list. If not supplied or not
        found, a built-in list is used.

    .PARAMETER DisallowTokens
        Array of strings to avoid (case-insensitive). If any token of length >=
        3 appears, regenerates.

    .EXAMPLE
        New-RandomPassword -Style Readable -Length 12 -Digits 2
        # Example: RiverStone88

    .EXAMPLE
        New-RandomPassword -Style Passphrase -Length 16 -Separator '-' -Digits 3
        # Example: tiger-forest-echo721

    .EXAMPLE
        New-RandomPassword -Style Random -Length 16 -NonAlpha 0 -NoAmbiguous
        # Example: Hw7t9GZxFv3K2QmN

    .OUTPUTS
        System.String - The generated password.
    #>
    [CmdletBinding(DefaultParameterSetName = 'Random')]
    param(
        [ValidateRange(8, 256)]
        [int]$Length = 16,

        # Random style only: number of required non-alphanumeric (symbols)
        [Parameter(ParameterSetName = 'Random')]
        [ValidateRange(0, 64)]
        [int]$NonAlpha = 0,

        [switch]$NoAmbiguous,

        [ValidateSet('Random', 'Readable', 'Passphrase')]
        [string]$Style = 'Random',

        # Word-based styles
        [ValidateRange(2, 6)]
        [int]$Words = 2,

        [ValidateRange(1, 6)]
        [int]$Digits = 2,

        [string]$Separator = '',

        [switch]$IncludeSymbol,

        [string]$WordListPath,

        [string[]]$DisallowTokens = @(),

        [ValidateRange(1, 200)]
        [int]$MaxRegenerate = 50
    )

    # Character sets
    $UpperSet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
    $LowerSet = 'abcdefghijklmnopqrstuvwxyz'
    $DigitSet = '0123456789'
    $SymbolSet = '!@#$%^&*_-+=?'

    if ($NoAmbiguous) {
        $UpperSet = 'ABCDEFGHJKLMNPQRSTUVWXYZ'      # no I, O
        $LowerSet = 'abcdefghijkmnpqrstuvwxyz'      # no l, o
        $DigitSet = '23456789'                      # no 0, 1
        # symbols ok as-is
    }

    # Crypto RNG helpers
    $rng = [System.Security.Cryptography.RandomNumberGenerator]::Create()
    $hasGetInt32 = ([System.Security.Cryptography.RandomNumberGenerator].GetMethod('GetInt32', [type[]]@([int], [int])) -ne $null)

    function Get-RandomIndex {
        param([int]$MaxExclusive)
        if ($MaxExclusive -le 0) { return 0 }
        if ($hasGetInt32) {
            return [System.Security.Cryptography.RandomNumberGenerator]::GetInt32(0, $MaxExclusive)
        }
        else {
            $b = New-Object byte[] 4
            $rng.GetBytes($b)
            return [Math]::Abs([BitConverter]::ToInt32($b, 0) % $MaxExclusive)
        }
    }

    function Get-RandomChar {
        param([string]$DigitSet)
        $DigitSet[(Get-RandomIndex $DigitSet.Length)]
    }

    function Get-RandomFromList {
        param([string[]]$List)
        $List[(Get-RandomIndex $List.Count)]
    }

    function Shuffle([char[]]$arr) {
        for ($i = $arr.Length - 1; $i -gt 0; $i--) {
            $j = Get-RandomIndex ($i + 1)
            if ($j -ne $i) {
                $tmp = $arr[$i]; $arr[$i] = $arr[$j]; $arr[$j] = $tmp
            }
        }
        -join $arr
    }

    function Import-WordList {
        param([string]$Path, [switch]$NoAmbiguous)
        $list = @()
        if ($Path -and (Test-Path -LiteralPath $Path)) {
            $list = Get-Content -LiteralPath $Path -ErrorAction Stop | Where-Object { $_ -match '^[A-Za-z]{3,10}$' }
        }
        if (-not $list -or $list.Count -lt 100) {
            # Fallback mini list if wordlist.txt fails to Import
            $list = @(
                'river', 'stone', 'blue', 'green', 'tiger', 'forest', 'echo', 'delta', 'nova', 'ember', 'maple', 'cedar', 'birch', 'pine',
                'silver', 'shadow', 'crimson', 'cobalt', 'onyx', 'raven', 'falcon', 'otter', 'fox', 'wolf', 'lynx', 'badger', 'eagle',
                'harbor', 'summit', 'meadow', 'prairie', 'canyon', 'valley', 'spring', 'autumn', 'winter', 'summer', 'breeze', 'cloud',
                'storm', 'thunder', 'rain', 'snow', 'frost', 'glacier', 'aurora', 'comet', 'meteor', 'orbit', 'quartz', 'granite', 'basalt',
                'pebble', 'coral', 'reef', 'tide', 'delta', 'lagoon', 'moss', 'fern', 'willow', 'aspen', 'spruce', 'hemlock', 'elm',
                'copper', 'iron', 'nickel', 'zinc', 'amber', 'topaz', 'agate', 'jade', 'opal', 'pearl', 'sapphire', 'ruby', 'garnet',
                'swift', 'brisk', 'rapid', 'steady', 'bold', 'bright', 'quiet', 'gentle', 'keen', 'vivid', 'lively', 'nimble', 'solid',
                'lofty', 'noble', 'true', 'prime', 'vantage', 'zenith', 'apex', 'vertex', 'vector', 'gamma', 'omega', 'alpha', 'sigma',
                'orbit', 'photon', 'quark', 'ion', 'pixel', 'matrix', 'cipher', 'beacon', 'signal', 'kernel', 'crypto', 'evergreen', 'lake'
            )
        }
        $list = $list | ForEach-Object { $_.ToLowerInvariant().Trim() } | Where-Object { $_ -ne '' } | Select-Object -Unique
        if ($NoAmbiguous) {
            $list = $list | Where-Object { $_ -notmatch '[ilo10]' } # filter words with ambiguous chars
        }
        return $list
    }

    function Confirm-Tokens {
        param([string]$Text, [string[]]$Tokens)
        foreach ($t in $Tokens) {
            if ([string]::IsNullOrWhiteSpace($t)) { continue }
            $tok = $t.Trim()
            if ($tok.Length -lt 3) { continue } # AD typically flags 3+ char sequences
            if ($Text -imatch [regex]::Escape($tok)) { return $true }
        }
        return $false
    }

    try {
        switch ($Style) {
            'Random' {
                # Ensure at least: 1 upper, 1 lower, 1 digit, + NonAlpha symbols
                $minRequired = 3 + $NonAlpha
                if ($Length -lt $minRequired) {
                    throw "Requested Length $Length is less than required minimum $minRequired (1 upper + 1 lower + 1 digit + $NonAlpha symbol(s))."
                }

                # Collect mandatory characters
                $chars = New-Object System.Collections.Generic.List[char]
                $chars.Add((Get-RandomChar $UpperSet))
                $chars.Add((Get-RandomChar $LowerSet))
                $chars.Add((Get-RandomChar $DigitSet))
                for ($i = 0; $i -lt $NonAlpha; $i++) { $chars.Add((Get-RandomChar $SymbolSet)) }

                # Fill remaining with union of sets (respecting NonAlpha=0 if you want no symbols)
                $all = ($UpperSet + $LowerSet + $DigitSet + ($NonAlpha -gt 0 ? $SymbolSet : '')).ToCharArray()
                while ($chars.Count -lt $Length) {
                    $chars.Add($all[(Get-RandomIndex $all.Length)])
                }

                # Shuffle & return
                $pwd = Shuffle ($chars.ToArray())
                return $pwd
            }

            'Readable' {
                # Make at least 2 words capitalized to ensure Upper+Lower, plus digits -> meets 3/4
                $wl = Import-WordList -Path $WordListPath -NoAmbiguous:$NoAmbiguous
                if ($Words -lt 2) { $Words = 2 } # enforce sane min for readability

                for ($attempt = 0; $attempt -lt $MaxRegenerate; $attempt++) {
                    $picked = for ($i = 1; $i -le $Words; $i++) { Get-RandomFromList $wl }
                    $capIdx = Get-RandomIndex $picked.Count
                    $wordsOut = for ($i = 0; $i -lt $picked.Count; $i++) {
                        if ($i -eq $capIdx) {
                            # TitleCase one word for uppercase category
                            ($picked[$i].Substring(0, 1).ToUpperInvariant() + $picked[$i].Substring(1).ToLowerInvariant())
                        }
                        else {
                            $picked[$i].ToLowerInvariant()
                        }
                    }

                    $digitsStr = -join (1..$Digits | ForEach-Object { Get-RandomChar $DigitSet })
                    $parts = @($wordsOut -join $Separator, $digitsStr)

                    if ($IncludeSymbol) {
                        # Insert symbol at a random position among parts
                        $sym = Get-RandomChar $SymbolSet
                        $insertPos = Get-RandomIndex ($parts.Count + 1)
                        $parts = ($parts[0..($insertPos - 1)] + $sym + $parts[$insertPos..($parts.Count - 1)]) -join ''
                    }
                    else {
                        $parts = -join $parts
                    }

                    $candidate = $parts

                    # Ensure minimum length (pad with lowercase if short)
                    if ($candidate.Length -lt $Length) {
                        $padCount = $Length - $candidate.Length
                        $pad = -join (1..$padCount | ForEach-Object { Get-RandomChar $LowerSet })
                        $candidate += $pad
                    }

                    if ($DisallowTokens.Count -gt 0 -and (Confirm-Tokens -Text $candidate -Tokens $DisallowTokens)) {
                        continue
                    }

                    # Sanity: ensure categories: upper, lower, digit
                    if (($candidate -cmatch '[A-Z]') -and ($candidate -cmatch '[a-z]') -and ($candidate -match '\d')) {
                        return $candidate
                    }
                }
                throw "Failed to generate a Readable password after $MaxRegenerate attempts. Consider relaxing DisallowTokens/length."
            }

            'Passphrase' {
                # Typically 3+ words, lower/title with separator, + digits; length is a minimum
                if ($Words -lt 3) { $Words = 3 }
                $wl = Import-WordList -Path $WordListPath -NoAmbiguous:$NoAmbiguous

                for ($attempt = 0; $attempt -lt $MaxRegenerate; $attempt++) {
                    $picked = for ($i = 1; $i -le $Words; $i++) { Get-RandomFromList $wl }
                    # Capitalize one random word to ensure uppercase category
                    $capIdx = Get-RandomIndex $picked.Count
                    for ($i = 0; $i -lt $picked.Count; $i++) {
                        if ($i -eq $capIdx) {
                            $picked[$i] = $picked[$i].Substring(0, 1).ToUpperInvariant() + $picked[$i].Substring(1).ToLowerInvariant()
                        }
                        else {
                            $picked[$i] = $picked[$i].ToLowerInvariant()
                        }
                    }

                    $core = ($picked -join $Separator)
                    $digitsStr = -join (1..$Digits | ForEach-Object { Get-RandomChar $DigitsSet })
                    $candidate = $core + $digitsStr

                    if ($IncludeSymbol) {
                        $candidate += (Get-RandomChar $SymbolSet)
                    }

                    if ($candidate.Length -lt $Length) {
                        $padCount = $Length - $candidate.Length
                        $pad = -join (1..$padCount | ForEach-Object { Get-RandomChar $LowerSet })
                        $candidate += $pad
                    }

                    if ($DisallowTokens.Count -gt 0 -and (Confirm-Tokens -Text $candidate -Tokens $DisallowTokens)) {
                        continue
                    }

                    # Ensure categories: upper, lower, digit
                    if (($candidate -cmatch '[A-Z]') -and ($candidate -cmatch '[a-z]') -and ($candidate -match '\d')) {
                        return $candidate
                    }
                }
                throw "Failed to generate a Passphrase after $MaxRegenerate attempts. Consider relaxing DisallowTokens/length."
            }
        }
    }
    finally {
        $rng.Dispose()
    }
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Private\System\Utilities\PasswordRelated\Show-Step.ps1
function Show-Step {
    param(
        [string]$Activity,
        [string]$Status,
        [int]$Percent
    )
    Write-Log -Level Info -Message "$Activity :: $Status"
    if ($ShowProgress) {
        Write-Progress -Activity $Activity -Status $Status -PercentComplete $Percent
    }
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Private\System\Utilities\RemoteWorkHelpers\Get-ModuleRoot.ps1
function Get-ModuleRoot {
    $mod = $ExecutionContext.SessionState.Module
    if ($mod -and $mod.Path) { return (Split-Path -Parent $mod.Path) }

    $m = Get-Module -Name TechToolbox -ErrorAction Ignore | Select-Object -First 1
    if ($m -and $m.Path) { return (Split-Path -Parent $m.Path) }

    if ($PSScriptRoot) { return (Split-Path -Parent $PSScriptRoot) }
    if ($MyInvocation.MyCommand.Path) { return (Split-Path -Parent $MyInvocation.MyCommand.Path) }

    throw "Unable to resolve TechToolbox module root."
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Private\System\Utilities\RemoteWorkHelpers\Invoke-RemoteSystemCollection.ps1
function Invoke-RemoteSystemCollection {
  <#
.SYNOPSIS
  Run the PDQ diagnostics on a remote host under SYSTEM via a one-shot Scheduled Task.

.DESCRIPTION
  - Reads Workers\RemoteSystemCollection.Worker.ps1 (local file), sends its text to the remote (C:\Windows\Temp).
  - Writes a small JSON args file on the remote.
  - Registers and runs a one-time scheduled task as SYSTEM to execute the worker.
  - Waits up to -TimeoutSec for completion (done flag).
  - Returns remote paths; leaves ZIP on the remote for the caller to retrieve.
#>
  [CmdletBinding()]
  param(
    [Parameter(Mandatory)]
    [System.Management.Automation.Runspaces.PSSession]$Session,

    [Parameter(Mandatory)]
    [string]$Timestamp,

    [string[]]$ExtraPaths,
    [string]$ConnectDataPath,

    [int]$TimeoutSec = 180
  )

  Set-StrictMode -Version Latest
  $oldEAP = $ErrorActionPreference
  $ErrorActionPreference = 'Stop'
  try {
    # --- Load worker content from file ---
    $workerPath = 'C:\TechToolbox\Workers\RemoteSystemCollection.Worker.ps1'
    if (-not (Test-Path -LiteralPath $workerPath)) {
      throw "Worker script not found: $workerPath"
    }
    $workerContent = Get-Content -LiteralPath $workerPath -Raw -Encoding UTF8

    # --- Execute SYSTEM workflow remotely ---
    $res = Invoke-Command -Session $Session -ScriptBlock {
      param(
        [string]$ts,
        [string[]]$extras,
        [string]$connectPath,
        [string]$workerText,
        [int]$waitSec
      )

      $ErrorActionPreference = 'Stop'

      # Use C:\Windows\Temp so SYSTEM can read/write
      $tempRoot = Join-Path $env:windir 'Temp'
      $argsPath = Join-Path $tempRoot ("PDQDiag_args_{0}.json" -f $ts)
      $scrPath = Join-Path $tempRoot ("PDQDiag_worker_{0}.ps1" -f $ts)
      $stagPath = Join-Path $tempRoot ("PDQDiag_{0}_{1}" -f $env:COMPUTERNAME, $ts)
      $doneFlag = Join-Path $stagPath 'system_done.flag'
      $zipPath = Join-Path $tempRoot ("PDQDiag_{0}_{1}.zip" -f $env:COMPUTERNAME, $ts)

      # Prepare args JSON
      $payload = [pscustomobject]@{
        Timestamp       = $ts
        ConnectDataPath = $connectPath
        ExtraPaths      = @($extras)
      } | ConvertTo-Json -Depth 5

      # Write worker + args to remote temp
      $payload    | Set-Content -Path $argsPath -Encoding UTF8
      $workerText | Set-Content -Path $scrPath  -Encoding UTF8

      # Prefer pwsh.exe if available; else powershell.exe
      $pwsh = (Get-Command pwsh.exe -ErrorAction SilentlyContinue).Source
      $exe = if ($pwsh) { 'pwsh.exe' } else { 'powershell.exe' }
      $actionArgs = if ($pwsh) {
        "-NoLogo -NoProfile -ExecutionPolicy Bypass -File `"$scrPath`" -ArgsPath `"$argsPath`""
      }
      else {
        "-NoProfile -ExecutionPolicy Bypass -File `"$scrPath`" -ArgsPath `"$argsPath`""
      }

      $taskName = "PDQDiag-Collect-$ts"
      $usedSchtasks = $false

      try {
        $act = New-ScheduledTaskAction -Execute $exe -Argument $actionArgs
        $task = Register-ScheduledTask -TaskName $taskName -Action $act -RunLevel Highest -User 'SYSTEM' -Force
        Start-ScheduledTask -TaskName $taskName
      }
      catch {
        $usedSchtasks = $true
        & schtasks.exe /Create /TN $taskName /SC ONCE /ST 00:00 /RL HIGHEST /RU SYSTEM /TR ("$exe $actionArgs") /F | Out-Null
        & schtasks.exe /Run /TN $taskName | Out-Null
      }

      # Wait up to -TimeoutSec for completion (done flag)
      $deadline = (Get-Date).AddSeconds($waitSec)
      while ((Get-Date) -lt $deadline -and -not (Test-Path -LiteralPath $doneFlag -ErrorAction SilentlyContinue)) {
        Start-Sleep -Seconds 2
      }
      $completed = Test-Path -LiteralPath $doneFlag -ErrorAction SilentlyContinue

      # Cleanup task registration only (leave files for caller)
      try {
        if ($usedSchtasks) {
          & schtasks.exe /Delete /TN $taskName /F | Out-Null
        }
        else {
          Unregister-ScheduledTask -TaskName $taskName -Confirm:$false -ErrorAction SilentlyContinue | Out-Null
        }
      }
      catch {}

      [pscustomobject]@{
        Staging   = $stagPath
        ZipPath   = $zipPath
        Script    = $scrPath
        Args      = $argsPath
        Completed = [bool]$completed
      }
    } -ArgumentList $Timestamp, $ExtraPaths, $ConnectDataPath, $workerContent, $TimeoutSec

    return $res
  }
  finally {
    $ErrorActionPreference = $oldEAP
  }
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Private\System\Utilities\RemoteWorkHelpers\Invoke-RemoteWorker.ps1
function Invoke-RemoteWorker {
    <#
    .SYNOPSIS
        Transfers helpers, loads them remotely, dot-sources a worker, calls its
        entry function, returns output.
    .DESCRIPTION
        Runspace/WSMan-safe engine:
          - Creates a remote TEMP workspace
          - Copies helpers ZIP; verifies SHA256; expands to "helpers" folder
          - Dot-sources all helper .ps1 files
          - Ensures worker exists at remote path; if missing and WorkerLocalPath
            is provided, it is copied
          - Dot-sources the worker script
          - Calls the specified entry function with optional arguments
            (hashtable)
          - Cleans up remote TEMP
    .PARAMETER Session
        Existing PSSession (WSMan / PS7 remoting endpoint).
    .PARAMETER HelpersZip
        Local path to the packaged helpers zip (from New-TTHelpersPackage).
    .PARAMETER HelpersZipHash
        SHA256 hash of the HelpersZip.
    .PARAMETER WorkerRemotePath
        Expected worker script path on the remote host (e.g.,
        C:\TechToolbox\Workers\Get-SystemSnapshot.worker.ps1).
    .PARAMETER WorkerLocalPath
        Optional local file path to copy up if WorkerRemotePath does not exist
        on remote.
    .PARAMETER EntryPoint
        The worker function name to invoke after dot-sourcing the worker script
        (e.g., 'Get-SystemSnapshotCore').
    .PARAMETER EntryParameters
        Hashtable of parameters to pass to the entry function.
    .OUTPUTS
        Whatever the entry function outputs (typically PSCustomObject).
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)] [System.Management.Automation.Runspaces.PSSession]$Session,
        [Parameter(Mandatory)] [string]$HelpersZip,
        [Parameter(Mandatory)] [string]$HelpersZipHash,
        [Parameter(Mandatory)] [string]$WorkerRemotePath,
        [Parameter()] [string]$WorkerLocalPath,
        [Parameter(Mandatory)] [string]$EntryPoint,
        [Parameter()] [hashtable]$EntryParameters,
        [Parameter()] [switch]$ForceUpdate = $true
    )

    # 1) Create remote temp root
    $remoteTmp = Invoke-Command -Session $Session -ScriptBlock {
        $base = Join-Path $env:TEMP ("TT_Worker_{0}" -f ([guid]::NewGuid()))
        New-Item -ItemType Directory -Path $base -Force | Out-Null
        $base
    } -ErrorAction Stop

    try {
        $remoteZip = Join-Path $remoteTmp 'helpers.zip'
        $remoteHelpers = Join-Path $remoteTmp 'helpers'
        
        # Ensure EntryParameters exists, and inject HelpersPath if not present
        if (-not $EntryParameters) { $EntryParameters = @{} }
        if (-not $EntryParameters.ContainsKey('HelpersPath')) {
            $EntryParameters['HelpersPath'] = $remoteHelpers
        }

        # 2) Push helpers.zip
        Copy-Item -ToSession $Session -Path $HelpersZip -Destination $remoteZip -Force -ErrorAction Stop

        # 3) Verify + expand on remote
        $expandedOk = Invoke-Command -Session $Session -ScriptBlock {
            param($zipPath, $expectedHash, $helpersDir)
            if (-not (Test-Path -LiteralPath $zipPath)) { throw "Remote zip not found: $zipPath" }
            $actual = (Get-FileHash -LiteralPath $zipPath -Algorithm SHA256).Hash
            if ($actual -ne $expectedHash) {
                throw "Hash mismatch for helpers.zip. Expected $expectedHash, got $actual."
            }

            New-Item -ItemType Directory -Path $helpersDir -Force | Out-Null
            try {
                if (Get-Command Expand-Archive -ErrorAction Ignore) {
                    Expand-Archive -Path $zipPath -DestinationPath $helpersDir -Force
                }
                else {
                    Add-Type -AssemblyName System.IO.Compression.FileSystem
                    [System.IO.Compression.ZipFile]::ExtractToDirectory($zipPath, $helpersDir, $true)
                }
            }
            catch {
                throw "Expand helpers failed: $($_.Exception.Message)"
            }

            Test-Path -LiteralPath $helpersDir
        } -ArgumentList $remoteZip, $HelpersZipHash, $remoteHelpers -ErrorAction Stop
        if (-not $expandedOk) { throw "Failed to expand helpers on remote." }

        # 4) Dot-source helpers
        Invoke-Command -Session $Session -ScriptBlock {
            param($helpersDir)
            if (-not (Test-Path -LiteralPath $helpersDir)) { throw "Helpers path not found: $helpersDir" }
            Get-ChildItem -LiteralPath $helpersDir -Filter '*.ps1' -File -ErrorAction Stop |
            ForEach-Object { . $_.FullName }
            $true
        } -ArgumentList $remoteHelpers -ErrorAction Stop | Out-Null

        # 5) Always copy worker script to remote host
        if (-not $WorkerLocalPath) {
            throw "WorkerLocalPath must be provided when always-copy mode is enabled."
        }

        $remoteDir = Split-Path -Path $WorkerRemotePath -Parent

        # Ensure remote directory exists
        Invoke-Command -Session $Session -ScriptBlock {
            param($dir)
            if (-not (Test-Path -LiteralPath $dir)) {
                New-Item -ItemType Directory -Path $dir -Force | Out-Null
            }
        } -ArgumentList $remoteDir -ErrorAction Stop

        # Always overwrite worker script
        Copy-Item -ToSession $Session -Path $WorkerLocalPath -Destination $WorkerRemotePath -Force -ErrorAction Stop
        
        # 6) Dot-source worker & call entry function
        $result = Invoke-Command -Session $Session -ScriptBlock {
            param($workerPath, $entry, $entryParams)
            if (-not (Test-Path -LiteralPath $workerPath)) { throw "Worker not found: $workerPath" }

            . $workerPath

            $fn = Get-Command -Name $entry -ErrorAction SilentlyContinue
            if (-not $fn) { throw "Entry function not found in worker: $entry" }

            & $entry @entryParams
        } -ArgumentList $WorkerRemotePath, $EntryPoint, $EntryParameters -ErrorAction Stop

        return $result
    }
    finally {
        # 7) Cleanup remote temp (best effort)
        try {
            Invoke-Command -Session $Session -ScriptBlock {
                param($root)
                if (Test-Path -LiteralPath $root) {
                    Remove-Item -LiteralPath $root -Recurse -Force -ErrorAction SilentlyContinue
                }
            } -ArgumentList $remoteTmp -ErrorAction SilentlyContinue | Out-Null
        }
        catch {}
    }
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Private\System\Utilities\RemoteWorkHelpers\New-HelpersPackage.ps1
function New-HelpersPackage {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string[]]$HelperFiles
    )
    # Make a temp staging folder and zip path
    $tmpRoot = Join-Path ([System.IO.Path]::GetTempPath()) ("TT_Helpers_{0}" -f ([guid]::NewGuid()))
    New-Item -ItemType Directory -Path $tmpRoot -Force | Out-Null
    try {
        foreach ($f in $HelperFiles) {
            if (-not (Test-Path -LiteralPath $f)) {
                throw "Helper file not found: $f"
            }
            Copy-Item -LiteralPath $f -Destination $tmpRoot -Force
        }

        $zipPath = Join-Path ([System.IO.Path]::GetTempPath()) ("TT_Helpers_{0}.zip" -f ([guid]::NewGuid()))
        if (Test-Path -LiteralPath $zipPath) { Remove-Item -LiteralPath $zipPath -Force }
        Compress-Archive -Path (Join-Path $tmpRoot '*') -DestinationPath $zipPath -Force
        $zipHash = (Get-FileHash -LiteralPath $zipPath -Algorithm SHA256).Hash

        [pscustomobject]@{
            ZipPath = $zipPath
            ZipHash = $zipHash
        }
    }
    finally {
        if (Test-Path -LiteralPath $tmpRoot) {
            Remove-Item -LiteralPath $tmpRoot -Recurse -Force -ErrorAction SilentlyContinue
        }
    }
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Private\System\Utilities\ReusableHelpers\Add-FencedBlock.ps1
function Add-FencedBlock {
    param(
        [string[]]$Lines,
        [string]$Language = ''  # e.g., 'txt'
    )
    $fence = '```' + $Language
    return @($fence) + $Lines + '```'
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Private\System\Utilities\ReusableHelpers\Add-TimestampToFilePath.ps1
function Add-TimestampToFilePath {
    param(
        [Parameter(Mandatory)]
        [string]$Path,

        [string]$Format = "yyyy-MM-dd_HH-mm-ss"
    )

    $timestamp = Get-Date -Format $Format

    $dir = Split-Path $Path -Parent
    $file = Split-Path $Path -Leaf

    $name = [System.IO.Path]::GetFileNameWithoutExtension($file)
    $ext = [System.IO.Path]::GetExtension($file)

    return (Join-Path $dir "$name`_$timestamp$ext")
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Private\System\Utilities\ReusableHelpers\Format-Text.ps1

function Format-Text {
    <#
    .SYNOPSIS
        Strips tags/whitespace and decodes HTML entities.
    #>
    [CmdletBinding()]
    param([Parameter(Mandatory)][string]$Text)

    $t = $Text -replace '(?is)<br\s*/?>', ' ' -replace '(?is)<[^>]+>', ' '
    $t = [System.Net.WebUtility]::HtmlDecode($t)
    $t = ($t -replace '\s+', ' ').Trim()
    return $t
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Private\System\Utilities\ReusableHelpers\Get-WorkerBasePath.ps1
function Get-WorkerBasePath {
    if (-not $script:cfg -or -not $script:cfg.settings -or -not $script:cfg.settings.workerPath) {
        return 'C:\TechToolbox\Workers'  # hard fallback
    }

    # Accept both simple string OR { default: "..."} structure
    $wp = $script:cfg.settings.workerPath
    if ($wp -is [string]) { return $wp }

    if ($wp.default) { return $wp.default }

    return 'C:\TechToolbox\Workers'
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Private\System\Utilities\ReusableHelpers\Invoke-CreateDirectory.ps1
function Invoke-CreateDirectory {
    [CmdletBinding()]
    param(
        # Accept array & pipeline input
        [Parameter(Mandatory, Position = 0, ValueFromPipeline, ValueFromRemainingArguments)]
        [string[]]$Path,

        # If set, treat every input as a directory (skip file-parent logic)
        [switch]$AsDirectoryOnly
    )

    begin {
        $results = New-Object System.Collections.Generic.List[object]
    }

    process {
        foreach ($p in $Path) {
            if ([string]::IsNullOrWhiteSpace($p)) { continue }

            # Decide directory target
            $targetDir = $null

            if ($AsDirectoryOnly) {
                $targetDir = $p
            }
            elseif (Test-Path -LiteralPath $p -PathType Container) {
                # Existing directory
                $targetDir = $p
            }
            elseif ($p -match '[\\\/]$') {
                # Trailing slash implies directory intent
                $targetDir = $p
            }
            else {
                # Treat as file path  get parent directory (robustly)
                $parent = $null

                # Use Split-Path default behavior (parent) with -LiteralPath, no -Parent
                try {
                    $parent = Split-Path -LiteralPath $p -ErrorAction Stop
                }
                catch {
                    # Fallback to .NET if Split-Path fails
                    try { $parent = [System.IO.Path]::GetDirectoryName($p) } catch { $parent = $null }
                }

                # If no parent resolved (rare), fall back to the original path
                $targetDir = if ([string]::IsNullOrWhiteSpace($parent)) { $p } else { $parent }
            }

            if ([string]::IsNullOrWhiteSpace($targetDir)) {
                Write-Verbose "Skipped empty/undeterminable target for input path: '$p'"
                continue
            }

            $created = $false
            $errorMsg = $null

            try {
                if (-not (Test-Path -LiteralPath $targetDir -PathType Container)) {
                    Write-Verbose "Creating directory: $targetDir"
                    New-Item -Path $targetDir -ItemType Directory -Force -ErrorAction Stop | Out-Null
                    $created = $true
                }
                else {
                    Write-Verbose "Directory already exists: $targetDir"
                }
            }
            catch {
                $errorMsg = $_.Exception.Message
                Write-Error "Failed to create directory '$targetDir' (from '$p'): $errorMsg"
            }

            # Exists should reflect the ensured directory as a Container
            $existsNow = $false
            try { $existsNow = Test-Path -LiteralPath $targetDir -PathType Container } catch { }

            $results.Add([pscustomobject]@{
                    InputPath  = $p
                    EnsuredDir = $targetDir
                    Created    = $created
                    Exists     = $existsNow
                    Error      = $errorMsg
                })
        }
    }

    end {
        $results | Out-Null
    }
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Private\System\Utilities\ReusableHelpers\Invoke-LargeFileSearch.ps1
function Invoke-LargeFileSearch {
    [CmdletBinding()]
    param(
        [string[]]$SearchDirectory,
        [int]$MinSizeMB,
        [int]$Depth,
        [switch]$UseDepth
    )

    $minBytes = [int64]$MinSizeMB * 1MB
    $results = New-Object System.Collections.Generic.List[object]

    foreach ($root in $SearchDirectory) {
        try {
            $gciParams = @{
                Path        = $root
                File        = $true
                Recurse     = $true
                ErrorAction = 'SilentlyContinue'
                Force       = $true
            }

            if ($UseDepth) {
                $gciParams['Depth'] = $Depth
            }

            Get-ChildItem @gciParams |
            Where-Object { $_.Length -ge $minBytes } |
            Sort-Object Length -Descending |
            ForEach-Object {
                $results.Add([pscustomobject]@{
                        FullName = $_.FullName
                        SizeMB   = [math]::Round(($_.Length / 1MB), 2)
                    })
            }
        }
        catch {
            $results.Add([pscustomobject]@{
                    FullName = "<ERROR scanning $root>"
                    SizeMB   = 0
                    Error    = $_.Exception.Message
                })
        }
    }

    return $results
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Private\System\Utilities\ReusableHelpers\Move-ToCamelKey.ps1

function Move-ToCamelKey {
    [CmdletBinding()]
    param([Parameter(Mandatory)][string]$Label)

    $map = @{
        'Design Capacity'      = 'designCapacity'
        'Full Charge Capacity' = 'fullChargeCapacity'
        'Chemistry'            = 'chemistry'
        'Serial Number'        = 'serialNumber'
        'Manufacturer'         = 'manufacturer'
        'Name'                 = 'name'
        'Battery Name'         = 'batteryName'
        'Cycle Count'          = 'cycleCount'
        'Remaining Capacity'   = 'remainingCapacity'
    }

    # Normalize input
    $Label = [string]$Label
    $Label = $Label.Trim()

    if ([string]::IsNullOrWhiteSpace($Label)) {
        return $null
    }

    # Try direct map match
    foreach ($k in $map.Keys) {
        if ($Label -match ('^(?i)' + [regex]::Escape($k) + '$')) {
            return $map[$k]
        }
    }

    # Fallback: sanitize and split
    $fallback = ($Label -replace '[^A-Za-z0-9 ]', '' -replace '\s+', ' ').Trim()
    if (-not $fallback) { return $null }

    $parts = $fallback.Split(' ', [System.StringSplitOptions]::RemoveEmptyEntries)
    if ($parts.Count -eq 0) { return $null }
    if ($parts.Count -eq 1) { return $parts[0].ToLower() }

    $first = $parts[0].ToLower()
    $rest = $parts[1..($parts.Count - 1)] | ForEach-Object {
        $_.Substring(0, 1).ToUpper() + $_.Substring(1).ToLower()
    }

    return ($first + ($rest -join ''))
}
[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Private\System\Utilities\ReusableHelpers\Receive-RemoteFile.ps1
function Receive-RemoteFile {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)][System.Management.Automation.Runspaces.PSSession]$Session,
        [Parameter(Mandatory)][string]$RemotePath,
        [Parameter(Mandatory)][string]$LocalPath,
        [ValidateSet('FromSession', 'Bytes', 'SMB')]
        [string]$Mode = 'FromSession'
    )
    $comp = $Session.ComputerName
    $ok = $false
    $errs = @()

    switch ($Mode) {
        'FromSession' {
            try {
                Copy-Item -Path $RemotePath -Destination $LocalPath -FromSession $Session -ErrorAction Stop
                $ok = $true
            }
            catch {
                $errs += "[$comp] FromSession failed: $($_.Exception.Message)"
            }
            if ($ok) { break }
        }
        'Bytes' {
            if (-not $ok) {
                try {
                    $b64 = Invoke-Command -Session $Session -ScriptBlock {
                        param($p) [Convert]::ToBase64String([IO.File]::ReadAllBytes($p))
                    } -ArgumentList $RemotePath -ErrorAction Stop
                    [IO.File]::WriteAllBytes($LocalPath, [Convert]::FromBase64String($b64))
                    $ok = $true
                }
                catch {
                    $errs += "[$comp] Bytes failed: $($_.Exception.Message)"
                }
            }
            if ($ok) { break }
            try {
                $drive = $RemotePath.Substring(0, 1)
                $rest = $RemotePath.Substring(2)
                $unc = "\\$comp\${drive}$" + $rest
                Copy-Item -Path $unc -Destination $LocalPath -Force -ErrorAction Stop
                $ok = $true
            }
            catch {
                $errs += "[$comp] SMB failed: $($_.Exception.Message)"
            }
        }
        'SMB' {
            try {
                $drive = $RemotePath.Substring(0, 1)
                $rest = $RemotePath.Substring(2)
                $unc = "\\$comp\${drive}$" + $rest
                Copy-Item -Path $unc -Destination $LocalPath -Force -ErrorAction Stop
                $ok = $true
            }
            catch {
                $errs += "[$comp] SMB failed: $($_.Exception.Message)"
            }
        }
    }

    if (-not $ok) { throw ($errs -join ' | ') }
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Private\System\Utilities\ReusableHelpers\Test-Administrator.ps1
function Test-Administrator {
    <#
    .SYNOPSIS
        Tests if the current PowerShell session is running with Administrator
        privileges.
    .NOTES
        Reusable function for TechToolbox.
    #>
    [CmdletBinding()]
    param()

    try {
        $principal = New-Object Security.Principal.WindowsPrincipal(
            [Security.Principal.WindowsIdentity]::GetCurrent()
        )
        return $principal.IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)
    }
    catch {
        return $false
    }
}
[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Private\System\Utilities\ReusableHelpers\Update-CamelKey.ps1
function Update-CamelKey {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$Label
    )

    # Normalize text first
    $clean = Update-Text $Label

    # Lowercase, remove non-alphanumerics except spaces
    $clean = ($clean.ToLower() -replace '[^a-z0-9 ]', '').Trim()

    if ([string]::IsNullOrWhiteSpace($clean)) {
        return ""
    }

    $parts = $clean -split '\s+'
    $key = $parts[0]

    for ($i = 1; $i -lt $parts.Length; $i++) {
        $part = $parts[$i]
        $key += ($part.Substring(0, 1).ToUpper() + $part.Substring(1))
    }

    return $key
}
[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Private\System\Utilities\ReusableHelpers\Update-Text.ps1
function Update-Text {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$Text
    )

    if (-not $Text) { return "" }

    # Decode HTML entities if possible
    try {
        $decoded = [System.Web.HttpUtility]::HtmlDecode($Text)
    }
    catch {
        $decoded = $Text
    }

    # Strip HTML tags, normalize whitespace, remove non-breaking spaces
    $clean = ($decoded -replace '<[^>]+>', '')
    $clean = $clean -replace [char]0xA0, ' '
    $clean = $clean -replace '\s+', ' '

    return $clean.Trim()
}
[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Private\System\Utilities\TestAdmin\Assert-Elevated.ps1
function Assert-Elevated {
    $isAdmin = ([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()
    ).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)
    if (-not $isAdmin) {
        Write-Host "Re-launching elevated..."
        Start-Process -FilePath "powershell.exe" -ArgumentList "-NoProfile -ExecutionPolicy Bypass -File `"$PSCommandPath`"" -Verb RunAs
        exit
    }
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Private\System\Utilities\TestAdmin\Use-DomainAdmin.ps1
function Use-DomainAdmin {
    param(
        [Parameter()]
        [System.Management.Automation.PSCredential]$Credential,
        [Parameter()]
        [string]$Server
    )
    if (-not $Credential) { $Credential = Get-Credential -Message 'Enter domain admin credential' }
    $splat = @{ Credential = $Credential }
    if ($Server) { $splat.Server = $Server }
    return $splat
}

# Example usage:
# $adSplat = Use-DomainAdmin -Credential $Credential -Server $Server
# $user = Get-ADUser @adSplat -Identity $Identity -Properties proxyAddresses

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Public\ActiveDirectory\Disable-User.ps1
function Disable-User {
    <#
    .SYNOPSIS
    Disables an Active Directory user account and optionally performs cloud
    offboarding actions.

    .DESCRIPTION
    Disables an AD user account, moves them to a disabled OU, removes group
    memberships, and optionally disables Exchange Online and Teams access.

    .PARAMETER Identity
    The identity of the user to disable (e.g. sAMAccountName, UPN, or display
    name).

    .PARAMETER IncludeEXO
    Switch to include Exchange Online offboarding actions.

    .PARAMETER ForceCloud
    Switch to force cloud offboarding actions even if IncludeEXO is not specified.

    .PARAMETER Credential
    Optional PSCredential for authentication to AD and cloud services.
    
    .EXAMPLE
    Disable-User -Identity "jdoe" -IncludeEXO
    #>
    [CmdletBinding(SupportsShouldProcess, ConfirmImpact = 'Medium')]
    param(
        [Parameter(Mandatory)][string]$Identity,
        [switch]$IncludeEXO,
        [switch]$ForceCloud,
        [pscredential]$Credential
    )

    # --- Runtime init (config/logging/env) ---
    Initialize-TechToolboxRuntime

    $user = $null
    $exoConnected = $false
    $results = [ordered]@{}

    try {
        Write-Log -Level Info -Message ("Starting Disable-User workflow for '{0}'..." -f $Identity)

        # --- Config load & validation ---
        $cfg = $script:cfg
        if (-not $cfg) { throw "Effective config is null. Check config.json path and schema." }

        $settings = $cfg.settings
        if (-not $settings) { throw "Config missing 'settings' node." }

        $off = $settings.offboarding
        if (-not $off) { throw "Config missing 'settings.offboarding' node." }

        # --- Compute effective options (switches override config) ---
        $effective = [ordered]@{
            IncludeEXO           = if ($PSBoundParameters.ContainsKey('IncludeEXO')) { [bool]$IncludeEXO } else { [bool]$off.includeEXO }
            UseHybridAutoDisable = if ($PSBoundParameters.ContainsKey('ForceCloud')) { -not [bool]$ForceCloud } else { [bool]$off.useHybridAutoDisable }
            DisabledOU           = [string]$off.disabledOU
            CleanupADGroups      = [bool]$off.cleanupADGroups
        }

        if ($effective.DisabledOU -is [string] -and [string]::IsNullOrWhiteSpace($effective.DisabledOU)) {
            Write-Log -Level Warn -Message "settings.offboarding.disabledOU is empty; OU move will be skipped."
        }

        # --- Resolve user (AD-only Search-User) ---
        Write-Log -Level Info -Message ("Offboarding: Resolving user '{0}'..." -f $Identity)
        $suParams = @{ Identity = $Identity }
        if ($Credential) { $suParams.Credential = $Credential }

        try {
            $user = Search-User @suParams
        }
        catch {
            throw "Search-User error for '$Identity': $($_.Exception.Message)"
        }
        if (-not $user) { throw "User '$Identity' not found." }

        # --- Disable AD user ---
        Write-Log -Level Info -Message ("Offboarding: Disabling AD account for '{0}'..." -f $user.SamAccountName)
        if ($PSCmdlet.ShouldProcess($user.SamAccountName, "Disable AD account")) {
            $disableParams = @{ SamAccountName = $user.SamAccountName; DisabledOU = $effective.DisabledOU }
            $results.ADDisable = Disable-ADUserAccount @disableParams
        }

        # --- Move to Disabled OU (if not already handled in Disable-ADUserAccount) ---
        $movedHandled = $false
        if ($results.ADDisable) {
            if ($results.ADDisable -is [hashtable]) { $movedHandled = [bool]$results.ADDisable['MovedToOU'] }
            elseif ($results.ADDisable.PSObject.Properties.Name -contains 'MovedToOU') { $movedHandled = [bool]$results.ADDisable.MovedToOU }
        }

        if ($effective.DisabledOU -and -not $movedHandled) {
            Write-Log -Level Info -Message ("Offboarding: Moving '{0}' to Disabled OU..." -f $user.SamAccountName)
            if ($PSCmdlet.ShouldProcess($user.SamAccountName, "Move AD user to Disabled OU")) {
                $moveParams = @{ SamAccountName = $user.SamAccountName; TargetOU = $effective.DisabledOU }
                if ($Credential) { $moveParams.Credential = $Credential }
                $results.MoveOU = Move-UserToDisabledOU @moveParams
            }
        }

        # --- Optional: cleanup AD groups ---
        if ($effective.CleanupADGroups) {
            Write-Log -Level Info -Message ("Offboarding: Cleaning AD group memberships for '{0}'..." -f $user.SamAccountName)
            if ($PSCmdlet.ShouldProcess($user.SamAccountName, "Cleanup AD group memberships")) {
                $grpParams = @{ SamAccountName = $user.SamAccountName }
                if ($Credential) { $grpParams.Credential = $Credential }
                $results.ADGroups = Remove-ADUserGroups @grpParams
            }
        }

        # --- Hybrid auto-disable short-circuit ---
        if ($effective.UseHybridAutoDisable) {
            Write-Log -Level Info -Message "Hybrid auto-disable enabled; cloud actions deferred to AAD Connect or downstream automation."
            if (Get-Command -Name Write-OffboardingSummary -ErrorAction SilentlyContinue) {
                Write-OffboardingSummary -User $user -Results $results
            }
            Write-Log -Level Ok -Message ("Disable-User workflow completed for '{0}' (hybrid short-circuit)." -f ($user.UserPrincipalName ? $user.UserPrincipalName : $Identity))
            return [pscustomobject]$results
        }

        # --- Exchange Online (EXO) actions ---
        if ($effective.IncludeEXO) {
            Write-Log -Level Info -Message "EXO: starting Exchange Online actions."
            $exoConnected = $false

            try {
                # Prefer your helper; fallback to native connect
                $helperCmd = Get-Command -Name Connect-ExchangeOnlineIfNeeded -ErrorAction SilentlyContinue
                if ($helperCmd) {
                    $null = Connect-ExchangeOnlineIfNeeded -ShowProgress:$false -ErrorAction Stop
                    $exoConnected = $true
                }
                else {
                    $nativeConnect = Get-Command -Name Connect-ExchangeOnline -ErrorAction SilentlyContinue
                    if (-not $nativeConnect) {
                        throw "ExchangeOnlineManagement cmdlets not available in this session."
                    }
                    Connect-ExchangeOnline -ShowBanner:$false -UseRPSSession:$false -ErrorAction Stop | Out-Null
                    $exoConnected = $true
                }
            }
            catch {
                Write-Log -Level Warn -Message ("EXO: connect failed; skipping EXO actions. Reason: {0}" -f $_.Exception.Message)
            }

            if ($exoConnected -and $user.UserPrincipalName) {
                # Cache command lookups once
                $convertCmd = Get-Command -Name Convert-MailboxToShared -ErrorAction SilentlyContinue
                $grantCmd = Get-Command -Name Grant-ManagerMailboxAccess -ErrorAction SilentlyContinue

                if (-not $convertCmd -and -not $grantCmd) {
                    Write-Log -Level Warn -Message "EXO: required cmdlets not found (Convert-MailboxToShared / Grant-ManagerMailboxAccess)."
                }

                if ($convertCmd -and $PSCmdlet.ShouldProcess($user.UserPrincipalName, "Convert mailbox to shared")) {
                    try {
                        Write-Log -Level Info -Message ("EXO: converting mailbox to shared for '{0}'..." -f $user.UserPrincipalName)
                        $results.Mailbox = Convert-MailboxToShared -Identity $user.UserPrincipalName -ErrorAction Stop
                    }
                    catch {
                        Write-Log -Level Warn -Message ("EXO: mailbox conversion failed for '{0}': {1}" -f $user.UserPrincipalName, $_.Exception.Message)
                    }
                }

                if ($grantCmd -and $PSCmdlet.ShouldProcess($user.UserPrincipalName, "Grant manager mailbox access")) {
                    try {
                        if ($user.ManagerUpn) {
                            Write-Log -Level Info -Message ("EXO: granting manager mailbox access for '{0}' to '{1}'..." -f $user.UserPrincipalName, $user.ManagerUpn)
                            $results.ManagerAccess = Grant-ManagerMailboxAccess `
                                -Identity $user.UserPrincipalName `
                                -ManagerUPN $user.ManagerUpn `
                                -ErrorAction Stop
                        }
                        else {
                            Write-Log -Level Warn -Message ("EXO: skipping manager mailbox access  no manager assigned for '{0}'." -f $user.UserPrincipalName)
                        }
                    }
                    catch {
                        Write-Log -Level Warn -Message ("EXO: grant manager access failed for '{0}': {1}" -f $user.UserPrincipalName, $_.Exception.Message)
                    }
                }
            }
            elseif (-not $exoConnected) {
                # Already logged the connect failure above
                Write-Log -Level Info -Message "EXO: actions skipped (not connected)."
            }
            elseif (-not $user.UserPrincipalName) {
                Write-Log -Level Warn -Message "EXO: actions skipped (UserPrincipalName is empty)."
            }
        }
        else {
            Write-Log -Level Info -Message "EXO: IncludeEXO is false; skipping EXO actions."
        }

        # --- Summary & return ---
        Write-Log -Level Info -Message ("Offboarding: Generating summary for '{0}'..." -f ($user.UserPrincipalName ? $user.UserPrincipalName : $Identity))
        if (Get-Command -Name Write-OffboardingSummary -ErrorAction SilentlyContinue) {
            Write-OffboardingSummary -User $user -Results $results
        }
        Write-Log -Level Ok -Message ("Disable-User workflow completed for '{0}'." -f ($user.UserPrincipalName ? $user.UserPrincipalName : $Identity))
        return [pscustomobject]$results
    }
    catch {
        $who = ($user -and $user.UserPrincipalName) ? $user.UserPrincipalName : $Identity
        Write-Log -Level Error -Message ("Disable-User failed for '{0}': {1}" -f $who, $_.Exception.Message)
        throw
    }
    finally {
        if ($exoConnected) {
            try {
                if (Get-Command -Name Disconnect-ExchangeOnline -ErrorAction SilentlyContinue) {
                    Disconnect-ExchangeOnline -Confirm:$false | Out-Null
                }
            }
            catch { }
        }
    }
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Public\ActiveDirectory\New-OnPremUserFromTemplate.ps1

function New-OnPremUserFromTemplate {
    <#
    .SYNOPSIS
    Create a new on-premises AD user based on a template user.

    .DESCRIPTION
    Creates a new Active Directory user by copying attributes and group
    memberships from a specified template user. Naming (UPN, SAM, alias) derives
    from config unless overridden.

    .PARAMETER TemplateIdentity
    Identity (sAMAccountName, DN, SID, GUID) of the template user to copy.

    .PARAMETER TemplateSearch
    Hashtable of attribute=value pairs to locate the template (first match
    wins).

    .PARAMETER GivenName
    First name of the new user.

    .PARAMETER Surname
    Last name of the new user.

    .PARAMETER DisplayName
    Display name of the new user.

    .PARAMETER TargetOU
    DistinguishedName of the OU to create the user in. Defaults to templates
    OU.

    .PARAMETER SamAccountName
    sAMAccountName for the new user. Derived if omitted.

    .PARAMETER UpnPrefix
    UPN prefix for the new user. Derived if omitted.

    .PARAMETER CopyAttributes
    Attributes to copy from template to the new user.

    .PARAMETER ExcludedGroups
    Group names to exclude when copying memberships.

    .PARAMETER InitialPasswordLength
    Length of the generated initial password.

    .PARAMETER Credential
    Directory credential to run AD operations as.

    .PARAMETER Server
    Optional DC to target (avoid replication latency during create+modify).
    #>
    [CmdletBinding(SupportsShouldProcess)]
    param(
        [Parameter(ParameterSetName = 'ByIdentity')]
        [string]$TemplateIdentity,

        [Parameter(ParameterSetName = 'BySearch')]
        [hashtable]$TemplateSearch,

        [Parameter(Mandatory)]
        [string]$GivenName,

        [Parameter(Mandatory)]
        [string]$Surname,

        [Parameter(Mandatory)]
        [string]$DisplayName,

        [string]$TargetOU,

        [string]$SamAccountName,
        [string]$UpnPrefix,

        [string[]]$CopyAttributes = @(
            'description', 'department', 'company', 'office', 'manager'
        ),

        [string[]]$ExcludedGroups = @(
            'Domain Admins', 'Enterprise Admins', 'Schema Admins', 'Administrators',
            'Protected Users', 'Server Operators', 'Account Operators', 'Backup Operators',
            'Print Operators', 'Read-only Domain Controllers', 'Enterprise Read-only Domain Controllers'
        ),

        [int]$InitialPasswordLength = 16,

        [Parameter(Mandatory)]
        [pscredential]$Credential,

        [string]$Server
    )

    begin {
        $ErrorActionPreference = 'Stop'
        Initialize-TechToolboxRuntime
        Import-Module ActiveDirectory -ErrorAction Stop

        # Load config (throws if missing essentials)
        $cfg = $script:cfg
        $Tenant = $cfg.settings.tenant
        $Naming = $cfg.settings.naming
        # If caller did NOT pass -CopyAttributes, take it from config
        $callerSpecifiedCopyAttrs = $PSBoundParameters.ContainsKey('CopyAttributes')
        if (-not $callerSpecifiedCopyAttrs) {
            if ($Naming -and $Naming['copyAttributes']) {
                $CopyAttributes = @($Naming['copyAttributes'])
            }
            else {
                $CopyAttributes = @()
            }
        }
        # Ensure it's an array of strings
        $CopyAttributes = @($CopyAttributes | ForEach-Object { $_.ToString() }) | Where-Object { $_ -and $_.Trim() -ne '' }

        # Map config-friendly names -> LDAP names (keyed lowercase for case-insensitive lookup)
        $configToLdap = @{
            'description' = 'description'
            'department'  = 'department'
            'company'     = 'company'
            'office'      = 'physicalDeliveryOfficeName'
            'manager'     = 'manager'
        }

        # Compute the LDAP attributes to request for the template user
        $CopyLdapAttrs = foreach ($name in $CopyAttributes) {
            $key = $name.ToLowerInvariant()
            if ($configToLdap.ContainsKey($key)) { $configToLdap[$key] } else { $name }
        }
        $CopyLdapAttrs = $CopyLdapAttrs | Select-Object -Unique

        # Map LDAP -> friendly AD parameter where one exists (used later when applying)
        $LdapToParam = @{
            department                 = 'Department'
            physicalDeliveryOfficeName = 'Office'
            company                    = 'Company'
            description                = 'Description'
            # manager is special (DN)  friendly param 'Manager' but value must be DN
        }

        # --- Resolve template user (according to parameter set) ---
        $adBase = @{ Credential = $Credential }
        if ($Server) { $adBase['Server'] = $Server }

        switch ($PSCmdlet.ParameterSetName) {
            'ByIdentity' {
                if ([string]::IsNullOrWhiteSpace($TemplateIdentity)) {
                    throw "Parameter set 'ByIdentity' requires -TemplateIdentity."
                }
                $templateUser = Get-ADUser @adBase -Identity $TemplateIdentity -Properties $CopyLdapAttrs
            }
            'BySearch' {
                if (-not $TemplateSearch -or $TemplateSearch.Count -eq 0) {
                    throw "Parameter set 'BySearch' requires -TemplateSearch (hashtable filter)."
                }
                # Build a -Filter from the hashtable (simple AND of equality clauses)
                $clauses = foreach ($k in $TemplateSearch.Keys) {
                    $v = $TemplateSearch[$k]
                    # Escape quotes in value
                    $v = ($v -replace "'", "''")
                    "($k -eq '$v')"
                }
                $filter = ($clauses -join ' -and ')
                $templateUser = Get-ADUser @adBase -Filter $filter -Properties $CopyLdapAttrs |
                Select-Object -First 1
                if (-not $templateUser) {
                    throw "Template user not found using search filter: $filter"
                }
            }
            default {
                throw "Unknown parameter set: $($PSCmdlet.ParameterSetName)"
            }
        }

        # Expose a couple of helper items for the process/end blocks
        Set-Variable -Name LdapToParam     -Value $LdapToParam     -Scope 1
        Set-Variable -Name CopyLdapAttrs   -Value $CopyLdapAttrs   -Scope 1
        Set-Variable -Name templateUser    -Value $templateUser    -Scope 1
        Set-Variable -Name adBase          -Value $adBase          -Scope 1
    }

    process {
        # Breadcrumb #1: entering function
        Write-Log -Level Info -Message ("Entering New-OnPremUserFromTemplate (ParamSet={0})" -f $PSCmdlet.ParameterSetName)

        # 1) Resolve template user
        $templateUser = $null
        switch ($PSCmdlet.ParameterSetName) {
            'ByIdentity' {
                $templateUser = Get-ADUser @adBase -Identity $TemplateIdentity -Properties $CopyLdapAttrs
            }
            'BySearch' {
                if (-not $TemplateSearch) { throw "Provide -TemplateSearch (e.g., @{ title='Engineer'; company='Company' })." }
                $ldapFilterParts = foreach ($k in $TemplateSearch.Keys) {
                    $val = [System.Text.RegularExpressions.Regex]::Escape($TemplateSearch[$k])
                    "($k=$val)"
                }
                $ldapFilter = "(&" + ($ldapFilterParts -join '') + ")"
                $templateUser = Get-ADUser @adBase -LDAPFilter $ldapFilter -Properties * -ErrorAction Stop |
                Select-Object -First 1
                if (-not $templateUser) { throw "No template user matched filter $ldapFilter." }
            }
            default { throw "Unexpected parameter set." }
        }

        Write-Log -Level Info -Message ("Template resolved: {0} ({1})" -f $templateUser.SamAccountName, $templateUser.UserPrincipalName)

        # 2) Derive naming via config (unless caller overrides)
        if (-not $UpnPrefix -or -not $SamAccountName) {
            $nm = Resolve-Naming -Naming $Naming -GivenName $GivenName -Surname $Surname
            if (-not $UpnPrefix) { $UpnPrefix = $nm.UpnPrefix }
            if (-not $SamAccountName) { $SamAccountName = $nm.Sam }
        }

        $newUpn = "$UpnPrefix@$($Tenant.upnSuffix)"

        # 3) Resolve target OU (default to template's OU)
        if (-not $TargetOU) {
            $TargetOU = ($templateUser.DistinguishedName -replace '^CN=.*?,')
        }

        Write-Log -Level Info -Message ("Provisioning: DisplayName='{0}', Sam='{1}', UPN='{2}', OU='{3}'" -f $DisplayName, $SamAccountName, $newUpn, $TargetOU)

        # 4) Idempotency check
        $exists = Get-ADUser @adBase -LDAPFilter "(userPrincipalName=$newUpn)" -ErrorAction SilentlyContinue
        if ($exists) {
            Write-Log -Level Warn -Message "User UPN '$newUpn' already exists. Aborting."
            return
        }

        # 5) Create new user
        $initialPassword = Get-NewPassword -length $InitialPasswordLength -nonAlpha 3
        $securePass = ConvertTo-SecureString $initialPassword -AsPlainText -Force

        $newParams = @{
            Name                  = $DisplayName
            DisplayName           = $DisplayName
            GivenName             = $GivenName
            Surname               = $Surname
            SamAccountName        = $SamAccountName
            UserPrincipalName     = $newUpn
            Enabled               = $true     # set $false if prefer disabled on creation
            Path                  = $TargetOU
            ChangePasswordAtLogon = $true
            AccountPassword       = $securePass
        }

        if ($PSCmdlet.ShouldProcess($newUpn, "Create AD user")) {
            New-ADUser @adBase @newParams
            Write-Log -Level Ok -Message ("Created AD user: {0}" -f $newUpn)
        }

        # 6) Copy selected attributes from template (uses mappings from begin{})
        $friendlyProps = @{}
        $otherAttrs = @{}

        foreach ($attr in $CopyAttributes) {
            if (-not $attr) { continue }
            $key = $attr.ToString()
            $ldapName = $configToLdap[$key.ToLowerInvariant()]
            if (-not $ldapName) { $ldapName = $key }  # treat unknown as raw LDAP (e.g., extensionAttribute1)

            $val = $templateUser.$ldapName
            if ($null -eq $val) { continue }
            if ($val -is [string] -and [string]::IsNullOrWhiteSpace($val)) { continue }

            if ($ldapName -eq 'manager') {
                # Manager must be DN; set via friendly param if it looks like a DN
                if ($val -is [string] -and $val -match '^CN=.+,DC=.+') {
                    $friendlyProps['Manager'] = $val
                }
                else {
                    Write-Verbose "Skipping manager; value is not a DN: $val"
                }
                continue
            }

            if ($LdapToParam.ContainsKey($ldapName)) {
                $friendlyProps[$LdapToParam[$ldapName]] = $val
            }
            else {
                $otherAttrs[$ldapName] = $val
            }
        }

        # Avoid double-setting Office via friendly and LDAP at once
        if ($friendlyProps.ContainsKey('Office') -and $otherAttrs.ContainsKey('physicalDeliveryOfficeName')) {
            $null = $otherAttrs.Remove('physicalDeliveryOfficeName')
        }

        if ($PSCmdlet.ShouldProcess($newUpn, "Apply copied attributes")) {
            if ($friendlyProps.Count -gt 0) {
                Set-ADUser @adBase -Identity $SamAccountName @friendlyProps
            }
            if ($otherAttrs.Count -gt 0) {
                Set-ADUser @adBase -Identity $SamAccountName -Replace $otherAttrs
            }
            Write-Log -Level Ok -Message "Copied attributes applied from template."
        }

        # 7) proxyAddresses  single primary at creation (idempotent)
        $primaryProxy = "SMTP:$UpnPrefix@$($Tenant.upnSuffix)"
        $proxiesToSet = @($primaryProxy)

        if ($PSCmdlet.ShouldProcess($newUpn, "Set primary proxyAddress")) {
            Set-ADUser @adBase -Identity $SamAccountName -Replace @{ proxyAddresses = $proxiesToSet }
            Write-Log -Level Ok -Message "Primary proxyAddress applied."
        }

        # 8) Copy group memberships (exclude known admin/builtin)
        $tmplGroupDNs = (Get-ADUser @adBase -Identity $templateUser.DistinguishedName -Property memberOf).memberOf
        if (-not $tmplGroupDNs) { $tmplGroupDNs = @() }

        $tmplGroupNames = foreach ($dn in $tmplGroupDNs) {
            (Get-ADGroup @adBase -Identity $dn -ErrorAction SilentlyContinue).Name
        }

        $toAdd = $tmplGroupNames | Where-Object { $_ -and ($ExcludedGroups -notcontains $_) }

        if ($PSCmdlet.ShouldProcess($newUpn, "Add group memberships")) {
            $added = 0
            foreach ($gName in $toAdd) {
                try {
                    Add-ADGroupMember @adBase -Identity $gName -Members $SamAccountName -ErrorAction Stop
                    $added++
                    Write-Log -Level Info -Message ("Added to: {0}" -f $gName)
                }
                catch {
                    Write-Log -Level Warn -Message ("Group add failed '{0}': {1}" -f $gName, $_.Exception.Message)
                }
            }
            Write-Log -Level Ok -Message ("Group additions complete: {0} added" -f $added)
        }

        # 9) Output summary (force visible + return)
        $result = [pscustomobject]@{
            UserPrincipalName = $newUpn
            SamAccountName    = $SamAccountName
            DisplayName       = $DisplayName
            TargetOU          = $TargetOU
            CopiedAttributes  = $CopyAttributes
            GroupsAdded       = $toAdd
            InitialPassword   = $initialPassword  # caller is responsible for secure handling
        }

        # Force a visible summary even if caller pipes to Out-Null
        $result | Format-List | Out-Host
    }

    end { }
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Public\ActiveDirectory\Reset-ADPassword.ps1
function Reset-ADPassword {
    <#
    .SYNOPSIS
    Resets an AD user's password using TechToolbox's private password generator.

    .DESCRIPTION
    - Attempts to dot-source Private\Passwords\Get-NewPassword.ps1 (or a path
      you specify)
    - Calls Get-NewPassword with optional parameters; defaults are read from
      $script:cfg by your function
    - Falls back to $candidate if generator sets it instead of returning a value
    - Resets AD password; optional Unlock and ChangePasswordAtLogon
    - Logging via Write-Log; no progress UI

    .PARAMETER Identity
    The AD user identity (sAMAccountName, UPN, or DN).

    .PARAMETER PasswordFunctionPath
    Optional full/relative path to Get-NewPassword.ps1. If not provided, common
    Private paths are probed.

    .PARAMETER ChangePasswordAtLogon
    Set "User must change password at next logon".

    .PARAMETER Unlock
    Unlock the account after resetting the password.

    .PARAMETER ShowPassword
    Echo the plaintext password via Write-Log (use with care; may log to file
    depending on your config).

    .PARAMETER OutFile
    Write the plaintext password to a file (plaintext).

    .PARAMETER Clipboard
    Copy plaintext password to clipboard (Windows only).

    .EXAMPLE
    Reset-ADPassword -Identity jdoe -ChangePasswordAtLogon -Clipboard
    #>
    [CmdletBinding(SupportsShouldProcess = $true)]
    param(
        [Parameter(Mandatory = $true)]
        [string]$Identity,

        [switch]$ChangePasswordAtLogon = $true,
        [switch]$Unlock,

        [string]$OutFile,
        [switch]$Clipboard
    )

    Initialize-TechToolboxRuntime
    $PasswordFunctionPath = $script:cfg.settings.resetPassword.passwordFunctionPath
    $InitialPasswordLength = $script:cfg.settings.resetPassword.initialPasswordLength
    $ShowPassword = $script:cfg.settings.resetPassword.showPassword
    Write-Log -Level Info -Message "Starting Reset-ADPassword for '$Identity'"

    if (-not (Get-Module ActiveDirectory) -and -not (Get-Module ActiveDirectory -ListAvailable)) {
        Write-Log -Level Error -Message "ActiveDirectory module unavailable. Install RSAT or ensure AD tools are accessible."
        throw "Missing ActiveDirectory module."
    }
    Import-Module ActiveDirectory -ErrorAction Stop

    # --- Generate the password (prefer return value; fallback to $candidate)
    $InitialPassword = Get-NewPassword -length $InitialPasswordLength -nonAlpha 3
    $SecurePass = ConvertTo-SecureString $initialPassword -AsPlainText -Force

    # --- Resolve AD user ---
    try {
        $user = Get-ADUser -Identity $Identity -Properties LockedOut, PasswordExpired -ErrorAction Stop
        Write-Log -Level Info -Message "Resolved AD user '$($user.SamAccountName)'"
    }
    catch {
        Write-Log -Level Error -Message "Failed to resolve user '$Identity': $($_.Exception.Message)"
        throw
    }

    # --- Reset password ---
    if ($PSCmdlet.ShouldProcess($user.SamAccountName, "Reset AD password")) {
        try {
            Set-ADAccountPassword -Identity $user.DistinguishedName -NewPassword $securePass -Reset -ErrorAction Stop
            Write-Log -Level Ok -Message "Password reset successful for '$($user.SamAccountName)'"
        }
        catch {
            Write-Log -Level Error -Message "Password reset failed for '$($user.SamAccountName)': $($_.Exception.Message)"
            throw
        }
    }

    # --- Optional unlock & change-at-logon ---
    if ($Unlock) {
        try {
            Unlock-ADAccount -Identity $user.DistinguishedName -ErrorAction Stop
            Write-Log -Level Ok -Message "Account unlocked: $($user.SamAccountName)"
        }
        catch {
            Write-Log -Level Warn -Message "Failed to unlock account: $($_.Exception.Message)"
        }
    }

    if ($ChangePasswordAtLogon) {
        try {
            Set-ADUser -Identity $user.DistinguishedName -ChangePasswordAtLogon $true -ErrorAction Stop
            Write-Log -Level Ok -Message "ChangePasswordAtLogon set for: $($user.SamAccountName)"
        }
        catch {
            Write-Log -Level Warn -Message "Failed to set ChangePasswordAtLogon: $($_.Exception.Message)"
        }
    }

    # --- Delivery controls (opt-in only) ---
    if ($ShowPassword) {
        Write-Log -Level Warn -Message "Displaying password as requested:"
        Write-Log -Level Warn -Message "$initialPassword"
    }

    if ($OutFile) {
        try {
            $parent = Split-Path $OutFile -Parent
            if ($parent -and -not (Test-Path $parent)) {
                New-Item -Path $parent -ItemType Directory -Force | Out-Null
            }
            Set-Content -Path $OutFile -Value $initialPassword -NoNewline -Force
            Write-Log -Level Info -Message "Password written to file: $OutFile (plaintext)"
        }
        catch {
            Write-Log -Level Warn -Message "Failed to write password to '$OutFile': $($_.Exception.Message)"
        }
    }

    if ($Clipboard) {
        if ($IsWindows) {
            try {
                $null = $initialPassword | clip.exe
                Write-Log -Level Info -Message "Password copied to clipboard."
            }
            catch {
                Write-Log -Level Warn -Message "Failed to copy to clipboard: $($_.Exception.Message)"
            }
        }
        else {
            Write-Log -Level Warn -Message "Clipboard copy is only supported on Windows."
        }
    }

    Write-Log -Level Ok -Message "Completed Reset-ADPassword for '$($user.SamAccountName)'"
    [pscustomobject]@{
        SamAccountName        = $user.SamAccountName
        DistinguishedName     = $user.DistinguishedName
        ChangePasswordAtLogon = [bool]$ChangePasswordAtLogon
        Unlocked              = [bool]$Unlock
        PasswordDelivery      = @(
            $(if ($ShowPassword) { 'Console' })
            $(if ($OutFile) { 'File' })
            $(if ($Clipboard) { 'Clipboard' })
        ) -join ', '
        Timestamp             = (Get-Date)
    }
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Public\ActiveDirectory\Search-User.ps1
function Search-User {
    <#
    .SYNOPSIS
        Searches for a user in AD (primary) and optionally EXO/Teams, returns a
        unified record.
    .DESCRIPTION
        Graph/Entra lookups are excluded. This function resolves the user from:
          - Active Directory (primary, with optional proxyAddresses/mail search)
          - Exchange Online (optional, if wrappers exist and
            requested/available)
          - Microsoft Teams (optional, if wrappers exist and
            requested/available) Normalizes via Format-UserRecord. Returns $null
            if no match unless -AllowMultiple.
    .PARAMETER Identity
        UPN or SamAccountName. If not found exactly, falls back to broader LDAP
        (displayName/mail/proxyAddresses).
    .PARAMETER IncludeEXO
        When present, attempts to query Exchange Online (Get-ExchangeUser
        wrapper).
    .PARAMETER IncludeTeams
        When present, attempts to query Teams (Get-TeamsUser wrapper).
    .PARAMETER Server
        Optional domain controller to target (overrides config).
    .PARAMETER SearchBase
        Optional SearchBase (overrides config).
    .PARAMETER SearchScope
        LDAP search scope (Base|OneLevel|Subtree). Default from config or
        Subtree.
    .PARAMETER Credential
        PSCredential used for AD queries (and for manager/group resolution).
    .PARAMETER EnableProxyAddressSearch
        Include proxyAddresses in fallback LDAP search. Default: On.
    .PARAMETER EnableMailSearch
        Include mail attribute in fallback LDAP search. Default: On.
    .PARAMETER ResolveManager
        Resolve Manager to UPN/Name/SAM/Mail. Default: On.
    .PARAMETER ResolveGroups
        Resolve MemberOf to Name/SAM/Scope/Category. Default: On.
    .PARAMETER AllowMultiple
        Return all matches when more than one user is found. Default: Off
        (throws).
    .EXAMPLE
        Search-User -Identity "jdoe"
    .EXAMPLE
        Search-User -Identity "jdoe@contoso.com" -IncludeEXO
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$Identity,

        [string]$Server,
        [string]$SearchBase,
        [ValidateSet('Base', 'OneLevel', 'Subtree')]
        [string]$SearchScope,

        [pscredential]$Credential,

        [switch]$EnableProxyAddressSearch,
        [switch]$EnableMailSearch,

        [switch]$ResolveManager,
        [switch]$ResolveGroups,

        [switch]$AllowMultiple
    )

    $oldEAP = $ErrorActionPreference
    $ErrorActionPreference = 'Stop'
    try {
        # --- Config (block/dot) ---
        Initialize-TechToolboxRuntime
        $cfg = $script:cfg
        $adCfg = $cfg.settings.ad
        $searchCfg = $cfg.settings.userSearch
        $ADprops = $searchCfg.props

        if (-not $adCfg) { throw "Config missing settings.ad node." }
        if (-not $searchCfg) { Write-Log -Level Warn -Message "Config missing settings.userSearch node (using defaults)." }

        # Defaults from config (override with parameters if provided)
        if (-not $Server) { $Server = $adCfg.domainController }
        if (-not $SearchBase) { $SearchBase = $adCfg.searchBase }
        if (-not $SearchScope) { $SearchScope = $adCfg.searchScope ? $adCfg.searchScope : 'Subtree' }

        # Behavior toggles (default ON unless explicitly disabled)
        if (-not $PSBoundParameters.ContainsKey('EnableProxyAddressSearch')) { $EnableProxyAddressSearch = $true }
        if (-not $PSBoundParameters.ContainsKey('EnableMailSearch')) { $EnableMailSearch = $true }
        if (-not $PSBoundParameters.ContainsKey('ResolveManager')) { $ResolveManager = $true }
        if (-not $PSBoundParameters.ContainsKey('ResolveGroups')) { $ResolveGroups = $true }

        # --- Resolve helper availability ---
        $hasAD = !!(Get-Module ActiveDirectory -ListAvailable -ErrorAction SilentlyContinue)
        if (-not $hasAD) { throw "ActiveDirectory module not found. Install RSAT or run on a domain-joined admin workstation." }

        # Import AD but suppress providers warning about default drive init
        $prevWarn = $WarningPreference
        try {
            $WarningPreference = 'SilentlyContinue'
            Import-Module ActiveDirectory -ErrorAction Stop -WarningAction SilentlyContinue | Out-Null
        }
        finally {
            $WarningPreference = $prevWarn
        }

        # Optional: ensure the AD: drive isnt lingering (prevents later re-init noise)
        Remove-PSDrive -Name AD -ErrorAction SilentlyContinue

        # --- Helpers ---
        function Register-LdapFilterValue {
            param([Parameter(Mandatory)] [string]$Value)
            # RFC 4515 escaping: \ * ( ) NUL -> escaped hex
            $v = $Value.Replace('\', '\5c').Replace('*', '\2a').Replace('(', '\28').Replace(')', '\29')
            # NUL not likely in user input; keep for completeness
            $v = ($v -replace '\x00', '\00')
            return $v
        }

        # AD property set needed by Format-UserRecord
        $props = $ADprops

        $common = @{
            Properties  = $props
            ErrorAction = 'Stop'
        }
        if ($Server) { $common['Server'] = $Server }
        if ($SearchBase) { $common['SearchBase'] = $SearchBase }
        if ($SearchScope) { $common['SearchScope'] = $SearchScope }
        if ($Credential) { $common['Credential'] = $Credential }

        $adUsers = @()

        # --- 1) Exact match attempt (UPN or SAM) ---
        $isUPN = ($Identity -match '^[^@\s]+@[^@\s]+\.[^@\s]+$')
        $idEsc = Register-LdapFilterValue $Identity
        $exactLdap = if ($isUPN) { "(userPrincipalName=$idEsc)" } else { "(sAMAccountName=$idEsc)" }

        try {
            $adUsers = Get-ADUser @common -LDAPFilter $exactLdap
        }
        catch {
            Write-Log -Level Warn -Message ("[Search-User][AD/Exact] {0}" -f $_.Exception.Message)
        }

        # --- 2) Fallback broader search (displayName/mail/proxyAddresses) if none found ---
        if (-not $adUsers -or $adUsers.Count -eq 0) {
            $terms = @(
                "(sAMAccountName=$idEsc)"
                "(userPrincipalName=$idEsc)"
                "(displayName=*$idEsc*)"
            )

            if ($EnableMailSearch) {
                $terms += "(mail=$idEsc)"
            }
            if ($EnableProxyAddressSearch) {
                # proxyAddresses is case-sensitive on the prefix; include both primary & aliases
                $terms += "(proxyAddresses=SMTP:$idEsc)"
                $terms += "(proxyAddresses=smtp:$idEsc)"
            }

            $ldap = "(|{0})" -f ($terms -join '')
            try {
                $adUsers = Get-ADUser @common -LDAPFilter $ldap
            }
            catch {
                Write-Log -Level Warn -Message ("[Search-User][AD/Fallback] {0}" -f $_.Exception.Message)
            }
        }

        if (-not $adUsers -or $adUsers.Count -eq 0) {
            Write-Log -Level Warn -Message ("No AD user found matching '{0}'." -f $Identity)
            return $null
        }

        # --- Handle multiplicity ---
        if (($adUsers | Measure-Object).Count -gt 1 -and -not $AllowMultiple) {
            $names = ($adUsers | Select-Object -First 5 | ForEach-Object { $_.SamAccountName }) -join ', '
            throw "Multiple AD users matched '$Identity' (e.g., $names). Use -AllowMultiple to return all."
        }

        # --- Normalize via Format-UserRecord ---
        if (-not (Get-Command Format-UserRecord -ErrorAction SilentlyContinue)) {
            throw "Format-UserRecord not found. Ensure it is dot-sourced from Private and available."
        }

        $normalized = $adUsers | ForEach-Object {
            Format-UserRecord -AD $_ -Server $Server -Credential $Credential `
                -ResolveManager:$ResolveManager -ResolveGroups:$ResolveGroups
        }

        if (-not $normalized) {
            Write-Log -Level Warn -Message ("No usable record produced for '{0}'." -f $Identity)
            return $null
        }

        if ($AllowMultiple) {
            Write-Log -Level Ok -Message ("{0} user(s) found and normalized." -f (($normalized | Measure-Object).Count))
            return $normalized
        }
        else {
            $one = $normalized | Select-Object -First 1
            Write-Log -Level Ok -Message ("User '{0}' found and normalized." -f $one.UserPrincipalName)
            return $one
        }
    }
    catch {
        Write-Log -Level Error -Message ("[Search-User] Failed: {0}" -f $_.Exception.Message)
        throw
    }
    finally {
        $ErrorActionPreference = $oldEAP
    }
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Public\AI\Invoke-CodeAssistant.ps1
function Invoke-CodeAssistant {
    <#
    .SYNOPSIS
        Analyzes PowerShell code using a local LLM and generates a Markdown
        report.

    .DESCRIPTION
        This function:
        - Accepts raw PowerShell code and a filename.
        - Removes signature blocks and PEM blocks.
        - Builds a mode-specific analysis prompt (General, Static, Security,
          Refactor, Tests, Combined).
        - Sends the prompt to a local LLM via Invoke-LocalLLM.
        - Saves a timestamped Markdown report to C:\TechToolbox\CodeAnalysis.

    .PARAMETER Code
        The raw PowerShell code to analyze.

    .PARAMETER FileName
        The name of the file the code came from. Used for naming the output
        report.

    .PARAMETER Mode
        The type of analysis to perform:
        - General  : High-level review (readability, structure, performance,
          best practices).
        - Static   : Lint-style static analysis (unused vars, error handling,
          structure).
        - Security : Security-focused review (unsafe patterns, secrets,
          injection, etc.).
        - Refactor : Proposes a refactored version of the code.
        - Tests    : Generates Pester test ideas or scaffolding.
        - Combined : Performs all of the above in a structured, multi-section
          response.
        - ModuleReview : Reviews an entire PowerShell module, including all
          functions and scripts, for best practices, structure, and potential
          improvements.

    .PARAMETER Encoding
        Optional output encoding for the Markdown file. Defaults to UTF8.

    .OUTPUTS
        System.String  The path to the generated Markdown report.

    .NOTES
        Part of the TechToolbox AI subsystem.
    #>

    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [ValidateNotNullOrEmpty()]
        [string]$Code,

        [Parameter(Mandatory)]
        [ValidateNotNullOrEmpty()]
        [string]$FileName,

        [ValidateSet('General', 'Static', 'Security', 'Refactor', 'Tests', 'Combined', 'ModuleReview')]
        [string]$Mode = 'General',

        [ValidateSet('UTF8', 'ASCII', 'Unicode', 'UTF7', 'UTF32', 'Default', 'OEM')]
        [string]$Encoding = 'UTF8'
    )

    # -------------------------------------------------------------------------
    # Load Config from JSON
    # -------------------------------------------------------------------------

    Initialize-TechToolboxRuntime
    $model = $script:cfg.settings.ai.model
    $promptPackPath = $script:cfg.settings.ai.promptPackPath

    # Load prompt pack
    $PromptPackPath = $promptPackPath
    if (-not (Test-Path $PromptPackPath)) {
        throw "Prompt pack not found at $PromptPackPath"
    }

    $PromptPack = Get-Content $PromptPackPath -Raw | ConvertFrom-Json

    # Select mode config
    $PromptConfig = $PromptPack.$Mode
    if (-not $PromptConfig) {
        throw "Prompt mode '$Mode' not found in prompts.json"
    }

    # -------------------------------------------------------------------------
    # Helper: Remove signature blocks and PEM blocks
    # -------------------------------------------------------------------------
    function Remove-SignatureBlocks {
        param([string]$InputCode)

        $clean = $InputCode -replace '(?is)[SIGNATURE BLOCK REMOVED]', '[SIGNATURE BLOCK REMOVED]'
        $clean = $clean -replace '(?is)-----BEGIN [A-Z0-9 ]+-----(.+?)-----END [A-Z0-9 ]+-----', '[PEM BLOCK REMOVED]'
        return $clean
    }

    # -------------------------------------------------------------------------
    # Begin main function logic
    # -------------------------------------------------------------------------
    try {
        # Clean the code
        $cleanCode = Remove-SignatureBlocks -InputCode $Code

        # Normalize user_template (supports string OR array)
        $template = $PromptConfig.user_template
        if ($template -is [System.Collections.IEnumerable] -and $template -notlike '*string*') {
            $template = $template -join "`n"
        }

        $prompt = $template.Replace("{{code}}", $cleanCode)

        # Call local LLM
        $result = Invoke-LocalLLM -Prompt $prompt

        # Prepare output folder
        $folder = "C:\TechToolbox\CodeAnalysis"
        if (-not (Test-Path $folder)) { New-Item -ItemType Directory -Path $folder | Out-Null }

        # Build output path
        $timestamp = (Get-Date).ToString("yyyy-MM-dd_HHmmss")
        $baseName = [System.IO.Path]::GetFileNameWithoutExtension($FileName)
        # Sanitize model name for filesystem (remove invalid chars)
        $sanitizedModel = Format-FileName -Name $model
        $path = Join-Path $folder "Analysis-$sanitizedModel-$baseName-$Mode-$timestamp.md"

        # Build Markdown
        $md = @'
# Code Analysis Report
Generated: {0}

## Mode
{3}

## Summary
{1}

## Source Code
```powershell
{2}
```
'@ -f (Get-Date), $result, $cleanCode, $Mode
        # Save file
        $md | Out-File -FilePath $path -Encoding $Encoding

        Write-Log -Level OK -Message ("`nSaved analysis ($Mode) to: {0}" -f $path)
    }
    catch {
        Write-Log -Level Error -Message ("Invoke-CodeAssistant ($Mode) failed: {0}" -f $_.Exception.Message)
        throw
    }
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Public\AI\Invoke-CodeAssistantFolder.ps1
function Invoke-CodeAssistantFolder {
    <#
    .SYNOPSIS
    Invokes the code assistant on all PowerShell files in a folder recursively.

    .DESCRIPTION
    Analyzes all .ps1 files in the specified path and its subdirectories using
    the Invoke-CodeAssistant function.

    .PARAMETER Path
    The root folder path to search for PowerShell files.

    .EXAMPLE
    Invoke-CodeAssistantFolder -Path "C:\Scripts"
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$Path
    )

    Initialize-TechToolboxRuntime

    # Get all .ps1 files recursively
    $files = Get-ChildItem -Path $Path -Filter *.ps1 -File -Recurse

    foreach ($file in $files) {
        Write-Host "`n=== Analyzing: $($file.FullName) ===`n" -ForegroundColor Cyan

        $code = Get-Content $file.FullName -Raw

        Invoke-CodeAssistant -Code $code -FileName $file.Name
    }
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Public\AI\Invoke-CodeAssistantWrapper.ps1
function Invoke-CodeAssistantWrapper {
    <#
    .SYNOPSIS
    Wrapper for Invoke-CodeAssistant that supports file-level and module-level analysis.

    .PARAMETER Path
    Path to a file OR a folder (for ModuleReview mode).

    .PARAMETER Mode
    Analysis mode: General, Static, Security, Refactor, Tests, Combined, ModuleReview.
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$Path,

        [ValidateSet('General', 'Static', 'Security', 'Refactor', 'Tests', 'Combined', 'ModuleReview')]
        [string]$Mode = 'General'
    )

    Initialize-TechToolboxRuntime

    # ---------------------------------------------------------------------
    # MODULE REVIEW MODE
    # ---------------------------------------------------------------------
    if ($Mode -eq 'ModuleReview') {

        if (-not (Test-Path -LiteralPath $Path)) {
            throw "Path not found: $Path"
        }

        # If it's a directory, gather all module files
        if (Test-Path -LiteralPath $Path -PathType Container) {

            $files = Get-ChildItem -Path $Path -Recurse -Include *.ps1, *.psm1

            if (-not $files) {
                throw "No PowerShell source files found in module path: $Path"
            }

            $combined = foreach ($file in $files) {
                "### FILE: $($file.FullName)`n" +
                (Get-Content -LiteralPath $file.FullName -Raw) +
                "`n`n"
            }

            $moduleSource = $combined -join "`n"

            Invoke-CodeAssistant -Code $moduleSource -FileName "ModuleReview" -Mode $Mode
            return
        }

        # If it's a file, fallback to normal behavior
        # (Allows reviewing a single script with ModuleReview if desired)
    }

    # ---------------------------------------------------------------------
    # NORMAL FILE MODE
    # ---------------------------------------------------------------------
    if (-not (Test-Path -LiteralPath $Path -PathType Leaf)) {
        throw "File not found: $Path"
    }

    $code = Get-Content -LiteralPath $Path -Raw
    $fileName = [System.IO.Path]::GetFileName($Path)

    Invoke-CodeAssistant -Code $code -FileName $fileName -Mode $Mode
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Public\Get\Get-AutodiscoverXmlInteractive.ps1
function Get-AutodiscoverXmlInteractive {
    <#
    .SYNOPSIS
        Interactive (or parameterized) Autodiscover XML probe for
        Exchange/Hosted/M365.

    .DESCRIPTION
        Prompts (or accepts params) for Email, Schema, URI, and Credentials;
        POSTs the Outlook Autodiscover request; follows redirects; saves the
        XML; and summarizes common nodes. Hardened for DNS/connection errors and
        missing ResponseUri.

    .PARAMETER Email
        Mailbox UPN/email to test. If omitted, prompts.

    .PARAMETER Uri
        Full Autodiscover endpoint (e.g.,
        https://autodiscover.domain.com/autodiscover/autodiscover.xml). If
        omitted, will suggest
        https://autodiscover.<domain>/autodiscover/autodiscover.xml.

    .PARAMETER Schema
        AcceptableResponseSchema. Defaults to 2006a.

    .PARAMETER TryAllPaths
        If set, will attempt a sequence of common endpoints derived from the
        email's domain.

    .EXAMPLE
        Get-AutodiscoverXmlInteractive

    .EXAMPLE
        Get-AutodiscoverXmlInteractive -Email user@domain.com -Uri https://autodiscover.domain.com/autodiscover/autodiscover.xml

    .EXAMPLE
        Get-AutodiscoverXmlInteractive -Email user@domain.com -TryAllPaths
    #>
    [CmdletBinding()]
    param(
        [Parameter(Position = 0)]
        [string] $Email,
        [Parameter(Position = 1)]
        [string] $Uri,
        [ValidateSet('http://schemas.microsoft.com/exchange/autodiscover/outlook/responseschema/2006a',
            'http://schemas.microsoft.com/exchange/autodiscover/outlook/responseschema/2006')]
        [string] $Schema = 'http://schemas.microsoft.com/exchange/autodiscover/outlook/responseschema/2006a',
        [switch] $TryAllPaths
    )

    Write-Log -Level Info -Message "=== Autodiscover XML Probe (Interactive/Param) ==="
    Initialize-TechToolboxRuntime

    # 1) Email
    while ([string]::IsNullOrWhiteSpace($Email) -or $Email -notmatch '^[^@\s]+@[^@\s]+\.[^@\s]+$') {
        if ($Email) { Write-Log -Level Warn -Message "That doesn't look like a valid email address." }
        $Email = Read-Host "Enter the mailbox Email Address (e.g., user@domain.com)"
    }
    $domain = $Email.Split('@')[-1]

    # 2) URI (build suggestion if not provided)
    $suggested = "https://autodiscover.$domain/autodiscover/autodiscover.xml"
    if ([string]::IsNullOrWhiteSpace($Uri)) {
        Write-Log -Level Info -Message "Detected domain: $domain"
        Write-Log -Level Info -Message "Suggested Autodiscover URI: $suggested"
        $Uri = Read-Host "Enter Autodiscover URI or press Enter to use the suggestion"
        if ([string]::IsNullOrWhiteSpace($Uri)) { $Uri = $suggested }
    }

    # Helper: normalize URI and ensure well-known path
    function Resolve-AutodiscoverUri {
        param([string]$InputUri)
        try {
            $u = [Uri]$InputUri
            if (-not $u.Scheme.StartsWith("http")) { throw "URI must start with http or https." }
            if ($u.Host -match '\.xml$') { throw "Hostname ends with .xml (`"$($u.Host)`"). Remove the .xml from the host." }

            $path = $u.AbsolutePath.TrimEnd('/')
            if ([string]::IsNullOrWhiteSpace($path) -or $path -eq "/") {
                # Bare host/root  append the well-known path
                $normalized = ($u.GetLeftPart([System.UriPartial]::Authority)).TrimEnd('/') + "/autodiscover/autodiscover.xml"
            }
            elseif ($path -match '/autodiscover/?$') {
                # '/autodiscover'  append final segment
                $normalized = ($u.GetLeftPart([System.UriPartial]::Authority)).TrimEnd('/') + "/autodiscover/autodiscover.xml"
            }
            else {
                # Leave as-is if user pointed directly at an XML endpoint
                $normalized = $u.AbsoluteUri
            }
            return $normalized
        }
        catch {
            throw "Invalid URI '$InputUri': $($_.Exception.Message)"
        }
    }

    $Uri = Resolve-AutodiscoverUri -InputUri $Uri

    # Candidate list if -TryAllPaths is set
    $candidates = @($Uri)
    if ($TryAllPaths) {
        $candidates = @(
            "https://autodiscover.$domain/autodiscover/autodiscover.xml",
            "https://$domain/autodiscover/autodiscover.xml",
            "https://mail.$domain/autodiscover/autodiscover.xml"
        ) | Select-Object -Unique
    }

    # 3) Credentials
    Write-Log -Level Info -Message ""
    $cred = Get-Credential -Message "Enter credentials for $Email (or the mailbox being tested)"

    # 4) Request body
    $body = @"
<?xml version="1.0" encoding="utf-8"?>
<Autodiscover xmlns="http://schemas.microsoft.com/exchange/autodiscover/outlook/requestschema/2006">
  <Request>
    <EMailAddress>$Email</EMailAddress>
    <AcceptableResponseSchema>$Schema</AcceptableResponseSchema>
  </Request>
</Autodiscover>
"@

    $headers = @{
        "User-Agent" = "AutodiscoverProber/1.3"
        "Accept"     = "text/xml, application/xml"
    }

    # 5) Probe loop (single or multiple URIs)
    foreach ($candidate in $candidates) {
        # DNS pre-check
        try {
            Write-Log -Level Info -Message "`nChecking DNS for host: $(([Uri]$candidate).Host)"
            $null = Resolve-DnsName -Name ([Uri]$candidate).Host -ErrorAction Stop
            Write-Log -Level Info -Message "DNS OK."
        }
        catch {
            Write-Log -Level Warn -Message "DNS check failed: $($_.Exception.Message)"
            if (-not $TryAllPaths) { return }
            else { continue }
        }

        Write-Log -Level Info -Message "`nPosting to: $candidate"
        try {
            Write-Log -Level Info -Message "`nPosting to: $candidate"

            # IMPORTANT: Do NOT throw on HTTP errors; we want to inspect redirects/challenges.
            $resp = Invoke-WebRequest `
                -Uri $candidate `
                -Method POST `
                -Headers $headers `
                -ContentType "text/xml" `
                -Body $body `
                -Credential $cred `
                -MaximumRedirection 10 `
                -AllowUnencryptedAuthentication:$false `
                -SkipHttpErrorCheck `
                -ErrorAction Stop

            # Try to capture the final URI if available (it may not exist on some failures)
            $finalUri = $null
            if ($resp.BaseResponse -and $resp.BaseResponse.PSObject.Properties.Name -contains 'ResponseUri' -and $resp.BaseResponse.ResponseUri) {
                $finalUri = $resp.BaseResponse.ResponseUri.AbsoluteUri
            }

            # If you want to see what status we actually got:
            $code = $null
            $reason = $null
            if ($resp.PSObject.Properties.Name -contains 'StatusCode') { $code = [int]$resp.StatusCode }
            if ($resp.PSObject.Properties.Name -contains 'StatusDescription') { $reason = $resp.StatusDescription }

            Write-Log -Level Info -Message ("`nHTTP Status: " + ($(if ($code) { "$code " } else { "" }) + ($reason ?? "")))
            if ($finalUri) { Write-Log -Level Info -Message "Final Endpoint: $finalUri" }

            Write-Log -Level Info -Message "`nHTTP Status: $($resp.StatusCode) $($resp.StatusDescription)"
            if ($finalUri) { Write-Log -Level Info -Message "Final Endpoint: $finalUri" }

            if ($resp.Content) {
                try {
                    [xml]$xml = $resp.Content
                    $stamp = (Get-Date).ToString("yyyyMMdd_HHmmss")
                    $outFile = Join-Path $PWD "Autodiscover_$($domain)_$stamp.xml"
                    $xml.Save($outFile)
                    Write-Log -Level Info -Message "Saved XML to: $outFile"

                    # Summarize common nodes if present
                    Write-Log -Level Info -Message "`n--- Key Autodiscover Nodes (if available) ---"
                    $ns = New-Object System.Xml.XmlNamespaceManager($xml.NameTable)
                    $ns.AddNamespace("a", "http://schemas.microsoft.com/exchange/autodiscover/outlook/responseschema/2006a")
                    $ns.AddNamespace("r", "http://schemas.microsoft.com/exchange/autodiscover/responseschema/2006")

                    $ewsExt = $xml.SelectNodes("//a:Protocol[a:Type='EXPR' or a:Type='EXCH']/a:ExternalEwsUrl", $ns)
                    $ewsInt = $xml.SelectNodes("//a:Protocol[a:Type='EXCH']/a:InternalEwsUrl", $ns)
                    $mapiSrv = $xml.SelectNodes("//a:Protocol[a:Type='EXCH']/a:Server", $ns)

                    if ($ewsExt) { $ewsExt | ForEach-Object { Write-Log -Level Info -Message ("EWS External URL: " + $_.'#text') } }
                    if ($ewsInt) { $ewsInt | ForEach-Object { Write-Log -Level Info -Message ("EWS Internal URL: " + $_.'#text') } }
                    if ($mapiSrv) { $mapiSrv | ForEach-Object { Write-Log -Level Info -Message ("MAPI/HTTP Server: " + $_.'#text') } }

                    Write-Log -Level Info -Message "------------------------------------------------"
                }
                catch {
                    Write-Log -Level Warn -Message "Response received but not valid XML. Raw content follows:"
                    Write-Log -Level Info -Message $resp.Content
                }
            }
            else {
                Write-Log -Level Warn -Message "No content returned."
            }

            # Success: stop probing
            return
        }
        catch {
            # Primary error message only (no secondary exceptions)
            Write-Log -Level Error -Message ("Request failed: " + $_.Exception.Message)

            # Try to surface a helpful endpoint without assuming properties exist
            $respObj = $null
            $hintUri = $null

            # Windows-style WebException
            if ($_.Exception.PSObject.Properties.Name -contains 'Response') {
                try { $respObj = $_.Exception.Response } catch {}
                if ($respObj -and $respObj.PSObject.Properties.Name -contains 'ResponseUri' -and $respObj.ResponseUri) {
                    $hintUri = $respObj.ResponseUri.AbsoluteUri
                }
            }

            # PS7 HttpRequestException.ResponseMessage
            if (-not $hintUri -and $_.Exception.PSObject.Properties.Name -contains 'ResponseMessage') {
                try {
                    $respMsg = $_.Exception.ResponseMessage
                    if ($respMsg -and $respMsg.PSObject.Properties.Name -contains 'RequestMessage' -and $respMsg.RequestMessage) {
                        $hintUri = $respMsg.RequestMessage.RequestUri.AbsoluteUri
                    }
                }
                catch {}
            }

            # Fall back to the candidate we attempted
            if (-not $hintUri) { $hintUri = $candidate }

            Write-Log -Level Info -Message ("Endpoint (on error): " + $hintUri)

            if (-not $TryAllPaths) { return }
            else {
                Write-Log -Level Warn -Message "Trying next candidate endpoint..."
                Start-Sleep -Milliseconds 200
            }
        }
    }

    # If we got here with TryAllPaths, everything failed
    if ($TryAllPaths) {
        Write-Log -Level Error -Message "All Autodiscover candidates failed for $Email"
    }
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Public\Get\Get-BatteryHealth.ps1

function Get-BatteryHealth {
    <#
    .SYNOPSIS
        Generates a Windows battery report and parses its HTML into structured
        JSON with health metrics.
    .DESCRIPTION
        Runs 'powercfg /batteryreport' to produce the HTML report, parses the
        "Installed batteries" table, computes health (FullCharge/Design ratios),
        logs progress, and exports a JSON file. Paths can be provided by
        parameters or taken from TechToolbox config (BatteryReport section).
    .PARAMETER ReportPath
        Output path for the HTML report (e.g., C:\Temp\battery-report.html). If
        omitted, uses config.
    .PARAMETER OutputJson
        Path to write parsed JSON (e.g., C:\Temp\installed-batteries.json). If
        omitted, uses config.
    .PARAMETER DebugInfo
        Optional path to write parser debug info (e.g., detected headings) when
        table detection fails. If omitted, uses config.
    .INPUTS
        None. You cannot pipe objects to Get-BatteryHealth.
    .OUTPUTS
        [pscustomobject[]] Battery objects with capacity and health metrics.
    .EXAMPLE
        Get-BatteryHealth
    .EXAMPLE
        Get-BatteryHealth -ReportPath 'C:\Temp\battery-report.html' -OutputJson 'C:\Temp\batteries.json' -WhatIf
        # Preview file creation/JSON export without writing.
    .LINK
        [TechToolbox](https://github.com/dan-damit/TechToolbox)
    #>
    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]
    [OutputType([object[]])]
    param(
        [Parameter()][string]$ReportPath,
        [Parameter()][string]$OutputJson,
        [Parameter()][string]$DebugInfo
    )

    # --- Resolve defaults from normalized config when parameters not supplied
    Initialize-TechToolboxRuntime
    $br = $script:cfg.settings.batteryReport

    # Generate timestamped paths for report and JSON output
    $initReportPath = Join-Path -Path $br.reportPath -ChildPath $br.reportFileNamePattern
    $outJSON = Join-Path -Path $br.outputJson -ChildPath $br.jsonFileNamePattern
    $timestampedPath = Add-TimestampToFilePath -Path $initReportPath
    $timestampedJson = Add-TimestampToFilePath -Path $outJSON

    # ReportPath
    if (-not $PSBoundParameters.ContainsKey('ReportPath') -or 
        [string]::IsNullOrWhiteSpace($ReportPath)) {
        if ($null -ne $br.reportPath -and 
            -not [string]::IsNullOrWhiteSpace($br.reportPath)) {

            $ReportPath = [string]$br.reportPath
        }
    }
    Invoke-CreateDirectory "$ReportPath"

    # OutputJson
    if (-not $PSBoundParameters.ContainsKey('OutputJson') -or 
        [string]::IsNullOrWhiteSpace($OutputJson)) {
        if ($null -ne $br.outputJson -and 
            -not [string]::IsNullOrWhiteSpace($br.outputJson)) {

            $OutputJson = [string]$br.outputJson
        }
    }
    Invoke-CreateDirectory "$OutputJson"

    # DebugInfo
    if (-not $PSBoundParameters.ContainsKey('DebugInfo') -or 
        [string]::IsNullOrWhiteSpace($DebugInfo)) {
        if ($null -ne $br.debugInfo -and 
            -not [string]::IsNullOrWhiteSpace($br.debugInfo)) {

            $DebugInfo = [string]$br.debugInfo
        }
    }
    Invoke-CreateDirectory "$DebugInfo"

    Write-Log -Level Info -Message "Generating battery report..."
    $reportReady = Invoke-BatteryReport -ReportPath "$timestampedPath" -WhatIf:$WhatIfPreference -Confirm:$false
    if (-not $reportReady) {
        Write-Log -Level Error -Message ("Battery report was not generated or is empty at: {0}" -f $timestampedPath)
        return
    }
    Write-Log -Level Ok -Message "Battery report generated."

    # Read and parse HTML with check for no batteries
    $html = Get-Content -LiteralPath $timestampedPath -Raw
    if ($html -notmatch 'Installed batteries') {
        Write-Log -Level Warning -Message "No battery detected on this system."
        return [pscustomobject]@{
            hasBattery = $false
            reason     = "System does not contain a battery subsystem."
            timestamp  = (Get-Date)
        }
    }
    $batteries, $debug = Get-BatteryReportHtml -Html $html

    if (-not $batteries -or $batteries.Count -eq 0) {
        Write-Log -Level Error -Message "No battery data parsed."
        if ($DebugInfo -and $debug) {
            Write-Log -Level Warn -Message ("Writing parser debug info to: {0}" -f $DebugInfo)
            if ($PSCmdlet.ShouldProcess($DebugInfo, 'Write debug info')) {
                Set-Content -LiteralPath $DebugInfo -Value $debug -Encoding UTF8
            }
        }
        return
    }

    Write-Log -Level Ok -Message ("Parsed {0} battery object(s)." -f $batteries.Count)

    # Export JSON
    if ($OutputJson) {
        $dir = Split-Path -Parent $OutputJson
        if ($dir -and $PSCmdlet.ShouldProcess($dir, 'Ensure output directory')) {
            if (-not (Test-Path -LiteralPath $dir)) {
                New-Item -ItemType Directory -Path $dir -Force | Out-Null
            }
        }

        $json = $batteries | ConvertTo-Json -Depth 6
        if ($PSCmdlet.ShouldProcess($timestampedJson, 'Write JSON')) {
            Set-Content -LiteralPath $timestampedJson -Value $json -Encoding UTF8
        }
        Write-Log -Level Ok -Message ("Exported JSON with health metrics to {0}" -f $timestampedJson)
    }

    return $batteries
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Public\Get\Get-DomainAdminCredential.ps1

function Get-DomainAdminCredential {
    <#
    .SYNOPSIS
    Returns the modules domain admin credential; optionally clears or
    re-prompts & persists.

    .DESCRIPTION
    - Default: Returns the in-memory credential if present; if not present and
      config contains a username/password, reconstructs and caches it; if still
      missing, prompts the user (but does not save unless -Persist is supplied).
    - -Clear: Wipes username/password in config.json and removes in-memory
      $script:domainAdminCred.
    - -ForcePrompt: Always prompt for a credential now (ignores whats on disk).
    - -Persist: When prompting, saves username and DPAPI-protected password back
      to config.json.
    - -PassThru: Returns the PSCredential object to the caller.

    .PARAMETER Clear
    Wipe stored username/password in config.json and clear in-memory credential.

    .PARAMETER ForcePrompt
    Ignore existing stored credential and prompt for a new one now.

    .PARAMETER Persist
    When prompting (either because none exists or -ForcePrompt), write the new
    credential to config.json.

    .PARAMETER PassThru
    Return the credential object to the pipeline.

    .EXAMPLE
    # Just get the cred (from memory or disk); prompt only if missing
    $cred = Get-DomainAdminCredential -PassThru

    .EXAMPLE
    # Force a new prompt and persist to config.json
    $cred = Get-DomainAdminCredential -ForcePrompt -Persist -PassThru

    .EXAMPLE
    # Clear stored username/password in config.json and in-memory cache
    Get-DomainAdminCredential -Clear -Confirm

    .NOTES
    Requires Initialize-Config to have populated $script:cfg and
    $script:ConfigPath.
    #>
    [CmdletBinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    param(
        [switch]$Clear,
        [switch]$ForcePrompt,
        [switch]$Persist,
        [switch]$PassThru
    )

    # --- Preconditions ---
    Initialize-TechToolboxRuntime
    
    if (-not $script:cfg) {
        throw "[Get-DomainAdminCredential] Config not loaded. Run Initialize-Config first."
    }
    if (-not $script:ConfigPath) {
        throw "[Get-DomainAdminCredential] ConfigPath not set. Run Initialize-Config first."
    }

    # Ensure password branch exists
    if (-not $script:cfg.settings) { $script:cfg.settings = @{} }
    if (-not $script:cfg.settings.passwords) { $script:cfg.settings.passwords = @{} }
    if (-not $script:cfg.settings.passwords.domainAdminCred) {
        $script:cfg.settings.passwords.domainAdminCred = @{
            username = ''
            password = ''
        }
    }

    $node = $script:cfg.settings.passwords.domainAdminCred

    # --- CLEAR path ---
    if ($Clear) {
        $target = "domainAdminCred in $($script:ConfigPath)"
        if ($PSCmdlet.ShouldProcess($target, "Clear username and password")) {
            try {
                $node.username = ''
                $node.password = ''
                # Persist to disk
                $script:cfg | ConvertTo-Json -Depth 50 | Set-Content -Path $script:ConfigPath -Encoding UTF8
                # Clear in-memory cache
                $script:domainAdminCred = $null
                Write-Log -Level 'Ok' -Message "[Get-DomainAdminCredential] Cleared stored domainAdminCred and in-memory cache."
            }
            catch {
                Write-Log -Level 'Error' -Message "[Get-DomainAdminCredential] Failed to clear and persist: $($_.Exception.Message)"
                throw
            }
        }
        return
    }

    # --- Use cached in-memory credential unless forcing prompt ---
    if (-not $ForcePrompt -and $script:domainAdminCred -is [System.Management.Automation.PSCredential]) {
        if ($PassThru) { return $script:domainAdminCred } else { return }
    }

    # --- If not forcing prompt, try to rebuild from config ---
    $hasUser = ($node.PSObject.Properties.Name -contains 'username') -and -not [string]::IsNullOrWhiteSpace([string]$node.username)
    $hasPass = ($node.PSObject.Properties.Name -contains 'password') -and -not [string]::IsNullOrWhiteSpace([string]$node.password)

    if (-not $ForcePrompt -and $hasUser -and $hasPass) {
        try {
            $username = [string]$node.username
            $securePwd = [string]$node.password | ConvertTo-SecureString
            $script:domainAdminCred = New-Object -TypeName PSCredential -ArgumentList $username, $securePwd
            Write-Log -Level 'Debug' -Message "[Get-DomainAdminCredential] Reconstructed credential from config."
            if ($PassThru) { return $script:domainAdminCred } else { return }
        }
        catch {
            Write-Log -Level 'Warn' -Message "[Get-DomainAdminCredential] Failed to reconstruct credential from config: $($_.Exception.Message)"
            # fall through to prompt
        }
    }

    # --- PROMPT path (ForcePrompt or nothing stored/valid) ---
    try {
        $cred = Get-Credential -Message "Enter Domain Admin Credential"
    }
    catch {
        Write-Log -Level 'Error' -Message "[Get-DomainAdminCredential] Prompt cancelled or failed: $($_.Exception.Message)"
        throw
    }

    $script:domainAdminCred = $cred

    # Persist on request
    if ($Persist) {
        $target = "domainAdminCred in $($script:ConfigPath)"
        if ($PSCmdlet.ShouldProcess($target, "Persist username and DPAPI-protected password")) {
            try {
                $script:cfg.settings.passwords.domainAdminCred = @{
                    username = $cred.UserName
                    password = (ConvertFrom-SecureString $cred.Password)
                }
                $script:cfg | ConvertTo-Json -Depth 50 | Set-Content -Path $script:ConfigPath -Encoding UTF8
                Write-Log -Level 'Ok' -Message "[Get-DomainAdminCredential] Persisted credential to config.json."
            }
            catch {
                Write-Log -Level 'Error' -Message "[Get-DomainAdminCredential] Failed to persist credential: $($_.Exception.Message)"
                throw
            }
        }
    }

    if ($PassThru) { return $script:domainAdminCred }
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Public\Get\Get-MessageTrace.ps1
function Get-MessageTrace { 
    <#
    .SYNOPSIS
    Retrieve Exchange Online message trace summary and details using V2 cmdlets
    with chunking and throttling handling.
    .DESCRIPTION
    This cmdlet retrieves message trace summary and details from Exchange Online
    using the V2 cmdlets (Get-MessageTraceV2 and Get-MessageTraceDetailV2). It
    handles chunking for date ranges over 10 days and manages throttling with
    exponential backoff retries. The cmdlet supports filtering by MessageId,
    Sender, Recipient, and Subject, and can automatically export results to CSV.
    .PARAMETER MessageId
    Filter by specific Message ID.
    .PARAMETER Sender
    Filter by sender email address.
    .PARAMETER Recipient
    Filter by recipient email address.
    .PARAMETER Subject
    Filter by email subject.
    .PARAMETER StartDate
    Start of the date range for the message trace (default: now - configured
    lookback).
    .PARAMETER EndDate
    End of the date range for the message trace (default: now).
    .PARAMETER ExportFolder
    Folder path to export results. If not specified, uses default from config.
    .EXAMPLE
    Get-MessageTrace -Sender "user@example.com" -StartDate (Get-Date).AddDays(-7) -EndDate (Get-Date)
    Retrieves message traces for the specified sender over the last 7 days.
    .NOTES
    Requires Exchange Online V2 cmdlets (3.7.0+). Ensure you are connected to
    Exchange Online before running this cmdlet.
    .INPUTS
    None.
    .OUTPUTS
    None. Outputs are logged to the console and optionally exported to CSV.
    #>

    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]
    param(
        [Parameter()][string]  $MessageId,
        [Parameter()][string]  $Sender,
        [Parameter()][string]  $Recipient,
        [Parameter()][string]  $Subject,
        [Parameter()][datetime]$StartDate,
        [Parameter()][datetime]$EndDate,
        [Parameter()][string]  $ExportFolder
    )

    # --- Config & defaults ---
    Initialize-TechToolboxRuntime

    $exo = $script:cfg.settings.exchangeOnline
    $mt = $script:cfg.settings.messageTrace

    # Make sure our in-house EXO module is imported
    Import-ExchangeOnlineModule  # v3.7.0+ exposes V2 cmdlets after connect

    # Lookback hours (safe default)
    $lookbackHours = [int]$mt.defaultLookbackHours
    if ($lookbackHours -le 0) { $lookbackHours = 48 }

    # Auto export flag
    $autoExport = [bool]$mt.autoExport

    # Resolve export folder default
    $defaultExport = $mt.defaultExportFolder
    if ([string]::IsNullOrWhiteSpace($defaultExport)) {
        $defaultExport = $script:cfg.paths.exportDirectory
    }

    # Resolve StartDate/EndDate defaults
    if (-not $StartDate) { $StartDate = (Get-Date).AddHours(-$lookbackHours) }
    if (-not $EndDate) { $EndDate = (Get-Date) }

    if ($StartDate -ge $EndDate) {
        Write-Log -Level Error -Message "StartDate must be earlier than EndDate."
        throw "Invalid date window."
    }

    # --- Validate search criteria ---
    if (-not $MessageId -and -not $Sender -and -not $Recipient -and -not $Subject) {
        Write-Log -Level Error -Message "You must specify at least one of: MessageId, Sender, Recipient, Subject."
        throw "At least one search filter is required."
    }

    # --- Ensure EXO connection and V2 availability ---
    # V2 cmdlets are only available after Connect-ExchangeOnline (they load into tmpEXO_*).
    # We'll auto-connect (quietly) if V2 isn't visible, then re-check.  (Docs: GA + V2 usage)  [TechCommunity + Learn]
    function Confirm-EXOConnected {
        if (-not (Get-Command -Name Get-MessageTraceV2 -ErrorAction SilentlyContinue)) {
            if (Get-Command -Name Connect-ExchangeOnline -ErrorAction SilentlyContinue) {
                try {
                    # Prefer your wrapper if present
                    if (Get-Command -Name Connect-ExchangeOnlineIfNeeded -ErrorAction SilentlyContinue) {
                        Connect-ExchangeOnlineIfNeeded -ShowProgress:([bool]$exo.showProgress)
                    }
                    else {
                        Connect-ExchangeOnline -ShowBanner:$false | Out-Null
                    }
                }
                catch {
                    Write-Log -Level Error -Message ("Failed to connect to Exchange Online: {0}" -f $_.Exception.Message)
                    throw
                }
            }
        }
    }
    Confirm-EXOConnected

    # Resolve cmdlets (they are Functions exported from tmpEXO_* after connect)
    try {
        $getTraceCmd = Get-Command -Name Get-MessageTraceV2       -ErrorAction Stop
        $getDetailCmd = Get-Command -Name Get-MessageTraceDetailV2 -ErrorAction Stop
    }
    catch {
        Write-Log -Level Error -Message ("Message Trace V2 cmdlets not available. Are you connected to EXO? {0}" -f $_.Exception.Message)
        throw
    }

    # --- Helper: throttle-aware invoker with retries for transient 429/5xx ---
    function Invoke-WithBackoff {
        param([scriptblock]$Block)
        $delay = 1
        for ($i = 1; $i -le 5; $i++) {
            try { return & $Block }
            catch {
                $msg = $_.Exception.Message
                if ($msg -match 'Too many requests|429|throttle|temporarily unavailable|5\d{2}') {
                    Write-Log -Level Warn -Message ("Transient/throttle error (attempt {0}/5): {1}  sleeping {2}s" -f $i, $msg, $delay)
                    Start-Sleep -Seconds $delay
                    $delay = [Math]::Min($delay * 2, 30)
                    continue
                }
                throw
            }
        }
        throw "Exceeded retry attempts."
    }

    # --- Chunked V2 invoker (10-day slices + continuation when >5k rows) ---
    function Invoke-MessageTraceV2Chunked {
        [CmdletBinding()]
        param(
            [Parameter(Mandatory)][datetime]$StartDate,
            [Parameter(Mandatory)][datetime]$EndDate,
            [Parameter()][string] $MessageId,
            [Parameter()][string] $SenderAddress,
            [Parameter()][string] $RecipientAddress,
            [Parameter()][string] $Subject,
            [Parameter()][int]    $ResultSize = 5000
        )
        # Docs: V2 supports 90 days history but only 10 days per request; up to 5000 rows; times are returned as UTC.  [Learn]
        # When result size is exceeded, query subsequent data by using StartingRecipientAddress and EndDate with
        # the values from the previous result's Recipient address and Received time.  [Learn]
        $sliceStart = $StartDate
        $endLimit = $EndDate
        $maxSpan = [TimeSpan]::FromDays(10)
        $results = New-Object System.Collections.Generic.List[object]

        while ($sliceStart -lt $endLimit) {
            $sliceEnd = $sliceStart.Add($maxSpan)
            if ($sliceEnd -gt $endLimit) { $sliceEnd = $endLimit }

            Write-Information ("[Trace] Querying slice {0:u}  {1:u}" -f $sliceStart.ToUniversalTime(), $sliceEnd.ToUniversalTime()) -InformationAction Continue

            $continuationRecipient = $null
            $continuationEndUtc = $sliceEnd

            do {
                $params = @{
                    StartDate   = $sliceStart
                    EndDate     = $continuationEndUtc
                    ResultSize  = $ResultSize
                    ErrorAction = 'Stop'
                }
                if ($MessageId) { $params.MessageId = $MessageId }
                if ($SenderAddress) { $params.SenderAddress = $SenderAddress }
                if ($RecipientAddress) { $params.RecipientAddress = $RecipientAddress }
                if ($Subject) { $params.Subject = $Subject }

                if ($continuationRecipient) {
                    $params.StartingRecipientAddress = $continuationRecipient
                }

                $batch = Invoke-WithBackoff { & $getTraceCmd @params }

                if ($batch -and $batch.Count -gt 0) {
                    $results.AddRange($batch)

                    # Continuation: use the oldest row's RecipientAddress and Received (UTC)
                    $last = $batch | Sort-Object Received -Descending | Select-Object -Last 1
                    $continuationRecipient = $last.RecipientAddress
                    $continuationEndUtc = $last.Received

                    # Pace to respect tenant throttling (100 req / 5 min)
                    Start-Sleep -Milliseconds 200
                }
                else {
                    $continuationRecipient = $null
                }

            } while ($batch.Count -ge $ResultSize)

            $sliceStart = $sliceEnd
        }

        return $results
    }

    # --- Log filters (friendly) ---
    Write-Log -Level Info -Message "Message trace filters:"
    Write-Log -Level Info -Message ("  MessageId : {0}" -f ($MessageId ?? '<none>'))
    Write-Log -Level Info -Message ("  Sender    : {0}" -f ($Sender ?? '<none>'))
    Write-Log -Level Info -Message ("  Recipient : {0}" -f ($Recipient ?? '<none>'))
    Write-Log -Level Info -Message ("  Subject   : {0}" -f ($Subject ?? '<none>'))
    Write-Log -Level Info -Message ("  Window    : {0}  {1} (UTC shown by EXO)" -f $StartDate.ToString('u'), $EndDate.ToString('u'))

    # --- Execute (chunked) ---
    $summary = Invoke-MessageTraceV2Chunked `
        -StartDate        $StartDate `
        -EndDate          $EndDate `
        -MessageId        $MessageId `
        -SenderAddress    $Sender `
        -RecipientAddress $Recipient `
        -Subject          $Subject `
        -ResultSize       5000

    if (-not $summary -or $summary.Count -eq 0) {
        Write-Log -Level Warn -Message "No results found. Check filters, UTC vs. local time, and the 10-day-per-call limit."
        return
    }

    # Summary view (EXO returns UTC timestamps)
    $summaryView = $summary |
    Select-Object Received, SenderAddress, RecipientAddress, Subject, Status, MessageTraceId

    Write-Log -Level Ok   -Message ("Summary results ({0}):" -f $summaryView.Count)
    Write-Log -Level Info -Message ($summaryView | Sort-Object Received | Format-Table -AutoSize | Out-String)

    # --- Details ---
    Write-Log -Level Info -Message "Enumerating per-recipient details..."
    $detailsAll = New-Object System.Collections.Generic.List[object]

    foreach ($row in $summary) {
        $mtid = $row.MessageTraceId
        $rcpt = $row.RecipientAddress
        if (-not $mtid -or -not $rcpt) { continue }

        try {
            $details = Invoke-WithBackoff { & $getDetailCmd -MessageTraceId $mtid -RecipientAddress $rcpt -ErrorAction Stop }
            if ($details) {
                $detailsView = $details | Select-Object `
                @{n = 'Recipient'; e = { $rcpt } },
                @{n = 'MessageTraceId'; e = { $mtid } },
                Date, Event, Detail
                $detailsAll.AddRange($detailsView)
            }
        }
        catch {
            Write-Log -Level Warn -Message ("Failed to get details for {0} / MTID {1}: {2}" -f $rcpt, $mtid, $_.Exception.Message)
        }
    }

    if ($detailsAll.Count -gt 0) {
        Write-Log -Level Ok   -Message ("Details ({0} rows):" -f $detailsAll.Count)
        Write-Log -Level Info -Message ($detailsAll | Format-Table -AutoSize | Out-String)
    }
    else {
        Write-Log -Level Warn -Message "No detail records returned."
    }

    # --- Export ---
    $shouldExport = $autoExport -or (-not [string]::IsNullOrWhiteSpace($ExportFolder))
    if ($shouldExport) {
        if ([string]::IsNullOrWhiteSpace($ExportFolder)) {
            $ExportFolder = $defaultExport
        }

        if ($PSCmdlet.ShouldProcess($ExportFolder, "Export message trace results")) {
            Export-MessageTraceResults `
                -Summary $summaryView `
                -Details $detailsAll `
                -ExportFolder $ExportFolder `
                -WhatIf:$WhatIfPreference `
                -Confirm:$false
        }
    }
    [void](Invoke-DisconnectExchangeOnline -ExchangeOnline $exo)
}
[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Public\Get\Get-PDQDiagLogs.ps1

function Get-PDQDiagLogs {
  <#
    .SYNOPSIS
      Collect PDQ diagnostics under SYSTEM context (local and remote), zip on
      target, and copy back to C:\PDQDiagLogs on the machine running this script.
    
    .DESCRIPTION
      - Local & remote: run a one-time Scheduled Task as SYSTEM that performs
        collection.
      - PS7-first remoting via New-PSRemoteSession helper if present (fallback
        included).
      - Resilient copy (Copy-Item then robocopy /B), plus Event Log export via
        wevtutil.
      - ZIP pulled back to the collector and named
        PDQDiag_<Computer>_<timestamp>.zip.
    
    .PARAMETER ComputerName
      Target computer(s). Defaults to local machine.
    
    .PARAMETER Credential
      Optional credential for remote connections. If omitted and
      $Global:TTDomainCred exists, New-PSRemoteSession helper may use it.
    
    .PARAMETER LocalDropPath
      Path on the collector to store retrieved ZIP(s). Default: C:\PDQDiagLogs.
    
    .PARAMETER TransferMode
      Retrieval method for remote ZIPs: FromSession (default), Bytes, or SMB.
    
    .PARAMETER ExtraPaths
      Extra file/folder paths on the target(s) to include.
    
    .PARAMETER ConnectDataPath
      PDQ Connect data root. Default: "$env:ProgramData\PDQ\PDQConnectAgent"
    
    .PARAMETER UseSsh, SshPort, Ps7ConfigName, WinPsConfigName
      Passed through to session creation if helper supports them.
    
    .EXAMPLE
      Get-PDQDiagLogs
    .EXAMPLE
      Get-PDQDiagLogs -ComputerName EDI-2.vadtek.com -Credential (Get-Credential)
    .EXAMPLE
      Get-PDQDiagLogs. -ComputerName PC01,PC02 -ExtraPaths 'C:\Temp\PDQ','D:\Logs\PDQ'
    #>

  [CmdletBinding()]
  param(
    [Parameter(ValueFromPipeline, ValueFromPipelineByPropertyName)]
    [Alias('CN', 'DNSHostName', 'Computer')]
    [string[]]$ComputerName = $env:COMPUTERNAME,

    [pscredential]$Credential,

    [string]$LocalDropPath = 'C:\PDQDiagLogs',

    [ValidateSet('FromSession', 'Bytes', 'SMB')]
    [string]$TransferMode = 'FromSession',

    [string[]]$ExtraPaths,

    [string]$ConnectDataPath = (Join-Path $env:ProgramData 'PDQ\PDQConnectAgent'),

    [switch]$UseSsh,
    [int]$SshPort = 22,

    [string]$Ps7ConfigName = 'PowerShell.7',
    [string]$WinPsConfigName = 'Microsoft.PowerShell',

    [switch]$VerifyHash,      # optional: compare SHA256 before cleanup
    [switch]$NoCleanup        # optional: keep remote artifacts
  )

  begin {
    $useUserHelper = [bool](Get-Command -Name Start-NewPSRemoteSession -ErrorAction SilentlyContinue)
    Initialize-TechToolboxRuntime

    # Local session fallback if helper isn't present
    function New-ToolboxSession {
      param(
        [Parameter(Mandatory)][string]$ComputerName,
        [pscredential]$Credential,
        [switch]$UseSsh,
        [int]$Port = 22,
        [string]$Ps7ConfigName = 'PowerShell.7',
        [string]$WinPsConfigName = 'Microsoft.PowerShell'
      )

      if ($UseSsh) {
        $sshParams = @{
          HostName    = $ComputerName
          Port        = $Port
          ErrorAction = 'Stop'
        }
        if ($Credential) {
          $sshParams.UserName = $Credential.UserName
          $sshParams.Password = $Credential.GetNetworkCredential().Password
        }
        return New-PSSession @sshParams
      }
      else {
        try {
          return New-PSSession -ComputerName $ComputerName -Credential $Credential `
            -ConfigurationName $Ps7ConfigName -ErrorAction Stop
        }
        catch {
          return New-PSSession -ComputerName $ComputerName -Credential $Credential `
            -ConfigurationName $WinPsConfigName -ErrorAction Stop
        }
      }
    }

    $timestamp = Get-Date -Format 'yyyyMMdd-HHmmss'
    $results = New-Object System.Collections.Generic.List[object]
  }

  process {
    foreach ($comp in $ComputerName) {
      if ([string]::IsNullOrWhiteSpace($comp)) { continue }

      $display = $comp
      $fileName = "PDQDiag_{0}_{1}.zip" -f ($display -replace '[^\w\.-]', '_'), $timestamp
      $collectorZipPath = Join-Path $LocalDropPath $fileName

      Write-Log -Level Info -Message ("[{0}] Starting collection (SYSTEM)..." -f $display)

      # Remote session lifecycle
      $session = $null
      try {
        if ($useUserHelper) {
          $params = @{
            ComputerName    = $comp
            Credential      = $Credential
            UseSsh          = $UseSsh
            Port            = $SshPort
            Ps7ConfigName   = $Ps7ConfigName
            WinPsConfigName = $WinPsConfigName
          }
          $session = Start-NewPSRemoteSession @params
        }
        else {
          $session = New-ToolboxSession -ComputerName $comp -Credential $Credential -UseSsh:$UseSsh -Port $SshPort -Ps7ConfigName $Ps7ConfigName -WinPsConfigName $WinPsConfigName
        }

        # Run the SYSTEM worker on the remote
        $remote = Invoke-RemoteSystemCollection -Session $session -Timestamp $timestamp -ExtraPaths $ExtraPaths -ConnectDataPath $ConnectDataPath

        # Make sure the worker actually finished and ZIP exists
        $completed = $remote.PSObject.Properties['Completed'] -and $remote.Completed
        if (-not $completed) {
          # If the new property isn't present, fall back to probing the flag/zip
          $zipExists = Invoke-Command -Session $session -ScriptBlock { param($p) Test-Path -LiteralPath $p } -ArgumentList $remote.ZipPath
          if (-not $zipExists) {
            throw "Remote worker did not complete within the timeout; ZIP not found at $($remote.ZipPath)"
          }
        }

        # (Optional) compute remote hash before transfer
        $remoteHash = $null
        if ($VerifyHash) {
          $remoteHash = Invoke-Command -Session $session -ScriptBlock {
            param($p)
            if (Test-Path -LiteralPath $p) { (Get-FileHash -LiteralPath $p -Algorithm SHA256).Hash } else { $null }
          } -ArgumentList $remote.ZipPath
        }

        # Retrieve ZIP to collector
        Receive-RemoteFile -Session $session -RemotePath $remote.ZipPath -LocalPath $collectorZipPath -Mode $TransferMode
        Write-Log -Level Info -Message ("[{0}] ZIP retrieved: {1}" -f $comp, $collectorZipPath)

        # (Optional) verify local hash matches
        if ($VerifyHash -and $remoteHash) {
          $localHash = (Get-FileHash -LiteralPath $collectorZipPath -Algorithm SHA256).Hash
          if ($localHash -ne $remoteHash) {
            throw "Hash mismatch after transfer. Remote=$remoteHash Local=$localHash"
          }
          Write-Log -Level Ok -Message ("[{0}] SHA256 verified." -f $comp)
        }

        # Remote cleanup (optional)
        if (-not $NoCleanup) {
          try {
            Invoke-Command -Session $session -ScriptBlock {
              param($stag, $zip, $scr, $arg)
              foreach ($p in @($stag, $zip, $scr, $arg)) {
                if ($p -and (Test-Path -LiteralPath $p -ErrorAction SilentlyContinue)) {
                  Remove-Item -LiteralPath $p -Recurse -Force -ErrorAction SilentlyContinue
                }
              }
            } -ArgumentList $remote.Staging, $remote.ZipPath, $remote.Script, $remote.Args -ErrorAction SilentlyContinue | Out-Null
          }
          catch { }
        }

        $obj = [pscustomobject]@{
          ComputerName = $comp
          Status       = 'Success'
          ZipPath      = $collectorZipPath
          Notes        = 'Remote SYSTEM collection'
        }
        $results.Add($obj) | Out-Null
        Write-Output $obj
      }
      catch {
        $msg = $_.Exception.Message
        Write-Log -Level Error -Message ("[{0}] FAILED: {1}" -f $comp, $msg)
        $obj = [pscustomobject]@{
          ComputerName = $comp
          Status       = 'Failed'
          ZipPath      = $null
          Notes        = $msg
        }
        $results.Add($obj) | Out-Null
        Write-Output $obj
      }
      finally {
        if ($session) { Remove-PSSession $session }
      }
    }
  }

  end {
    return
  }
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Public\Get\Get-RemoteInstalledSoftware.ps1
function Get-RemoteInstalledSoftware {
    <#
    .SYNOPSIS
    Retrieves installed software from one or more remote computers.

    .DESCRIPTION
    This function uses PowerShell Remoting to gather a list of installed
    software from remote computers. It can optionally include AppX packages and
    export results to CSV files.

    .PARAMETER ComputerName
    The name(s) of the computer(s) to query.

    .PARAMETER Credential
    Optional credentials to use for the remote connection.

    .PARAMETER IncludeAppx
    If specified, includes AppX packages in the results.

    .PARAMETER OutDir
    The output directory for CSV exports. Defaults to the current location.

    .PARAMETER Consolidated
    If specified, exports all results to a single CSV file instead of
    per-computer files.

    .PARAMETER ThrottleLimit
    The maximum number of concurrent remote sessions. Range: 1-128. Default: 32.

    .PARAMETER PreferPS7
    If specified, prefers PowerShell 7+ for remote connections if available.

    .OUTPUTS
    System.Management.Automation.PSCustomObject Returns custom objects
    containing software inventory data.
    #>
    [CmdletBinding(SupportsShouldProcess, ConfirmImpact = 'Low')]
    [OutputType([pscustomobject])]
    param(
        [Parameter(Mandatory, Position = 0)]
        [string[]]$ComputerName,

        [pscredential]$Credential,

        [switch]$IncludeAppx,

        [string]$OutDir,

        [switch]$Consolidated,

        [ValidateRange(1, 128)]
        [int]$ThrottleLimit = 32,

        [switch]$PreferPS7
    )

    begin {
        Initialize-TechToolboxRuntime

        # Config defaults
        $defaults = $script:cfg.settings.remoteSoftwareInventory
        if ($defaults) {
            if (-not $PSBoundParameters.ContainsKey('IncludeAppx') -and $defaults.IncludeAppx) { $IncludeAppx = $true }
            if (-not $PSBoundParameters.ContainsKey('Consolidated') -and $defaults.Consolidated) { $Consolidated = $true }
            if (-not $PSBoundParameters.ContainsKey('ThrottleLimit') -and $defaults.ThrottleLimit) { $ThrottleLimit = [int]$defaults.ThrottleLimit }
            if (-not $PSBoundParameters.ContainsKey('OutDir') -and $defaults.OutDir) { $OutDir = [string]$defaults.OutDir }
        }

        if (-not $OutDir) { $OutDir = (Get-Location).Path }

        # Worker paths
        $moduleRoot = Get-ModuleRoot
        $workerLocal = Join-Path $moduleRoot 'Workers\Get-RemoteInstalledSoftware.worker.ps1'
        $workerRemote = 'C:\TechToolbox\Workers\Get-RemoteInstalledSoftware.worker.ps1'

        # No helpers needed
        $pkg = New-HelpersPackage -HelperFiles @()

        $all = New-Object System.Collections.Generic.List[object]
        $timestamp = Get-Date -Format 'yyyy-MM-dd_HH-mm-ss'
    }

    process {
        foreach ($cn in $ComputerName) {
            $session = $null
            try {
                $session = Start-NewPSRemoteSession -ComputerName $cn -Credential $Credential -PreferPS7:$PreferPS7

                $result = Invoke-RemoteWorker `
                    -Session $session `
                    -HelpersZip $pkg.ZipPath `
                    -HelpersZipHash $pkg.ZipHash `
                    -WorkerRemotePath $workerRemote `
                    -WorkerLocalPath $workerLocal `
                    -EntryPoint 'Get-RemoteInstalledSoftwareCore' `
                    -EntryParameters @{ IncludeAppx = $IncludeAppx }

                if ($result) {
                    $all.AddRange($result)
                }
            }
            catch {
                Write-Log -Level Warn -Message ("{0}: {1}" -f $cn, $_.Exception.Message)
            }
            finally {
                if ($session) { Remove-PSSession $session -ErrorAction SilentlyContinue }
            }
        }
    }

    end {
        $results = $all.ToArray()
        if (-not $results) { return }

        # CSV Export
        if ($Consolidated) {
            $csv = Join-Path $OutDir "InstalledSoftware_AllHosts_$timestamp.csv"
            if ($PSCmdlet.ShouldProcess($csv, 'Export consolidated CSV')) {
                $results |
                Sort-Object ComputerName, DisplayName, DisplayVersion |
                Export-Csv -Path $csv -NoTypeInformation -Encoding UTF8
            }
        }
        else {
            $grouped = $results | Group-Object ComputerName
            foreach ($g in $grouped) {
                $csv = Join-Path $OutDir ("{0}_InstalledSoftware_{1}.csv" -f $g.Name, $timestamp)
                if ($PSCmdlet.ShouldProcess($csv, "Export CSV for $($g.Name)")) {
                    $g.Group |
                    Sort-Object DisplayName, DisplayVersion |
                    Export-Csv -Path $csv -NoTypeInformation -Encoding UTF8
                }
            }
        }

        return $results
    }
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Public\Get\Get-SystemSnapshot.ps1
function Get-SystemSnapshot {
    <#
    .SYNOPSIS
        Retrieves a system snapshot from one or more remote computers.

    .DESCRIPTION
        Thin controller: resolves config, prepares helper package, executes worker
        locally or remotely via Invoke-TTRemoteWorker (Option A: dot-source worker +
        call entry), and optionally exports.

    .PARAMETER ComputerName
        One or more computers to snapshot.

    .PARAMETER Report
        Show the interactive report after snapshot.

    .PARAMETER Credential
        Credential for remote connections.

    .PARAMETER IncludeServices
        Include service information in the snapshot (default from config).

    .PARAMETER IncludeRoles
        Include server role information in the snapshot (default from config).

    .PARAMETER OutDir
        Output directory for CSV export (default from config).

    .PARAMETER NoExport
        Skip CSV export.

    .PARAMETER PreferPS7
        Prefer PowerShell 7 for remote sessions (honored by Start-NewPSRemoteSession
        if supported).
    #>
    [CmdletBinding(SupportsShouldProcess)]
    [OutputType([pscustomobject])]
    param(
        [Parameter(Mandatory)]
        [string[]]$ComputerName,
        [Parameter()] [switch]$Report,
        [pscredential]$Credential,
        [switch]$IncludeServices,
        [switch]$IncludeRoles,
        [string]$OutDir,
        [switch]$NoExport,
        [switch]$PreferPS7
    )

    begin {
        Initialize-TechToolboxRuntime

        # Config (null-safe)
        $ss = $script:cfg.settings.systemSnapshot

        # Defaults from config
        if (-not $PSBoundParameters.ContainsKey('IncludeServices')) { $IncludeServices = [bool]$ss.includeServices }
        if (-not $PSBoundParameters.ContainsKey('IncludeRoles')) { $IncludeRoles = [bool]$ss.includeRoles }

        # OutDir default
        if (-not $PSBoundParameters.ContainsKey('OutDir')) {
            $OutDir = if ($ss.exportPath) { [string]$ss.exportPath } else { Join-Path (Get-ModuleRoot) "Exports/SystemSnapshot" }
        }
        if (-not (Test-Path -LiteralPath $OutDir)) { New-Item -ItemType Directory -Path $OutDir -Force | Out-Null }

        # Helpers: from config (same semantics as before)
        $helperSourceDir = if ($ss.helperPath) { [string]$ss.helperPath } else { Join-Path (Get-ModuleRoot) "Private/System/Snapshot" }
        $helperFilesByName = @()
        if ($ss.helperFiles) { $helperFilesByName = [string[]]$ss.helperFiles }

        $helperFiles = @()
        foreach ($name in $helperFilesByName) {
            $p = Join-Path $helperSourceDir $name
            if (-not (Test-Path -LiteralPath $p)) {
                throw "Configured helper not found: $p"
            }
            $helperFiles += $p
        }

        # Package helpers once per run (engine expects a zip)
        $pkg = New-HelpersPackage -HelperFiles $helperFiles
        $zipPath = $pkg.ZipPath
        $zipHash = $pkg.ZipHash

        # Worker paths & local converters
        $workerRemotePath = if ($ss.workerPath) { [string]$ss.workerPath } else { "C:\TechToolbox\Workers\Get-SystemSnapshot.worker.ps1" }
        $localWorker = Join-Path (Get-ModuleRoot) "Workers/Get-SystemSnapshot.worker.ps1"

        $convert1 = Join-Path (Get-ModuleRoot) "Private/System/Snapshot/Convert-SnapshotToFlatObject.ps1"
        $convert2 = Join-Path (Get-ModuleRoot) "Private/System/Snapshot/Convert-FlatSnapshotToRows.ps1"
        if ((-not (Test-Path $convert1)) -or (-not (Test-Path $convert2))) {
            Write-Verbose "Snapshot flatteners not found; NoExport will be forced."
            $NoExport = $true
        }

        $all = New-Object System.Collections.Generic.List[object]
    }

    process {
        foreach ($cn in $ComputerName) {
            $IsLocal = $cn -eq $env:COMPUTERNAME -or $cn -eq 'localhost' -or $cn -eq '127.0.0.1'
            $session = $null
            try {
                if ($IsLocal) {
                    Write-Log -Level Info -Message "Running snapshot in local mode for $cn"
                    # Dot-source helpers locally
                    foreach ($h in $helperFiles) { . $h }

                    if (-not (Test-Path -LiteralPath $localWorker)) { throw "Local worker not found: $localWorker" }
                    . $localWorker

                    if (-not (Get-Command -Name Get-SystemSnapshotCore -ErrorAction SilentlyContinue)) {
                        throw "Worker does not define required entry function: Get-SystemSnapshotCore"
                    }

                    $entryParams = @{
                        IncludeServices = $IncludeServices
                        IncludeRoles    = $IncludeRoles
                    }

                    $snapshot = Get-SystemSnapshotCore @entryParams
                }
                else {
                    # Session (your existing helper decides PS5/PS7 based on PreferPS7)
                    $session = Start-NewPSRemoteSession -ComputerName $cn -Credential $Credential

                    # Call the engine
                    $entryParams = @{
                        IncludeServices = $IncludeServices
                        IncludeRoles    = $IncludeRoles
                    }

                    $snapshot = Invoke-RemoteWorker `
                        -Session          $session `
                        -HelpersZip       $zipPath `
                        -HelpersZipHash   $zipHash `
                        -WorkerRemotePath $workerRemotePath `
                        -WorkerLocalPath  $localWorker `
                        -EntryPoint       'Get-SystemSnapshotCore' `
                        -EntryParameters  $entryParams
                }

                if ($snapshot) {
                    if (-not $NoExport) {
                        . $convert1
                        . $convert2

                        $flat = Convert-SnapshotToFlatObject -Snapshot $snapshot
                        $rows = Convert-FlatSnapshotToRows -FlatObject $flat

                        $name = "SystemSnapshot_{0}_{1:yyyyMMdd_HHmmss}.csv" -f $cn, (Get-Date)
                        $csvPath = Join-Path $OutDir $name

                        if ($PSCmdlet.ShouldProcess($csvPath, "Export system snapshot CSV")) {
                            $rows | Export-Csv -Path $csvPath -NoTypeInformation -Encoding UTF8 -Force
                        }
                    }
                    $all.Add($snapshot)
                    if ($Report) { Show-SystemSnapshotReport -Snapshot $snapshot }
                }
            }
            catch {
                Write-Warning ("{0}: {1}" -f $cn, $_.Exception.Message)
            }
            finally {
                if ($session) {
                    try { Remove-PSSession -Session $session -ErrorAction SilentlyContinue } catch {}
                }
            }
        }
    }

    end {
        # Return all collected snapshots
        $all.ToArray() | Out-Null
    }
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Public\Get\Get-SystemUptime.ps1
function Get-SystemUptime {
    <#
    .SYNOPSIS
    Retrieves the system uptime information from one or more remote computers.
    .DESCRIPTION
    Uses the TechToolbox remote worker engine to run a small uptime worker
    script on each remote host and optionally exports results to CSV.
    #>
    [CmdletBinding(SupportsShouldProcess)]
    [OutputType([pscustomobject])]
    param(
        [Parameter(Mandatory)]
        [string[]]$ComputerName,

        [pscredential]$Credential,

        [string]$OutDir,

        [switch]$NoExport,

        [switch]$PreferPS7
    )

    begin {
        Initialize-TechToolboxRuntime

        $OutDir = Resolve-UptimeExportPath -OutDir $OutDir

        $moduleRoot = Get-ModuleRoot
        $workerLocal = Join-Path $moduleRoot 'Workers\Get-SystemUptime.worker.ps1'
        $workerRemote = 'C:\TechToolbox\Workers\Get-SystemUptime.worker.ps1'

        # No helpers needed for uptime, but engine expects a package object
        $pkg = New-HelpersPackage -HelperFiles @()

        $all = New-Object System.Collections.Generic.List[object]
    }

    process {
        foreach ($cn in $ComputerName) {
            $session = $null
            try {
                $session = Start-NewPSRemoteSession -ComputerName $cn -Credential $Credential -PreferPS7:$PreferPS7

                $result = Invoke-RemoteWorker `
                    -Session $session `
                    -HelpersZip $pkg.ZipPath `
                    -HelpersZipHash $pkg.ZipHash `
                    -WorkerRemotePath $workerRemote `
                    -WorkerLocalPath $workerLocal `
                    -EntryPoint 'Get-SystemUptimeCore'

                if ($result) {
                    if (-not $NoExport) {
                        if ($PSCmdlet.ShouldProcess($cn, "Export uptime CSV")) {
                            Export-UptimeCsv -OutDir $OutDir -ComputerName $cn -Data $result
                        }
                    }
                    $all.Add($result)
                }
            }
            catch {
                Write-Log -Level Warn -Message ("{0}: {1}" -f $cn, $_.Exception.Message)
            }
            finally {
                if ($session) {
                    Remove-PSSession -Session $session -ErrorAction SilentlyContinue
                }
            }
        }
    }

    end {
        $all.ToArray()
    }
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Public\Get\Get-TechToolboxConfig.ps1
function Get-TechToolboxConfig {
    <#
    .SYNOPSIS
    Retrieves and caches the TechToolbox configuration from a JSON file.

    .DESCRIPTION
    Loads a JSON configuration file and converts it to a hashtable. Results are
    cached in the session to improve performance on subsequent calls.

    .PARAMETER Path
    The literal file path to the JSON configuration file.

    .OUTPUTS
    [hashtable] The configuration data as a hashtable.

    .EXAMPLE
    $config = Get-TechToolboxConfig -Path "C:\config.json"
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [ValidateNotNullOrEmpty()]
        [string]$Path
    )

    # --- PS5-compatible deep converter (only used on PS5) ---
    function ConvertTo-Hashtable {
        param([Parameter(Mandatory)]$InputObject)
        if ($InputObject -is [hashtable]) { return $InputObject }
        if ($InputObject -is [System.Collections.IDictionary]) {
            $ht = @{}
            foreach ($k in $InputObject.Keys) { $ht[$k] = ConvertTo-Hashtable $InputObject[$k] }
            return $ht
        }
        if ($InputObject -is [System.Collections.IEnumerable] -and -not ($InputObject -is [string])) {
            return @($InputObject | ForEach-Object { ConvertTo-Hashtable $_ })
        }
        if ($InputObject -is [pscustomobject]) {
            $ht = @{}
            foreach ($p in $InputObject.PSObject.Properties) { $ht[$p.Name] = ConvertTo-Hashtable $p.Value }
            return $ht
        }
        return $InputObject
    }

    if (-not (Test-Path -LiteralPath $Path)) {
        throw "Get-TechToolboxConfig: config file not found at '$Path'."
    }

    $fi = Get-Item -LiteralPath $Path

    # --- Simple session cache ---
    if (-not (Get-Variable -Name __cfgCache -Scope Script -ErrorAction SilentlyContinue)) {
        $script:__cfgCache = $null
    }

    if ($script:__cfgCache -and
        $script:__cfgCache.Path -eq $fi.FullName -and
        $script:__cfgCache.LastWriteTimeUtc -eq $fi.LastWriteTimeUtc) {
        return $script:__cfgCache.Data
    }

    # --- Load & parse (use -Raw; DO NOT use $raw variable) ---
    $jsonRaw = Get-Content -LiteralPath $fi.FullName -Raw -ErrorAction Stop

    if ($PSVersionTable.PSVersion.Major -ge 7) {
        $data = ConvertFrom-Json -InputObject $jsonRaw -AsHashtable
    }
    else {
        $data = ConvertTo-Hashtable (ConvertFrom-Json -InputObject $jsonRaw)
    }

    # --- Update cache ---
    $script:__cfgCache = @{
        Path             = $fi.FullName
        LastWriteTimeUtc = $fi.LastWriteTimeUtc
        Data             = $data
    }

    # Optional: maintain the legacy global if other code expects it
    $script:TechToolboxConfig = $data

    return $data
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Public\Get\Get-ToolboxHelp.ps1
function Get-ToolboxHelp {
    <#
    .SYNOPSIS
        Provides help information for TechToolbox public commands.
    .DESCRIPTION
        Displays overview, lists commands, shows full help for a given command,
        or prints the effective configuration.
    #>
    [CmdletBinding()]
    param(
        [string]$Name,
        [switch]$List,
        [switch]$ShowEffectiveConfig,
        [switch]$AsJson
    )

    # Ensure runtime (config/logging/etc.) is initialized
    try {
        Initialize-TechToolboxRuntime
    }
    catch {
        # If runtime can't init (e.g., config missing), we still want the help text to show.
        Write-Verbose ("Get-ToolboxHelp: runtime init failed: {0}" -f $_.Exception.Message)
    }

    # Safe access to config (strict-mode friendly)
    $configLoaded = $false
    $Config = $null
    if (Get-Variable -Name cfg -Scope Script -ErrorAction SilentlyContinue) {
        $Config = $script:cfg
        $configLoaded = [bool]$Config
    }

    # If user explicitly asked for effective config but it's not loaded, try to load it directly
    if ($ShowEffectiveConfig -and -not $configLoaded) {
        try {
            # Resolve default config path the same way Initialize-Config does
            if (-not $script:ModuleRoot) { $script:ModuleRoot = $ExecutionContext.SessionState.Module.ModuleBase }
            $configDir = Join-Path $script:ModuleRoot 'Config'
            $cfgPath = Join-Path $configDir 'config.json'
            if (Test-Path -LiteralPath $cfgPath) {
                $Config = Get-TechToolboxConfig -Path $cfgPath
                $configLoaded = [bool]$Config
            }
        }
        catch {
            Write-Verbose ("Get-ToolboxHelp: direct config load failed: {0}" -f $_.Exception.Message)
        }
    }

    # ---------- Presentation ----------
    Write-Host ""
    Write-Host "========================================" -ForegroundColor DarkCyan
    Write-Host "        TechToolbox Help Center         " -ForegroundColor Cyan
    Write-Host "========================================" -ForegroundColor DarkCyan
    Write-Host ""
    Write-Host "A technician-grade PowerShell toolkit for:" -ForegroundColor Gray
    Write-Host "   Diagnostics" -ForegroundColor Gray
    Write-Host "   Automation" -ForegroundColor Gray
    Write-Host "   Environment-agnostic workflows" -ForegroundColor Gray
    Write-Host ""
    Write-Host "----------------------------------------" -ForegroundColor DarkGray
    Write-Host " Common Commands:" -ForegroundColor White
    Write-Host "----------------------------------------" -ForegroundColor DarkGray
    Write-Host ""
    Write-Host "  Get-ToolboxHelp -List" -ForegroundColor Yellow
    Write-Host "    Displays all available commands." -ForegroundColor Gray
    Write-Host ""
    Write-Host "  Get-ToolboxHelp Invoke-SubnetScan" -ForegroundColor Yellow
    Write-Host "    Shows detailed help for Invoke-SubnetScan." -ForegroundColor Gray
    Write-Host ""
    Write-Host "  Invoke-PurviewPurge -CaseName 'XYZ123'" -ForegroundColor Yellow
    Write-Host "    Creates a Case search and purges the search results." -ForegroundColor Gray
    Write-Host ""
    Write-Host "----------------------------------------" -ForegroundColor DarkGray
    Write-Host " For full help on any command:" -ForegroundColor White
    Write-Host "----------------------------------------" -ForegroundColor DarkGray
    Write-Host ""
    Write-Host "  Get-ToolboxHelp <CommandName>" -ForegroundColor Yellow
    Write-Host ""
    Write-Host "========================================" -ForegroundColor DarkCyan

    # ----- Effective configuration requested -----
    if ($ShowEffectiveConfig) {
        Write-Host ""
        Write-Host "TechToolbox Effective Configuration" -ForegroundColor Cyan
        Write-Host "----------------------------------------"

        if (-not $configLoaded) {
            Write-Host "(configuration not loaded)" -ForegroundColor Yellow
            return
        }

        if ($AsJson) {
            $Config | ConvertTo-Json -Depth 10
        }
        else {
            $Config | Format-List
        }

        Write-Host ""
        return
    }

    # ----- List commands -----
    if ($List) {
        Write-Host ""
        Write-Host "TechToolbox Commands" -ForegroundColor Cyan
        Write-Host "----------------------------------------"
        # Use the current module name to be resilient if someone renames it
        $modName = $PSCmdlet.MyInvocation.MyCommand.ModuleName
        if (-not $modName) { $modName = 'TechToolbox' }

        Get-Command -Module $modName -CommandType Function |
        Select-Object -ExpandProperty Name |
        Sort-Object |
        ForEach-Object { Write-Host "  $_" }
        Write-Host ""
        return
    }

    # ----- Specific command help -----
    if ($Name) {
        try {
            Write-Host ""
            Write-Host "Help for: $Name" -ForegroundColor Cyan
            Write-Host "----------------------------------------"
            # -Full can be noisy; keep it if thats your preference
            Get-Help -Name $Name -Full
            Write-Host ""
        }
        catch {
            Write-Host "No help found for '$Name'." -ForegroundColor Yellow
        }
        return
    }

    # Clear-BrowserProfileData
    if ($Name -eq 'Clear-BrowserProfileData') {
        Write-Host ""
        Write-Host "Clear-BrowserProfileData" -ForegroundColor Cyan
        Write-Host "----------------------------------------"
        return
    }

    # Invoke-SubnetScan
    if ($Name -eq 'Invoke-SubnetScan') {
        Write-Host ""
        Write-Host "Invoke-SubnetScan" -ForegroundColor Cyan
        Write-Host "----------------------------------------"
        return
    }

    # Get-RemoteInstalledSoftware
    if ($Name -eq 'Get-RemoteInstalledSoftware') {
        Write-Host ""
        Write-Host "Get-RemoteInstalledSoftware" -ForegroundColor Cyan
        Write-Host "----------------------------------------"
        return
    }

    # New-OnPremUserFromTemplate
    if ($Name -eq 'New-OnPremUserFromTemplate') {
        Write-Host ""
        Write-Host "New-OnPremUserFromTemplate" -ForegroundColor Cyan
        Write-Host "----------------------------------------"
        return
    }

    # Get-BatteryHealth
    if ($Name -eq 'Get-BatteryHealth') {
        Write-Host ""
        Write-Host "Get-BatteryHealth" -ForegroundColor Cyan
        Write-Host "----------------------------------------"
        return
    }

    # Get-MessageTrace
    if ($Name -eq 'Get-MessageTrace') {
        Write-Host ""
        Write-Host "Get-MessageTrace" -ForegroundColor Cyan
        Write-Host "----------------------------------------"
        return
    }

    # Get-TechToolboxConfig
    if ($Name -eq 'Get-TechToolboxConfig') {
        Write-Host ""
        Write-Host "Get-TechToolboxConfig" -ForegroundColor Cyan
        Write-Host "----------------------------------------"
        return
    }

    # Get-ToolboxHelp
    if ($Name -eq 'Get-ToolboxHelp') {
        Write-Host ""
        Write-Host "Get-ToolboxHelp" -ForegroundColor Cyan
        Write-Host "----------------------------------------"
        return
    }

    # Get-WindowsProductKey
    if ($Name -eq 'Get-WindowsProductKey') {
        Write-Host ""
        Write-Host "Get-WindowsProductKey" -ForegroundColor Cyan
        Write-Host "----------------------------------------"
        return
    }

    # Invoke-AADSyncRemote
    if ($Name -eq 'Invoke-AADSyncRemote') {
        Write-Host ""
        Write-Host "Invoke-AADSyncRemote" -ForegroundColor Cyan
        Write-Host "----------------------------------------"
        return
    }

    # Invoke-DownloadsCleanup
    if ($Name -eq 'Invoke-DownloadsCleanup') {
        Write-Host ""
        Write-Host "Invoke-DownloadsCleanup" -ForegroundColor Cyan
        Write-Host "----------------------------------------"
        return
    }

    # Invoke-PurviewPurge
    if ($Name -eq 'Invoke-PurviewPurge') {
        Write-Host ""
        Write-Host "Invoke-PurviewPurge" -ForegroundColor Cyan
        Write-Host "----------------------------------------"
        return
    }

    # Invoke-SystemRepair
    if ($Name -eq 'Invoke-SystemRepair') {
        Write-Host ""
        Write-Host "Invoke-SystemRepair" -ForegroundColor Cyan
        Write-Host "----------------------------------------"
        return
    }

    # Set-PageFileSize
    if ($Name -eq 'Set-PageFileSize') {
        Write-Host ""
        Write-Host "Set-PageFileSize" -ForegroundColor Cyan
        Write-Host "----------------------------------------"
        return
    }

    # Set-ProxyAddress
    if ($Name -eq 'Set-ProxyAddress') {
        Write-Host ""
        Write-Host "Set-ProxyAddress" -ForegroundColor Cyan
        Write-Host "----------------------------------------"
        return
    }

    # Start-DnsQueryLogger
    if ($Name -eq 'Start-DnsQueryLogger') {
        Write-Host ""
        Write-Host "Start-DnsQueryLogger" -ForegroundColor Cyan
        Write-Host "----------------------------------------"
        return
    }

    # Copy-Directory
    if ($Name -eq 'Copy-Directory') {
        Write-Host ""
        Write-Host "Copy-Directory" -ForegroundColor Cyan
        Write-Host "----------------------------------------"
        return
    }

    # Reset-WindowsUpdateComponents
    if ($Name -eq 'Reset-WindowsUpdateComponents') {
        Write-Host ""
        Write-Host "Reset-WindowsUpdateComponents" -ForegroundColor Cyan
        Write-Host "----------------------------------------"
        return
    }

    # Test-PathAs
    if ($Name -eq 'Test-PathAs') {
        Write-Host ""
        Write-Host "Test-PathAs" -ForegroundColor Cyan
        Write-Host "----------------------------------------"
        return
    }

    # New-OnPremUserFromTemplate
    if ($Name -eq 'New-OnPremUserFromTemplate') {
        Write-Host ""
        Write-Host "New-OnPremUserFromTemplate" -ForegroundColor Cyan
        Write-Host "----------------------------------------"
        return
    }

    # Get-SystemSnapshot
    if ($Name -eq 'Get-SystemSnapshot') {
        Write-Host ""
        Write-Host "Get-SystemSnapshot" -ForegroundColor Cyan
        Write-Host "----------------------------------------"
        return
    }

    # Search-User
    if ($Name -eq 'Search-User') {
        Write-Host ""
        Write-Host "Search-User" -ForegroundColor Cyan
        Write-Host "----------------------------------------"
        return
    }

    # Disable-User
    if ($Name -eq 'Disable-User') {
        Write-Host ""
        Write-Host "Disable-User" -ForegroundColor Cyan
        Write-Host "----------------------------------------"
        return
    }

    #Remove-Printers
    if ($Name -eq 'Remove-Printers') {
        Write-Host ""
        Write-Host "Remove-Printers" -ForegroundColor Cyan
        Write-Host "----------------------------------------"
        return
    }

    # Initialize-DomainAdminCred
    if ($Name -eq 'Initialize-DomainAdminCred') {
        Write-Host ""
        Write-Host "Initialize-DomainAdminCred" -ForegroundColor Cyan
        Write-Host "----------------------------------------"
        return
    }

    # Get-DomainAdminCredential
    if ($Name -eq 'Get-DomainAdminCredential') {
        Write-Host ""
        Write-Host "Get-DomainAdminCredential" -ForegroundColor Cyan
        Write-Host "----------------------------------------"
        return
    }

    # Enable-NetFx3
    if ($Name -eq 'Enable-NetFx3') {
        Write-Host ""
        Write-Host "Enable-NetFx3" -ForegroundColor Cyan
        Write-Host "----------------------------------------"
        return
    }

    # Initialize-TTWordList
    if ($Name -eq 'Initialize-TTWordList') {
        Write-Host ""
        Write-Host "Initialize-TTWordList" -ForegroundColor Cyan
        Write-Host "----------------------------------------"
        return
    }

    # Get-SystemUptime
    if ($Name -eq 'Get-SystemUptime') {
        Write-Host ""
        Write-Host "Get-SystemUptime" -ForegroundColor Cyan
        Write-Host "----------------------------------------"
        return
    }

    # Get-AutodiscoverXmlInteractive
    if ($Name -eq 'Get-AutodiscoverXmlInteractive') {
        Write-Host ""
        Write-Host "Get-AutodiscoverXmlInteractive" -ForegroundColor Cyan
        Write-Host "----------------------------------------"
        return
    }

    # Start-PDQDiagLocalElevated
    if ($Name -eq 'Start-PDQDiagLocalElevated') {
        Write-Host ""
        Write-Host "Start-PDQDiagLocalElevated" -ForegroundColor Cyan
        Write-Host "----------------------------------------"
        return
    }

    # Get-PDQDiagLogs
    if ($Name -eq 'Get-PDQDiagLogs') {
        Write-Host ""
        Write-Host "Get-PDQDiagLogs" -ForegroundColor Cyan
        Write-Host "----------------------------------------"
        return
    }

    # Invoke-LocalLLM
    if ($Name -eq 'Invoke-LocalLLM') {
        Write-Host ""
        Write-Host "Invoke-LocalLLM" -ForegroundColor Cyan
        Write-Host "----------------------------------------"
        return
    }
    
    # Invoke-CodeAssistant
    if ($Name -eq 'Invoke-CodeAssistant') {
        Write-Host ""
        Write-Host "Invoke-CodeAssistant" -ForegroundColor Cyan
        Write-Host "----------------------------------------"
        return
    }

    # Invoke-CodeAssistantWrapper
    if ($Name -eq 'Invoke-CodeAssistantWrapper') {
        Write-Host ""
        Write-Host "Invoke-CodeAssistantWrapper" -ForegroundColor Cyan
        Write-Host "----------------------------------------"
        return
    }

    # Invoke-CodeAssistantFolder
    if ($Name -eq 'Invoke-CodeAssistantFolder') {
        Write-Host ""
        Write-Host "Invoke-CodeAssistantFolder" -ForegroundColor Cyan
        Write-Host "----------------------------------------"
        return
    }

    # Watch-ISPConnection
    if ($Name -eq 'Watch-ISPConnection') {
        Write-Host ""
        Write-Host "Watch-ISPConnection" -ForegroundColor Cyan
        Write-Host "----------------------------------------"
        return
    }

    # Test-MailHeaderAuth
    if ($Name -eq 'Test-MailHeaderAuth') {
        Write-Host ""
        Write-Host "Test-MailHeaderAuth" -ForegroundColor Cyan
        Write-Host "----------------------------------------"
        return
    }

    # Get-AutoDiscoverXmlInteractive
    if ($Name -eq 'Get-AutoDiscoverXmlInteractive') {
        Write-Host ""
        Write-Host "Get-AutoDiscoverXmlInteractive" -ForegroundColor Cyan
        Write-Host "----------------------------------------"
        return
    }

    # Set-EmailAlias
    if ($Name -eq 'Set-EmailAlias') {
        Write-Host ""
        Write-Host "Set-EmailAlias" -ForegroundColor Cyan
        Write-Host "----------------------------------------"
        return
    }
}
[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Public\Get\Get-WindowsProductKey.ps1
function Get-WindowsProductKey {
    <#
    .SYNOPSIS
    Retrieves Windows product key information from a local or remote computer.

    .DESCRIPTION
    Gets OEM product key, partial keys, and activation status using WMI and
    slmgr.vbs.

    .PARAMETER ComputerName
    The name of the computer to query. Defaults to the local computer.

    .PARAMETER Credential
    Credentials for remote connection if querying a remote computer.
    #>
    [CmdletBinding()]
    param(
        [string]$ComputerName = $env:COMPUTERNAME,
        [System.Management.Automation.PSCredential]$Credential
    )

    Initialize-TechToolboxRuntime

    $exportRoot = $script:cfg.settings.windowsActivation.logDir
    if (-not (Test-Path -LiteralPath $exportRoot)) {
        New-Item -Path $exportRoot -ItemType Directory -Force | Out-Null
    }

    $isLocal = ($ComputerName -eq $env:COMPUTERNAME -and -not $Credential)

    if ($isLocal) {
        # --- LOCAL PATH (no remoting) ---
        try {
            $oemKey = (Get-CimInstance -ClassName 'SoftwareLicensingService' -ErrorAction Stop).OA3xOriginalProductKey
        }
        catch {
            $oemKey = $null
        }

        try {
            $partialKeys = Get-CimInstance -ClassName 'SoftwareLicensingProduct' -ErrorAction Stop |
            Where-Object { $_.PartialProductKey } |
            Select-Object Name, Description, LicenseStatus, PartialProductKey
        }
        catch {
            $partialKeys = $null
        }

        try {
            $slmgrOutput = cscript.exe //Nologo C:\Windows\System32\slmgr.vbs /dlv 2>&1
            $slmgrOutput = $slmgrOutput -join "`n"
        }
        catch {
            $slmgrOutput = "Failed to retrieve slmgr report: $($_.Exception.Message)"
        }

        $result = [pscustomobject]@{
            ComputerName     = $ComputerName
            OemProductKey    = $oemKey
            PartialKeys      = $partialKeys
            ActivationReport = $slmgrOutput
        }
    }
    else {
        # --- REMOTE PATH (new engine) ---
        $moduleRoot = Get-ModuleRoot
        $workerLocal = Join-Path $moduleRoot 'Workers\Get-WindowsProductKey.worker.ps1'
        $workerRemote = 'C:\TechToolbox\Workers\Get-WindowsProductKey.worker.ps1'

        # No helpers needed right now
        $pkg = New-HelpersPackage -HelperFiles @()

        $session = $null
        try {
            $session = Start-NewPSRemoteSession -ComputerName $ComputerName -Credential $Credential

            $result = Invoke-RemoteWorker `
                -Session $session `
                -HelpersZip $pkg.ZipPath `
                -HelpersZipHash $pkg.ZipHash `
                -WorkerRemotePath $workerRemote `
                -WorkerLocalPath $workerLocal `
                -EntryPoint 'Get-WindowsProductKeyCore'
        }
        catch {
            Write-Error ("Get-WindowsProductKey: remote execution failed on {0}: {1}" -f $ComputerName, $_.Exception.Message)
            return
        }
        finally {
            if ($session) { Remove-PSSession -Session $session -ErrorAction SilentlyContinue }
        }
    }

    # --- Export log (same for local/remote) ---
    $timestamp = (Get-Date).ToString('yyyyMMdd-HHmmss')
    $fileName = $script:cfg.settings.windowsActivation.fileNameFormat
    $fileName = $fileName -replace '{computer}', $result.ComputerName
    $fileName = $fileName -replace '{yyyyMMdd-HHmmss}', $timestamp
    $exportPath = Join-Path $exportRoot $fileName

    $logContent = @()
    $logContent += "Computer Name: $($result.ComputerName)"
    $logContent += "OEM Product Key: $($result.OemProductKey)"
    $logContent += ""
    $logContent += "=== Partial Keys ==="

    if ($result.PartialKeys) {
        foreach ($item in $result.PartialKeys) {
            $logContent += "Name: $($item.Name)"
            $logContent += "Description: $($item.Description)"
            $logContent += "LicenseStatus: $($item.LicenseStatus)"
            $logContent += "PartialProductKey: $($item.PartialProductKey)"
            $logContent += ""
        }
    }
    else {
        $logContent += "None found."
    }

    $logContent += ""
    $logContent += "=== SLMGR /DLV Output ==="
    $logContent += $result.ActivationReport

    $logContent | Out-File -FilePath $exportPath -Encoding UTF8
    Write-Host "Windows activation info exported to: $exportPath"

    $result
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Public\Invoke\Enable-NetFx3.ps1
function Enable-NetFx3 {
    <#
    .SYNOPSIS
    Enables .NET Framework 3.5 (NetFx3) on local or remote computers.

    .DESCRIPTION
    This function enables the .NET Framework 3.5 optional feature using either
    Enable-WindowsOptionalFeature or DISM with timeout support.

    .PARAMETER ComputerName
    Target computer(s) for remote enablement.

    .PARAMETER Credential
    Credentials for remote sessions.

    .PARAMETER Source
    Source path for feature files (UNC path recommended for remote).

    .PARAMETER Quiet
    Suppresses restart prompts.

    .PARAMETER NoRestart
    Prevents automatic restart.

    .PARAMETER TimeoutMinutes
    Timeout for DISM operation in minutes. Default is 45.

    .PARAMETER Validate
    Validates feature enablement after operation.
    #>
    [CmdletBinding()]
    param(
        [string[]]$ComputerName,
        [System.Management.Automation.PSCredential]$Credential,
        [string]$Source,
        [switch]$Quiet,
        [switch]$NoRestart,
        [int]$TimeoutMinutes = 45,
        [switch]$Validate
    )

    Initialize-TechToolboxRuntime

    # ----------------------------
    # Remote mode
    # ----------------------------
    if ($ComputerName -and $ComputerName.Count -gt 0) {
        if (-not $Credential -and $script:domainAdminCred) {
            $Credential = $script:domainAdminCred
            Write-Log -Level 'Debug' -Message "[Enable-NetFx3] Using module domainAdminCred for remoting."
        }

        if ($Source -and -not ($Source.StartsWith('\\'))) {
            Write-Log -Level 'Warn' -Message "[Enable-NetFx3] -Source '$Source' is not a UNC path. Ensure it exists on EACH target."
        }

        Write-Log -Level 'Info' -Message "[Enable-NetFx3] Remote mode  targets: $($ComputerName -join ', ')"

        $moduleRoot = Get-ModuleRoot
        $workerLocal = Join-Path $moduleRoot 'Workers\Enable-NetFx3.worker.ps1'
        $workerRemote = 'C:\TechToolbox\Workers\Enable-NetFx3.worker.ps1'

        $pkg = New-HelpersPackage -HelperFiles @()

        $results = @()

        foreach ($cn in $ComputerName) {
            $session = $null
            try {
                $session = Start-NewPSRemoteSession -ComputerName $cn -Credential $Credential

                $r = Invoke-RemoteWorker `
                    -Session $session `
                    -HelpersZip $pkg.ZipPath `
                    -HelpersZipHash $pkg.ZipHash `
                    -WorkerRemotePath $workerRemote `
                    -WorkerLocalPath $workerLocal `
                    -EntryPoint 'Enable-NetFx3Core' `
                    -EntryParameters @{
                    Source         = $Source
                    TimeoutMinutes = $TimeoutMinutes
                    Validate       = $Validate
                    NoRestart      = $NoRestart
                    Quiet          = $Quiet
                }

                if ($r) { $results += $r }
            }
            catch {
                $results += [pscustomobject]@{
                    ComputerName   = $cn
                    ExitCode       = 1
                    Success        = $false
                    RebootRequired = $false
                    State          = $null
                    Message        = $_.Exception.Message
                }
            }
            finally {
                if ($session) { Remove-PSSession -Session $session -ErrorAction SilentlyContinue }
            }
        }

        foreach ($r in $results) {
            if ($r.Success) {
                if ($r.RebootRequired) {
                    Write-Log -Level 'Warn' -Message "[Enable-NetFx3][$($r.ComputerName)] Success (reboot required)."
                }
                else {
                    Write-Log -Level 'Ok' -Message "[Enable-NetFx3][$($r.ComputerName)] Success."
                }
            }
            else {
                $tail = if ($r.Message) { " - $($r.Message)" } else { "" }
                Write-Log -Level 'Error' -Message "[Enable-NetFx3][$($r.ComputerName)] Failed (Exit $($r.ExitCode))$tail"
            }
        }

        return $results
    }

    # ----------------------------
    # Local mode (no engine)
    # ----------------------------
    Write-Log -Level 'Info' -Message "[Enable-NetFx3] Starting enablement (local)."

    $params = @{
        Online      = $true
        FeatureName = 'NetFx3'
        All         = $true
    }
    if ($PSBoundParameters.ContainsKey('Source') -and $Source) {
        $params.Source = $Source
        $params.LimitAccess = $true
    }
    if ($Quiet) { $params.NoRestart = $true }
    if ($NoRestart) { $params.NoRestart = $true }

    $useDirectDism = ($TimeoutMinutes -gt 0)
    Write-Log -Level 'Info'  -Message "[Enable-NetFx3] Enabling .NET Framework 3.5 (NetFx3)..."
    Write-Log -Level 'Debug' -Message ("[Enable-NetFx3] Using {0} path." -f ($(if ($useDirectDism) { 'DISM (timeout)' } else { 'Enable-WindowsOptionalFeature' })))

    $overallSuccess = $false
    $dismExit = $null
    $state = $null
    $msg = $null

    try {
        if (-not $useDirectDism) {
            $result = Enable-WindowsOptionalFeature @params -ErrorAction Stop
            Write-Log -Level 'Ok' -Message "[Enable-NetFx3] State: $($result.State)"
            $overallSuccess = $true
            $state = $result.State
        }
        else {
            $argsList = @(
                '/online', '/enable-feature', '/featurename:NetFx3', '/All'
            )
            if ($Quiet) { $argsList += '/Quiet' }
            if ($NoRestart) { $argsList += '/NoRestart' }

            if ($params.ContainsKey('Source')) {
                $argsList += "/Source:`"$($params.Source)`""
                $argsList += '/LimitAccess'
            }

            $psi = New-Object System.Diagnostics.ProcessStartInfo
            $psi.FileName = 'dism.exe'
            $psi.Arguments = ($argsList -join ' ')
            $psi.UseShellExecute = $false
            $psi.RedirectStandardOutput = $true
            $psi.RedirectStandardError = $true

            $proc = New-Object System.Diagnostics.Process
            $proc.StartInfo = $psi

            if (-not $proc.Start()) {
                Write-Log -Level 'Error' -Message "[Enable-NetFx3] Failed to start DISM."
                $msg = "Failed to start DISM."
                $overallSuccess = $false
            }
            else {
                $proc.add_OutputDataReceived({ param($s, $e) if ($e.Data) { Write-Log -Level 'Info' -Message $e.Data } })
                $proc.add_ErrorDataReceived( { param($s, $e) if ($e.Data) { Write-Log -Level 'Warn' -Message $e.Data } })
                $proc.BeginOutputReadLine()
                $proc.BeginErrorReadLine()

                $timeoutMs = [int][TimeSpan]::FromMinutes($TimeoutMinutes).TotalMilliseconds
                if (-not $proc.WaitForExit($timeoutMs)) {
                    Write-Log -Level 'Error' -Message "[Enable-NetFx3] Timeout after $TimeoutMinutes minutes. Attempting to terminate DISM..."
                    try { $proc.Kill() } catch {}
                    $overallSuccess = $false
                    $msg = "Timeout after $TimeoutMinutes minutes."
                }
                else {
                    $dismExit = $proc.ExitCode
                    Write-Log -Level 'Debug' -Message "[Enable-NetFx3] DISM exit code: $dismExit"

                    if ($dismExit -in 0, 3010) {
                        $overallSuccess = $true
                        if ($dismExit -eq 3010) {
                            Write-Log -Level 'Warn' -Message "[Enable-NetFx3] Reboot required to complete NetFx3 enablement."
                        }
                    }
                    else {
                        Write-Log -Level 'Error' -Message "[Enable-NetFx3] DISM reported failure."
                        $overallSuccess = $false
                        $msg = "DISM failed with exit code $dismExit."
                    }
                }
            }
        }
    }
    catch {
        Write-Log -Level 'Error' -Message "[Enable-NetFx3] Failed: $($_.Exception.Message)"
        $overallSuccess = $false
        $msg = $_.Exception.Message
    }

    if ($overallSuccess -and $Validate) {
        try {
            $state = (Get-WindowsOptionalFeature -Online -FeatureName NetFx3).State
            Write-Log -Level 'Info' -Message "[Enable-NetFx3] Feature state: $state"
            if ($state -in 'Enabled', 'EnablePending', 'EnabledPending') {
                Write-Log -Level 'Ok' -Message "[Enable-NetFx3] NetFx3 enablement validated."
            }
            else {
                Write-Log -Level 'Error' -Message "[Enable-NetFx3] NetFx3 state not enabled after operation."
                $overallSuccess = $false
            }
        }
        catch {
            Write-Log -Level 'Warn' -Message "[Enable-NetFx3] Validation skipped: $($_.Exception.Message)"
        }
    }

    $exitCode = if ($overallSuccess) { if ($dismExit) { $dismExit } else { 0 } } else { 1 }

    [pscustomobject]@{
        ComputerName   = $env:COMPUTERNAME
        ExitCode       = $exitCode
        Success        = [bool]$overallSuccess
        RebootRequired = ($exitCode -eq 3010)
        State          = $state
        Message        = $msg
    }
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Public\Invoke\Invoke-AADSyncRemote.ps1

function Invoke-AADSyncRemote {
    <#
    .SYNOPSIS
        Remotely triggers Azure AD Connect (ADSync) sync cycle (Delta/Initial)
        on a target server via PSRemoting.
    .DESCRIPTION
        Creates a remote PSSession (Kerberos or credential-based) to the AAD
        Connect host, validates ADSync module/service, and triggers
        Start-ADSyncSyncCycle. Uses TechToolbox config for defaults and
        Write-Log for unified logging.
    .PARAMETER ComputerName
        FQDN/hostname of AAD Connect server.
    .PARAMETER PolicyType
        Sync policy type: Delta or Initial. Default pulled from config
        (AADSync.DefaultPolicyType).
    .PARAMETER Port
        WinRM port: 5985 (HTTP) or 5986 (HTTPS). Default pulled from config
        (AADSync.DefaultPort).
    .PARAMETER Credential
        PSCredential for remote connection. If not supplied, Kerberos auth
        is used.
    .INPUTS
        None. You cannot pipe objects to Invoke-AADSyncRemote.
    .OUTPUTS
        None. Output is written to the Information stream.
    .EXAMPLE
        Invoke-AADSyncRemote -ComputerName aadconnect01 -PolicyType Delta
    .EXAMPLE
        Invoke-AADSyncRemote -ComputerName aadconnect01 -PolicyType Initial -UseKerberos -WhatIf
    .LINK
        [TechToolbox](https://github.com/dan-damit/TechToolbox)
    #>
    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Medium')]
    param(
        [Parameter()] [string]$ComputerName,
        [Parameter()] [ValidateSet('Delta', 'Initial')] [string]$PolicyType,
        [Parameter()] [ValidateSet(5985, 5986)] [int]$Port,
        [Parameter()] [pscredential]$Credential
    )

    # --- Config & defaults ---
    Initialize-TechToolboxRuntime

    $aadSync = $script:cfg.settings.aadSync
    $defaults = $script:cfg.settings.defaults

    # PolicyType (parameter > config > fallback)
    if (-not $PSBoundParameters.ContainsKey('PolicyType') -or [string]::IsNullOrWhiteSpace($PolicyType)) {
        $PolicyType = $aadSync.defaultPolicyType
        if ([string]::IsNullOrWhiteSpace($PolicyType)) { $PolicyType = 'Delta' }
    }

    # Port (parameter > config > fallback)
    if (-not $PSBoundParameters.ContainsKey('Port') -or $Port -eq 0) {
        $Port = [int]$aadSync.defaultPort
        if ($Port -eq 0) { $Port = 5985 }
    }

    # Prompt for hostname if missing
    if ([string]::IsNullOrWhiteSpace($ComputerName)) {
        $shouldPromptHost = $defaults.promptForHostname
        if ($null -eq $shouldPromptHost) { $shouldPromptHost = $true }

        if ($shouldPromptHost) {
            $ComputerName = Read-Host -Prompt 'Enter the FQDN or hostname of the AAD Connect server'
        }
        else {
            throw "ComputerName is required and prompting is disabled by config."
        }
    }
    $ComputerName = $ComputerName.Trim()

    # --- Connect session (credential-based only) ---
    $session = $null
    try {
        Write-Log -Level Info -Message ("Creating remote session to {0} on port {1} ..." -f $ComputerName, $Port)

        $session = New-PSSession -ComputerName $ComputerName `
            -Port $Port `
            -UseSSL:($Port -eq 5986) `
            -Credential $Credential `
            -Authentication Default `
            -ErrorAction Stop

        Write-Log -Level Ok -Message "Session established using supplied credentials."
    }
    catch {
        Write-Log -Level Error -Message ("Failed to create remote session: {0}" -f $_.Exception.Message)
        return
    }

    # --- Remote check + sync trigger ---
    try {
        Write-Log -Level Info -Message ("Checking ADSync module and service state on {0} ..." -f $ComputerName)

        $precheck = Test-AADSyncRemote -Session $session
        if ($precheck.Status -eq 'PreCheckFailed') {
            Write-Log -Level Error -Message ("Remote pre-checks failed: {0}" -f $precheck.Errors)
            return
        }

        $result = Invoke-RemoteADSyncCycle -Session $session -PolicyType $PolicyType -WhatIf:$WhatIfPreference -Confirm:$false
        Write-Log -Level Ok -Message ("Sync ({0}) triggered successfully on {1}." -f $PolicyType, $ComputerName)

        # Pretty table to Information stream
        $table = $result | Format-Table ComputerName, PolicyType, Status, Errors -AutoSize | Out-String
        Write-Information $table
    }
    catch {
        Write-Log -Level Error -Message ("Unhandled error: {0}" -f $_.Exception.Message)
        throw
    }
    finally {
        if ($session) {
            Remove-PSSession -Session $session -ErrorAction SilentlyContinue
            Write-Log -Level Info -Message "Remote session closed."
        }
    }
}
[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Public\Invoke\Invoke-DownloadsCleanup.ps1
function Invoke-DownloadsCleanup {
    <#
    .SYNOPSIS
    Cleans up old files from the Downloads folder.

    .DESCRIPTION
    Removes files older than the specified cutoff year from user Downloads
    directories, either locally or on a remote computer.

    .PARAMETER ComputerName
    The name of the remote computer to clean up. If not specified, cleanup runs
    locally.

    .PARAMETER CutoffYear
    The year threshold for file deletion. Files older than this year will be
    removed.

    .PARAMETER Local
    Switch to force local cleanup even if ComputerName is specified.

    .EXAMPLE
    Invoke-DownloadsCleanup -Local
    Invoke-DownloadsCleanup -ComputerName "SERVER01" -CutoffYear 2020
    #>
    [CmdletBinding(SupportsShouldProcess)]
    param(
        [Parameter()][string]$ComputerName,
        [Parameter()][int]$CutoffYear,
        [switch]$Local
    )

    Initialize-TechToolboxRuntime

    $dlCfg = $script:cfg.settings.downloadsCleanup
    if (-not $CutoffYear) { $CutoffYear = $dlCfg.cutoffYear }
    $dryRun = $dlCfg.dryRun

    # 
    # LOCAL MODE
    # 
    if ($Local -or (-not $ComputerName)) {
        Write-Log -Level Info -Message "Running Downloads cleanup locally."

        $result = Invoke-DownloadsCleanupCore `
            -CutoffYear $CutoffYear `
            -DryRun:$dryRun

        foreach ($entry in $result) {
            if ($entry.Status -eq "OK") {
                Write-Log -Level Ok -Message "[$($entry.User)] Deleted $($entry.Deleted) old files."
            }
            elseif ($entry.Status -like "Failed*") {
                Write-Log -Level Warn -Message "[$($entry.User)] Failed to delete: $($entry.Path)  $($entry.Status)"
            }
            else {
                Write-Log -Level Info -Message "[$($entry.User)] $($entry.Status)"
            }
        }

        Write-Log -Level Ok -Message "Local Downloads cleanup completed."
        return $result
    }

    # 
    # REMOTE MODE (new engine)
    # 

    Write-Log -Level Info -Message "Connecting to $ComputerName..."

    $creds = $null
    if ($script:cfg.settings.defaults.promptForCredentials) {
        $creds = Get-Credential -Message "Enter credentials for $ComputerName"
    }

    $session = $null
    try {
        $session = Start-NewPSRemoteSession -ComputerName $ComputerName -Credential $creds
        Write-Log -Level Ok -Message "Connected to $ComputerName."
    }
    catch {
        Write-Log -Level Error -Message "Failed to create PSSession: $($_.Exception.Message)"
        return
    }

    $moduleRoot = Get-ModuleRoot
    $workerLocal = Join-Path $moduleRoot 'Workers\Invoke-DownloadsCleanup.worker.ps1'
    $workerRemote = 'C:\TechToolbox\Workers\Invoke-DownloadsCleanup.worker.ps1'

    # No helpers needed
    $pkg = New-HelpersPackage -HelperFiles @()

    Write-Log -Level Info -Message "Running Downloads cleanup on $ComputerName..."

    try {
        $result = Invoke-RemoteWorker `
            -Session $session `
            -HelpersZip $pkg.ZipPath `
            -HelpersZipHash $pkg.ZipHash `
            -WorkerRemotePath $workerRemote `
            -WorkerLocalPath $workerLocal `
            -EntryPoint 'Invoke-DownloadsCleanupCore' `
            -EntryParameters @{
            CutoffYear = $CutoffYear
            DryRun     = $dryRun
        }
    }
    catch {
        Write-Log -Level Error -Message "Remote cleanup failed: $($_.Exception.Message)"
        return
    }
    finally {
        if ($session) { Remove-PSSession $session -ErrorAction SilentlyContinue }
    }

    foreach ($entry in $result) {
        if ($entry.Status -eq "OK") {
            Write-Log -Level Ok -Message "[$($entry.User)] Deleted $($entry.Deleted) old files."
        }
        elseif ($entry.Status -like "Failed*") {
            Write-Log -Level Warn -Message "[$($entry.User)] Failed to delete: $($entry.Path)  $($entry.Status)"
        }
        else {
            Write-Log -Level Info -Message "[$($entry.User)] $($entry.Status)"
        }
    }

    Write-Log -Level Ok -Message "Downloads cleanup completed on $ComputerName."
    return $result
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Public\Invoke\Invoke-PurviewPurge.ps1

function Invoke-PurviewPurge {
    <#
    .SYNOPSIS
        End-to-end Purview HardDelete purge workflow: connect, clone search,
        wait, purge, optionally disconnect.
    .DESCRIPTION
        Imports ExchangeOnlineManagement (if needed), connects to Purview with
        SearchOnly session, prompts for any missing inputs (config-driven),
        clones an existing search (mailbox-only), waits for completion, and
        submits a HardDelete purge. Uses Write-Log and supports
        -WhatIf/-Confirm.
    .PARAMETER UserPrincipalName
        The UPN to use for connecting to Purview (Exchange Online).
    .PARAMETER CaseName
        The eDiscovery Case Name/ID containing the Compliance Search to clone.
    .PARAMETER ContentMatchQuery
        The KQL/keyword query to match items to purge (e.g.,
        'from:("*@pm-bounces.broobe.*" OR "*@broobe.*") AND subject:"Aligned
        Assets"'). If omitted, a new mailbox-only search will be created via
        prompted KQL query.
    .PARAMETER Log
        A hashtable of logging configuration options to merge into the module-
        scope logging bag. See Get-TechToolboxConfig "settings.logging" for
        available keys.
    .PARAMETER ShowProgress
        Switch to enable console logging/progress output for this invocation.
    .EXAMPLE
        PS> Invoke-PurviewPurge -UserPrincipalName "user@company.com" `
            -CaseName "Legal Case 123" -ContentMatchQuery 'from:("*@pm-bounces.broobe.*" OR "*@broobe.*") AND subject:"Aligned Assets"'
    #>
    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Medium')]
    param(
        [Parameter(Mandatory = $true)][ValidateNotNullOrEmpty()][string]$UserPrincipalName,
        [Parameter(Mandatory = $true)][ValidateNotNullOrEmpty()][string]$CaseName,

        # The KQL/keyword query to match items to purge (e.g., 'from:("*@pm-bounces.broobe.*" OR "*@broobe.*") AND subject:"Aligned Assets"')
        [Parameter()][ValidateNotNullOrEmpty()][string]$ContentMatchQuery,

        # Optional naming override/prefix; the function will add a timestamp suffix to ensure uniqueness
        [Parameter()][ValidateNotNullOrEmpty()][string]$SearchNamePrefix = "TTX-Purge",

        [Parameter()][hashtable]$Log,
        [switch]$ShowProgress
    )

    # Load dependencies
    Initialize-TechToolboxRuntime

    try {
        # ---- Config & defaults ----
        $purv = $script:cfg.settings.purview
        $defaults = $script:cfg.settings.defaults
        $exo = $script:cfg.settings.exchangeOnline
        $confirm = $purv.purge.requireConfirmation

        # Support both legacy and purge.* keys in config
        $timeoutSeconds = [int]$purv.purge.timeoutSeconds
        if ($timeoutSeconds -le 0) { $timeoutSeconds = 1200 }
        $pollSeconds = [int]$purv.purge.pollSeconds
        if ($pollSeconds -le 0) { $pollSeconds = 5 }

        # Registration wait (configurable)
        $regTimeout = [int]$purv.registrationWaitSeconds
        if ($regTimeout -le 0) { $regTimeout = 90 }
        $regPoll = [int]$purv.registrationPollSeconds
        if ($regPoll -le 0) { $regPoll = 3 }
        
        # ----- Query prompt + validation/normalization -----
        $promptQuery = $defaults.promptForContentMatchQuery ?? $true

        while ($true) {
            if ([string]::IsNullOrWhiteSpace($ContentMatchQuery)) {
                if ($promptQuery) {
                    $ContentMatchQuery = Read-Host 'Enter ContentMatchQuery (e.g., from:("*@pm-bounces.broobe.*" OR "*@broobe.*") AND subject:"Aligned Assets")'
                }
                else {
                    throw "ContentMatchQuery is required but prompting is disabled by config."
                }
            }

            $normRef = [ref] $null
            $isValid = $false
            try {
                $isValid = Test-ContentMatchQuery -Query $ContentMatchQuery -Normalize -NormalizedQuery $normRef
            }
            catch {
                # If the validator ever throws, treat as invalid and re-prompt
                Write-Warning ("Validator error: {0}" -f $_.Exception.Message)
                $ContentMatchQuery = $null
                continue
            }

            if (-not $isValid) {
                Write-Warning "KQL appears invalid (unbalanced quotes/parentheses or unsupported property). Please re-enter."
                $ContentMatchQuery = $null
                continue
            }

            # Valid: commit normalized value (if provided) and break
            if ($normRef.Value) {
                $ContentMatchQuery = $normRef.Value
            }
            Write-Log -Level Info -Message ("Final ContentMatchQuery: {0}" -f $ContentMatchQuery)
            break
        }

        # ---- Module & session ----
        Import-ExchangeOnlineModule -ErrorAction Stop
        Connect-PurviewSearchOnly -UserPrincipalName $UserPrincipalName -ErrorAction Stop
        
        # ---- Build a unique search name ----
        $ts = (Get-Date).ToString("yyyyMMdd-HHmmss")
        $baseName = "{0}-{1}" -f $SearchNamePrefix, $CaseName
        $searchName = "{0}-{1}" -f $baseName, $ts

        Write-Log -Level Info -Message ("Creating mailbox-only Compliance Search '{0}' in case '{1}'..." -f $searchName, $CaseName)
        Write-Log -Level Info -Message "Scope: ExchangeLocation=All"

        # ---- Create the mailbox-only search (ALL mailboxes) ----
        $newParams = @{
            Name              = $searchName
            Case              = $CaseName
            ExchangeLocation  = 'All'
            ContentMatchQuery = $ContentMatchQuery
            # Add other parameters as needed, e.g., Description, etc.
        }

        # Create (respects WhatIf)
        if ($PSCmdlet.ShouldProcess(("Case '{0}'" -f $CaseName), ("Create compliance search '{0}' (mailbox-only / All mailboxes)" -f $searchName))) {
            $null = New-ComplianceSearch @newParams -Confirm:$confirm
            Write-Log -Level Ok -Message ("Search created: {0}" -f $searchName)
        }
        else {
            Write-Log -Level Info -Message "Creation skipped due to -WhatIf/-Confirm."
            return
        }

        # ---- Wait until the search object is registered/visible ----
        Write-Log -Level Info -Message ("Waiting for search '{0}' to register (timeout={1}s, poll={2}s)..." -f $searchName, $regTimeout, $regPoll)
        $registered = Wait-ComplianceSearchRegistration -SearchName $searchName -TimeoutSeconds $regTimeout -PollSeconds $regPoll
        if (-not $registered) {
            throw "Search object '$searchName' was not visible after creation (waited ${regTimeout}s). Aborting."
        }

        # ---- Start the search after registration ----
        if ($PSCmdlet.ShouldProcess(("Search '{0}'" -f $searchName), 'Start compliance search')) {
            Start-ComplianceSearch -Identity $searchName
            Write-Log -Level Info -Message ("Search started: {0}" -f $searchName)
        }
        else {
            Write-Log -Level Info -Message "Start skipped due to -WhatIf/-Confirm."
            return
        }

        # ---- Wait until completion ----
        Write-Log -Level Info -Message ("Waiting for search '{0}' to complete (timeout={1}s, poll={2}s)..." -f $searchName, $timeoutSeconds, $pollSeconds)
        $searchObj = Wait-SearchCompletion -SearchName $searchName -CaseName $CaseName -TimeoutSeconds $timeoutSeconds -PollSeconds $pollSeconds -ErrorAction Stop

        if ($null -eq $searchObj) { throw "Search object not returned for '$searchName' (case '$CaseName')." }
        Write-Log -Level Ok -Message ("Search status: {0}; Items: {1}" -f $searchObj.Status, $searchObj.Items)

        if ($searchObj.Items -le 0) {
            throw "Search '$searchName' returned 0 mailbox items. Purge aborted."
        }

        # ---- Purge (HardDelete) ----
        if ($PSCmdlet.ShouldProcess(("Case '{0}' Search '{1}'" -f $CaseName, $searchName), 'Submit Purview HardDelete purge')) {
            $null = Invoke-HardDelete -SearchName $searchName -CaseName $CaseName -Confirm:$confirm -ErrorAction Stop
            Write-Log -Level Ok -Message ("[Done] Purview HardDelete purge submitted for '{0}' in case '{1}'." -f $searchName, $CaseName)
        }
        else {
            Write-Log -Level Info -Message "Purge submission skipped due to -WhatIf/-Confirm."
        }

        # ---- Summary ----
        Write-Log -Level Ok -Message ("Summary: search='{0}' status='{1}' items={2} purgeSubmitted={3}" -f $searchName, $searchObj.Status, $searchObj.Items, $true)
    }
    catch {
        Write-Error ("[ERROR] {0}" -f $_.Exception.Message)
        if ($script:log["enableConsole"]) {
            Write-Log -Level Error -Message ("[ERROR] {0}" -f $_.Exception.Message)
        }
        throw
    }
    finally {
        [void](Invoke-DisconnectExchangeOnline -ExchangeOnline $exo)
    }
}
[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Public\Invoke\Invoke-SubnetScan.ps1
function Invoke-SubnetScan {
    <#
    .SYNOPSIS
    Performs a subnet scan to discover hosts and gather network information.

    .DESCRIPTION
    Scans a subnet (specified in CIDR notation) to identify active hosts,
    retrieve MAC addresses, resolve DNS names, check TCP ports, and optionally
    fetch HTTP banner information. Can execute locally or on a remote computer
    via WSMan or SSH.

    .PARAMETER CIDR
    The subnet to scan in CIDR notation (e.g., '192.168.1.0/24').

    .PARAMETER ComputerName
    Remote computer on which to execute the scan. If not specified, the scan
    runs locally.

    .PARAMETER Transport
    Protocol for remote execution: 'WSMan' or 'SSH'. Default is 'WSMan'.

    .PARAMETER Credential
    PSCredential for remote authentication.

    .PARAMETER UserName
    Username for SSH authentication.

    .PARAMETER KeyFilePath
    Path to SSH private key file.

    .PARAMETER LocalOnly
    Forces local execution even if ComputerName is specified.

    .PARAMETER Port
    TCP port to check for availability. Default is read from config.

    .PARAMETER ResolveNames
    Attempts to resolve hostnames via DNS, NetBIOS, and mDNS.

    .PARAMETER HttpBanner
    Retrieves HTTP Server headers from discovered hosts.

    .PARAMETER ExportCsv
    Exports results to a CSV file.

    .PARAMETER ExportTarget
    Location to export results: 'Local' or 'Remote'. Default is 'Local'.

    .EXAMPLE
    Invoke-SubnetScan -CIDR "192.168.1.0/24" -Port 80 -ResolveNames -ExportCsv

    .EXAMPLE
    Invoke-SubnetScan -CIDR "10.0.0.0/25" -ComputerName "RemoteHost" -Transport WSMan -Credential $cred
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$CIDR,

        # Remote options
        [string]$ComputerName,
        [ValidateSet('WSMan', 'SSH')]
        [string]$Transport = 'WSMan',
        [pscredential]$Credential,
        [string]$UserName,
        [string]$KeyFilePath,
        [switch]$LocalOnly,

        # Scan behavior
        [int]$Port,
        [switch]$ResolveNames,
        [switch]$HttpBanner,

        # Export control
        [switch]$ExportCsv,
        [ValidateSet('Local', 'Remote')]
        [string]$ExportTarget = 'Local'
    )

    Initialize-TechToolboxRuntime
    $oldEAP = $ErrorActionPreference

    try {
        # --- CONFIG & DEFAULTS ---
        $cfg = $script:cfg
        if (-not $cfg) { throw "TechToolbox config is null/empty. Ensure Config\config.json exists and is valid JSON." }

        $scanCfg = $cfg.settings.subnetScan
        if (-not $scanCfg) { throw "Config missing 'settings.subnetScan'." }

        if (-not $PSBoundParameters.ContainsKey('Port')) { $Port = $scanCfg.defaultPort ?? 80 }
        if (-not $PSBoundParameters.ContainsKey('ResolveNames')) { $ResolveNames = [bool]($scanCfg.resolveNames ?? $false) }
        if (-not $PSBoundParameters.ContainsKey('HttpBanner')) { $HttpBanner = [bool]($scanCfg.httpBanner ?? $false) }
        if (-not $PSBoundParameters.ContainsKey('ExportCsv')) { $ExportCsv = [bool]($scanCfg.exportCsv ?? $false) }

        $localExportDir = $scanCfg.exportDir
        if ($ExportCsv -and $ExportTarget -eq 'Local') {
            if (-not $localExportDir) { throw "Config 'settings.subnetScan.exportDir' is missing." }
            if (-not (Test-Path -LiteralPath $localExportDir)) {
                New-Item -ItemType Directory -Path $localExportDir -Force | Out-Null
            }
        }

        Write-Log -Level Info -Message ("SubnetScan: CIDR={0} Port={1} ResolveNames={2} HttpBanner={3} ExportCsv={4} Target={5}" -f `
                $CIDR, $Port, $ResolveNames, $HttpBanner, $ExportCsv, $ExportTarget)

        $runLocal = $LocalOnly -or (-not $ComputerName)
        $results = $null

        # --- LOCAL MODE ---
        if ($runLocal) {
            Write-Log -Level Info -Message "Executing subnet scan locally."

            $doRemoteExport = $false
            $results = Invoke-SubnetScanLocal `
                -CIDR $CIDR `
                -Port $Port `
                -ResolveNames:$ResolveNames `
                -HttpBanner:$HttpBanner `
                -ExportCsv:$doRemoteExport
        }
        else {
            Write-Log -Level Info -Message "Executing subnet scan on remote host: $ComputerName via $Transport"

            # --- Build session (reuse your existing transport logic) ---
            $session = $null
            try {
                if ($Transport -eq 'WSMan') {
                    $session = Start-NewPSRemoteSession -ComputerName $ComputerName -Credential $Credential
                }
                else {
                    if (-not $UserName -and $Credential) { $UserName = $Credential.UserName }
                    if (-not $UserName) { throw "For SSH transport, specify -UserName or -Credential." }

                    $sshParams = @{ HostName = $ComputerName; UserName = $UserName; ErrorAction = 'Stop' }
                    if ($KeyFilePath) { $sshParams['KeyFilePath'] = $KeyFilePath }
                    elseif ($Credential) { $sshParams['Password'] = $Credential.GetNetworkCredential().Password }

                    $session = New-PSSession @sshParams
                    Write-Log -Level Ok -Message "Connected to $ComputerName (SSH)."
                }
            }
            catch {
                Write-Log -Level Error -Message "Failed to create PSSession: $($_.Exception.Message)"
                return
            }

            try {
                $moduleRoot = Get-ModuleRoot
                $workerLocal = Join-Path $moduleRoot 'Workers\SubnetScan.worker.ps1'
                $workerRemote = 'C:\TechToolbox\Workers\SubnetScan.worker.ps1'

                # Helpers required by Invoke-SubnetScanLocal + its dependencies
                $helperFiles = @(
                    (Join-Path $moduleRoot 'Private\Network\SubnetScan\Invoke-SubnetScanLocal.ps1')
                    (Join-Path $moduleRoot 'Private\Network\SubnetScan\Get-IPsFromCIDR.ps1')
                    (Join-Path $moduleRoot 'Private\Network\SubnetScan\Get-MacAddress.ps1')
                    (Join-Path $moduleRoot 'Private\Network\SubnetScan\Get-ReverseDns.ps1')
                    (Join-Path $moduleRoot 'Private\Network\SubnetScan\Get-NetbiosName.ps1')
                    (Join-Path $moduleRoot 'Private\Network\SubnetScan\Get-MdnsName.ps1')
                    (Join-Path $moduleRoot 'Private\Network\SubnetScan\Test-TcpPort.ps1')
                    (Join-Path $moduleRoot 'Private\Network\SubnetScan\Get-HttpInfo.ps1')
                    (Join-Path $moduleRoot 'Private\Network\SubnetScan\Show-ProgressBanner.ps1')
                )

                $pkg = New-HelpersPackage -HelperFiles $helperFiles

                $remoteExportDir = $null
                $doRemoteExport = $ExportCsv -and ($ExportTarget -eq 'Remote')
                if ($doRemoteExport) {
                    $remoteExportDir = $scanCfg.exportDir
                    if (-not $remoteExportDir) {
                        throw "Config 'settings.subnetScan.exportDir' is missing; required for remote export."
                    }
                }

                $results = Invoke-RemoteWorker `
                    -Session $session `
                    -HelpersZip $pkg.ZipPath `
                    -HelpersZipHash $pkg.ZipHash `
                    -WorkerRemotePath $workerRemote `
                    -WorkerLocalPath $workerLocal `
                    -EntryPoint 'Invoke-SubnetScanCore' `
                    -EntryParameters @{
                    CIDR         = $CIDR
                    Port         = $Port
                    ResolveNames = $ResolveNames
                    HttpBanner   = $HttpBanner
                    ExportCsv    = ($ExportCsv -and $ExportTarget -eq 'Remote')
                }
            }
            catch {
                Write-Log -Level Error -Message "Remote scan failed: $($_.Exception.Message)"
                return
            }
            finally {
                if ($session) { Remove-PSSession $session -ErrorAction SilentlyContinue }
            }
        }

        # --- Local export (if requested) ---
        if ($ExportCsv -and $ExportTarget -eq 'Local' -and $results) {
            try {
                $cidrSafe = $CIDR -replace '[^\w\-\.]', '_'
                $csvPath = Join-Path $localExportDir ("subnet-scan-{0}-{1}.csv" -f $cidrSafe, (Get-Date -Format 'yyyyMMdd-HHmmss'))
                $results | Export-Csv -Path $csvPath -NoTypeInformation -Encoding UTF8 -Force
                Write-Log -Level Ok -Message "Results exported to $csvPath"
            }
            catch {
                Write-Log -Level Error -Message "Failed to export CSV: $($_.Exception.Message)"
            }
        }

        if ($results) {
            Write-Host "Discovered hosts:" -ForegroundColor DarkYellow
            $results |
            Select-Object IP, RTTms, MacAddress, NetBIOS, PTR, Mdns, PortOpen, ServerHdr |
            Format-Table -AutoSize
        }

        return $results
    }
    finally {
        $ErrorActionPreference = $oldEAP
    }
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Public\Invoke\Invoke-SystemRepair.ps1
function Invoke-SystemRepair {
    <#
    .SYNOPSIS
    Invokes system repair operations on a local or remote computer.

    .DESCRIPTION
    Performs various system repair operations including DISM RestoreHealth,
    StartComponentCleanup, ResetBase, SFC /scannow, and Windows Update component
    reset.

    .PARAMETER RestoreHealth
    Run DISM RestoreHealth operation.

    .PARAMETER StartComponentCleanup
    Run DISM StartComponentCleanup operation.

    .PARAMETER ResetBase
    Run DISM ResetBase operation.

    .PARAMETER SfcScannow
    Run SFC /scannow operation.

    .PARAMETER ResetUpdateComponents
    Reset Windows Update components.

    .PARAMETER ComputerName
    Target computer name for remote execution.

    .PARAMETER Local
    Run operations locally instead of remotely.

    .PARAMETER Credential
    Credentials for remote session.
    #>
    [CmdletBinding(SupportsShouldProcess = $true)]
    param(
        [switch]$RestoreHealth,
        [switch]$StartComponentCleanup,
        [switch]$ResetBase,
        [switch]$SfcScannow,
        [switch]$ResetUpdateComponents,
        [string]$ComputerName,
        [switch]$Local,
        [pscredential]$Credential
    )

    if (-not ($RestoreHealth -or $StartComponentCleanup -or $ResetBase -or $SfcScannow -or $ResetUpdateComponents)) {
        Write-Log -Level Warn -Message "No operations specified. Choose at least one operation to run."
        return
    }

    Initialize-TechToolboxRuntime

    $repair = $script:cfg.settings.systemRepair
    $runRemoteDefault = $repair.runRemote ?? $true

    $targetComputer = $ComputerName
    if (-not $Local) {
        if (-not $targetComputer -and $repair.ContainsKey("defaultComputerName")) {
            $targetComputer = $repair["defaultComputerName"]
        }
    }

    $runRemoteEffective =
    -not $Local -and
    -not [string]::IsNullOrWhiteSpace($targetComputer) -and
    $runRemoteDefault

    $targetLabel = if ($runRemoteEffective) { "remote host $targetComputer" } else { "local machine" }

    Write-Log -Level Info -Message ("Preparing system repair operations on {0}." -f $targetLabel)

    $ops = @()
    if ($RestoreHealth) { $ops += "DISM RestoreHealth" }
    if ($StartComponentCleanup) { $ops += "DISM StartComponentCleanup" }
    if ($ResetBase) { $ops += "DISM ResetBase" }
    if ($SfcScannow) { $ops += "SFC /scannow" }
    if ($ResetUpdateComponents) { $ops += "Reset Windows Update Components" }

    $operationDesc = $ops -join ", "

    if (-not $PSCmdlet.ShouldProcess($targetLabel, "Run: $operationDesc")) { return }

    if ($runRemoteEffective) {
        Write-Log -Level Info -Message ("Executing repair operations remotely on [{0}]." -f $targetComputer)

        $moduleRoot = Get-ModuleRoot
        $workerLocal = Join-Path $moduleRoot 'Workers\Invoke-SystemRepair.Worker.ps1'
        $workerRemote = 'C:\TechToolbox\Workers\Invoke-SystemRepair.Worker.ps1'

        # build helper list
        $helperFiles = @()
        if ($ResetUpdateComponents) {
            # If this is a helper (not the worker), ensure the path and casing are correct and the file exists
            $helperPath = Join-Path $moduleRoot 'Workers\Reset-WindowsUpdateComponents.Worker.ps1'  # adjust if the helper is a different file
            if (Test-Path $helperPath) {
                $helperFiles += $helperPath
            }
            else {
                Write-Log -Level Warn -Message "Expected helper not found at: $helperPath"
            }
        }

        # Only package helpers if we actually have them
        $pkg = $null
        if ($helperFiles.Count -gt 0) {
            $pkg = New-HelpersPackage -HelperFiles $helperFiles
        }

        $session = $null
        try {
            $session = Start-NewPSRemoteSession -ComputerName $targetComputer -Credential $Credential

            $result = Invoke-RemoteWorker `
                -Session $session `
                -HelpersZip ($pkg?.ZipPath) `
                -HelpersZipHash ($pkg?.ZipHash) `
                -WorkerRemotePath $workerRemote `
                -WorkerLocalPath $workerLocal `
                -EntryPoint 'Invoke-SystemRepairCore' `
                -EntryParameters @{
                RestoreHealth         = $RestoreHealth
                StartComponentCleanup = $StartComponentCleanup
                ResetBase             = $ResetBase
                SfcScannow            = $SfcScannow
                ResetUpdateComponents = $ResetUpdateComponents
            }
        }
        catch {
            Write-Log -Level Error -Message ("Invoke-SystemRepair remote failed on {0}: {1}" -f $targetComputer, $_.Exception.Message)
            return
        }
        finally {
            if ($session) { Remove-PSSession -Session $session -ErrorAction SilentlyContinue }
        }

        Write-Log -Level Ok -Message ("System repair operations completed on {0}." -f $targetLabel)
        return $result
    }
    else {
        Write-Log -Level Info -Message "Executing repair operations locally."

        Invoke-SystemRepairLocal `
            -RestoreHealth:$RestoreHealth `
            -StartComponentCleanup:$StartComponentCleanup `
            -ResetBase:$ResetBase `
            -SfcScannow:$SfcScannow `
            -ResetUpdateComponents:$ResetUpdateComponents

        Write-Log -Level Ok -Message ("System repair operations completed on {0}." -f $targetLabel)
    }
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Public\Set\Set-EmailAlias.ps1
function Set-EmailAlias {
    <#
    .SYNOPSIS
        Safely sets, removes, or promotes an SMTP alias on an on-prem AD user.

    .DESCRIPTION
        Adds an SMTP proxy address (secondary) or promotes one to primary. Ensures
        exactly one primary (uppercase 'SMTP:') exists after changes, prevents
        duplicates, validates email format and allowed domains, and avoids
        collisions with other AD objects. Idempotent: no change -> no write.

    .PARAMETER Identity
        User identity (samAccountName, DN, GUID, or UPN).

    .PARAMETER EmailAlias
        The SMTP alias to add or make primary (e.g., jane.doe@vadtek.com).

    .PARAMETER MakePrimary
        If specified, ensures EmailAlias is the *primary* (uppercase 'SMTP:').

    .PARAMETER Remove
        If specified, removes EmailAlias from proxyAddresses.

    .PARAMETER AllowedDomains
        Optional whitelist of domains permitted for aliases.

    .PARAMETER FailIfInUse
        If specified (default: $true), fails when EmailAlias already exists on a
        different AD object.

    .PARAMETER Credential
        PSCredential to run AD queries and updates under (e.g., your domain admin
        credential).

    .PARAMETER Server
        Optional Domain Controller to target (FQDN or hostname). Useful with
        -Credential to avoid referrals.

    .EXAMPLE
        # Prompt for domain admin and add secondary alias
        $cred = Get-Credential
        Set-EmailAlias -Identity jdoe -EmailAlias john.doe@ltlsupply.com -Credential $cred

    .EXAMPLE
        # Promote to primary with explicit DC
        Set-EmailAlias -Identity jdoe -EmailAlias john.doe@vadtek.com -MakePrimary -Credential $cred -Server 'dc01.vadtek.com'
    #>

    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Medium')]
    param(
        [Parameter(Mandatory)]
        [string]$Identity,

        [Parameter(Mandatory)]
        [string]$EmailAlias,

        [Parameter()]
        [switch]$MakePrimary,

        [Parameter()]
        [switch]$Remove,

        [Parameter()]
        [string[]]$AllowedDomains,

        [Parameter()]
        [bool]$FailIfInUse = $true,

        [Parameter()]
        [System.Management.Automation.PSCredential]$Credential,

        [Parameter()]
        [string]$Server
    )

    # --- Runtime & modules ----------------------------------------------------
    Initialize-TechToolboxRuntime
    Import-Module ActiveDirectory -ErrorAction Stop

    # Build a common splat for AD cmdlets
    $adSplat = @{}
    if ($PSBoundParameters.ContainsKey('Credential')) { $adSplat.Credential = $Credential }
    if ($PSBoundParameters.ContainsKey('Server')) { $adSplat.Server = $Server }

    # --- Helpers --------------------------------------------------------------
    function Test-Email {
        param([string]$Address)
        $pattern = '^(?=.{3,254}$)(?!\.)[A-Za-z0-9._%+\''-]+(?<!\.)@[A-Za-z0-9.-]+\.[A-Za-z]{2,63}$'
        return [regex]::IsMatch($Address, $pattern)
    }

    function ConvertTo-LdapFilterEscaped {
        param([Parameter(Mandatory)][string]$Value)
        $sb = New-Object System.Text.StringBuilder
        foreach ($ch in $Value.ToCharArray()) {
            switch ($ch) {
                '\' { [void]$sb.Append('\5c') }
                '*' { [void]$sb.Append('\2a') }
                '(' { [void]$sb.Append('\28') }
                ')' { [void]$sb.Append('\29') }
                { [int]$_ -eq 0 } { [void]$sb.Append('\00') } # NUL
                default { [void]$sb.Append($ch) }
            }
        }
        $sb.ToString()
    }

    try {
        # Normalize and validate input
        $aliasLower = $EmailAlias.Trim().ToLowerInvariant()

        if (-not (Test-Email -Address $aliasLower)) {
            throw "Invalid email address format: '$EmailAlias'"
        }

        $domain = $aliasLower.Split('@')[-1]
        if ($AllowedDomains -and ($AllowedDomains -notcontains $domain)) {
            throw "Domain '$domain' is not in AllowedDomains: $($AllowedDomains -join ', ')"
        }

        # Load the user
        $user = Get-ADUser @adSplat -Identity $Identity -Properties proxyAddresses -ErrorAction Stop
        if ($null -eq $user) { throw "User '$Identity' not found." }

        # Current addresses as a modifiable list (PS5-safe)
        $current = New-Object 'System.Collections.Generic.List[string]'
        if ($user.proxyAddresses) {
            $current.AddRange([string[]]$user.proxyAddresses)
        }

        $secondaryForm = "smtp:$aliasLower"
        $primaryForm = "SMTP:$aliasLower"

        $escapedLower = ConvertTo-LdapFilterEscaped -Value $secondaryForm
        $escapedUpper = ConvertTo-LdapFilterEscaped -Value $primaryForm
        $filter = "(|(proxyAddresses=$escapedLower)(proxyAddresses=$escapedUpper))"

        $collision = Get-ADObject @adSplat -LDAPFilter $filter -Properties proxyAddresses -ErrorAction Stop |
        Where-Object { $_.DistinguishedName -ne $user.DistinguishedName } |
        Select-Object -First 1

        if ($collision -and $FailIfInUse) {
            throw "Alias '$aliasLower' already exists on another object: $($collision.DistinguishedName)"
        }

        # Case-insensitive set for dedupe (PS5-safe constructor taking comparer)
        $newSet = New-Object 'System.Collections.Generic.HashSet[string]' ([System.StringComparer]::OrdinalIgnoreCase)
        foreach ($addr in $current) { [void]$newSet.Add($addr) }

        $changed = $false

        if ($Remove) {
            if ($newSet.Remove($secondaryForm)) { $changed = $true }
            if ($newSet.Remove($primaryForm)) { $changed = $true }

            # If we removed a primary, we do not auto-promote another primary.

        }
        else {
            # Ensure alias exists (at least secondary)
            if (-not $newSet.Contains($secondaryForm) -and -not $newSet.Contains($primaryForm)) {
                [void]$newSet.Add($secondaryForm)
                $changed = $true
            }

            if ($MakePrimary) {
                # Demote any existing primaries
                $primaries = @($newSet | Where-Object { $_ -like 'SMTP:*' })
                foreach ($p in $primaries) {
                    $null = $newSet.Remove($p)
                    $null = $newSet.Add($p.ToLowerInvariant())  # 'smtp:'
                    $changed = $true
                }

                # Promote target
                if ($newSet.Remove($secondaryForm)) { $changed = $true }
                if (-not $newSet.Contains($primaryForm)) {
                    [void]$newSet.Add($primaryForm)
                    $changed = $true
                }
            }
            else {
                # Caller didn't ask to make primary: ensure it's not primary by accident
                if ($newSet.Contains($primaryForm)) {
                    $null = $newSet.Remove($primaryForm)
                    if (-not $newSet.Contains($secondaryForm)) {
                        [void]$newSet.Add($secondaryForm)
                    }
                    $changed = $true
                }
            }
        }

        if (-not $changed) {
            Write-Log -Level INFO -Message "No change needed for '$($user.SamAccountName)'; alias state already compliant."
            return [pscustomobject]@{
                Identity          = $user.SamAccountName
                DistinguishedName = $user.DistinguishedName
                EmailAlias        = $aliasLower
                Action            = if ($Remove) { 'NoOp-Remove' } elseif ($MakePrimary) { 'NoOp-MakePrimary' } else { 'NoOp-Add' }
                Changed           = $false
                ProxyAddresses    = [string[]]$current
            }
        }
        
        $newArray = @()
        foreach ($addr in @($newSet)) { $newArray += [string]$addr }
        $newArray = [string[]]$newArray

        if ($PSCmdlet.ShouldProcess($user.SamAccountName, "Update proxyAddresses (count $($current.Count) -> $($newArray.Count))")) {
            Set-ADUser @adSplat -Identity $user.DistinguishedName -Replace @{ proxyAddresses = $newArray } -ErrorAction Stop
            Write-Log -Level OK -Message ("Updated proxyAddresses for '{0}': {1}" -f $user.SamAccountName, ($newArray -join '; '))
        }

        return [pscustomobject]@{
            Identity          = $user.SamAccountName
            DistinguishedName = $user.DistinguishedName
            EmailAlias        = $aliasLower
            Action            = if ($Remove) { 'Remove' } elseif ($MakePrimary) { 'MakePrimary' } else { 'AddOrEnsureSecondary' }
            Changed           = $true
            ProxyAddresses    = $newArray
        }
    }
    catch {
        Write-Log -Level ERROR -Message "Failed to set email alias for '$Identity'  '$EmailAlias': $_"
        throw
    }
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Public\Set\Set-PageFileSize.ps1
function Set-PageFileSize {
    <#
    .SYNOPSIS
    Sets the page file size on a remote computer.

    .DESCRIPTION
    Configures the initial and maximum page file size on a remote computer via
    PSRemoting.

    .PARAMETER ComputerName
    The name of the remote computer to configure.

    .PARAMETER InitialSize
    The initial page file size in MB. If not provided, user will be prompted.

    .PARAMETER MaximumSize
    The maximum page file size in MB. If not provided, user will be prompted.

    .PARAMETER Path
    The path where the page file will be created. Defaults to configured default
    path.
    #>
    [CmdletBinding(SupportsShouldProcess)]
    param(
        [Parameter(Mandatory)][string]$ComputerName,
        [int]$InitialSize,
        [int]$MaximumSize,
        [string]$Path
    )

    Initialize-TechToolboxRuntime

    $pfCfg = $script:cfg.settings.pagefile

    if (-not $Path) { $Path = $pfCfg.defaultPath }
    $minSize = $pfCfg.minSizeMB
    $maxSize = $pfCfg.maxSizeMB

    if (-not $InitialSize) {
        $InitialSize = Read-Int -Prompt "Enter initial pagefile size (MB)" -Min $minSize -Max $maxSize
    }

    if (-not $MaximumSize) {
        $MaximumSize = Read-Int -Prompt "Enter maximum pagefile size (MB)" -Min $InitialSize -Max $maxSize
    }

    $creds = $null
    if ($script:cfg.settings.defaults.promptForCredentials) {
        $creds = Get-Credential -Message "Enter credentials for $ComputerName"
    }

    Write-Log -Level Info -Message "Connecting to $ComputerName..."

    $session = $null
    try {
        $session = Start-NewPSRemoteSession -ComputerName $ComputerName -Credential $creds
        Write-Log -Level Ok -Message "Connected to $ComputerName."
    }
    catch {
        Write-Log -Level Error -Message "Failed to create PSSession: $($_.Exception.Message)"
        return
    }

    Write-Log -Level Info -Message "Applying pagefile settings on $ComputerName..."

    $moduleRoot = Get-ModuleRoot
    $workerLocal = Join-Path $moduleRoot 'Workers\Set-PageFileSize.worker.ps1'
    $workerRemote = 'C:\TechToolbox\Workers\Set-PageFileSize.worker.ps1'

    $helperPath = Join-Path $moduleRoot 'Private\PageFile\Invoke-PageFileConfig.ps1'
    $pkg = New-HelpersPackage -HelperFiles @($helperPath)

    try {
        $result = Invoke-RemoteWorker `
            -Session $session `
            -HelpersZip $pkg.ZipPath `
            -HelpersZipHash $pkg.ZipHash `
            -WorkerRemotePath $workerRemote `
            -WorkerLocalPath $workerLocal `
            -EntryPoint 'Set-PageFileSizeCore' `
            -EntryParameters @{
            Path        = $Path
            InitialSize = $InitialSize
            MaximumSize = $MaximumSize
        }
    }
    catch {
        Write-Log -Level Error -Message "Remote failure: $($_.Exception.Message)"
        return
    }
    finally {
        if ($session) { Remove-PSSession $session -ErrorAction SilentlyContinue }
    }

    if ($result.Success) {
        Write-Log -Level Ok -Message $result.Message
    }
    else {
        Write-Log -Level Error -Message "Remote failure: $($result.Message)"
        return
    }

    $resp = Read-Host "Reboot $ComputerName now? (y/n)"
    if ($resp -match '^(y|yes)$') {
        Write-Log -Level Info -Message "Rebooting $ComputerName..."
        Restart-Computer -ComputerName $ComputerName -Force -Credential $creds
    }
    else {
        Write-Log -Level Warn -Message "Reboot later to apply changes."
    }
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Public\Set\Set-ProxyAddress.ps1

function Set-ProxyAddress {
    <#
    .SYNOPSIS
    Sets the primary SMTP proxy address for an Active Directory user.

    .DESCRIPTION
    This function sets the primary SMTP proxy address for a specified Active
    Directory user. It ensures that the new primary address is added correctly
    and removes any existing primary SMTP addresses.

    .PARAMETER Username
    The username (sAMAccountName) of the Active Directory user.

    .PARAMETER ProxyAddress
    The new primary SMTP proxy address to set (e.g., user@example.com).

    .INPUTS
        None. You cannot pipe objects to Set-ProxyAddress.

    .OUTPUTS
        None. Output is written to the Information stream.

    .EXAMPLE
    Set-ProxyAddress -Username "jdoe" -ProxyAddress "jdoe@example.com"

    .LINK
        [TechToolbox](https://github.com/dan-damit/TechToolbox)
    #>
    param(
        [Parameter(Mandatory)][string]$Username,
        [Parameter(Mandatory)][ValidatePattern('^[^@\s]+@[^@\s]+\.[^@\s]+$')][string]$ProxyAddress
    )

    # Load dependencies
    Initialize-TechToolboxRuntime

    try {
        Import-Module ActiveDirectory -ErrorAction Stop
    }
    catch {
        Write-Error "The ActiveDirectory module is required to run this script. $_"
        return
    }
    $PrimarySMTP = "SMTP:$ProxyAddress"
    try {
        Set-ADUser -Identity $Username -Add @{ proxyAddresses = $PrimarySMTP } -ErrorAction Stop
        Write-Host "Primary SMTP address '$PrimarySMTP' added to user '$Username'."
    }
    catch {
        Write-Error "Failed to add primary SMTP address '$PrimarySMTP' to user '$Username'. Error: $($_.Exception.Message)"
    }
    $user = Get-ADUser -Identity $Username -Properties proxyAddresses
    $existingProxyAddresses = @()
    if ($user.proxyAddresses) {
        $existingProxyAddresses = @($user.proxyAddresses)
    }

    # Remove any existing primary SMTP entries and any duplicates of the new primary address (case-insensitive)
    $filteredProxyAddresses = $existingProxyAddresses | Where-Object {
        ($_ -notlike 'SMTP:*') -and
        ($_.ToLower() -ne $PrimarySMTP.ToLower())
    }

    # Add the new primary SMTP address
    $updatedProxyAddresses = $filteredProxyAddresses + $PrimarySMTP

    # Replace proxyAddresses to ensure there is a single, correct primary SMTP value
    Set-ADUser -Identity $Username -Replace @{ proxyAddresses = $updatedProxyAddresses }
    Write-Host "Primary SMTP address '$PrimarySMTP' set for user '$Username'."
}
[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Public\Start\Start-DnsQueryLogger.ps1

function Start-DnsQueryLogger {
    <#
    .SYNOPSIS
        Starts real-time DNS query logging using the Windows DNS debug log.
    .DESCRIPTION
        This cmdlet starts logging DNS queries by enabling the Windows DNS debug log.
        It reads configuration settings from the TechToolbox config.json file to
        determine if DNS logging is enabled, the log file path, and parsing mode.
        If logging is enabled, it ensures the log directory exists and starts the
        DNS query logger.
    
    .INPUTS
        None. You cannot pipe objects to Start-DnsQueryLogger.

    .OUTPUTS
        None. Output is written to the Information stream.

    .EXAMPLE
        Start-DnsQueryLogger
        Starts the DNS query logger based on the configuration settings.

    .LINK
        [TechToolbox](https://github.com/dan-damit/TechToolbox)
    #>
    [CmdletBinding()]
    param()

    # Load config
    Initialize-TechToolboxRuntime
    $dnsCfg = $script:cfg.settings.dnsLogging

    if (-not $dnsCfg.enabled) {
        Write-Log -Level Warn -Message "DNS logging disabled in config.json"
        return
    }

    $logDir = $dnsCfg.logPath
    $parseMode = $dnsCfg.parseMode

    # Ensure directory exists
    if (-not (Test-Path $logDir)) {
        New-Item -ItemType Directory -Path $logDir -Force | Out-Null
    }

    Write-Log -Level Info -Message "Starting DNS query logger. Output: $dnsLog"

    # Call private worker
    Start-DnsQueryLoggerWorker -OutputPath $dnsLog
}
[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Public\Start\Start-PDQDiagLocalElevated.ps1
function Start-PDQDiagLocalElevated {
    <#
    .SYNOPSIS
      Open a new elevated PowerShell console (UAC), then run the local PDQ diag
      under SYSTEM.
    
    .DESCRIPTION
      - Spawns a new console with RunAs (UAC prompt).
      - In that console: Import-Module TechToolbox, call private
        Start-PDQDiagLocalSystem.
      - Captures full transcript to C:\PDQDiagLogs\LocalRun_<timestamp>.log.
      - On error, writes detailed info and optionally pauses so you can read it.
    
    .PARAMETER LocalDropPath
      Destination folder for the final ZIP. Default: C:\PDQDiagLogs
    
    .PARAMETER ExtraPaths
      Additional files/folders to include.
    
    .PARAMETER ConnectDataPath
      Root for PDQ Connect agent data. Default:
      "$env:ProgramData\PDQ\PDQConnectAgent"
    
    .PARAMETER StayOpen
      Keep the elevated console open after it finishes (adds -NoExit and a prompt).
    
    .PARAMETER ForcePwsh
      Prefer pwsh.exe explicitly; otherwise auto-detect pwsh then powershell.
    
    .EXAMPLE
      Start-PDQDiagLocalElevated -StayOpen
    
    .EXAMPLE
      Start-PDQDiagLocalElevated -ExtraPaths 'C:\Temp\PDQ','D:\Logs\PDQ'
    #>
    [CmdletBinding()]
    param(
        [string]  $LocalDropPath = 'C:\PDQDiagLogs',
        [string[]]$ExtraPaths,
        [string]  $ConnectDataPath = (Join-Path $env:ProgramData 'PDQ\PDQConnectAgent'),
        [switch]  $StayOpen,
        [switch]  $ForcePwsh
    )

    # Load dependencies
    Initialize-TechToolboxRuntime

    # Resolve the module path (ensure the elevated console imports the same module)
    $module = Get-Module -Name TechToolbox -ListAvailable | Select-Object -First 1
    if (-not $module) { throw "TechToolbox module not found in PSModulePath." }
    $modulePath = $module.Path

    # Ensure local drop path exists (used for transcript and final ZIP)
    if (-not (Test-Path -LiteralPath $LocalDropPath)) {
        New-Item -ItemType Directory -Path $LocalDropPath -Force | Out-Null
    }

    # Pre-compute timestamp so both runner + private use the same naming (optional/consistent)
    $timestamp = Get-Date -Format 'yyyyMMdd-HHmmss'
    $finalZip = Join-Path $LocalDropPath ("PDQDiag_{0}_{1}.zip" -f $env:COMPUTERNAME, $timestamp)
    $logPath = Join-Path $LocalDropPath ("LocalRun_{0}.log" -f $timestamp)

    # Safely render ExtraPaths as a PowerShell literal
    $extraLiteral = if ($ExtraPaths) {
        $escaped = $ExtraPaths | ForEach-Object { "'" + ($_ -replace "'", "''") + "'" }
        "@(" + ($escaped -join ',') + ")"
    }
    else { '@()' }

    # Build the runner script content that will execute in the elevated console
    $runnerLines = @()
    $runnerLines += '$ErrorActionPreference = "Continue"'
    $runnerLines += '$VerbosePreference = "Continue"'
    $runnerLines += "if (-not (Test-Path -LiteralPath `"$LocalDropPath`")) { New-Item -ItemType Directory -Path `"$LocalDropPath`" -Force | Out-Null }"
    $runnerLines += "Start-Transcript -Path `"$logPath`" -IncludeInvocationHeader -Force | Out-Null"
    $runnerLines += "`$modulePath = `"$modulePath`""
    $runnerLines += 'Import-Module $modulePath -Force'
    $runnerLines += ""
    $runnerLines += "Write-Host ('[LOCAL] Running Start-PDQDiagLocalSystem (SYSTEM)...') -ForegroundColor Cyan"
    $runnerLines += "try {"
    $runnerLines += "    Start-PDQDiagLocalSystem -LocalDropPath `"$LocalDropPath`" -ConnectDataPath `"$ConnectDataPath`" -ExtraPaths $extraLiteral -Timestamp `"$timestamp`" | Format-List *"
    $runnerLines += "    Write-Host ('[LOCAL] Expected ZIP: $finalZip') -ForegroundColor Green"
    $runnerLines += "} catch {"
    $runnerLines += "    Write-Host ('[ERROR] ' + `$_.Exception.Message) -ForegroundColor Red"
    $runnerLines += "    if (`$Error.Count -gt 0) {"
    $runnerLines += "        Write-Host '--- $Error[0] (detailed) ---' -ForegroundColor Yellow"
    $runnerLines += "        `$Error[0] | Format-List * -Force"
    $runnerLines += "    }"
    $runnerLines += "    throw"
    $runnerLines += "} finally {"
    $runnerLines += "    Stop-Transcript | Out-Null"
    $runnerLines += "}"
    if ($StayOpen) {
        # Keep the elevated console open so you can review logs/output
        $runnerLines += "Write-Host 'Transcript saved to: $logPath' -ForegroundColor Yellow"
        $runnerLines += "Read-Host 'Press Enter to close this elevated window'"
    }

    $runnerScript = Join-Path $env:TEMP ("PDQDiag_LocalElevated_{0}.ps1" -f $timestamp)
    Set-Content -Path $runnerScript -Value ($runnerLines -join [Environment]::NewLine) -Encoding UTF8

    # Pick host exe (pwsh preferred if available or forced; else Windows PowerShell)
    $hostExe = $null
    if ($ForcePwsh) {
        $hostExe = (Get-Command pwsh.exe -ErrorAction SilentlyContinue)?.Source
        if (-not $hostExe) { throw "ForcePwsh requested, but pwsh.exe not found." }
    }
    else {
        $hostExe = (Get-Command pwsh.exe -ErrorAction SilentlyContinue)?.Source
        if (-not $hostExe) { $hostExe = (Get-Command powershell.exe -ErrorAction SilentlyContinue)?.Source }
    }
    if (-not $hostExe) { throw "Neither pwsh.exe nor powershell.exe found on PATH." }

    $prelude = '$env:TT_ExportLocalHelper="1";'
    $args = @()
    if ($StayOpen) { $args += '-NoExit' }
    $args = @('-NoLogo', '-NoProfile', '-ExecutionPolicy', 'Bypass', '-Command', $prelude + " & `"$runnerScript`"")

    # Launch elevated; parent console stays open
    Start-Process -FilePath $hostExe -Verb RunAs -ArgumentList $args -WindowStyle Normal | Out-Null

    # Emit a quick hint in the parent console
    [pscustomobject]@{
        ComputerName = $env:COMPUTERNAME
        Status       = 'Launched'
        ZipExpected  = $finalZip
        Transcript   = $logPath
        Notes        = "Elevated console opened. Output + errors captured to transcript. Use -StayOpen to keep the window open."
    }
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Public\System\Security\Debug\Invoke-SCW.ps1
function Invoke-SCW {
    (Get-Module TechToolbox).Invoke({ Invoke-SanityCheck })
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Public\System\Security\Initialize-DomainAdminCred.ps1

function Initialize-DomainAdminCred {
    <#
    .SYNOPSIS
    Initializes the Domain Admin Credential in the session by loading from
    config or prompting the user.
    .DESCRIPTION
    This function checks if the domain admin credential is stored in the
    configuration. If not, it prompts the user to enter the credential via
    Get-Credential, stores it securely in the config file, and reconstructs
    the PSCredential object for use in the current session.
    .EXAMPLE
    Initialize-DomainAdminCred
    Initializes the domain admin credential for the session.
    .NOTES
    This will pull credentials from
    $script:cfg.settings.passwords.domainAdminCred. And set it to
    $script:domainAdminCred for session use.
    #>
    [CmdletBinding()]
    param()

    Write-Log -Level 'Debug' -Message "[Initialize-DomainAdminCred] Starting credential initialization."

    # Ensure config is loaded
    Initialize-TechToolboxRuntime
    if (-not $script:cfg) {
        Write-Log -Level 'Error' -Message "[Initialize-DomainAdminCred] Config not loaded. Initialize-Config must run first."
        throw "[Initialize-DomainAdminCred] Config not loaded."
    }

    # Navigate to credential node safely
    $credNode = $null
    try {
        $credNode = $script:cfg.settings.passwords.domainAdminCred
    }
    catch {
        # Create missing hierarchy
        if (-not $script:cfg.settings) { $script:cfg.settings = @{} }
        if (-not $script:cfg.settings.passwords) { $script:cfg.settings.passwords = @{} }
        $credNode = $null
    }

    # Determine if prompting is required
    $needCred = $false
    if (-not $credNode) { $needCred = $true }
    elseif (-not $credNode.username) { $needCred = $true }
    elseif (-not $credNode.password) { $needCred = $true }

    if ($needCred) {
        Write-Log -Level 'Warn' -Message "[Initialize-DomainAdminCred] No stored domain admin credentials found. Prompting user."

        $cred = Get-Credential -Message "Enter Domain Admin Credential"

        # Ensure config branch exists
        if (-not $script:cfg.settings.passwords) {
            $script:cfg.settings.passwords = @{}
        }

        # Store updated credential
        $script:cfg.settings.passwords.domainAdminCred = @{
            username = $cred.UserName
            password = ConvertFrom-SecureString $cred.Password
        }

        # Save updated config.json
        $configPath = $script:ConfigPath
        try {
            $script:cfg | ConvertTo-Json -Depth 25 | Set-Content -Path $configPath
            Write-Log -Level 'Ok' -Message "[Initialize-DomainAdminCred] Saved domainAdminCred to $configPath"
        }
        catch {
            Write-Log -Level 'Error' -Message "[Initialize-DomainAdminCred] Failed to write config: $($_.Exception.Message)"
            throw
        }
    }

    # Reconstruct PSCredential for session use
    try {
        $username = $script:cfg.settings.passwords.domainAdminCred.username
        $securePwd = $script:cfg.settings.passwords.domainAdminCred.password | ConvertTo-SecureString
        $script:domainAdminCred = New-Object -TypeName PSCredential -ArgumentList $username, $securePwd

        Write-Log -Level 'Debug' -Message "[Initialize-DomainAdminCred] Domain admin credential loaded into session."
    }
    catch {
        Write-Log -Level 'Error' -Message "[Initialize-DomainAdminCred] Failed to build PSCredential: $($_.Exception.Message)"
        throw
    }
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Public\System\Clear-BrowserProfileData.ps1
function Clear-BrowserProfileData {
    <#
    .SYNOPSIS
        Clears cache, cookies, and optional local storage for Chrome/Edge
        profiles.
    .DESCRIPTION
        Stops browser processes (optional), discovers Chromium profile folders,
        and clears cache/cookies/local storage per switches. Logging is
        centralized via Write-Log.
    .PARAMETER Browser
        Chrome, Edge, or All. Default: All.
    .PARAMETER Profiles
        One or more profile names to target (e.g., 'Default','Profile 1'). If
        omitted, all known profiles.
    .PARAMETER IncludeCookies
        Clears cookie databases. Default: $true
    .PARAMETER IncludeCache
        Clears browser cache folders. Default: $true
    .PARAMETER SkipLocalStorage
        Skips clearing 'Local Storage' content when $true. Default: $false
    .PARAMETER KillProcesses
        Attempts to stop browser processes before deletion. Default: $true
    .PARAMETER SleepAfterKillMs
        Milliseconds to wait after killing processes. Default: 1500
    .INPUTS
        None. You cannot pipe objects to Clear-BrowserProfileData.
    .OUTPUTS
        [PSCustomObject] with properties:
            Browser             - The browser processed (Chrome/Edge)
            Profile             - The profile name processed
            CacheCleared        - $true if cache was cleared
            CookiesCleared      - $true if cookies were cleared
            LocalStorageCleared - $true if local storage was cleared
            Timestamp           - DateTime of operation
    .EXAMPLE
        Clear-BrowserProfileData -Browser Chrome -Profiles 'Default','Profile 2' -WhatIf
    .EXAMPLE
        Clear-BrowserProfileData -Browser All -IncludeCache:$true -IncludeCookies:$false -Confirm
    .LINK
        [TechToolbox](https://github.com/dan-damit/TechToolbox)
    #>
    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Medium')]
    param(
        [ValidateSet('Chrome', 'Edge', 'All')]
        [string]$Browser = 'All',

        [string[]]$Profiles,

        [bool]$IncludeCookies = $true,
        [bool]$IncludeCache = $true,
        [bool]$SkipLocalStorage = $false,

        [bool]$KillProcesses = $true,
        [int]  $SleepAfterKillMs = 1500
    )

    begin {
        # --- Config & Defaults ---
        Initialize-TechToolboxRuntime
        $cfg = $script:cfg

        # Resolve settings.browserCleanup safely (works for hashtables or PSCustomObjects)
        $bc = @{}
        if ($cfg) {
            $settings = $cfg.settings
            if ($null -eq $settings) { $settings = $cfg.settings }
            if ($settings) {
                $bc = $settings.browserCleanup
                if ($null -eq $bc) { $bc = $settings.browserCleanup }
            }
            if ($null -eq $bc) { $bc = @{} }
        }

        # Apply config-driven defaults only when the parameter wasn't provided
        if (-not $PSBoundParameters.ContainsKey('IncludeCache') -and $bc.ContainsKey('includeCache')) { $IncludeCache = [bool]$bc.includeCache }
        if (-not $PSBoundParameters.ContainsKey('IncludeCookies') -and $bc.ContainsKey('includeCookies')) { $IncludeCookies = [bool]$bc.includeCookies }
        if (-not $PSBoundParameters.ContainsKey('SkipLocalStorage') -and $bc.ContainsKey('skipLocalStorage')) { $SkipLocalStorage = [bool]$bc.skipLocalStorage }
        if (-not $PSBoundParameters.ContainsKey('KillProcesses') -and $bc.ContainsKey('killProcesses')) { $KillProcesses = [bool]$bc.killProcesses }
        if (-not $PSBoundParameters.ContainsKey('SleepAfterKillMs') -and $bc.ContainsKey('sleepAfterKillMs')) { $SleepAfterKillMs = [int] $bc.sleepAfterKillMs }

        # Browser (string default)
        if (-not $PSBoundParameters.ContainsKey('Browser') -and [string]::IsNullOrWhiteSpace($Browser)) {
            if ($bc.ContainsKey('defaultBrowser') -and $bc.defaultBrowser) {
                $Browser = [string]$bc.defaultBrowser
            }
        }

        # Profiles (array or string)
        if (-not $PSBoundParameters.ContainsKey('Profiles') -and $bc.ContainsKey('defaultProfiles') -and $null -ne $bc.defaultProfiles) {
            $dp = $bc.defaultProfiles
            $Profiles = @(
                if ($dp -is [System.Collections.IEnumerable] -and -not ($dp -is [string])) { $dp }
                else { "$dp" }
            )
        }

        # Metadata per browser
        $BrowserMeta = @{
            Chrome = @{ ProcessName = 'chrome'; DisplayName = 'Google Chrome' }
            Edge   = @{ ProcessName = 'msedge'; DisplayName = 'Microsoft Edge' }
        }
    }

    process {
        $targetBrowsers = switch ($Browser) {
            'Chrome' { @('Chrome') }
            'Edge' { @('Edge') }
            'All' { @('Chrome', 'Edge') }
        }

        if ($WhatIfPreference) {
            Write-Information "=== DRY RUN SUMMARY ==="
            Write-Information ("Browsers: {0}" -f ($targetBrowsers -join ', '))
            Write-Information "Include Cache: $IncludeCache"
            Write-Information "Include Cookies: $IncludeCookies"
            Write-Information "Skip Local Storage: $SkipLocalStorage"
            Write-Information "Kill Processes: $KillProcesses"
            Write-Information ("Profiles filter: {0}" -f (($Profiles ?? @()) -join ', '))
            Write-Information "======================="
        }

        foreach ($b in $targetBrowsers) {
            Write-Log -Level Info -Message "=== Processing $b ==="

            $browserName = $BrowserMeta[$b].DisplayName
            $processName = $BrowserMeta[$b].ProcessName

            # Optional: stop processes
            if ($KillProcesses) {
                if ($PSCmdlet.ShouldProcess("$browserName ($processName)", "Stop processes")) {
                    Stop-Process -Name $processName -Force -ErrorAction SilentlyContinue
                    Start-Sleep -Milliseconds $SleepAfterKillMs
                }
            }

            $userData = Get-BrowserUserDataPath -Browser $b
            $profileDirs = @(Get-BrowserProfileFolders -UserDataPath $userData)  # ensure array

            if (-not $profileDirs -or $profileDirs.Count -eq 0) {
                Write-Log -Level Warn -Message "No profiles found for $b at '$userData'."
                continue
            }

            Write-Log -Level Info -Message ("Discovered profiles: {0}" -f ($profileDirs.Name -join ', '))

            # Optional filter by provided profile names
            if ($Profiles) {
                $profileDirs = @($profileDirs | Where-Object { $Profiles -contains $_.Name })
                Write-Log -Level Info -Message ("Filtered profiles: {0}" -f ($profileDirs.Name -join ', '))
                if (-not $profileDirs -or $profileDirs.Count -eq 0) {
                    Write-Log -Level Warn -Message "No profiles remain after filtering. Skipping $b."
                    continue
                }
            }

            foreach ($prof in $profileDirs) {
                # Support DirectoryInfo or string
                $profileName = try { $prof.Name } catch { Split-Path -Path $prof -Leaf }
                $profilePath = try { $prof.FullName } catch { [string]$prof }

                Write-Log -Level Info -Message "Profile: '$profileName' ($profilePath)"

                # Cookies & Local Storage
                if ($IncludeCookies) {
                    $cookieStatus = Clear-CookiesForProfile -ProfilePath $profilePath -SkipLocalStorage:$SkipLocalStorage
                    # (No outputdriver consumes status silently; use $cookieStatus for debug if needed)
                }
                else {
                    Write-Log -Level Info -Message "Cookies deletion skipped by configuration."
                }

                # Cache
                if ($IncludeCache) {
                    # If your cache helper returns status, capture silently to avoid tables
                    $cacheStatus = Clear-CacheForProfile -ProfilePath $profilePath
                    # Or: $null = Clear-CacheForProfile -ProfilePath $profilePath
                }
                else {
                    Write-Log -Level Info -Message "Cache deletion skipped by configuration."
                }

                Write-Log -Level Ok -Message "Finished: $profileName"
            }

            Write-Log -Level Ok -Message "=== Completed $b ==="
        }

        # No PSCustomObject results returned
        return
    }

    end {
        Write-Log -Level Ok -Message "All requested browser profile cleanup completed."
    }
}
[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Public\System\Copy-Directory.ps1
function Copy-Directory {
    <#
    .SYNOPSIS
        Copies a directory to another directory using Robocopy.
    .DESCRIPTION
        Supports local or remote execution via PowerShell Remoting. Uses
        config-driven defaults for logging, flags, retries, and mirror behavior.
    .PARAMETER Source
        The source directory to copy.
    .PARAMETER DestinationRoot
        The root destination directory where the source folder will be copied.
        The final destination will be DestinationRoot\SourceFolderName.
    .PARAMETER ComputerName
        The name of the remote computer to perform the copy on. If omitted, the
        copy is performed locally unless -Local is specified.
    .PARAMETER Local
        Switch to force local execution of the copy.
    .PARAMETER Mirror
        Switch to enable mirror mode (/MIR) for the copy, which deletes files in
        the destination that no longer exist in the source.
    .PARAMETER Credential
        Optional PSCredential to use for remote connections.
    .INPUTS
        None. You cannot pipe objects to Copy-Directory.
    .OUTPUTS
        The final destination path where the directory was copied.
    .EXAMPLE
        Copy-Directory -Source "C:\Data\FolderA" -DestinationRoot "D:\Backup"
        Copies FolderA to D:\Backup\FolderA locally.
    .EXAMPLE
        Copy-Directory -Source "C:\Data\FolderA" -DestinationRoot "D:\Backup" -ComputerName "Server01"
        Copies FolderA to D:\Backup\FolderA on the remote computer Server01.
    .LINK
        [TechToolbox](https://github.com/dan-damit/TechToolbox)
    #>
    [CmdletBinding(SupportsShouldProcess = $true)]
    param(
        [Parameter(Mandatory)]
        [string]$Source,

        [Parameter(Mandatory)]
        [string]$DestinationRoot,

        [Parameter()]
        [string]$ComputerName,

        [Parameter()]
        [switch]$Local,

        [Parameter()]
        [switch]$Mirror,

        [Parameter()]
        [pscredential]$Credential
    )

    # --- Config ---
    Initialize-TechToolboxRuntime

    $copy = $script:cfg.settings.copyDirectory

    $runRemote = $copy.runRemote ?? $true
    $defaultComp = $copy.defaultComputerName
    $logDir = $copy.logDir ?? "C:\LogsAndExports\TechToolbox\Logs\Robocopy"
    $retryCount = $copy.retryCount ?? 2
    $waitSeconds = $copy.waitSeconds ?? 5
    $copyFlags = $copy.copyFlags ?? @("/E", "/COPYALL")
    $mirrorCfg = $copy.mirror ?? $false

    # Effective mirror mode (param overrides config)
    $mirrorEffective = if ($Mirror.IsPresent) { $true } else { [bool]$mirrorCfg }

    if ($mirrorEffective) {
        # /MIR implies /E + purge; ignore configured copyFlags when mirroring
        $copyFlags = @("/MIR", "/COPYALL")
    }

    # Ensure log directory exists (local)
    if (-not (Test-Path -Path $logDir -PathType Container)) {
        New-Item -ItemType Directory -Path $logDir -Force | Out-Null
    }

    # Derive folder name & destination
    $folderName = Split-Path -Path $Source -Leaf
    $destination = Join-Path -Path $DestinationRoot -AdditionalChildPath $folderName

    # Log file (local path; may be on remote share if desired)
    $logFile = Join-Path -Path $logDir -AdditionalChildPath ("{0}-robocopy.log" -f $folderName)

    Write-Log -Level Info -Message "Preparing to copy directory..."
    Write-Log -Level Info -Message (" Source: {0}" -f $Source)
    Write-Log -Level Info -Message (" Destination root: {0}" -f $DestinationRoot)
    Write-Log -Level Info -Message (" Effective destination: {0}" -f $destination)
    Write-Log -Level Info -Message (" Log file: {0}" -f $logFile)

    if ($mirrorEffective) {
        Write-Log -Level Warn -Message "MIRROR MODE ENABLED: destination deletions will occur to match source (/MIR)."
    }

    # Decide local vs remote
    $targetComputer = $ComputerName
    if (-not $Local) {
        if (-not $targetComputer -and $defaultComp) {
            $targetComputer = $defaultComp
        }
    }

    $runRemoteEffective =
    -not $Local -and
    -not [string]::IsNullOrWhiteSpace($targetComputer) -and
    $runRemote

    $targetDescription = if ($runRemoteEffective) {
        "{0} (remote on {1})" -f $destination, $targetComputer
    }
    else {
        "{0} (local)" -f $destination
    }

    if ($mirrorEffective) {
        $targetDescription = "$targetDescription [MIRROR: deletions may occur]"
    }

    if ($PSCmdlet.ShouldProcess($targetDescription, "Copy directory via Robocopy")) {

        if ($runRemoteEffective) {
            Write-Log -Level Info -Message (" Executing Robocopy remotely on [{0}]." -f $targetComputer)

            Start-RobocopyRemote `
                -Source $Source `
                -Destination $destination `
                -LogFile $logFile `
                -RetryCount $retryCount `
                -WaitSeconds $waitSeconds `
                -CopyFlags $copyFlags `
                -ComputerName $targetComputer `
                -Credential $Credential
        }
        else {
            Write-Log -Level Info -Message " Executing Robocopy locally."

            Start-RobocopyLocal `
                -Source $Source `
                -Destination $destination `
                -LogFile $logFile `
                -RetryCount $retryCount `
                -WaitSeconds $waitSeconds `
                -CopyFlags $copyFlags `
                -Credential $Credential
        }

        Write-Log -Level Ok -Message ("Copy completed for folder '{0}'." -f $folderName)
    }

    return $destination
}
[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Public\System\Find-LargeFiles.ps1
function Find-LargeFiles {
    <#
    .SYNOPSIS
    Finds large files in specified directories.

    .DESCRIPTION
    Searches for files exceeding a specified size threshold in local or remote
    locations.
    #>
    [CmdletBinding()]
    param(
        [string[]]$SearchDirectory,
        [int]$MinSizeMB,
        [int]$Depth,
        [switch]$Export,
        [string]$ExportDirectory,
        [string]$CsvDelimiter = ',',
        [string]$ComputerName,
        [switch]$Local,
        [pscredential]$Credential
    )

    Initialize-TechToolboxRuntime
    $cfg = $script:cfg.settings.largeFileSearch

    # Resolve MinSizeMB
    if (-not $MinSizeMB) {
        $MinSizeMB = $cfg.defaultMinSizeMB ?? 256
    }

    # Resolve SearchDirectory
    if (-not $SearchDirectory) {
        $SearchDirectory = $cfg.defaultSearchDirectory
        if (-not $SearchDirectory) {
            $inputPath = Read-Host "Enter directories to search (use ';' to separate multiple)"
            $SearchDirectory = $inputPath -split ';' | ForEach-Object { $_.Trim() }
        }
    }

    # Normalize and validate
    $SearchDirectory = $SearchDirectory |
    ForEach-Object { [Environment]::ExpandEnvironmentVariables($_) } |
    Where-Object { Test-Path $_ }

    if (-not $SearchDirectory) {
        Write-Log -Level Error -Message "No valid search directories."
        return
    }

    # Determine local vs remote
    $runRemote = (-not $Local -and $ComputerName)

    if ($runRemote) {
        # --- Remote Mode ---
        Write-Log -Level Info -Message "Scanning large files on $ComputerName..."

        $creds = $Credential
        if ($script:cfg.settings.defaults.promptForCredentials -and -not $creds) {
            $creds = Get-Credential -Message "Enter credentials for $ComputerName"
        }

        $session = Start-NewPSRemoteSession -ComputerName $ComputerName -Credential $creds

        $moduleRoot = Get-ModuleRoot
        $workerLocal = Join-Path $moduleRoot 'Workers\Find-LargeFiles.worker.ps1'
        $workerRemote = 'C:\TechToolbox\Workers\Find-LargeFiles.worker.ps1'

        $helperPath = Join-Path $moduleRoot 'Private\LargeFiles\Invoke-LargeFileSearch.ps1'
        $pkg = New-HelpersPackage -HelperFiles @($helperPath)

        $result = Invoke-RemoteWorker `
            -Session $session `
            -HelpersZip $pkg.ZipPath `
            -HelpersZipHash $pkg.ZipHash `
            -WorkerRemotePath $workerRemote `
            -WorkerLocalPath $workerLocal `
            -EntryPoint 'Find-LargeFilesCore' `
            -EntryParameters @{
            SearchDirectory = $SearchDirectory
            MinSizeMB       = $MinSizeMB
            Depth           = $Depth
            UseDepth        = $PSBoundParameters.ContainsKey('Depth')
        }

        Remove-PSSession $session
    }
    else {
        # --- Local Mode ---
        Write-Log -Level Info -Message "Scanning large files locally..."
        $result = Invoke-LargeFileSearch `
            -SearchDirectory $SearchDirectory `
            -MinSizeMB $MinSizeMB `
            -Depth $Depth `
            -UseDepth:($PSBoundParameters.ContainsKey('Depth'))
    }

    # Sort and output
    $sorted = $result | Sort-Object SizeMB -Descending
    $sorted

    # Export if requested
    if ($Export) {
        if (-not $ExportDirectory) {
            $ExportDirectory = $cfg.exportDirectory
        }

        New-Item -ItemType Directory -Path $ExportDirectory -Force | Out-Null

        $timestamp = Get-Date -Format 'yyyyMMdd_HHmmss'
        $fileName = "LargeFiles_${timestamp}.csv"
        $exportPath = Join-Path $ExportDirectory $fileName

        $sorted | Export-Csv -Path $exportPath -NoTypeInformation -Encoding UTF8 -Delimiter $CsvDelimiter
        Write-Log -Level Ok -Message "Exported $($sorted.Count) items to $exportPath"
    }
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Public\System\Initialize-TTWordList.ps1

function Initialize-TTWordList {
    <#
    .SYNOPSIS
    Initializes a word list file with a curated set of words.

    .DESCRIPTION
    Creates a word list file containing a curated starter list of words.
    Optionally filters out words containing ambiguous characters (i, l, o).

    .PARAMETER Path
    The file path where the word list will be written. Default:
    'C:\TechToolbox\Config\wordlist.txt'

    .PARAMETER NoAmbiguous
    If specified, filters out words containing the letters i, l, or o.

    .EXAMPLE
    Initialize-TTWordList

    .EXAMPLE
    Initialize-TTWordList -Path 'C:\custom\path\wordlist.txt' -NoAmbiguous
    #>
    [CmdletBinding()]
    param(
        [string]$Path = 'C:\TechToolbox\Config\wordlist.txt',
        [switch]$NoAmbiguous
    )

    # Curated starter list (add to this as you like)
    $words = @'
river
stone
blue
green
tiger
forest
echo
delta
nova
ember
maple
cedar
birch
pine
spruce
willow
aspen
elm
fir
hemlock
oak
silver
shadow
crimson
cobalt
onyx
raven
falcon
otter
fox
wolf
lynx
badger
eagle
harbor
summit
meadow
prairie
canyon
valley
spring
autumn
winter
summer
breeze
cloud
storm
thunder
rain
snow
frost
glacier
aurora
comet
meteor
orbit
quartz
granite
basalt
pebble
coral
reef
tide
lagoon
moss
fern
copper
iron
nickel
zinc
amber
topaz
agate
jade
opal
pearl
sapphire
ruby
garnet
swift
brisk
rapid
steady
bold
bright
quiet
gentle
keen
vivid
lively
nimble
solid
lofty
noble
true
prime
vantage
zenith
apex
vertex
vector
gamma
omega
alpha
sigma
photon
quark
ion
pixel
matrix
cipher
beacon
signal
kernel
crypto
evergreen
lake
riverbank
brook
cove
grove
ridge
peak
hollow
dawn
dusk
ember
flare
spark
glow
blaze
shade
marble
slate
shale
granule
opaline
auric
argent
bronze
brass
steel
carbon
graphite
neon
argon
radon
xenon
sonic
echoes
north
south
east
west
midway
frontier
praxis
nimbus
cirrus
stratus
cumulus
zephyr
current
eddy
vortex
ripple
cascade
deltaic
arbor
thicket
bramble
meander
vernal
solstice
equinox
tundra
taiga
sierra
mesa
butte
cairn
grottos
harvest
emberly
solace
tranquil
serene
poise
steadfast
anchor
keystone
waypoint
signal
beacon
lumen
prism
spectra
radian
vector
scalar
tensor
axial
normal
median
summitry
'@ -split "`n"

    $clean = $words |
    ForEach-Object { $_.Trim().ToLowerInvariant() } |
    Where-Object { $_ -match '^[a-z]{3,10}$' } |
    Select-Object -Unique

    if ($NoAmbiguous) {
        $clean = $clean | Where-Object { $_ -notmatch '[ilo]' }
    }

    $clean | Sort-Object | Set-Content -LiteralPath $Path -Encoding UTF8
    Write-Log -Level OK -Message "Word list written: $Path (`$NoAmbiguous=$NoAmbiguous)"
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Public\System\Remove-EpicorEdgeAgent.ps1
function Remove-EpicorEdgeAgent {
    <#
    .SYNOPSIS
        Public wrapper that runs the Remove-EpicorEdgeAgent worker on one or
        more computers.

    .DESCRIPTION
        Windows PowerShell 5.1-compatible remote runner. Uses Start-NewPSSession
        if available; otherwise falls back to New-PSSession
        (Microsoft.PowerShell endpoint). Streams progress and returns worker
        results with -PassThru.

    .PARAMETER ComputerName
        One or more target computers. Defaults to local computer.

    .PARAMETER Credential
        PSCredential used for creating the PSSession (fallback path and
        Start-NewPSSession when supported).

    .PARAMETER ThrottleLimit
        Reserved for future use; simple foreach currently.

    .PARAMETER AsJob
        Invoke the worker as a background job on each remote computer and return
        Job objects.

    .PARAMETER PassThru
        Emit the worker's result object(s) to the pipeline.

    .PARAMETER WorkerPath
        Path to the worker script. Defaults to
        ..\Workers\Remove-EpicorEdgeAgent.Worker.ps1

    .PARAMETER AnalyzeOnly
        Sends -AnalyzeOnly to the worker (dry-run; no system changes).
    #>
    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'High')]
    param(
        [Parameter(ValueFromPipeline, ValueFromPipelineByPropertyName)]
        [Alias('CN', 'Server', 'Computer')]
        [string[]]$ComputerName = $env:COMPUTERNAME,

        [Parameter()]
        [System.Management.Automation.PSCredential]$Credential,

        [int]$ThrottleLimit = 8,

        [switch]$AsJob,

        [switch]$PassThru,

        [string]$WorkerDir,

        [switch]$AnalyzeOnly
    )

    begin {
        Initialize-TechToolboxRuntime
        $WorkerDir = $script:cfg.settings.workerPath.default

        $resolvedWorkerDir = (Resolve-Path -LiteralPath $WorkerDir -ErrorAction Stop).Path
        $expectedPrefix = 'Remove-EpicorEdgeAgent'   # base name before .Worker.ps1
        $targetName = "$expectedPrefix.Worker.ps1"

        $worker = Get-ChildItem -LiteralPath $resolvedWorkerDir -Filter $targetName -File |
        Select-Object -First 1

        if (-not $worker) {
            $candidates = Get-ChildItem -LiteralPath $resolvedWorkerDir -Filter '*.Worker.ps1' -File
            throw "No worker matching '$targetName' found in $resolvedWorkerDir. Candidates: $($candidates.Name -join ', ')"
        }

        $resolvedWorkerPath = $worker.FullName

        $resolvedWorkerPath = $worker.FullName
        $workerContent = Get-Content -LiteralPath $resolvedWorkerPath -Raw
        $scriptBlock = [ScriptBlock]::Create($workerContent)

        $StartNewPSRemoteSession = Get-Command -Name Start-NewPSRemoteSession -ErrorAction SilentlyContinue

        $results = New-Object System.Collections.Generic.List[object]
        $jobs = @()
        $targets = @()
    }

    process {
        $targets += ($ComputerName | Where-Object { $_ -and $_.Trim() } | Select-Object -Unique)
    }

    end {
        if (-not $targets -or $targets.Count -eq 0) {
            Write-Log -Level Warn "No target computers were specified."
            return
        }

        $i = 0; $total = $targets.Count
        foreach ($cn in $targets) {
            $i++
            $action = "Remove Epicor Edge Agent via worker"
            if (-not $PSCmdlet.ShouldProcess($cn, $action)) { continue }

            # Build a session using Start-NewPSSession if available, else New-PSSession
            $session = $null
            try {
                if ($StartNewPSRemoteSession) {
                    $sParams = @{ ComputerName = $cn }
                    if ($Credential) { $sParams.Credential = $Credential }
                    $session = Start-NewPSRemoteSession @sParams
                }
                else {
                    $nParams = @{ ComputerName = $cn }
                    if ($Credential) { $nParams.Credential = $Credential }
                    $session = New-PSSession @nParams
                }
            }
            catch {
                Write-Log -Level Error "[$cn] Failed to create PSSession. $_"
                continue
            }

            try {
                # Pass a single positional boolean to bind worker's [switch]$AnalyzeOnly
                $arg = $AnalyzeOnly.IsPresent
                if ($AsJob) {
                    $job = Invoke-Command -Session $session -ScriptBlock $scriptBlock -ArgumentList $arg -AsJob
                    $jobs += $job
                    continue
                }
                else {
                    $res = Invoke-Command -Session $session -ScriptBlock $scriptBlock -ArgumentList $arg -ErrorAction Stop
                    if ($PassThru) { $results.Add($res) | Out-Null }
                }
            }
            catch {
                Write-Log -Level Error "[$cn] Worker execution failed. $_"
            }
            finally {
                if ($session) {
                    try { Remove-PSSession -Session $session -ErrorAction SilentlyContinue } catch {}
                }
            }
        }

        if ($AsJob) { return $jobs }
        if ($PassThru) { return $results }
    }
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Public\System\Remove-Printers.ps1

function Remove-Printers {
    <#
    .SYNOPSIS
        Removes all printers from the system, with optional removal of ports,
        drivers, and per-user mappings.
    .DESCRIPTION
        Uses Win32_Printer (CIM) to remove queues after resetting the spooler
        and clearing the spool folder. Optionally removes TCP/IP ports and
        printer drivers. Adds fallbacks for provider hiccups and frees common
        process locks (splwow64/PrintIsolationHost). Can also remove per-user
        connections across all profiles.
    .PARAMETER IncludePorts
        Also remove TCP/IP printer ports (non-standard).
    .PARAMETER IncludeDrivers
        Also remove printer drivers (after queues are gone).
    .PARAMETER Force
        Best-effort forced cleanup of driver packages via pnputil if standard
        removal fails.
    .PARAMETER AllUsers
        Attempt to remove per-user network printer connections for all user
        profiles.
    .PARAMETER PassThru
        Output a summary object with counts and failures.
    .EXAMPLE
        Remove-Printers -IncludePorts -IncludeDrivers -Force -AllUsers -PassThru
    .EXAMPLE
        Remove-Printers -WhatIf
    #>
    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'High')]
    param(
        [switch] $IncludePorts,
        [switch] $IncludeDrivers,
        [switch] $Force,
        [switch] $AllUsers,
        [switch] $PassThru
    )

    Begin {
        # Load dependencies
        Initialize-TechToolboxRuntime
        $cfg = $script:cfg
        $defs = $cfg.defaults
        $log = $cfg.logging
        $paths = $cfg.paths

        # Counters
        $removedPrinters = 0; $failedPrinters = @()
        $removedPorts = 0; $failedPorts = @()
        $removedDrivers = 0; $failedDrivers = @()
        $removedUserMaps = 0; $failedUserMaps = @()

        Write-Log -Level Info -Message "=== Remove-Printers started ==="
    }

    Process {
        # Track original spooler state
        $spooler = Get-Service -Name Spooler -ErrorAction SilentlyContinue
        $spoolerWasRunning = $false
        if ($spooler) { $spoolerWasRunning = $spooler.Status -eq 'Running' }

        # 1) Stop spooler and clear jobs
        if ($PSCmdlet.ShouldProcess("Spooler", "Stop and clear PRINTERS folder")) {
            Write-Log -Level Info -Message "Stopping Print Spooler..."
            Stop-Service -Name Spooler -Force -ErrorAction SilentlyContinue

            $spoolPath = Join-Path $env:WINDIR 'System32\spool\PRINTERS'
            if (Test-Path $spoolPath) {
                Write-Log -Level Info -Message "Clearing spool folder: $spoolPath"
                Get-ChildItem -Path $spoolPath -File -ErrorAction SilentlyContinue |
                Remove-Item -Force -ErrorAction SilentlyContinue
            }

            Write-Log -Level Info -Message "Starting Print Spooler..."
            Start-Service -Name Spooler -ErrorAction SilentlyContinue
        }

        # (Optional) Remove per-user connections for all profiles
        if ($AllUsers) {
            Write-Log -Level Info -Message "Removing per-user network printer connections for all profiles..."
            # Enumerate mounted + offline hives under HKEY_USERS
            $userSids = Get-ChildItem -Path Registry::HKEY_USERS -ErrorAction SilentlyContinue |
            Where-Object { $_.Name -match 'S-1-5-21-\d+-\d+-\d+-\d+$' } |
            ForEach-Object { $_.PSChildName }

            foreach ($sid in $userSids) {
                $connKey = "Registry::HKEY_USERS\$sid\Printers\Connections"
                if (Test-Path $connKey) {
                    Get-ChildItem $connKey -ErrorAction SilentlyContinue | ForEach-Object {
                        # Value names typically look like ,Server,Queue (commas)
                        $raw = $_.PSChildName.Trim()
                        # Normalize to \\server\queue if possible
                        $serverQueue = $raw -replace '^,', '' -replace ',', '\'
                        if ($serverQueue -notmatch '^\\\\') { $serverQueue = "\\$serverQueue" }
                        if ($PSCmdlet.ShouldProcess("User:${sid} Mapping '$serverQueue'", "Disconnect")) {
                            try {
                                # Current process context removes only for current user,
                                # so we invoke PrintUIEntry targeting the path (best-effort).
                                rundll32 printui.dll, PrintUIEntry /dn /q /n "$serverQueue"
                                $removedUserMaps++
                                Write-Log -Level Info -Message "  - Disconnected $serverQueue for ${sid}"
                            }
                            catch {
                                $failedUserMaps += $serverQueue
                                Write-Log -Level Warn -Message "    Failed to disconnect $serverQueue for ${sid}: $($_.Exception.Message)"
                            }
                        }
                    }
                }
            }
        }
        else {
            Write-Log -Level Info -Message "Skipping per-user mapping removal (use -AllUsers to enable)."
        }

        # 2) Remove printers via Win32_Printer (bypasses MSFT_Printer provider issues)
        Write-Log -Level Info -Message "Removing all printers via Win32_Printer..."
        Get-CimInstance Win32_Printer | ForEach-Object {
            $name = $_.Name
            if ($PSCmdlet.ShouldProcess("Printer '$name'", "Remove")) {
                try {
                    $_ | Remove-CimInstance -ErrorAction Stop
                    $removedPrinters++
                    Write-Log -Level Info -Message "  - Removed $name"
                }
                catch {
                    $failedPrinters += $name
                    Write-Log -Level Warn -Message "    Failed to remove '$name': $($_.Exception.Message)"
                }
            }
        }

        # 3) Optional: remove ports (with WMI fallback)
        if ($IncludePorts) {
            Write-Log -Level Info -Message "Removing TCP/IP printer ports..."
            $standardPrefixes = @('FILE:', 'LPT', 'COM', 'WSD', 'XPS', 'SHRFAX:', 'PORTPROMPT:', 'NULL:')
            $ports = @()

            try {
                $ports = Get-PrinterPort -ErrorAction Stop
            }
            catch {
                Write-Log -Level Warn -Message "Get-PrinterPort failed, falling back to Win32_TCPIPPrinterPort..."
                $ports = Get-WmiObject -Class Win32_TCPIPPrinterPort -ErrorAction SilentlyContinue |
                ForEach-Object { New-Object psobject -Property @{ Name = $_.Name } }
            }

            $ports = $ports | Where-Object {
                $n = $_.Name
                -not ($standardPrefixes | ForEach-Object { $n.StartsWith($_, 'CurrentCultureIgnoreCase') }) `
                    -and ($n -notmatch '^(nul:|PDF:)')
            }

            foreach ($p in $ports) {
                if ($PSCmdlet.ShouldProcess("Port '$($p.Name)'", "Remove")) {
                    try {
                        Remove-PrinterPort -Name $p.Name -ErrorAction Stop
                        $removedPorts++
                        Write-Log -Level Info -Message "  - Removed port $($p.Name)"
                    }
                    catch {
                        $failedPorts += $p.Name
                        Write-Log -Level Warn -Message "    Failed to remove port '$($p.Name)': $($_.Exception.Message)"
                    }
                }
            }
        }
        else {
            Write-Log -Level Info -Message "Skipping port removal (use -IncludePorts to enable)."
        }

        # 4) Optional: remove drivers (free common locks first)
        if ($IncludeDrivers) {
            # Make sure spooler is running
            if ((Get-Service Spooler).Status -ne 'Running') {
                Start-Service Spooler -ErrorAction SilentlyContinue
            }

            # Free common locks
            Get-Process splwow64, PrintIsolationHost -ErrorAction SilentlyContinue | ForEach-Object {
                try { Stop-Process -Id $_.Id -Force -ErrorAction Stop } catch {}
            }

            Write-Log -Level Info -Message "Removing printer drivers..."
            $drivers = Get-PrinterDriver -ErrorAction SilentlyContinue
            foreach ($d in $drivers) {
                if ($PSCmdlet.ShouldProcess("Driver '$($d.Name)'", "Remove")) {
                    try {
                        Remove-PrinterDriver -Name $d.Name -ErrorAction Stop
                        $removedDrivers++
                        Write-Log -Level Info -Message "  - Removed driver '$($d.Name)'"
                    }
                    catch {
                        $failedDrivers += $d.Name
                        Write-Log -Level Warn -Message "    Failed to remove driver '$($d.Name)': $($_.Exception.Message)"

                        if ($Force) {
                            # Attempt package removal by published name (oemXX.inf)
                            Write-Log -Level Info -Message "    Enumerating driver packages via pnputil..."
                            $enum = & pnputil /enum-drivers 2>$null
                            if ($enum) {
                                # crude but effective matching
                                $blocks = ($enum -join "`n") -split "(?ms)^Published Name : "
                                $targets = $blocks | Where-Object { $_ -match [regex]::Escape($d.Name) -and $_ -match "Class\s*:\s*Printer" }
                                foreach ($blk in $targets) {
                                    if ($blk -match '^(oem\d+\.inf)') {
                                        $oem = $matches[1]
                                        try {
                                            Write-Log -Level Info -Message "    Forcing removal of ${oem} via pnputil..."
                                            & pnputil /delete-driver $oem /uninstall /force | Out-Null
                                        }
                                        catch {
                                            Write-Log -Level Warn -Message "    pnputil failed for ${oem}: $($_.Exception.Message)"
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        else {
            Write-Log -Level Info -Message "Skipping driver removal (use -IncludeDrivers to enable)."
        }

        # Restore spooler to original state
        if ($spoolerWasRunning) {
            # ensure it's up
            if ((Get-Service Spooler).Status -ne 'Running') {
                Start-Service -Name Spooler -ErrorAction SilentlyContinue
            }
        }
        else {
            # it was stopped before we began; stop it again
            if ($PSCmdlet.ShouldProcess("Spooler", "Restore to Stopped state")) {
                Stop-Service -Name Spooler -Force -ErrorAction SilentlyContinue
            }
        }
    }

    End {
        Write-Log -Level Info -Message "=== Remove-Printers completed ==="
        if ($PassThru) {
            [pscustomobject]@{
                PrintersRemoved = $removedPrinters
                PrintersFailed  = $failedPrinters
                PortsRemoved    = $removedPorts
                PortsFailed     = $failedPorts
                DriversRemoved  = $removedDrivers
                DriversFailed   = $failedDrivers
                UserMapsRemoved = $removedUserMaps
                UserMapsFailed  = $failedUserMaps
            }
        }
    }
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Public\System\Reset-WindowsUpdateComponents.ps1
function Reset-WindowsUpdateComponents {
    <#
    .SYNOPSIS
    Resets Windows Update components on a local or remote computer.

    .DESCRIPTION
    Stops Windows Update services, renames update-related folders, and clears
    cached data to resolve update issues.

    .PARAMETER ComputerName
    The name of the computer to reset. Defaults to the local computer.

    .PARAMETER Credential
    Credentials to use for remote connections.

    .EXAMPLE
    Reset-WindowsUpdateComponents -ComputerName "SERVER01"
    #>
    [CmdletBinding()]
    param(
        [string]$ComputerName = $env:COMPUTERNAME,
        [pscredential]$Credential
    )

    Initialize-TechToolboxRuntime

    $logDir = $script:cfg.settings.windowsUpdate.logDir
    if (-not (Test-Path $logDir)) {
        New-Item -Path $logDir -ItemType Directory -Force | Out-Null
    }

    $isLocal = ($ComputerName -eq $env:COMPUTERNAME -and -not $Credential)

    if ($isLocal) {
        Write-Log -Level Info -Message "Resetting Windows Update components locally..."
        $result = Invoke-WUResetLocal
    }
    else {
        Write-Log -Level Info -Message "Resetting Windows Update components on $ComputerName..."

        $creds = $Credential
        if ($script:cfg.settings.defaults.promptForCredentials -and -not $creds) {
            $creds = Get-Credential -Message "Enter credentials for $ComputerName"
        }

        $session = Start-NewPSRemoteSession -ComputerName $ComputerName -Credential $creds

        $moduleRoot = Get-ModuleRoot
        $workerLocal = Join-Path $moduleRoot 'Workers\Reset-WindowsUpdateComponents.worker.ps1'
        $workerRemote = 'C:\TechToolbox\Workers\Reset-WindowsUpdateComponents.worker.ps1'

        $helperPath = Join-Path $moduleRoot 'Private\WindowsUpdate\Invoke-WUResetLocal.ps1'
        $pkg = New-HelpersPackage -HelperFiles @($helperPath)

        $result = Invoke-RemoteWorker `
            -Session $session `
            -HelpersZip $pkg.ZipPath `
            -HelpersZipHash $pkg.ZipHash `
            -WorkerRemotePath $workerRemote `
            -WorkerLocalPath $workerLocal `
            -EntryPoint 'Reset-WindowsUpdateComponentsCore'

        Remove-PSSession $session
    }

    # Export log
    $timestamp = (Get-Date).ToString('yyyyMMdd-HHmmss')
    $exportPath = Join-Path $logDir ("WUReset_{0}_{1}.txt" -f $ComputerName, $timestamp)

    $log = @()
    $log += "Windows Update Reset Report"
    $log += "Computer: $ComputerName"
    $log += "Timestamp: $timestamp"
    $log += ""
    $log += "Stopped Services:"
    $log += $result.StoppedServices
    $log += ""
    $log += "Renamed Folders:"
    $log += $result.RenamedFolders
    $log += ""
    $log += "Errors:"
    $log += $result.Errors

    $log | Out-File -FilePath $exportPath -Encoding UTF8

    Write-Log -Level Ok -Message "Windows Update components reset. Log saved to: $exportPath"

    return $result
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Public\System\Watch-ISPConnection.ps1
function Watch-ISPConnection {
    <#
    .SYNOPSIS
      Monitors connectivity to a host (IP, DNS name, or URL) and logs structured
      results.
    
    .DESCRIPTION
      Starts a background monitoring job that pings the formatted target at the
      specified interval and writes CSV rows to a per-session log file. Provides
      Start/Stop/Status.
    
    .PARAMETER Target
      IP, DNS name, or URL (e.g., https://example.com). URLs will be formatted to
      host.
    
    .PARAMETER IntervalSeconds
      Seconds between samples. Minimum 1. Default 10.
    
    .PARAMETER SessionName
      Optional name; if omitted, a random one is generated.
    
    .PARAMETER TimeoutSeconds
      Timeout for each ping attempt. Default 3.
    
    .PARAMETER Start
      Start a new monitoring session.
    
    .PARAMETER Stop
      Stop a running session by name.
    
    .PARAMETER Status
      Show status of all sessions (jobs, start time, last heartbeat, etc.).
    #>

    [CmdletBinding(DefaultParameterSetName = 'Start')]
    param(
        # --- START ---
        [Parameter(ParameterSetName = 'Start', Mandatory = $true)]
        [Alias('FirewallIP')]
        [string]$Target,

        [Parameter(ParameterSetName = 'Start')]
        [ValidateRange(1, 86400)]
        [int]$IntervalSeconds = 10,

        [Parameter(ParameterSetName = 'Start')]
        [ValidateRange(1, 60)]
        [int]$TimeoutSeconds = 3,

        [Parameter(ParameterSetName = 'Start')]
        [string]$SessionName,

        # --- STOP ---
        [Parameter(ParameterSetName = 'Stop', Mandatory = $true)]
        [switch]$Stop,

        [Parameter(ParameterSetName = 'Stop', Mandatory = $true)]
        [string]$StopSessionName,

        # --- STATUS ---
        [Parameter(ParameterSetName = 'Status', Mandatory = $true)]
        [switch]$Status
    )

    begin {
        # Load dependencies
        Initialize-TechToolboxRuntime
        
        # SAFE StrictMode-friendly init
        $existing = Get-Variable -Name ISPWatchSessions -Scope Script -ErrorAction SilentlyContinue
        if (-not $existing) {
            Set-Variable -Name ISPWatchSessions -Scope Script -Value (@{}) -Option None
        }

        if ($PSCmdlet.ParameterSetName -eq 'Start' -and $IntervalSeconds -lt 1) {
            throw "IntervalSeconds must be >= 1."
        }

        $rootLogPath = $script:cfg.settings.ispConnection.logPath
        try {
            $null = New-Item -ItemType Directory -Path $rootLogPath -Force -ErrorAction Stop
        }
        catch {
            Write-Log -Level ERROR -Message "Failed to create log directory '$rootLogPath': $($_.Exception.Message)"
            throw
        }

        function Format-TargetHost {
            param([string]$InputTarget)
            try {
                $u = [uri]$InputTarget
                if ($u -and $u.Host) { return $u.DnsSafeHost }
            }
            catch { }
            return $InputTarget
        }

        function New-SessionName {
            param([string]$Base)
            if ([string]::IsNullOrWhiteSpace($Base)) {
                return "ISPWatch_{0:yyyyMMddHHmmss}_{1}" -f (Get-Date), (Get-Random -Max 99999)
            }
            return $Base
        }
    }

    process {
        switch ($PSCmdlet.ParameterSetName) {

            'Start' {
                $hostOrIp = Format-TargetHost -InputTarget $Target
                if ([string]::IsNullOrWhiteSpace($hostOrIp)) {
                    throw "Target '$Target' could not be formatted to a hostname or IP."
                }

                $name = New-SessionName -Base $SessionName

                if ($script:ISPWatchSessions.ContainsKey($name)) {
                    throw "A session named '$name' already exists."
                }

                $sessionLogDir = Join-Path $rootLogPath $name
                $sessionCsv = Join-Path $sessionLogDir "$name.csv"

                try {
                    New-Item -ItemType Directory -Path $sessionLogDir -Force | Out-Null
                }
                catch {
                    Write-Log -Level Error -Message "Failed to ensure session log directory '$sessionLogDir': $($_.Exception.Message)"
                    throw
                }

                # Start thread job that runs the sample loop
                $job = Start-ThreadJob -Name $name -ArgumentList @($hostOrIp, $IntervalSeconds, $TimeoutSeconds, $sessionCsv) -ScriptBlock {
                    param($target, $interval, $timeout, $csvPath)

                    # Ensure CSV header
                    if (-not (Test-Path -Path $csvPath)) {
                        'Timestamp,Target,ResolvedAddress,Success,LatencyMs,ErrorType,ErrorMessage' | Out-File -FilePath $csvPath -Encoding utf8
                    }

                    while ($true) {
                        $ts = Get-Date
                        $resolved = $null
                        $success = $false
                        $latency = $null
                        $errType = ''
                        $errMsg = ''

                        try {
                            # DNS resolve (optional but useful for logging)
                            try {
                                $res = Resolve-DnsName -Name $target -Type A -ErrorAction Stop
                                $resolved = ($res | Select-Object -First 1 -ExpandProperty IPAddress)
                            }
                            catch {
                                # If Resolve-DnsName fails (non-Windows or no DNS), continue; ping may still work
                                $resolved = ''
                            }

                            # Single ping with timeout; PS7 Test-Connection returns objects
                            $pong = Test-Connection -TargetName $target -Count 1 -TimeoutSeconds $timeout -ErrorAction Stop
                            if ($pong) {
                                $success = $true
                                # On PS7+, Latency is a property; fall back if missing
                                $latency = ($pong | Select-Object -First 1 -ExpandProperty Latency -ErrorAction SilentlyContinue)
                                if (-not $latency) { $latency = '' }
                            }
                        }
                        catch {
                            $errType = $_.Exception.GetType().Name
                            $errMsg = ($_.Exception.Message -replace '[\r\n]+', ' ')
                        }

                        $line = ('{0:o},{1},{2},{3},{4},{5},"{6}"' -f $ts, $target, $resolved, $success, $latency, $errType, $errMsg)
                        try {
                            Add-Content -Path $csvPath -Value $line -Encoding utf8
                        }
                        catch {
                            # If we can't write logs, there's no point continuing
                            break
                        }

                        Start-Sleep -Seconds $interval
                    }
                }

                $script:ISPWatchSessions[$name] = [ordered]@{
                    Name            = $name
                    Target          = $hostOrIp
                    IntervalSeconds = $IntervalSeconds
                    TimeoutSeconds  = $TimeoutSeconds
                    StartTime       = (Get-Date)
                    JobId           = $job.Id
                    LogPath         = $sessionCsv
                }

                Write-Log -Level Info -Message "Session '$name' started for target '$hostOrIp' (JobId=$($job.Id))"
                [pscustomobject]$script:ISPWatchSessions[$name]
            }

            'Stop' {
                $name = $StopSessionName
                if (-not $script:ISPWatchSessions.ContainsKey($name)) {
                    Write-Log -Level Error -Message "Session '$name' not found."
                    return
                }

                $jobId = $script:ISPWatchSessions[$name].JobId
                $job = Get-Job -Id $jobId -ErrorAction SilentlyContinue
                if ($job) {
                    try {
                        Stop-Job -Job $job -ErrorAction SilentlyContinue
                        Receive-Job -Job $job -ErrorAction SilentlyContinue | Out-Null
                        Remove-Job -Job $job -Force -ErrorAction SilentlyContinue
                    }
                    catch { }
                }

                $null = $script:ISPWatchSessions.Remove($name)
                Write-Log -Level Info -Message "Session '$name' stopped and removed."
            }

            'Status' {
                if ($script:ISPWatchSessions.Count -eq 0) {
                    Write-Log -Level Info -Message "No active sessions."
                    return
                }

                $script:ISPWatchSessions.GetEnumerator() | ForEach-Object {
                    $Info = $_.Value
                    $job = Get-Job -Id $Info.JobId -ErrorAction SilentlyContinue
                    $state = if ($job) { $job.State } else { 'Unknown' }
                    [pscustomobject]@{
                        SessionName     = $Info.Name
                        Target          = $Info.Target
                        IntervalSeconds = $Info.IntervalSeconds
                        TimeoutSeconds  = $Info.TimeoutSeconds
                        Started         = $Info.StartTime
                        JobState        = $state
                        LogPath         = $Info.LogPath
                    }
                } | Format-Table -AutoSize
            }
        }
    }
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Public\Test\Test-MailHeaderAuth.ps1
function Test-MailHeaderAuth {
    <#
    .SYNOPSIS
    Analyzes email headers to determine authentication status and phishing risk.

    .DESCRIPTION
    Tests mail headers for SPF, DKIM, DMARC, and ARC authentication results.
    Provides verdict on message legitimacy based on authentication alignment.

    .PARAMETER HeadersText
    Raw email headers as a string.

    .PARAMETER Path
    Path to a file containing email headers.

    .PARAMETER FromClipboard
    Read headers from clipboard (Windows only).

    .PARAMETER Format
    Output format: 'Summary' (default), 'Markdown', 'Object', or 'Json'.

    .PARAMETER AsObject
    Return PowerShell object instead of formatted output.

    .OUTPUTS
    PSCustomObject or formatted string depending on Format parameter.
    #>
    [CmdletBinding()]
    param(
        [Parameter(ParameterSetName = 'Text', Mandatory)][string]$HeadersText,
        [Parameter(ParameterSetName = 'File', Mandatory)][string]$Path,
        [Parameter(ParameterSetName = 'Clipboard')][switch]$FromClipboard,

        [ValidateSet('Summary', 'Markdown', 'Object', 'Json')]
        [string]$Format = 'Summary',

        [switch]$AsObject
    )

    $ErrorActionPreference = 'Stop'
    Initialize-TechToolboxRuntime
    Write-Log -Level Info -Message "Starting header analysis..."
    try {
        if ($PSCmdlet.ParameterSetName -eq 'File') {
            if (-not (Test-Path $Path)) { throw "File not found: $Path" }
            $HeadersText = Get-Content -LiteralPath $Path -Raw
            Write-Log -Level Warn -Message "Loaded headers from file: $Path"
        }
        elseif ($PSCmdlet.ParameterSetName -eq 'Clipboard') {
            if ($IsWindows) {
                $HeadersText = Get-Clipboard -Raw
                if (-not $HeadersText) { throw "Clipboard is empty." }
                Write-Log -Level Warn -Message "Loaded headers from clipboard."
            }
            else {
                throw "-FromClipboard is only supported on Windows."
            }
        }

        $block = Get-HeaderBlock -HeadersText $HeadersText
        $lines = $block.Lines

        # Extract key headers
        $kv = @{
            From       = ($lines | Where-Object { $_ -match '^(?i)From:' }        | Select-Object -First 1)
            Sender     = ($lines | Where-Object { $_ -match '^(?i)Sender:' }      | Select-Object -First 1)
            ReturnPath = ($lines | Where-Object { $_ -match '^(?i)Return-Path:' } | Select-Object -First 1)
            Subject    = ($lines | Where-Object { $_ -match '^(?i)Subject:' }     | Select-Object -First 1)
            MessageID  = ($lines | Where-Object { $_ -match '^(?i)Message-Id:' }  | Select-Object -First 1)
        }

        $fromAddr = $kv.From -replace '^(?i)From:\s*', ''
        $senderAddr = $kv.Sender -replace '^(?i)Sender:\s*', ''
        $returnPath = $kv.ReturnPath -replace '^(?i)Return-Path:\s*', ''

        $fromDomain = if ($fromAddr) { Get-Domain $fromAddr }
        $senderDomain = if ($senderAddr) { Get-Domain $senderAddr }
        $rpDomain = if ($returnPath) { Get-Domain $returnPath }

        # Collect Authentication-Results variants
        $ar_edge = $lines | Where-Object { $_ -match '^(?i)Authentication-Results:' }
        $ar_origin1 = $lines | Where-Object { $_ -match '^(?i)Authentication-Results-Original:' }
        $ar_origin2 = $lines | Where-Object { $_ -match '^(?i)X-Original-Authentication-Results:' }

        $edgeAuth = if ($ar_edge) { Format-AuthResults -Lines $ar_edge    -Label 'edge' }   else { $null }
        $originAuth = if ($ar_origin1 -or $ar_origin2) {
            Format-AuthResults -Lines ($ar_origin1 + $ar_origin2) -Label 'origin'
        }
        else { $null }

        # Received chain
        $receivedLines = $lines | Where-Object { $_ -match '^(?i)Received:' }
        $firstPublicIP = if ($receivedLines) { Get-FirstPublicIP -ReceivedLines $receivedLines } else { $null }

        # Also look for helper hints
        $xLastPublicIp = ($lines | Where-Object { $_ -match '^(?i)X-Fe-Last-Public-Client-Ip:' } | Select-Object -First 1) -replace '^(?i)X-Fe-Last-Public-Client-Ip:\s*', ''
        if (-not $firstPublicIP -and $xLastPublicIp) { $firstPublicIP = $xLastPublicIp }

        # Find envelope MailFrom (smtp.mailfrom)
        $mailFrom = $null
        if ($edgeAuth -and $edgeAuth.SPF_MailFrom) { $mailFrom = $edgeAuth.SPF_MailFrom }
        elseif ($originAuth -and $originAuth.SPF_MailFrom) { $mailFrom = $originAuth.SPF_MailFrom }
        elseif ($returnPath) { $mailFrom = $returnPath }

        $mailFromDomain = if ($mailFrom) { Get-Domain $mailFrom } else { $null }

        # Determine alignment & verdict
        $signals = [ordered]@{
            FromDomain        = $fromDomain
            MailFromDomain    = $mailFromDomain
            DKIM_Domains      = @()  # always an array
            SPF_Status_Edge   = $edgeAuth.SPF
            SPF_Status_Orig   = $originAuth.SPF
            DKIM_Status_Edge  = $edgeAuth.DKIM
            DKIM_Status_Orig  = $originAuth.DKIM
            DMARC_Status_Edge = $edgeAuth.DMARC
            DMARC_Status_Orig = $originAuth.DMARC
            ARC_Status_Edge   = $edgeAuth.ARC
            ARC_Status_Orig   = $originAuth.ARC
            CompAuth          = $edgeAuth.CompAuth
        }
    
        # Collect
        $dkimCollected = @()
        if ($edgeAuth -and ($edgeAuth.PSObject.Properties.Name -contains 'DKIM_Domains') -and $edgeAuth.DKIM_Domains) {
            $dkimCollected += @($edgeAuth.DKIM_Domains)
        }
        if ($originAuth -and ($originAuth.PSObject.Properties.Name -contains 'DKIM_Domains') -and $originAuth.DKIM_Domains) {
            $dkimCollected += @($originAuth.DKIM_Domains)
        }

        # De-dup & normalize
        $dkimDomains = @($dkimCollected | Where-Object { $_ } | Select-Object -Unique)
    
        # Prepare DKIM display vars from the finalized list (no $obj yet)
        $dkimList = @($dkimDomains)              # already unique & normalized
        $dkimCount = $dkimList.Count

        # (Optional) compute alignment now that we have final lists
        $dkimAligned = $false
        foreach ($d in $dkimDomains) {
            if ($fromDomain -and $d) {
                if ($d -eq $fromDomain -or $d -like "*.$fromDomain" -or $fromDomain -like "*.$d") {
                    $dkimAligned = $true; break
                }
            }
        }

        $spfAligned = $false
        if ($fromDomain -and $mailFromDomain) {
            if ($mailFromDomain -eq $fromDomain -or
                $mailFromDomain -like "*.$fromDomain" -or
                $fromDomain -like "*.$mailFromDomain") {
                $spfAligned = $true
            }
        }

        # Build reasons list (for human-readable explanations in summary/markdown, and also include in object for structured output)
        $reasons = New-Object System.Collections.Generic.List[string]
        # Determine best-available statuses (prefer edge if present; else origin)
        $spf = $signals.SPF_Status_Edge ?? $signals.SPF_Status_Orig
        $dkim = $signals.DKIM_Status_Edge ?? $signals.DKIM_Status_Orig
        $dmarc = $signals.DMARC_Status_Edge ?? $signals.DMARC_Status_Orig
        $arc = $signals.ARC_Status_Edge ?? $signals.ARC_Status_Orig

        if ($dmarc -eq 'pass') {
            $verdict = 'Low chance of phishing, etc. - Likely Legitimate'
            $reasons.Add('DMARC passed (aligned).')
        }
        elseif ($dkim -eq 'pass' -and $dkimAligned) {
            $verdict = 'Low chance of phishing, etc. - Likely Legitimate'
            $reasons.Add('DKIM passed and aligned with From domain.')
        }
        elseif ($spf -eq 'pass' -and $spfAligned) {
            $verdict = 'Low chance of phishing, etc. - Likely Legitimate'
            $reasons.Add('SPF passed and aligned with From domain.')
        }
        elseif ($dkim -eq 'pass' -and -not $dkimAligned) {
            $verdict = 'Medium - Possibly Legitimate - Check DKIM domains.'
            $reasons.Add('DKIM passed but appears misaligned with From domain (possible mailing list/forwarder).')
        }
        elseif ($arc -eq 'pass' -and $dmarc -ne 'pass') {
            $verdict = 'Medium - Possibly Legitimate - Check ARC/DMARC.'
            $reasons.Add('ARC passed but DMARC did not; forwarded/mediated message likely.')
        }
        else {
            # If we get here, likely spoof or badly configured sender
            $verdict = 'High - Likely Malicious - Failing DMARC/SPF/DKIM is a strong signal of spoofing/phishing.'
            if ($dmarc -eq 'fail') { $reasons.Add('DMARC failed.') }
            if ($dkim -in @('fail', 'none', $null)) { $reasons.Add('DKIM did not validate.') }
            if ($spf -in @('fail', 'softfail', 'none', $null)) { $reasons.Add('SPF did not validate.') }
            if (-not $fromDomain) { $reasons.Add('Unable to parse From domain.') }
        }

        # Build object
        $obj = [pscustomobject]@{
            Verdict     = $verdict
            Confidence  = if ($verdict -like 'Low*') { 'High' } elseif ($verdict -like 'Medium*') { 'Medium' } else { 'Variable' }
            Reasons     = $reasons              # always a list/array

            VisibleFrom = $fromAddr
            Sender      = $senderAddr
            ReturnPath  = $returnPath

            Domains     = [pscustomobject]@{
                From     = $fromDomain
                MailFrom = $mailFromDomain
                DKIM     = $dkimDomains         # normalized array
            }

            AuthSummary = [pscustomobject]@{
                Edge      = $edgeAuth
                Origin    = $originAuth
                Best      = [pscustomobject]@{
                    SPF   = ($signals.SPF_Status_Edge ?? $signals.SPF_Status_Orig)
                    DKIM  = ($signals.DKIM_Status_Edge ?? $signals.DKIM_Status_Orig)
                    DMARC = ($signals.DMARC_Status_Edge ?? $signals.DMARC_Status_Orig)
                    ARC   = ($signals.ARC_Status_Edge ?? $signals.ARC_Status_Orig)
                }
                Alignment = [pscustomobject]@{
                    DKIM_Aligned = $dkimAligned
                    SPF_Aligned  = $spfAligned
                }
                CompAuth  = $signals.CompAuth
            }

            Path        = [pscustomobject]@{
                FirstPublicIP = $firstPublicIP
                ReceivedHops  = $receivedLines
            }

            KeyHeaders  = [pscustomobject]@{
                Subject   = ($kv.Subject -replace '^(?i)Subject:\s*', '')
                MessageId = ($kv.MessageID -replace '^(?i)Message-Id:\s*', '')
            }
        }

        if ($Format -eq 'Object' -or $AsObject) {
            return $obj
        }
        elseif ($Format -eq 'Json') {
            return ($obj | ConvertTo-Json -Depth 6)
        }
        elseif ($Format -eq 'Markdown') {
            $md = @()
            $md += "# Mail Header Authentication Analysis"
            $md += ""
            $md += "**Verdict:** $($obj.Verdict)  "
            $md += "**Confidence:** $($obj.Confidence)"
            $md += ""

            if ($obj.Reasons -and $obj.Reasons.Count) {
                $md += "### Reasons"
                foreach ($r in $obj.Reasons) { $md += "- $r" }
                $md += ""
            }

            $md += "### Sender"
            $md += "- From: ``$($obj.VisibleFrom)``"
            if ($obj.Sender) {
                $md += "- Sender: ``$($obj.Sender)``"
            }
            if ($obj.ReturnPath) {
                $md += "- Return-Path: ``$($obj.ReturnPath)``"
            }

            $md += ""
            $md += "### Domains"
            $md += "- header.from: **$($obj.Domains.From)**"
            $md += "- smtp.mailfrom: **$($obj.Domains.MailFrom)**"
            $md += "- DKIM d=: **$([string]::Join(', ',$obj.Domains.DKIM))**"

            $md += ""
            $md += "### Authentication"
            $md += "- SPF: **$($obj.AuthSummary.Best.SPF)** (aligned: $($obj.AuthSummary.Alignment.SPF_Aligned))"
            $md += "- DKIM: **$($obj.AuthSummary.Best.DKIM)** (aligned: $($obj.AuthSummary.Alignment.DKIM_Aligned))"
            $md += "- DMARC: **$($obj.AuthSummary.Best.DMARC)**"
            if ($obj.AuthSummary.Best.ARC) { $md += "- ARC: **$($obj.AuthSummary.Best.ARC)**" }
            if ($obj.AuthSummary.CompAuth) { $md += "- CompAuth: **$($obj.AuthSummary.CompAuth)**" }

            $md += ""
            $md += "### Path"
            if ($obj.Path.FirstPublicIP) { $md += "- First public IP: **$($obj.Path.FirstPublicIP)**" }

            # Use a fenced code block for the Received chain
            # Created reusable helper for future use: Add-FencedBlock -Lines $obj.Path.ReceivedHops -Language 'txt'
            $md += "<details><summary>Received chain</summary>"
            $md += ""
            $md += Add-FencedBlock -Lines $obj.Path.ReceivedHops    # or -Language 'txt'
            $md += "</details>"

            $md += ""
            $md += "### Key Headers"
            if ($obj.KeyHeaders.Subject) { $md += "- Subject: $($obj.KeyHeaders.Subject)" }
            if ($obj.KeyHeaders.MessageId) { $md += "- Message-Id: $($obj.KeyHeaders.MessageId)" }
            $md += ""

            return ($md -join "`n")
        }
        else {
            # Summary (colorized handled inside Write-Log)
            Write-Log -level Info -Message ""
            Write-Log -level Info -Message ""
            Write-Log -Level OK -Message "Mail Header Authentication Analysis"
            Write-Log -Level OK -Message "-----------------------------------"
            Write-Log -level Info -Message ""
            Write-Log -Level Warn -Message ("Verdict: {0}" -f $obj.Verdict)
            Write-Log -Level Info -Message ("Confidence: {0}" -f $obj.Confidence)

            if ($obj.Reasons.Count) {
                Write-Log -Level OK -Message "Reasons:"
                $obj.Reasons | ForEach-Object {
                    Write-Log -Level Info -Message (" - {0}" -f $_)
                }
            }

            Write-Log -Level Info -Message ""
            Write-Log -Level OK -Message "Sender"

            Write-Log -Level Info -Message (" From: {0}" -f $obj.VisibleFrom)

            if ($obj.Sender) {
                Write-Log -Level Info -Message (" Sender: {0}" -f $obj.Sender)
            }
            if ($obj.ReturnPath) {
                Write-Log -Level Info -Message (" Return-Path: {0}" -f $obj.ReturnPath)
            }

            Write-Log -Level Info -Message ""
            Write-Log -Level OK -Message "Domains"
            Write-Log -Level Info -Message (" header.from: {0}" -f $obj.Domains.From)
            Write-Log -Level Info -Message (" smtp.mailfrom: {0}" -f $obj.Domains.MailFrom)
        
            # DKIM domains line
            Write-Log -Level Info -Message (" DKIM domains count: {0}" -f $dkimCount)
            if ($dkimCount -gt 0) {
                Write-Log -Level Info -Message (" dkim d=: {0}" -f ($dkimList -join ', '))
            }

            Write-Log -Level Info -Message ""
            Write-Log -Level OK -Message "Authentication"
            Write-Log -Level Info -Message (" SPF: {0} (aligned: {1})" -f $obj.AuthSummary.Best.SPF, $obj.AuthSummary.Alignment.SPF_Aligned)
            Write-Log -Level Info -Message (" DKIM: {0} (aligned: {1})" -f $obj.AuthSummary.Best.DKIM, $obj.AuthSummary.Alignment.DKIM_Aligned)
            Write-Log -Level Info -Message (" DMARC: {0}" -f $obj.AuthSummary.Best.DMARC)

            if ($obj.AuthSummary.Best.ARC) {
                Write-Log -Level Info -Message (" ARC: {0}" -f $obj.AuthSummary.Best.ARC)
            }
            if ($obj.AuthSummary.CompAuth) {
                Write-Log -Level Info -Message (" CompAuth: {0}" -f $obj.AuthSummary.CompAuth)
            }

            Write-Log -Level Info -Message ""
            Write-Log -Level OK -Message "Path"

            if ($obj.Path.FirstPublicIP) {
                Write-Log -Level Info -Message (" First public IP: {0}" -f $obj.Path.FirstPublicIP)
            }

            Write-Log -Level Info -Message (" Received hops: {0}" -f $obj.Path.ReceivedHops.Count)

            return $obj | Out-Null
        }
    }
    catch {
        Write-Log -Level Error -Message ("Error analyzing mail headers: {0}" -f $_.Exception.Message)
        return $null
    }
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Public\Test\Test-PathAs.ps1

function Test-PathAs {
    <#
    .SYNOPSIS
    Tests whether a path exists using alternate credentials.

    .DESCRIPTION
    Test-PathAs uses the TechToolbox impersonation subsystem to evaluate whether
    a file system path exists under the security context of the specified
    credential. This is useful for validating SMB access, deployment accounts,
    service accounts, and cross-domain permissions.

    .PARAMETER Path
    The file system or UNC path to test.

    .PARAMETER Credential
    The credential to impersonate while testing the path.

    .INPUTS
        None. You cannot pipe objects to Test-PathAs.

    .OUTPUTS
        [bool] $true if the path exists, otherwise $false.

    .EXAMPLE
    Test-PathAs -Path "\\server\share\installer.msi" -Credential $cred

    .EXAMPLE
    Test-PathAs -Path "C:\RestrictedFolder" -Credential $svc

    .LINK
        [TechToolbox](https://github.com/dan-damit/TechToolbox)
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)][string]$Path,
        [Parameter(Mandatory)][pscredential]$Credential
    )

    Invoke-Impersonation -Credential $Credential -ScriptBlock {
        Test-Path -LiteralPath $Path
    }
}
[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Workers\Enable-NetFx3.Worker.ps1
[CmdletBinding()]
param()

function Enable-NetFx3Core {
    [CmdletBinding()]
    param(
        [string]$Source,
        [int]$TimeoutMinutes = 45,
        [switch]$Validate,
        [switch]$NoRestart,
        [switch]$Quiet
    )

    $ErrorActionPreference = 'Stop'
    $overallSuccess = $false
    $exit = 1
    $state = $null
    $msg = $null

    try {
        $argsList = @(
            '/online',
            '/enable-feature',
            '/featurename:NetFx3',
            '/All'
        )

        if ($Quiet) { $argsList += '/Quiet' }
        if ($NoRestart) { $argsList += '/NoRestart' }

        if ($Source) {
            $argsList += "/Source:`"$Source`""
            $argsList += '/LimitAccess'
        }

        $psi = New-Object System.Diagnostics.ProcessStartInfo
        $psi.FileName = 'dism.exe'
        $psi.Arguments = ($argsList -join ' ')
        $psi.UseShellExecute = $false
        $psi.RedirectStandardOutput = $true
        $psi.RedirectStandardError = $true

        $proc = New-Object System.Diagnostics.Process
        $proc.StartInfo = $psi

        if (-not $proc.Start()) {
            $msg = "Failed to start DISM."
            throw $msg
        }

        $proc.BeginOutputReadLine()
        $proc.BeginErrorReadLine()

        $timeoutMs = [int][TimeSpan]::FromMinutes([Math]::Max(1, $TimeoutMinutes)).TotalMilliseconds
        if (-not $proc.WaitForExit($timeoutMs)) {
            try { $proc.Kill() } catch {}
            $msg = "Timeout after $TimeoutMinutes minutes."
            $exit = 1
        }
        else {
            $exit = $proc.ExitCode
            if ($exit -in 0, 3010) {
                $overallSuccess = $true
            }
            else {
                $msg = "DISM failed with exit code $exit."
            }
        }

        if ($overallSuccess -and $Validate) {
            try {
                $state = (Get-WindowsOptionalFeature -Online -FeatureName NetFx3).State
                if ($state -notin 'Enabled', 'EnablePending', 'EnabledPending') {
                    $overallSuccess = $false
                    if (-not $msg) { $msg = "Feature state after enablement: $state" }
                    if ($exit -in 0, 3010) { $exit = 1 }
                }
            }
            catch {
                if (-not $msg) { $msg = "Validation failed: $($_.Exception.Message)" }
            }
        }
    }
    catch {
        $msg = $_.Exception.Message
    }

    [pscustomobject]@{
        ComputerName   = $env:COMPUTERNAME
        ExitCode       = $exit
        Success        = [bool]$overallSuccess
        RebootRequired = ($exit -eq 3010)
        State          = $state
        Message        = $msg
    }
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Workers\Find-LargeFiles.Worker.ps1
[CmdletBinding()]
param()

function Find-LargeFilesCore {
    [CmdletBinding()]
    param(
        [string[]]$SearchDirectory,
        [int]$MinSizeMB,
        [int]$Depth,
        [switch]$UseDepth
    )

    $minBytes = [int64]$MinSizeMB * 1MB
    $results = New-Object System.Collections.Generic.List[object]

    foreach ($root in $SearchDirectory) {
        try {
            $gciParams = @{
                Path        = $root
                File        = $true
                Recurse     = $true
                ErrorAction = 'SilentlyContinue'
                Force       = $true
            }

            if ($UseDepth) {
                $gciParams['Depth'] = $Depth
            }

            Get-ChildItem @gciParams |
            Where-Object { $_.Length -ge $minBytes } |
            Sort-Object Length -Descending |
            ForEach-Object {
                $results.Add([pscustomobject]@{
                        FullName = $_.FullName
                        SizeMB   = [math]::Round(($_.Length / 1MB), 2)
                    })
            }
        }
        catch {
            $results.Add([pscustomobject]@{
                    FullName = "<ERROR scanning $root>"
                    SizeMB   = 0
                    Error    = $_.Exception.Message
                })
        }
    }

    return $results
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Workers\Get-RemoteInstalledSoftware.Worker.ps1
[CmdletBinding()]
param()

function Convert-InstallDate {
    [CmdletBinding()]
    param([string]$Raw)

    if ([string]::IsNullOrWhiteSpace($Raw)) { return $null }

    $s = $Raw.Trim()
    if ($s -match '^\d{8}$') {
        try { return [datetime]::ParseExact($s, 'yyyyMMdd', $null) } catch {}
    }

    try { return [datetime]::Parse($s) } catch { return $null }
}

function Get-UninstallFromPath {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)][string]$RegPath,
        [Parameter(Mandatory)][string]$Scope,
        [Parameter(Mandatory)][string]$Arch
    )

    $results = @()

    try {
        $keys = Get-ChildItem -Path $RegPath -ErrorAction SilentlyContinue
        foreach ($k in $keys) {
            $p = Get-ItemProperty -Path $k.PSPath -ErrorAction SilentlyContinue
            if ($p.DisplayName) {
                $results += [PSCustomObject]@{
                    ComputerName    = $env:COMPUTERNAME
                    DisplayName     = $p.DisplayName
                    DisplayVersion  = $p.DisplayVersion
                    Publisher       = $p.Publisher
                    InstallDate     = Convert-InstallDate $p.InstallDate
                    UninstallString = $p.UninstallString
                    InstallLocation = $p.InstallLocation
                    EstimatedSizeKB = $p.EstimatedSize
                    Scope           = $Scope
                    Architecture    = $Arch
                    Source          = 'Registry'
                    RegistryPath    = $k.PSPath
                }
            }
        }
    }
    catch {}

    return $results
}

function Get-RemoteInstalledSoftwareCore {
    [CmdletBinding()]
    param(
        [switch]$IncludeAppx
    )

    $items = @()

    # HKLM
    $items += Get-UninstallFromPath -RegPath "HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall" -Scope 'Machine' -Arch 'x64'
    $items += Get-UninstallFromPath -RegPath "HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall" -Scope 'Machine' -Arch 'x86'

    # HKCU
    $items += Get-UninstallFromPath -RegPath "HKCU:\Software\Microsoft\Windows\CurrentVersion\Uninstall" -Scope 'User(Current)' -Arch 'x64'
    $items += Get-UninstallFromPath -RegPath "HKCU:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall" -Scope 'User(Current)' -Arch 'x86'

    # HKU (other logged-in users)
    try {
        $userHives = Get-ChildItem HKU:\ -ErrorAction SilentlyContinue |
        Where-Object { $_.Name -match '^HKEY_USERS\\S-1-5-21-' }

        foreach ($hive in $userHives) {
            $sid = $hive.PSChildName
            $items += Get-UninstallFromPath -RegPath "HKU:\$sid\Software\Microsoft\Windows\CurrentVersion\Uninstall" -Scope "User($sid)" -Arch 'x64'
            $items += Get-UninstallFromPath -RegPath "HKU:\$sid\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall" -Scope "User($sid)" -Arch 'x86'
        }
    }
    catch {}

    # AppX/MSIX
    if ($IncludeAppx) {
        try {
            $items += Get-AppxPackage -AllUsers -ErrorAction SilentlyContinue |
            ForEach-Object {
                [PSCustomObject]@{
                    ComputerName    = $env:COMPUTERNAME
                    DisplayName     = $_.Name
                    DisplayVersion  = $_.Version.ToString()
                    Publisher       = $_.Publisher
                    InstallDate     = $null
                    UninstallString = $null
                    InstallLocation = $_.InstallLocation
                    EstimatedSizeKB = $null
                    Scope           = 'Appx(AllUsers)'
                    Architecture    = 'Appx/MSIX'
                    Source          = 'Appx'
                    RegistryPath    = $_.PackageFullName
                }
            }
        }
        catch {}
    }

    return $items
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Workers\Get-SystemSnapshot.Worker.ps1
function Get-SystemSnapshotCore {
    <#
    .SYNOPSIS
        Worker entry point: builds a system snapshot on the remote host.

    .DESCRIPTION
        Runs ON the remote computer. Assumes the caller (Invoke-TTRemoteWorker)
        has already staged helper scripts onto the remote machine and passed in
        the resolved HelpersPath. This function dot-sources those helpers and
        emits a PSCustomObject snapshot. No formatting, no exporting, no exits.

    .PARAMETER HelpersPath
        Directory containing helper .ps1 files shipped from the controller.

    .PARAMETER IncludeServices
        Switch to include service information.

    .PARAMETER IncludeRoles
        Switch to include server role information (passed through to OS helper).
    #>

    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$HelpersPath,

        [switch]$IncludeServices = $true,
        [switch]$IncludeRoles = $true
    )

    # ----- Validate helper directory -----
    if (-not (Test-Path -LiteralPath $HelpersPath)) {
        throw "HelpersPath '$HelpersPath' not found on remote host."
    }

    # ----- Required helpers -----
    $required = @(
        'Convert-CimDate.ps1',
        'Get-SnapshotOS.ps1',
        'Get-SnapshotCPU.ps1',
        'Get-SnapshotMemory.ps1',
        'Get-SnapshotDisk.ps1',
        'Get-SnapshotNetwork.ps1',
        'Get-SnapshotIdentity.ps1'
    )

    # Optional helpers
    if ($IncludeServices) { $required += 'Get-SnapshotServices.ps1' }

    # Dot-source required helpers
    foreach ($file in $required) {
        $full = Join-Path $HelpersPath $file
        if (-not (Test-Path -LiteralPath $full)) {
            throw "Required helper missing: $full"
        }
        . $full
    }

    # ----- Gather subsystem information -----
    try {
        $cimDate = Convert-CimDate
        $osInfo = Get-SnapshotOS -IncludeRoles:$IncludeRoles
        $cpuInfo = Get-SnapshotCPU
        $memoryInfo = Get-SnapshotMemory
        $diskInfo = Get-SnapshotDisk
        $netInfo = Get-SnapshotNetwork
        $identity = Get-SnapshotIdentity

        $services = $null
        if ($IncludeServices) {
            $services = Get-SnapshotServices
        }

        # ----- Build snapshot object -----
        [pscustomobject]@{
            ComputerName = $env:COMPUTERNAME
            Timestamp    = Get-Date
            OS           = $osInfo
            CPU          = $cpuInfo
            Memory       = $memoryInfo
            Disks        = $diskInfo
            Network      = $netInfo
            Identity     = $identity
            Services     = $services
        }
    }
    catch {
        throw "Snapshot worker failed: $($_.Exception.Message)"
    }
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Workers\Get-SystemUptime.Worker.ps1
[CmdletBinding()]
param()

function Convert-CimDate {
    param([Parameter(ValueFromPipeline)][object]$CimDate)
    if ($null -eq $CimDate) { return $null }

    if ($CimDate -is [datetime]) { return [datetime]$CimDate }

    if ($CimDate -is [string] -and -not [string]::IsNullOrWhiteSpace($CimDate)) {
        try {
            return [Management.ManagementDateTimeConverter]::ToDateTime($CimDate)
        }
        catch { return $null }
    }

    return $null
}

function Format-TimeSpanCompact {
    param([timespan]$Span)
    $parts = @()
    if ($Span.Days -gt 0) { $parts += ("{0}d" -f $Span.Days) }
    $parts += ("{0:hh}h" -f $Span)
    $parts += ("{0:mm}m" -f $Span)
    $parts += ("{0:ss}s" -f $Span)
    $parts -join ' '
}

function Get-SystemUptimeCore {
    [CmdletBinding()]
    param()

    try {
        $os = Get-CimInstance -ClassName Win32_OperatingSystem -ErrorAction Stop
        $lastBoot = Convert-CimDate $os.LastBootUpTime

        $uptimeSeconds = $null
        $uptime = $null

        if ($lastBoot) {
            $span = (Get-Date) - $lastBoot
            $uptimeSeconds = [int][math]::Round($span.TotalSeconds, 0)
            $uptime = Format-TimeSpanCompact -Span $span
        }

        [pscustomobject]@{
            PSComputerName = $env:COMPUTERNAME
            LastBootUpTime = $lastBoot
            UptimeSeconds  = $uptimeSeconds
            Uptime         = $uptime
        }
    }
    catch {
        Write-Error ("Get-SystemUptimeCore failed: {0}" -f $_.Exception.Message)
    }
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Workers\Get-WindowsProductKey.Worker.ps1
[CmdletBinding()]
param()

function Get-WindowsProductKeyCore {
    [CmdletBinding()]
    param()

    $computerName = $env:COMPUTERNAME

    # OEM Product Key
    try {
        $oemKey = (Get-CimInstance -ClassName 'SoftwareLicensingService' -ErrorAction Stop).OA3xOriginalProductKey
    }
    catch {
        $oemKey = $null
    }

    # Partial Keys
    try {
        $partialKeys = Get-CimInstance -ClassName 'SoftwareLicensingProduct' -ErrorAction Stop |
        Where-Object { $_.PartialProductKey } |
        Select-Object Name, Description, LicenseStatus, PartialProductKey
    }
    catch {
        $partialKeys = $null
    }

    # Activation Report
    try {
        $slmgrOutput = cscript.exe //Nologo C:\Windows\System32\slmgr.vbs /dlv 2>&1
        $slmgrOutput = $slmgrOutput -join "`n"
    }
    catch {
        $slmgrOutput = "Failed to retrieve slmgr report: $($_.Exception.Message)"
    }

    [pscustomobject]@{
        ComputerName     = $computerName
        OemProductKey    = $oemKey
        PartialKeys      = $partialKeys
        ActivationReport = $slmgrOutput
    }
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Workers\Invoke-DownloadsCleanup.Worker.ps1
[CmdletBinding()]
param()

function Invoke-DownloadsCleanupCore {
    [CmdletBinding()]
    param(
        [int]$CutoffYear,
        [switch]$DryRun
    )

    $basePath = "C:\Users"
    $users = Get-ChildItem -Path $basePath -Directory -ErrorAction SilentlyContinue

    $report = @()

    foreach ($user in $users) {
        $downloadsPath = Join-Path $user.FullName "Downloads"

        if (-not (Test-Path $downloadsPath)) {
            $report += [pscustomobject]@{
                User    = $user.Name
                Path    = $downloadsPath
                Status  = "No Downloads folder"
                Deleted = 0
            }
            continue
        }

        $oldFiles = Get-ChildItem -Path $downloadsPath -Recurse -File -ErrorAction SilentlyContinue |
        Where-Object { $_.LastWriteTime.Year -le $CutoffYear }

        $deletedCount = 0

        foreach ($file in $oldFiles) {
            if ($DryRun) {
                $deletedCount++
                continue
            }

            try {
                Remove-Item -Path $file.FullName -Force -ErrorAction Stop
                $deletedCount++
            }
            catch {
                $report += [pscustomobject]@{
                    User    = $user.Name
                    Path    = $file.FullName
                    Status  = "Failed: $($_.Exception.Message)"
                    Deleted = 0
                }
            }
        }

        $report += [pscustomobject]@{
            User    = $user.Name
            Path    = $downloadsPath
            Status  = "OK"
            Deleted = $deletedCount
        }
    }

    return $report
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Workers\Invoke-SystemRepair.Worker.ps1
[CmdletBinding()]
param()

function Invoke-SystemRepairCore {
    [CmdletBinding()]
    param(
        [switch]$RestoreHealth,
        [switch]$StartComponentCleanup,
        [switch]$ResetBase,
        [switch]$SfcScannow,
        [switch]$ResetUpdateComponents
    )

    $results = [ordered]@{
        ComputerName          = $env:COMPUTERNAME
        RestoreHealthResult   = $null
        StartComponentCleanup = $null
        ResetBaseResult       = $null
        SfcResult             = $null
        ResetWUResult         = $null
    }

    function Invoke-DismCommand {
        param([string[]]$Args)

        $psi = New-Object System.Diagnostics.ProcessStartInfo
        $psi.FileName = 'dism.exe'
        $psi.Arguments = ($Args -join ' ')
        $psi.UseShellExecute = $false
        $psi.RedirectStandardOutput = $true
        $psi.RedirectStandardError = $true

        $proc = New-Object System.Diagnostics.Process
        $proc.StartInfo = $psi

        if (-not $proc.Start()) {
            return [pscustomobject]@{
                Success  = $false
                ExitCode = 1
                Message  = 'Failed to start DISM.'
            }
        }

        $out = New-Object System.Collections.Generic.List[string]
        $err = New-Object System.Collections.Generic.List[string]

        $proc.add_OutputDataReceived({ param($s, $e) if ($e.Data) { [void]$out.Add($e.Data) } })
        $proc.add_ErrorDataReceived( { param($s, $e) if ($e.Data) { [void]$err.Add($e.Data) } })
        $proc.BeginOutputReadLine()
        $proc.BeginErrorReadLine()

        $proc.WaitForExit()
        $exit = $proc.ExitCode

        [pscustomobject]@{
            Success  = ($exit -eq 0)
            ExitCode = $exit
            Message  = ($err -join "`n")
            Output   = ($out -join "`n")
        }
    }

    if ($RestoreHealth) {
        try {
            $r = Invoke-DismCommand -Args @('/online', '/cleanup-image', '/restorehealth')
            $results.RestoreHealthResult = $r
        }
        catch {
            $results.RestoreHealthResult = [pscustomobject]@{
                Success  = $false
                ExitCode = 1
                Message  = $_.Exception.Message
            }
        }
    }

    if ($StartComponentCleanup) {
        try {
            $r = Invoke-DismCommand -Args @('/online', '/cleanup-image', '/startcomponentcleanup')
            $results.StartComponentCleanup = $r
        }
        catch {
            $results.StartComponentCleanup = [pscustomobject]@{
                Success  = $false
                ExitCode = 1
                Message  = $_.Exception.Message
            }
        }
    }

    if ($ResetBase) {
        try {
            $r = Invoke-DismCommand -Args @('/online', '/cleanup-image', '/startcomponentcleanup', '/resetbase')
            $results.ResetBaseResult = $r
        }
        catch {
            $results.ResetBaseResult = [pscustomobject]@{
                Success  = $false
                ExitCode = 1
                Message  = $_.Exception.Message
            }
        }
    }

    if ($SfcScannow) {
        try {
            $sfc = & sfc.exe /scannow 2>&1
            $results.SfcResult = [pscustomobject]@{
                Success = $true
                Output  = ($sfc -join "`n")
            }
        }
        catch {
            $results.SfcResult = [pscustomobject]@{
                Success = $false
                Output  = "SFC failed: $($_.Exception.Message)"
            }
        }
    }

    if ($ResetUpdateComponents) {
        try {
            if (Get-Command -Name Reset-WindowsUpdateComponents -ErrorAction SilentlyContinue) {
                $wu = Reset-WindowsUpdateComponents
                $results.ResetWUResult = $wu
            }
            else {
                $results.ResetWUResult = [pscustomobject]@{
                    Success = $false
                    Message = 'Reset-WindowsUpdateComponents not available on remote host.'
                }
            }
        }
        catch {
            $results.ResetWUResult = [pscustomobject]@{
                Success = $false
                Message = "WU reset failed: $($_.Exception.Message)"
            }
        }
    }

    [pscustomobject]$results
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Workers\RemoteSystemCollection.Worker.ps1
# RemoteSystemCollection.Worker.ps1
param(
    [string]$ArgsPath
)

$ErrorActionPreference = 'Stop'

# Read args
$cfgRaw = if ($ArgsPath -and (Test-Path -LiteralPath $ArgsPath -ErrorAction SilentlyContinue)) {
    Get-Content -LiteralPath $ArgsPath -Raw -Encoding UTF8
}
else { $null }

$cfg = if ($cfgRaw) { $cfgRaw | ConvertFrom-Json } else { $null }

# Extract settings
$timestamp = if ($cfg.Timestamp) { [string]$cfg.Timestamp } else { (Get-Date -Format 'yyyyMMdd-HHmmss') }
$connectPath = if ($cfg.ConnectDataPath) { [string]$cfg.ConnectDataPath } else { (Join-Path $env:ProgramData 'PDQ\PDQConnectAgent') }
$extra = @()
if ($cfg.ExtraPaths) {
    if ($cfg.ExtraPaths -is [string]) { $extra = @($cfg.ExtraPaths) }
    elseif ($cfg.ExtraPaths -is [System.Collections.IEnumerable]) { $extra = @($cfg.ExtraPaths) }
}

# Paths
$tempRoot = Join-Path $env:windir 'Temp'
$staging = Join-Path $tempRoot ("PDQDiag_{0}_{1}" -f $env:COMPUTERNAME, $timestamp)
$zipPath = Join-Path $tempRoot ("PDQDiag_{0}_{1}.zip" -f $env:COMPUTERNAME, $timestamp)
$doneFlg = Join-Path $staging 'system_done.flag'
$copyErr = Join-Path $staging 'copy-errors.log'

# Clean & create staging
if (Test-Path $staging) { Remove-Item $staging -Recurse -Force -ErrorAction SilentlyContinue }
New-Item -ItemType Directory -Path $staging -Force | Out-Null

# Build PDQ paths
$pdqPaths = @(
    'C:\ProgramData\Admin Arsenal\PDQ Deploy\Logs'
    'C:\ProgramData\Admin Arsenal\PDQ Inventory\Logs'
    'C:\Windows\Temp\PDQDeployRunner'
    'C:\Windows\Temp\PDQInventory'
    (Join-Path $env:SystemRoot 'System32\Winevt\Logs\PDQ.com.evtx')
)
if ($connectPath) {
    $pdqPaths += (Join-Path $connectPath 'PDQConnectAgent.db')
    $pdqPaths += (Join-Path $connectPath 'Updates\install.log')
}

# Normalize extras (PS 5.1-safe)
$extras = if ($null -eq $extra -or -not $extra) { @() } else { $extra }

# Resilient copy helper (Copy-Item  robocopy /B)
function Copy-PathResilient {
    param([string]$SourcePath, [string]$StagingRoot)

    if (-not (Test-Path -LiteralPath $SourcePath -ErrorAction SilentlyContinue)) { return $false }

    $leaf = Split-Path -Leaf $SourcePath
    $dest = Join-Path $StagingRoot $leaf

    try {
        $it = Get-Item -LiteralPath $SourcePath -ErrorAction Stop
        if ($it -is [IO.DirectoryInfo]) {
            New-Item -ItemType Directory -Path $dest -Force | Out-Null
            Copy-Item -LiteralPath $SourcePath -Destination $dest -Recurse -Force -ErrorAction Stop
        }
        else {
            Copy-Item -LiteralPath $SourcePath -Destination $dest -Force -ErrorAction Stop
        }
        return $true
    }
    catch {
        $primary = $_.Exception.Message
        try {
            $rc = Get-Command robocopy.exe -ErrorAction SilentlyContinue
            if (-not $rc) { throw "robocopy.exe not found" }
            $it2 = Get-Item -LiteralPath $SourcePath -ErrorAction SilentlyContinue
            if ($it2 -is [IO.DirectoryInfo]) {
                New-Item -ItemType Directory -Path $dest -Force | Out-Null
                $null = & $rc.Source $SourcePath $dest /E /R:0 /W:0 /NFL /NDL /NJH /NJS /NS /NP /COPY:DAT /B
            }
            else {
                $srcDir = Split-Path -Parent $SourcePath
                $file = Split-Path -Leaf   $SourcePath
                New-Item -ItemType Directory -Path $StagingRoot -Force | Out-Null
                $null = & $rc.Source $srcDir $StagingRoot $file /R:0 /W:0 /NFL /NDL /NJH /NJS /NS /NP /COPY:DAT /B
            }
            if ($LASTEXITCODE -lt 8) { return $true }
            Add-Content -Path $copyErr -Value ("{0} | robocopy exit {1} | {2}" -f (Get-Date), $LASTEXITCODE, $SourcePath) -Encoding UTF8
            return $false
        }
        catch {
            Add-Content -Path $copyErr -Value ("{0} | Copy failed: {1} | {2}" -f (Get-Date), $primary, $SourcePath) -Encoding UTF8
            return $false
        }
    }
}

# Merge non-empty paths (no pre-Test-Path to avoid "Access denied" noise)
$all = @($pdqPaths; $extras) | Where-Object { $_ } | Select-Object -Unique
foreach ($p in $all) { try { Copy-PathResilient -SourcePath $p -StagingRoot $staging } catch {} }

# Export event log by name (avoids in-use copy issues)
try {
    $destEvtx = Join-Path $staging 'PDQ.com.evtx'
    if (-not (Test-Path -LiteralPath $destEvtx -ErrorAction SilentlyContinue)) {
        $logName = 'PDQ.com'
        $wevt = Join-Path $env:windir 'System32\wevtutil.exe'
        $sysnative = Join-Path $env:windir 'Sysnative\wevtutil.exe'
        if (Test-Path -LiteralPath $sysnative) { $wevt = $sysnative }
        $psi = New-Object System.Diagnostics.ProcessStartInfo
        $psi.FileName = $wevt
        $psi.Arguments = "epl `"$logName`" `"$destEvtx`""
        $psi.CreateNoWindow = $true
        $psi.UseShellExecute = $false
        $psi.RedirectStandardOutput = $true
        $psi.RedirectStandardError = $true
        $p = [Diagnostics.Process]::Start($psi); $p.WaitForExit()
        if ($p.ExitCode -ne 0) {
            $err = $p.StandardError.ReadToEnd()
            Add-Content -Path $copyErr -Value ("{0} | wevtutil failed ({1}): {2}" -f (Get-Date), $p.ExitCode, $err) -Encoding UTF8
        }
    }
}
catch {
    Add-Content -Path $copyErr -Value ("{0} | wevtutil exception: {1}" -f (Get-Date), $_.Exception.Message) -Encoding UTF8
}

# Useful metadata
try {
    Get-CimInstance Win32_Service |
    Where-Object { $_.Name -like 'PDQ*' -or $_.DisplayName -like '*PDQ*' } |
    Select-Object Name, DisplayName, State, StartMode |
    Export-Csv -Path (Join-Path $staging 'services.csv') -NoTypeInformation -Encoding UTF8
}
catch {}
try {
    Get-ItemProperty 'HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\*' |
    Where-Object { $_.DisplayName -match 'PDQ' -or $_.Publisher -match 'Admin Arsenal' } |
    Select-Object DisplayName, DisplayVersion, Publisher, InstallDate |
    Export-Csv -Path (Join-Path $staging 'installed.csv') -NoTypeInformation -Encoding UTF8
}
catch {}
try {
    $sys = Get-ComputerInfo -ErrorAction SilentlyContinue
    if ($sys) { $sys | ConvertTo-Json -Depth 3 | Set-Content -Path (Join-Path $staging 'computerinfo.json') -Encoding UTF8 }
    $PSVersionTable | Out-String | Set-Content -Path (Join-Path $staging 'psversion.txt') -Encoding UTF8
}
catch {}

# If folder is empty, drop a readme so Compress-Archive has input
if (-not (Get-ChildItem -Path $staging -Recurse -Force | Select-Object -First 1)) {
    "No PDQ artifacts were found." | Set-Content -Path (Join-Path $staging 'readme.txt') -Encoding UTF8
}

# Zip
if (Test-Path $zipPath) { Remove-Item -LiteralPath $zipPath -Force -ErrorAction SilentlyContinue }
Compress-Archive -Path (Join-Path $staging '*') -DestinationPath $zipPath -Force

# Done flag (intentionally after zip so it's not included)
"ZipPath=$zipPath" | Set-Content -Path $doneFlg -Encoding UTF8

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Workers\Remove-EpicorEdgeAgent.Worker.ps1
<#
.SYNOPSIS
    Worker script to fully scrub Epicor Edge Agent from a computer.

.DESCRIPTION
    Deep removal including:
      - Stop processes/services
      - MSI uninstall via registry Uninstall keys (avoids Win32_Product)
      - Remove scheduled tasks
      - Delete program/appdata folders
      - Remove registry keys

.PARAMETER AnalyzeOnly
    When supplied, perform a dry-run and DO NOT change the system.
#>

param(
    [switch]$AnalyzeOnly
)

# ----------------------------
# INITIALIZATION
# ----------------------------

$Result = [ordered]@{
    ComputerName        = $env:COMPUTERNAME
    AnalyzeOnly         = $AnalyzeOnly.IsPresent
    Status              = "Started"
    StartTime           = (Get-Date)
    DurationS           = $null
    ServicesStopped     = New-Object System.Collections.Generic.List[string]
    ProcessesKilled     = New-Object System.Collections.Generic.List[string]
    PackagesUninstalled = New-Object System.Collections.Generic.List[string]
    TasksRemoved        = New-Object System.Collections.Generic.List[string]
    DirsRemoved         = New-Object System.Collections.Generic.List[string]
    RegKeysRemoved      = New-Object System.Collections.Generic.List[string]
    Warnings            = New-Object System.Collections.Generic.List[string]
    Errors              = New-Object System.Collections.Generic.List[string]
    Actions             = New-Object System.Collections.Generic.List[string]
}

function Write-Action($msg) {
    Write-Host "[+] $msg" -ForegroundColor Cyan
    $Result.Actions.Add($msg) | Out-Null
}
function Write-Err($msg) {
    Write-Host "[!] $msg" -ForegroundColor Red
    $Result.Errors.Add($msg) | Out-Null
}
function Write-Warn($msg) {
    Write-Warning $msg
    $Result.Warnings.Add($msg) | Out-Null
}

# Require elevation for actual changes (not for AnalyzeOnly)
$IsAdmin = ([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()
).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)

if (-not $IsAdmin -and -not $AnalyzeOnly) {
    Write-Err "Administrator privileges are required. Re-run elevated or use -AnalyzeOnly."
    $Result.Status = "Failed"
    $Result.EndTime = Get-Date
    $Result.DurationS = [math]::Round(($Result.EndTime - $Result.StartTime).TotalSeconds, 2)
    return [pscustomobject]$Result
}

# ----------------------------
# STOP SERVICES (best-effort)
# ----------------------------

Write-Action "Stopping Epicor / Edge Agent services..."
$svcCandidates = Get-Service | Where-Object { $_.Name -match "Epicor|Edge|Kinetic" }

foreach ($svc in $svcCandidates) {
    try {
        if ($AnalyzeOnly) {
            Write-Action "[ANALYZE] Would stop service: $($svc.Name)"
            continue
        }
        if ($svc.Status -ne 'Stopped') {
            Stop-Service -Name $svc.Name -Force -ErrorAction Stop
            Write-Action "Stopped service: $($svc.Name)"
            $Result.ServicesStopped.Add($svc.Name) | Out-Null
        }
    }
    catch {
        Write-Err "Failed to stop service: $($svc.Name) :: $($_.Exception.Message)"
    }
}

# ----------------------------
# KILL PROCESSES
# ----------------------------

Write-Action "Killing Epicor / Edge Agent processes..."
$processTargets = @(
    "Epicor.EA.Tray",
    "Epicor.EA.Agent",
    "EdgeAgent",
    "Epicor"          # broad catch; safe as try/catch + SilentlyContinue
)

foreach ($p in $processTargets) {
    $procs = Get-Process -Name $p -ErrorAction SilentlyContinue
    foreach ($proc in $procs) {
        try {
            if ($AnalyzeOnly) {
                Write-Action "[ANALYZE] Would kill process: $($proc.ProcessName) (PID=$($proc.Id))"
                continue
            }
            $proc | Stop-Process -Force
            Write-Action "Killed process: $($proc.ProcessName) (PID=$($proc.Id))"
            $Result.ProcessesKilled.Add("$($proc.ProcessName)[$($proc.Id)]") | Out-Null
        }
        catch {
            Write-Err "Failed to kill process: $($proc.ProcessName) :: $($_.Exception.Message)"
        }
    }
}

# ----------------------------
# MSI UNINSTALL via Registry (no Win32_Product)
# ----------------------------

Write-Action "Searching for Epicor Edge Agent uninstall entries..."
$uninstallRoots = @(
    'HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall',
    'HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall'
)

$entries = foreach ($root in $uninstallRoots) {
    Get-ChildItem -LiteralPath $root -ErrorAction SilentlyContinue | ForEach-Object {
        try {
            $p = Get-ItemProperty -LiteralPath $_.PSPath -ErrorAction Stop
            if ($p.DisplayName -and ($p.DisplayName -match '(?i)Epicor.*Edge.*Agent|^Epicor Edge Agent$')) { $p }
        }
        catch {}
    }
}

function Invoke-SilentUninstall {
    param(
        [Parameter(Mandatory)] [string]$DisplayName,
        [Parameter(Mandatory)] [string]$UninstallString
    )
    $msiGuid = [regex]::Match($UninstallString, '{[0-9A-Fa-f\-]+}').Value
    $isMsiexec = ($UninstallString -match '(?i)msiexec\.exe')

    if ($isMsiexec -and $msiGuid) {
        $cmd = "msiexec.exe"
        $args = "/x $msiGuid /qn /norestart"
        if ($AnalyzeOnly) {
            Write-Action "[ANALYZE] Would uninstall MSI: $DisplayName -> $cmd $args"
            return $true
        }
        $p = Start-Process -FilePath $cmd -ArgumentList $args -Wait -PassThru -WindowStyle Hidden
        if ($p.ExitCode -eq 0) { return $true } else {
            Write-Err "MSI uninstall failed ($DisplayName). ExitCode=$($p.ExitCode)"
            return $false
        }
    }

    # Direct MSI path?
    if ($UninstallString -match '(?i)\.msi') {
        # Extract quoted path if present
        $msiPath = $null
        if ($UninstallString -match '"([^"]+\.msi)"') { $msiPath = $matches[1] }
        else {
            # Fallback: split and locate first token ending with .msi
            $token = ($UninstallString -split '\s+') | Where-Object { $_ -match '(?i)\.msi$' } | Select-Object -First 1
            if ($token) { $msiPath = $token }
        }
        if ($msiPath) {
            $cmd = "msiexec.exe"
            $args = "/x `"$msiPath`" /qn /norestart"
            if ($AnalyzeOnly) {
                Write-Action "[ANALYZE] Would uninstall MSI path: $DisplayName -> $cmd $args"
                return $true
            }
            $p = Start-Process -FilePath $cmd -ArgumentList $args -Wait -PassThru -WindowStyle Hidden
            if ($p.ExitCode -eq 0) { return $true } else {
                Write-Err "MSI path uninstall failed ($DisplayName). ExitCode=$($p.ExitCode)"
                return $false
            }
        }
    }

    # Unknown EXE uninstaller: attempt common silent switches (best-effort)
    $exe = $null; $argsExisting = $null
    if ($UninstallString -match '^\s*"([^"]+\.exe)"\s*(.*)$') {
        $exe = $matches[1]; $argsExisting = $matches[2]
    }
    elseif ($UninstallString -match '^\s*(\S+\.exe)\s*(.*)$') {
        $exe = $matches[1]; $argsExisting = $matches[2]
    }

    if ($exe) {
        $silentSwitches = @('/S', '/silent', '/quiet', '/VERYSILENT')
        if ($AnalyzeOnly) {
            Write-Action "[ANALYZE] Would try EXE uninstall: $DisplayName -> `"$exe`" $argsExisting + (one of $($silentSwitches -join ', '))"
            return $true
        }
        foreach ($sw in $silentSwitches) {
            try {
                $proc = Start-Process -FilePath $exe -ArgumentList "$argsExisting $sw" -Wait -PassThru -WindowStyle Hidden
                if ($proc.ExitCode -eq 0) { return $true }
            }
            catch {}
        }
        Write-Warn "EXE uninstall may require vendor-specific silent switch: ${DisplayName}"
        return $false
    }

    Write-Warn "Unrecognized uninstall string for ${DisplayName}: $UninstallString"
    return $false
}

foreach ($e in $entries) {
    if (-not $e.UninstallString) { continue }
    $name = $e.DisplayName
    $ok = Invoke-SilentUninstall -DisplayName $name -UninstallString $e.UninstallString
    if ($ok) { $Result.PackagesUninstalled.Add($name) | Out-Null }
}

# ----------------------------
# REMOVE SCHEDULED TASKS
# ----------------------------

Write-Action "Removing Epicor-related scheduled tasks..."
$removedTasks = 0
try {
    $tasks = Get-ScheduledTask -ErrorAction Stop | Where-Object {
        $_.TaskName -match '(?i)Epicor|Edge|Kinetic' -or $_.TaskPath -match '(?i)Epicor|Edge|Kinetic'
    }
}
catch {
    $tasks = @()
}

if (-not $tasks -or $tasks.Count -eq 0) {
    # Fallback to schtasks parsing
    $raw = schtasks /Query /FO LIST 2>$null | Select-String "TaskName:"
    $tasks = foreach ($line in $raw) { $tn = ($line -split ":")[1].Trim(); if ($tn) { [pscustomobject]@{ TaskName = $tn; TaskPath = "" } } }
}

foreach ($t in $tasks) {
    $name = $t.TaskName
    if ($AnalyzeOnly) {
        Write-Action "[ANALYZE] Would delete scheduled task: $name"
        continue
    }
    try {
        if (Get-Command Unregister-ScheduledTask -ErrorAction SilentlyContinue) {
            Unregister-ScheduledTask -TaskName $name -Confirm:$false -ErrorAction Stop
        }
        else {
            schtasks /Delete /TN $name /F | Out-Null
        }
        $Result.TasksRemoved.Add($name) | Out-Null
        $removedTasks++
    }
    catch {
        Write-Err "Failed to delete task: $name :: $($_.Exception.Message)"
    }
}

# ----------------------------
# DELETE PROGRAM FILES + APPDATA
# ----------------------------

Write-Action "Removing Epicor program/AppData directories..."
$paths = @(
    "C:\Program Files\Epicor",
    "C:\Program Files (x86)\Epicor",
    "$Env:LocalAppData\Epicor",
    "$Env:AppData\Epicor"
)

foreach ($path in $paths) {
    if (Test-Path $path) {
        if ($AnalyzeOnly) {
            Write-Action "[ANALYZE] Would remove directory: $path"
            continue
        }
        try {
            Remove-Item -Path $path -Recurse -Force -ErrorAction Stop
            Write-Action "Removed directory: $path"
            $Result.DirsRemoved.Add($path) | Out-Null
        }
        catch {
            Write-Err "Failed to remove directory: $path :: $($_.Exception.Message)"
        }
    }
}

# ----------------------------
# REMOVE REGISTRY ENTRIES
# ----------------------------

Write-Action "Cleaning Epicor registry keys..."
$regPaths = @(
    "HKLM:\Software\Epicor",
    "HKLM:\Software\WOW6432Node\Epicor",
    "HKCU:\Software\Epicor"
)

foreach ($regPath in $regPaths) {
    if (Test-Path $regPath) {
        if ($AnalyzeOnly) {
            Write-Action "[ANALYZE] Would remove registry key: $regPath"
            continue
        }
        try {
            Remove-Item $regPath -Recurse -Force -ErrorAction Stop
            Write-Action "Removed registry key: $regPath"
            $Result.RegKeysRemoved.Add($regPath) | Out-Null
        }
        catch {
            Write-Err "Failed to remove registry key: $regPath :: $($_.Exception.Message)"
        }
    }
}

# ----------------------------
# FINALIZE
# ----------------------------

$Result.Status = "Completed"
$Result.EndTime = Get-Date
$Result.DurationS = [math]::Round(($Result.EndTime - $Result.StartTime).TotalSeconds, 2)

Write-Action ("Epicor Edge Agent Removal {0}" -f ($(if ($AnalyzeOnly) { 'ANALYZE-ONLY (no changes)' } else { 'COMPLETED' })))

# Return typed object
[pscustomobject]$Result

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Workers\Reset-WindowsUpdateComponents.Worker.ps1
[CmdletBinding()]
param()

function Reset-WindowsUpdateComponentsCore {
    [CmdletBinding()]
    param()

    $result = [ordered]@{
        StoppedServices = @()
        RenamedFolders  = @()
        Errors          = @()
    }

    $services = 'wuauserv', 'cryptsvc', 'bits', 'msiserver'

    foreach ($svc in $services) {
        try {
            Stop-Service -Name $svc -Force -ErrorAction Stop
            $result.StoppedServices += $svc
        }
        catch {
            $result.Errors += "Failed to stop ${svc}: $($_.Exception.Message)"
        }
    }

    try {
        Remove-Item -Path "$env:ALLUSERSPROFILE\Application Data\Microsoft\Network\Downloader\qmgr*.dat" -Force -ErrorAction Stop
    }
    catch {
        $result.Errors += "Failed to delete qmgr files: $($_.Exception.Message)"
    }

    try {
        $sd = Join-Path $env:SystemRoot "SoftwareDistribution"
        $sd2 = Join-Path $env:SystemRoot "SoftwareDistribution.old"
        if (Test-Path $sd2) { Remove-Item -Path $sd2 -Recurse -Force }
        if (Test-Path $sd) {
            Rename-Item -Path $sd -NewName "SoftwareDistribution.old" -Force
            $result.RenamedFolders += "SoftwareDistribution  SoftwareDistribution.old"
        }
    }
    catch {
        $result.Errors += "Failed to rename SoftwareDistribution: $($_.Exception.Message)"
    }

    try {
        $cr = Join-Path $env:SystemRoot "System32\catroot2"
        $cr2 = Join-Path $env:SystemRoot "System32\catroot2.old"
        if (Test-Path $cr2) { Remove-Item -Path $cr2 -Recurse -Force }
        if (Test-Path $cr) {
            Rename-Item -Path $cr -NewName "catroot2.old" -Force
            $result.RenamedFolders += "catroot2  catroot2.old"
        }
    }
    catch {
        $result.Errors += "Failed to rename catroot2: $($_.Exception.Message)"
    }

    foreach ($svc in $services) {
        try {
            Start-Service -Name $svc -ErrorAction Stop
        }
        catch {
            $result.Errors += "Failed to start ${svc}: $($_.Exception.Message)"
        }
    }

    return [pscustomobject]$result
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Workers\Set-PageFileSize.Worker.ps1
[CmdletBinding()]
param()

function Set-PageFileSizeCore {
    [CmdletBinding()]
    param(
        [string]$Path,
        [int]$InitialSize,
        [int]$MaximumSize
    )

    try {
        $ok = Invoke-PageFileConfig `
            -Path $Path `
            -InitialSize $InitialSize `
            -MaximumSize $MaximumSize

        if ($ok) {
            return [pscustomobject]@{
                Success = $true
                Message = "Pagefile updated: $Path (Initial=$InitialSize MB, Max=$MaximumSize MB)"
            }
        }
        else {
            return [pscustomobject]@{
                Success = $false
                Message = "Invoke-PageFileConfig returned failure."
            }
        }
    }
    catch {
        return [pscustomobject]@{
            Success = $false
            Message = $_.Exception.Message
        }
    }
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Workers\SubnetScan.Worker.ps1
[CmdletBinding()]
param()

function Invoke-SubnetScanCore {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)][string]$CIDR,
        [int]$Port,
        [switch]$ResolveNames,
        [switch]$HttpBanner,
        [switch]$ExportCsv
    )

    # On remote, Invoke-SubnetScanLocal + helpers are already dot-sourced
    Invoke-SubnetScanLocal `
        -CIDR $CIDR `
        -Port $Port `
        -ResolveNames:$ResolveNames `
        -HttpBanner:$HttpBanner `
        -ExportCsv:$ExportCsv
}

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\Build.ps1
<#
.SYNOPSIS
  One-shot build for TechToolbox (rooted at C:\TechToolbox):
  - Update manifest (version & GUID)
  - (Optional) Run PSSA analysis
  - Sign module files
  - (Optional) Package artifacts

.NOTES
  - Prefers PS7+ but works on Windows PowerShell 5.1+
  - Non-interactive by default; prompts only with -Interactive
#>

[CmdletBinding(SupportsShouldProcess)]
param(
    [switch]$AutoVersionPatch,
    [switch]$RegenerateGuid,
    [switch]$SkipValidSigs = $true,
    [switch]$Recurse,
    [switch]$Analyze,         # Run PSSA (PowerShell ScriptAnalyzer)
    [switch]$FailOnPssa,      # Fail build if PSSA finds issues
    [switch]$ExportPublic,    # Export only functions discovered in Public\ (else '*')
    [switch]$Pack,            # Zip to .\Out\TechToolbox_<version>.zip
    [switch]$Interactive,     # Allow prompts when data is missing
    [string]$ModuleRoot = $PSScriptRoot,             # C:\TechToolbox
    [string]$ConfigPath = (Join-Path $PSScriptRoot 'Config\build.config.json'),
    [string]$TimestampServer,
    [string]$Thumbprint
)

# ---------------- 01. Load config --------------------------------------------
$cfg = $null
if (Test-Path -LiteralPath $ConfigPath) {
    $cfg = Get-Content -Raw -LiteralPath $ConfigPath | ConvertFrom-Json
}

$TimestampServer = $cfg.signing.timestamp ?? 'http://timestamp.digicert.com'
$Thumbprint = $cfg.signing.thumbprint
$outDir = $cfg.artifacts.outDir ?? (Join-Path $ModuleRoot 'Out')
$pssaSettings = $cfg.quality.pssaSettings ?? (Join-Path $ModuleRoot 'PSScriptAnalyzerSettings.psd1')
$analyzeEnabled = $Analyze.IsPresent -or ($cfg.quality.analyze -eq $true)
$failOnPssa = $FailOnPssa.IsPresent -or ($cfg.quality.failOnPssa -eq $true)

# ---------------- 02. Validate environment -----------------------------------
$manifestPath = Join-Path $ModuleRoot 'TechToolbox.psd1'
if (-not (Test-Path -LiteralPath $manifestPath)) {
    throw "Manifest not found: $manifestPath"
}

# ---------------- Helper: Import manifest ------------------------------------
$manifest = Import-PowerShellDataFile -Path $manifestPath

# ---------------- 03. Compute new values -------------------------------------
$oldGuid = $manifest.Guid
$newGuid = if ($RegenerateGuid) { [guid]::NewGuid().Guid } else { $oldGuid }

$oldVersion = [version]$manifest.ModuleVersion
$newVersion = if ($AutoVersionPatch) {
    $build = if ($oldVersion.Build -ge 0) { $oldVersion.Build } else { 0 }
    [version]::new($oldVersion.Major, $oldVersion.Minor, $build + 1)
}
else { $oldVersion }

# Paths
$publicFolder = Join-Path $ModuleRoot 'Public'
$manifestPath = Join-Path $ModuleRoot 'TechToolbox.psd1'

# Collect public function names from file basenames
$publicFiles = Get-ChildItem -LiteralPath $publicFolder -Filter *.ps1 -File -Recurse
$publicFuns = $publicFiles.BaseName | Sort-Object -Unique

# Fall back to '*' only if nothing found (e.g., dev shell without Public yet)
$functionsToExport = if ($publicFuns.Count -gt 0) { $publicFuns } else { @('*') }

# Keep aliases explicit (avoid '*') for faster module analysis
$aliasesToExport = @()  # set to concrete alias names when you have them

# Preserve existing PrivateData.PSData
$psdata = [ordered]@{}
if ($manifest.PrivateData -and $manifest.PrivateData.PSData) {
    $psdata = [ordered]@{} + $manifest.PrivateData.PSData
}
$privateData = if ($psdata.Count -gt 0) { [ordered]@{ PSData = $psdata } } else { @{} }

# Update manifest once
Update-ModuleManifest -Path $manifestPath `
    -FunctionsToExport $functionsToExport `
    -AliasesToExport   $aliasesToExport `
    -PrivateData       $privateData

# ---------------- 04. Dirty check & update manifest --------------------------
$manifestChanged = $false
$exportsChanged = ($manifest.FunctionsToExport -join ',') -ne ($functionsToExport -join ',')

if ($oldGuid -ne $newGuid -or $oldVersion -ne $newVersion -or $exportsChanged) {
    if ($PSCmdlet.ShouldProcess($manifestPath, "Update manifest")) {
        Update-ModuleManifest -Path $manifestPath `
            -ModuleVersion $newVersion `
            -Guid $newGuid `
            -FunctionsToExport $functionsToExport `
            -PrivateData $privateData
        $manifestChanged = $true
        Write-Host "Manifest updated  Version: $oldVersion  $newVersion; Guid: $oldGuid  $newGuid" -ForegroundColor Cyan
    }
}
else {
    Write-Host "Manifest unchanged (no updates needed)." -ForegroundColor DarkCyan
}

# ---------------- 05. (Optional) PSSA analysis --------------------------------
$pssaIssues = @()
if ($analyzeEnabled) {
    try {
        if (-not (Get-Module -ListAvailable -Name PSScriptAnalyzer)) {
            Write-Warning "PSScriptAnalyzer module not found. Skipping analysis."
        }
        else {
            Import-Module PSScriptAnalyzer -ErrorAction Stop
            Write-Host "Running PSSA (ScriptAnalyzer)..." -ForegroundColor Cyan
            $pssaIssues = Invoke-ScriptAnalyzer -Path $ModuleRoot `
                -Settings $pssaSettings -Recurse
            if ($pssaIssues.Count -gt 0) {
                # Store a machine-readable report under CodeAnalysis\
                $caDir = Join-Path $ModuleRoot 'CodeAnalysis'
                New-Item -ItemType Directory -Force -Path $caDir | Out-Null
                $reportPath = Join-Path $caDir ("PSSA-Report_{0:yyyyMMdd_HHmmss}.json" -f (Get-Date))
                $pssaIssues | ConvertTo-Json -Depth 6 | Out-File -LiteralPath $reportPath -Encoding UTF8
                Write-Host "PSSA found $($pssaIssues.Count) issue(s). Report: $reportPath" -ForegroundColor Yellow
                if ($failOnPssa -and -not $Interactive) {
                    throw "Build failed due to ScriptAnalyzer findings."
                }
            }
            else {
                Write-Host "PSSA clean." -ForegroundColor Green
            }
        }
    }
    catch {
        throw "PSSA run failed: $($_.Exception.Message)"
    }
}

# ---------------- 06. Signing -------------------------------------------------
function Get-CodeSigningCert {
    param([Parameter(Mandatory)] [string]$Thumb)
    $stores = @('Cert:\CurrentUser\My', 'Cert:\LocalMachine\My')
    foreach ($store in $stores) {
        $found = Get-ChildItem $store -ErrorAction SilentlyContinue |
        Where-Object { $_.Thumbprint -eq $Thumb }
        if ($found -and $found.HasPrivateKey) { return $found }
    }
    return $null
}

if (-not $Thumbprint) {
    if ($Interactive) { $Thumbprint = Read-Host "Enter code signing thumbprint" }
    else { throw "Thumbprint not provided (set Config\build.config.json signing.thumbprint or pass -Thumbprint)." }
}
$cert = Get-CodeSigningCert -Thumb $Thumbprint
if (-not $cert) { throw "Code signing cert not found or missing private key for thumbprint $Thumbprint." }

# What to sign
$search = @{ Path = $ModuleRoot; Include = '*.ps1', '*.psm1', '*.psd1'; File = $true; Recurse = $true }
$files = Get-ChildItem @search | Where-Object {
    $_.FullName -notmatch '\\(Out|Bin|CodeAnalysis|\.git)\\'
}

$ok = 0; $skip = 0; $warn = 0
Write-Host "Signing $(($files|Measure-Object).Count) file(s)..." -ForegroundColor Cyan
foreach ($f in $files) {
    try {
        if ($SkipValidSigs) {
            $sig = Get-AuthenticodeSignature -FilePath $f.FullName
            if ($sig.Status -eq 'Valid') { $skip++; continue }
        }
        $params = @{
            FilePath      = $f.FullName
            Certificate   = $cert
            HashAlgorithm = 'SHA256'
        }
        if ($TimestampServer) { $params['TimestampServer'] = $TimestampServer }
        $r = Set-AuthenticodeSignature @params
        if ($r.Status -eq 'Valid') { $ok++ } else { $warn++ }
    }
    catch {
        $warn++
    }
}
Write-Host "Signing complete  OK: $ok  Skipped: $skip  Warnings/Errors: $warn" -ForegroundColor Cyan

# ---------------- 07. (Optional) Package -------------------------------------
$artifact = $null
if ($Pack) {
    New-Item -ItemType Directory -Force -Path $outDir | Out-Null
    $zip = Join-Path $outDir ("TechToolbox_{0}.zip" -f $newVersion)
    if (Test-Path $zip) { Remove-Item $zip -Force }
    # Zip only module assets
    $items = @(
        (Join-Path $ModuleRoot 'TechToolbox.psd1'),
        (Join-Path $ModuleRoot 'TechToolbox.psm1'),
        (Join-Path $ModuleRoot 'Public\*'),
        (Join-Path $ModuleRoot 'Private\*'),
        (Join-Path $ModuleRoot 'Config\*')
    )
    Compress-Archive -Path $items -DestinationPath $zip
    $artifact = $zip
    Write-Host "Packaged  $artifact" -ForegroundColor Green
}

# ---------------- 08. Emit summary -------------------------------------------
$result = [pscustomobject]@{
    ManifestPath    = $manifestPath
    Version         = [pscustomobject]@{ Old = $oldVersion; New = $newVersion }
    Guid            = [pscustomobject]@{ Old = $oldGuid; New = $newGuid }
    ManifestUpdated = $manifestChanged
    PssaIssues      = $pssaIssues.Count
    FilesSigned     = $ok
    FilesSkipped    = $skip
    FilesWarned     = $warn
    ArtifactPath    = $artifact
}
$result

[SIGNATURE BLOCK REMOVED]



### FILE: C:\TechToolbox\TechToolbox.psm1

Set-StrictMode -Version Latest
$InformationPreference = 'Continue'

# Show logo
Write-Host @"

 #######                      #######                                           
    #    ######  ####  #    #    #     ####   ####  #      #####   ####  #    # 
    #    #      #    # #    #    #    #    # #    # #      #    # #    #  #  #  
    #    #####  #      ######    #    #    # #    # #      #####  #    #   ##   
    #    #      #      #    #    #    #    # #    # #      #    # #    #   ##   
    #    #      #    # #    #    #    #    # #    # #      #    # #    #  #  #  
    #    ######  ####  #    #    #     ####   ####  ###### #####   ####  #    # 
                                                                                

 -------------------------------------------------------------------------------
        TechToolbox PowerShell Module - A Collection of Sysadmin Tools

"@ -ForegroundColor Yellow
Write-Host ""

# --------------------------------------------
# TechToolbox Loader v2 (fast import)
# --------------------------------------------

# Predefine script-scoped vars before any reads
if (-not (Get-Variable -Name ModuleRoot        -Scope Script -ErrorAction SilentlyContinue)) { $script:ModuleRoot = $ExecutionContext.SessionState.Module.ModuleBase }
if (-not (Get-Variable -Name TT_Initialized    -Scope Script -ErrorAction SilentlyContinue)) { $script:TT_Initialized = $false }
if (-not (Get-Variable -Name TT_RuntimeReady   -Scope Script -ErrorAction SilentlyContinue)) { $script:TT_RuntimeReady = $false }
if (-not (Get-Variable -Name ConfigPath        -Scope Script -ErrorAction SilentlyContinue)) { $script:ConfigPath = $null }
if (-not (Get-Variable -Name log               -Scope Script -ErrorAction SilentlyContinue)) { $script:log = $null }
if (-not (Get-Variable -Name ModuleDependencies -Scope Script -ErrorAction SilentlyContinue)) { $script:ModuleDependencies = $null }
if (-not (Get-Variable -Name PrivateLoaded -Scope Script -ErrorAction SilentlyContinue)) { $script:PrivateLoaded = $false }
if (-not (Get-Variable -Name cfg -Scope Script -ErrorAction SilentlyContinue)) { $script:cfg = $null }

# Guard re-import
if ($script:TT_Initialized) { return }

# Optional timing (enable with $env:TT_TraceImport=1)
$__trace = [bool]($env:TT_TraceImport -eq '1')
$__sw = [System.Diagnostics.Stopwatch]::StartNew()
function __tt_trace([string]$msg) { if ($__trace) { Write-Verbose ("[TT Import] {0} @ {1}" -f $msg, $__sw.Elapsed) } }

# --- Load the self-install helper ---
$initHelper = Join-Path $script:ModuleRoot 'Private\Loader\Initialize-TechToolboxHome.ps1'
if (Test-Path $initHelper) { . $initHelper; __tt_trace "Sourced Initialize-TechToolboxHome.ps1" }
else { Write-Verbose "Initialize-TechToolboxHome.ps1 not found; skipping." }

# --- Gate self-install / self-heal (skip or once) ---
try {
    if ($env:TT_SkipHomeInit -ne '1') {
        # Simple sentinel: run only if the destination doesn't exist (or add your own version/sentinel check)
        if (-not (Test-Path 'C:\TechToolbox\.ready')) {
            Initialize-TechToolboxHome -HomePath 'C:\TechToolbox'
            # Optional sentinel drop
            try { New-Item -ItemType File -Path 'C:\TechToolbox\.ready' -Force | Out-Null } catch {}
            __tt_trace "Initialize-TechToolboxHome executed"
        }
        else {
            __tt_trace "Home already initialized; skipping"
        }
    }
    else {
        __tt_trace "Home init skipped via TT_SkipHomeInit=1"
    }
}
catch {
    Write-Warning "Initialize-TechToolboxHome failed: $($_.Exception.Message)"
    # Continue; tool can still run from the current location this session.
}

# --- Load Private functions ---
$privateRoot = Join-Path $script:ModuleRoot 'Private'
Get-ChildItem -Path $privateRoot -Recurse -Filter *.ps1 |
ForEach-Object { . $_.FullName }

# --- Lazy runtime initialization (config/logging/etc.) ---
function Initialize-TechToolboxRuntime {
    if ($script:TT_RuntimeReady) { return }

    try {
        Initialize-ModulePath
        Initialize-Config
        Initialize-Logging
        Initialize-Interop
        Initialize-Environment

        $script:TT_RuntimeReady = $true
    }
    catch {
        Write-Error "Runtime initialization failed: $_"
        throw
    }
}

# --- Load **Public** functions only (1 function per file convention) ---
$publicRoot = Join-Path $script:ModuleRoot 'Public'
$publicFiles = Get-ChildItem -Path $publicRoot -Recurse -Filter *.ps1 -File
foreach ($file in $publicFiles) {
    # Trust convention: the file defines a function named as the basename
    # This avoids Select-String scans and is how most PS modules are structured.
    . $file.FullName
}
$publicFunctionNames = $publicFiles.BaseName
__tt_trace ("Loaded Public functions: {0}" -f ($publicFunctionNames -join ', '))

if ($env:TT_ExportLocalHelper -eq '1') {
    Export-ModuleMember -Function 'Start-PDQDiagLocalSystem'
}
Export-ModuleMember -Function $publicFunctionNames

$script:TT_Initialized = $true
__tt_trace "Import complete"

[SIGNATURE BLOCK REMOVED]



```
